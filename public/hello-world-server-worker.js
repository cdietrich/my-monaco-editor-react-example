"use strict";
(() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var __accessCheck = (obj, member, msg) => {
    if (!member.has(obj))
      throw TypeError("Cannot " + msg);
  };
  var __privateGet = (obj, member, getter) => {
    __accessCheck(obj, member, "read from private field");
    return getter ? getter.call(obj) : member.get(obj);
  };
  var __privateAdd = (obj, member, value) => {
    if (member.has(obj))
      throw TypeError("Cannot add the same private member more than once");
    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  };

  // node_modules/vscode-jsonrpc/lib/common/ral.js
  var require_ral = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/ral.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var _ral;
      function RAL() {
        if (_ral === void 0) {
          throw new Error(`No runtime abstraction layer installed`);
        }
        return _ral;
      }
      (function(RAL2) {
        function install(ral) {
          if (ral === void 0) {
            throw new Error(`No runtime abstraction layer provided`);
          }
          _ral = ral;
        }
        RAL2.install = install;
      })(RAL || (RAL = {}));
      exports2.default = RAL;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/disposable.js
  var require_disposable = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/disposable.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Disposable = void 0;
      var Disposable5;
      (function(Disposable6) {
        function create(func) {
          return {
            dispose: func
          };
        }
        Disposable6.create = create;
      })(Disposable5 = exports2.Disposable || (exports2.Disposable = {}));
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/events.js
  var require_events = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/events.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Emitter = exports2.Event = void 0;
      var ral_1 = require_ral();
      var Event2;
      (function(Event3) {
        const _disposable = { dispose() {
        } };
        Event3.None = function() {
          return _disposable;
        };
      })(Event2 = exports2.Event || (exports2.Event = {}));
      var CallbackList = class {
        add(callback, context = null, bucket) {
          if (!this._callbacks) {
            this._callbacks = [];
            this._contexts = [];
          }
          this._callbacks.push(callback);
          this._contexts.push(context);
          if (Array.isArray(bucket)) {
            bucket.push({ dispose: () => this.remove(callback, context) });
          }
        }
        remove(callback, context = null) {
          if (!this._callbacks) {
            return;
          }
          let foundCallbackWithDifferentContext = false;
          for (let i = 0, len = this._callbacks.length; i < len; i++) {
            if (this._callbacks[i] === callback) {
              if (this._contexts[i] === context) {
                this._callbacks.splice(i, 1);
                this._contexts.splice(i, 1);
                return;
              } else {
                foundCallbackWithDifferentContext = true;
              }
            }
          }
          if (foundCallbackWithDifferentContext) {
            throw new Error("When adding a listener with a context, you should remove it with the same context");
          }
        }
        invoke(...args) {
          if (!this._callbacks) {
            return [];
          }
          const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
          for (let i = 0, len = callbacks.length; i < len; i++) {
            try {
              ret.push(callbacks[i].apply(contexts[i], args));
            } catch (e) {
              (0, ral_1.default)().console.error(e);
            }
          }
          return ret;
        }
        isEmpty() {
          return !this._callbacks || this._callbacks.length === 0;
        }
        dispose() {
          this._callbacks = void 0;
          this._contexts = void 0;
        }
      };
      var Emitter2 = class {
        constructor(_options) {
          this._options = _options;
        }
        /**
         * For the public to allow to subscribe
         * to events from this Emitter
         */
        get event() {
          if (!this._event) {
            this._event = (listener, thisArgs, disposables) => {
              if (!this._callbacks) {
                this._callbacks = new CallbackList();
              }
              if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                this._options.onFirstListenerAdd(this);
              }
              this._callbacks.add(listener, thisArgs);
              const result = {
                dispose: () => {
                  if (!this._callbacks) {
                    return;
                  }
                  this._callbacks.remove(listener, thisArgs);
                  result.dispose = Emitter2._noop;
                  if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                    this._options.onLastListenerRemove(this);
                  }
                }
              };
              if (Array.isArray(disposables)) {
                disposables.push(result);
              }
              return result;
            };
          }
          return this._event;
        }
        /**
         * To be kept private to fire an event to
         * subscribers
         */
        fire(event) {
          if (this._callbacks) {
            this._callbacks.invoke.call(this._callbacks, event);
          }
        }
        dispose() {
          if (this._callbacks) {
            this._callbacks.dispose();
            this._callbacks = void 0;
          }
        }
      };
      exports2.Emitter = Emitter2;
      Emitter2._noop = function() {
      };
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
  var require_messageBuffer = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.AbstractMessageBuffer = void 0;
      var CR = 13;
      var LF = 10;
      var CRLF = "\r\n";
      var AbstractMessageBuffer = class {
        constructor(encoding = "utf-8") {
          this._encoding = encoding;
          this._chunks = [];
          this._totalLength = 0;
        }
        get encoding() {
          return this._encoding;
        }
        append(chunk) {
          const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
          this._chunks.push(toAppend);
          this._totalLength += toAppend.byteLength;
        }
        tryReadHeaders() {
          if (this._chunks.length === 0) {
            return void 0;
          }
          let state = 0;
          let chunkIndex = 0;
          let offset = 0;
          let chunkBytesRead = 0;
          row:
            while (chunkIndex < this._chunks.length) {
              const chunk = this._chunks[chunkIndex];
              offset = 0;
              column:
                while (offset < chunk.length) {
                  const value = chunk[offset];
                  switch (value) {
                    case CR:
                      switch (state) {
                        case 0:
                          state = 1;
                          break;
                        case 2:
                          state = 3;
                          break;
                        default:
                          state = 0;
                      }
                      break;
                    case LF:
                      switch (state) {
                        case 1:
                          state = 2;
                          break;
                        case 3:
                          state = 4;
                          offset++;
                          break row;
                        default:
                          state = 0;
                      }
                      break;
                    default:
                      state = 0;
                  }
                  offset++;
                }
              chunkBytesRead += chunk.byteLength;
              chunkIndex++;
            }
          if (state !== 4) {
            return void 0;
          }
          const buffer = this._read(chunkBytesRead + offset);
          const result = /* @__PURE__ */ new Map();
          const headers = this.toString(buffer, "ascii").split(CRLF);
          if (headers.length < 2) {
            return result;
          }
          for (let i = 0; i < headers.length - 2; i++) {
            const header = headers[i];
            const index = header.indexOf(":");
            if (index === -1) {
              throw new Error("Message header must separate key and value using :");
            }
            const key = header.substr(0, index);
            const value = header.substr(index + 1).trim();
            result.set(key, value);
          }
          return result;
        }
        tryReadBody(length) {
          if (this._totalLength < length) {
            return void 0;
          }
          return this._read(length);
        }
        get numberOfBytes() {
          return this._totalLength;
        }
        _read(byteCount) {
          if (byteCount === 0) {
            return this.emptyBuffer();
          }
          if (byteCount > this._totalLength) {
            throw new Error(`Cannot read so many bytes!`);
          }
          if (this._chunks[0].byteLength === byteCount) {
            const chunk = this._chunks[0];
            this._chunks.shift();
            this._totalLength -= byteCount;
            return this.asNative(chunk);
          }
          if (this._chunks[0].byteLength > byteCount) {
            const chunk = this._chunks[0];
            const result2 = this.asNative(chunk, byteCount);
            this._chunks[0] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            return result2;
          }
          const result = this.allocNative(byteCount);
          let resultOffset = 0;
          let chunkIndex = 0;
          while (byteCount > 0) {
            const chunk = this._chunks[chunkIndex];
            if (chunk.byteLength > byteCount) {
              const chunkPart = chunk.slice(0, byteCount);
              result.set(chunkPart, resultOffset);
              resultOffset += byteCount;
              this._chunks[chunkIndex] = chunk.slice(byteCount);
              this._totalLength -= byteCount;
              byteCount -= byteCount;
            } else {
              result.set(chunk, resultOffset);
              resultOffset += chunk.byteLength;
              this._chunks.shift();
              this._totalLength -= chunk.byteLength;
              byteCount -= chunk.byteLength;
            }
          }
          return result;
        }
      };
      exports2.AbstractMessageBuffer = AbstractMessageBuffer;
    }
  });

  // node_modules/vscode-jsonrpc/lib/browser/ril.js
  var require_ril = __commonJS({
    "node_modules/vscode-jsonrpc/lib/browser/ril.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var ral_1 = require_ral();
      var disposable_1 = require_disposable();
      var events_1 = require_events();
      var messageBuffer_1 = require_messageBuffer();
      var MessageBuffer = class extends messageBuffer_1.AbstractMessageBuffer {
        constructor(encoding = "utf-8") {
          super(encoding);
          this.asciiDecoder = new TextDecoder("ascii");
        }
        emptyBuffer() {
          return MessageBuffer.emptyBuffer;
        }
        fromString(value, _encoding) {
          return new TextEncoder().encode(value);
        }
        toString(value, encoding) {
          if (encoding === "ascii") {
            return this.asciiDecoder.decode(value);
          } else {
            return new TextDecoder(encoding).decode(value);
          }
        }
        asNative(buffer, length) {
          if (length === void 0) {
            return buffer;
          } else {
            return buffer.slice(0, length);
          }
        }
        allocNative(length) {
          return new Uint8Array(length);
        }
      };
      MessageBuffer.emptyBuffer = new Uint8Array(0);
      var ReadableStreamWrapper = class {
        constructor(socket) {
          this.socket = socket;
          this._onData = new events_1.Emitter();
          this._messageListener = (event) => {
            const blob = event.data;
            blob.arrayBuffer().then((buffer) => {
              this._onData.fire(new Uint8Array(buffer));
            }, () => {
              (0, ral_1.default)().console.error(`Converting blob to array buffer failed.`);
            });
          };
          this.socket.addEventListener("message", this._messageListener);
        }
        onClose(listener) {
          this.socket.addEventListener("close", listener);
          return disposable_1.Disposable.create(() => this.socket.removeEventListener("close", listener));
        }
        onError(listener) {
          this.socket.addEventListener("error", listener);
          return disposable_1.Disposable.create(() => this.socket.removeEventListener("error", listener));
        }
        onEnd(listener) {
          this.socket.addEventListener("end", listener);
          return disposable_1.Disposable.create(() => this.socket.removeEventListener("end", listener));
        }
        onData(listener) {
          return this._onData.event(listener);
        }
      };
      var WritableStreamWrapper = class {
        constructor(socket) {
          this.socket = socket;
        }
        onClose(listener) {
          this.socket.addEventListener("close", listener);
          return disposable_1.Disposable.create(() => this.socket.removeEventListener("close", listener));
        }
        onError(listener) {
          this.socket.addEventListener("error", listener);
          return disposable_1.Disposable.create(() => this.socket.removeEventListener("error", listener));
        }
        onEnd(listener) {
          this.socket.addEventListener("end", listener);
          return disposable_1.Disposable.create(() => this.socket.removeEventListener("end", listener));
        }
        write(data, encoding) {
          if (typeof data === "string") {
            if (encoding !== void 0 && encoding !== "utf-8") {
              throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${encoding}`);
            }
            this.socket.send(data);
          } else {
            this.socket.send(data);
          }
          return Promise.resolve();
        }
        end() {
          this.socket.close();
        }
      };
      var _textEncoder = new TextEncoder();
      var _ril = Object.freeze({
        messageBuffer: Object.freeze({
          create: (encoding) => new MessageBuffer(encoding)
        }),
        applicationJson: Object.freeze({
          encoder: Object.freeze({
            name: "application/json",
            encode: (msg, options) => {
              if (options.charset !== "utf-8") {
                throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${options.charset}`);
              }
              return Promise.resolve(_textEncoder.encode(JSON.stringify(msg, void 0, 0)));
            }
          }),
          decoder: Object.freeze({
            name: "application/json",
            decode: (buffer, options) => {
              if (!(buffer instanceof Uint8Array)) {
                throw new Error(`In a Browser environments only Uint8Arrays are supported.`);
              }
              return Promise.resolve(JSON.parse(new TextDecoder(options.charset).decode(buffer)));
            }
          })
        }),
        stream: Object.freeze({
          asReadableStream: (socket) => new ReadableStreamWrapper(socket),
          asWritableStream: (socket) => new WritableStreamWrapper(socket)
        }),
        console,
        timer: Object.freeze({
          setTimeout(callback, ms, ...args) {
            const handle = setTimeout(callback, ms, ...args);
            return { dispose: () => clearTimeout(handle) };
          },
          setImmediate(callback, ...args) {
            const handle = setTimeout(callback, 0, ...args);
            return { dispose: () => clearTimeout(handle) };
          },
          setInterval(callback, ms, ...args) {
            const handle = setInterval(callback, ms, ...args);
            return { dispose: () => clearInterval(handle) };
          }
        })
      });
      function RIL() {
        return _ril;
      }
      (function(RIL2) {
        function install() {
          ral_1.default.install(_ril);
        }
        RIL2.install = install;
      })(RIL || (RIL = {}));
      exports2.default = RIL;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/is.js
  var require_is = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/is.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
      function boolean2(value) {
        return value === true || value === false;
      }
      exports2.boolean = boolean2;
      function string(value) {
        return typeof value === "string" || value instanceof String;
      }
      exports2.string = string;
      function number(value) {
        return typeof value === "number" || value instanceof Number;
      }
      exports2.number = number;
      function error(value) {
        return value instanceof Error;
      }
      exports2.error = error;
      function func(value) {
        return typeof value === "function";
      }
      exports2.func = func;
      function array(value) {
        return Array.isArray(value);
      }
      exports2.array = array;
      function stringArray(value) {
        return array(value) && value.every((elem) => string(elem));
      }
      exports2.stringArray = stringArray;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/messages.js
  var require_messages = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/messages.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Message = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType = exports2.RequestType0 = exports2.AbstractMessageSignature = exports2.ParameterStructures = exports2.ResponseError = exports2.ErrorCodes = void 0;
      var is = require_is();
      var ErrorCodes;
      (function(ErrorCodes2) {
        ErrorCodes2.ParseError = -32700;
        ErrorCodes2.InvalidRequest = -32600;
        ErrorCodes2.MethodNotFound = -32601;
        ErrorCodes2.InvalidParams = -32602;
        ErrorCodes2.InternalError = -32603;
        ErrorCodes2.jsonrpcReservedErrorRangeStart = -32099;
        ErrorCodes2.serverErrorStart = -32099;
        ErrorCodes2.MessageWriteError = -32099;
        ErrorCodes2.MessageReadError = -32098;
        ErrorCodes2.PendingResponseRejected = -32097;
        ErrorCodes2.ConnectionInactive = -32096;
        ErrorCodes2.ServerNotInitialized = -32002;
        ErrorCodes2.UnknownErrorCode = -32001;
        ErrorCodes2.jsonrpcReservedErrorRangeEnd = -32e3;
        ErrorCodes2.serverErrorEnd = -32e3;
      })(ErrorCodes = exports2.ErrorCodes || (exports2.ErrorCodes = {}));
      var ResponseError = class extends Error {
        constructor(code, message, data) {
          super(message);
          this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
          this.data = data;
          Object.setPrototypeOf(this, ResponseError.prototype);
        }
        toJson() {
          const result = {
            code: this.code,
            message: this.message
          };
          if (this.data !== void 0) {
            result.data = this.data;
          }
          return result;
        }
      };
      exports2.ResponseError = ResponseError;
      var ParameterStructures = class {
        constructor(kind) {
          this.kind = kind;
        }
        static is(value) {
          return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
        }
        toString() {
          return this.kind;
        }
      };
      exports2.ParameterStructures = ParameterStructures;
      ParameterStructures.auto = new ParameterStructures("auto");
      ParameterStructures.byPosition = new ParameterStructures("byPosition");
      ParameterStructures.byName = new ParameterStructures("byName");
      var AbstractMessageSignature = class {
        constructor(method, numberOfParams) {
          this.method = method;
          this.numberOfParams = numberOfParams;
        }
        get parameterStructures() {
          return ParameterStructures.auto;
        }
      };
      exports2.AbstractMessageSignature = AbstractMessageSignature;
      var RequestType0 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 0);
        }
      };
      exports2.RequestType0 = RequestType0;
      var RequestType = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports2.RequestType = RequestType;
      var RequestType1 = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports2.RequestType1 = RequestType1;
      var RequestType2 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 2);
        }
      };
      exports2.RequestType2 = RequestType2;
      var RequestType3 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 3);
        }
      };
      exports2.RequestType3 = RequestType3;
      var RequestType4 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 4);
        }
      };
      exports2.RequestType4 = RequestType4;
      var RequestType5 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 5);
        }
      };
      exports2.RequestType5 = RequestType5;
      var RequestType6 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 6);
        }
      };
      exports2.RequestType6 = RequestType6;
      var RequestType7 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 7);
        }
      };
      exports2.RequestType7 = RequestType7;
      var RequestType8 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 8);
        }
      };
      exports2.RequestType8 = RequestType8;
      var RequestType9 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 9);
        }
      };
      exports2.RequestType9 = RequestType9;
      var NotificationType = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports2.NotificationType = NotificationType;
      var NotificationType0 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 0);
        }
      };
      exports2.NotificationType0 = NotificationType0;
      var NotificationType1 = class extends AbstractMessageSignature {
        constructor(method, _parameterStructures = ParameterStructures.auto) {
          super(method, 1);
          this._parameterStructures = _parameterStructures;
        }
        get parameterStructures() {
          return this._parameterStructures;
        }
      };
      exports2.NotificationType1 = NotificationType1;
      var NotificationType2 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 2);
        }
      };
      exports2.NotificationType2 = NotificationType2;
      var NotificationType3 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 3);
        }
      };
      exports2.NotificationType3 = NotificationType3;
      var NotificationType4 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 4);
        }
      };
      exports2.NotificationType4 = NotificationType4;
      var NotificationType5 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 5);
        }
      };
      exports2.NotificationType5 = NotificationType5;
      var NotificationType6 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 6);
        }
      };
      exports2.NotificationType6 = NotificationType6;
      var NotificationType7 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 7);
        }
      };
      exports2.NotificationType7 = NotificationType7;
      var NotificationType8 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 8);
        }
      };
      exports2.NotificationType8 = NotificationType8;
      var NotificationType9 = class extends AbstractMessageSignature {
        constructor(method) {
          super(method, 9);
        }
      };
      exports2.NotificationType9 = NotificationType9;
      var Message;
      (function(Message2) {
        function isRequest(message) {
          const candidate = message;
          return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
        }
        Message2.isRequest = isRequest;
        function isNotification(message) {
          const candidate = message;
          return candidate && is.string(candidate.method) && message.id === void 0;
        }
        Message2.isNotification = isNotification;
        function isResponse(message) {
          const candidate = message;
          return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
        }
        Message2.isResponse = isResponse;
      })(Message = exports2.Message || (exports2.Message = {}));
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/linkedMap.js
  var require_linkedMap = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/linkedMap.js"(exports2) {
      "use strict";
      var _a4;
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LRUCache = exports2.LinkedMap = exports2.Touch = void 0;
      var Touch;
      (function(Touch2) {
        Touch2.None = 0;
        Touch2.First = 1;
        Touch2.AsOld = Touch2.First;
        Touch2.Last = 2;
        Touch2.AsNew = Touch2.Last;
      })(Touch = exports2.Touch || (exports2.Touch = {}));
      var LinkedMap2 = class {
        constructor() {
          this[_a4] = "LinkedMap";
          this._map = /* @__PURE__ */ new Map();
          this._head = void 0;
          this._tail = void 0;
          this._size = 0;
          this._state = 0;
        }
        clear() {
          this._map.clear();
          this._head = void 0;
          this._tail = void 0;
          this._size = 0;
          this._state++;
        }
        isEmpty() {
          return !this._head && !this._tail;
        }
        get size() {
          return this._size;
        }
        get first() {
          return this._head?.value;
        }
        get last() {
          return this._tail?.value;
        }
        has(key) {
          return this._map.has(key);
        }
        get(key, touch = Touch.None) {
          const item = this._map.get(key);
          if (!item) {
            return void 0;
          }
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
          return item.value;
        }
        set(key, value, touch = Touch.None) {
          let item = this._map.get(key);
          if (item) {
            item.value = value;
            if (touch !== Touch.None) {
              this.touch(item, touch);
            }
          } else {
            item = { key, value, next: void 0, previous: void 0 };
            switch (touch) {
              case Touch.None:
                this.addItemLast(item);
                break;
              case Touch.First:
                this.addItemFirst(item);
                break;
              case Touch.Last:
                this.addItemLast(item);
                break;
              default:
                this.addItemLast(item);
                break;
            }
            this._map.set(key, item);
            this._size++;
          }
          return this;
        }
        delete(key) {
          return !!this.remove(key);
        }
        remove(key) {
          const item = this._map.get(key);
          if (!item) {
            return void 0;
          }
          this._map.delete(key);
          this.removeItem(item);
          this._size--;
          return item.value;
        }
        shift() {
          if (!this._head && !this._tail) {
            return void 0;
          }
          if (!this._head || !this._tail) {
            throw new Error("Invalid list");
          }
          const item = this._head;
          this._map.delete(item.key);
          this.removeItem(item);
          this._size--;
          return item.value;
        }
        forEach(callbackfn, thisArg) {
          const state = this._state;
          let current = this._head;
          while (current) {
            if (thisArg) {
              callbackfn.bind(thisArg)(current.value, current.key, this);
            } else {
              callbackfn(current.value, current.key, this);
            }
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            current = current.next;
          }
        }
        keys() {
          const state = this._state;
          let current = this._head;
          const iterator = {
            [Symbol.iterator]: () => {
              return iterator;
            },
            next: () => {
              if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
              }
              if (current) {
                const result = { value: current.key, done: false };
                current = current.next;
                return result;
              } else {
                return { value: void 0, done: true };
              }
            }
          };
          return iterator;
        }
        values() {
          const state = this._state;
          let current = this._head;
          const iterator = {
            [Symbol.iterator]: () => {
              return iterator;
            },
            next: () => {
              if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
              }
              if (current) {
                const result = { value: current.value, done: false };
                current = current.next;
                return result;
              } else {
                return { value: void 0, done: true };
              }
            }
          };
          return iterator;
        }
        entries() {
          const state = this._state;
          let current = this._head;
          const iterator = {
            [Symbol.iterator]: () => {
              return iterator;
            },
            next: () => {
              if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
              }
              if (current) {
                const result = { value: [current.key, current.value], done: false };
                current = current.next;
                return result;
              } else {
                return { value: void 0, done: true };
              }
            }
          };
          return iterator;
        }
        [(_a4 = Symbol.toStringTag, Symbol.iterator)]() {
          return this.entries();
        }
        trimOld(newSize) {
          if (newSize >= this.size) {
            return;
          }
          if (newSize === 0) {
            this.clear();
            return;
          }
          let current = this._head;
          let currentSize = this.size;
          while (current && currentSize > newSize) {
            this._map.delete(current.key);
            current = current.next;
            currentSize--;
          }
          this._head = current;
          this._size = currentSize;
          if (current) {
            current.previous = void 0;
          }
          this._state++;
        }
        addItemFirst(item) {
          if (!this._head && !this._tail) {
            this._tail = item;
          } else if (!this._head) {
            throw new Error("Invalid list");
          } else {
            item.next = this._head;
            this._head.previous = item;
          }
          this._head = item;
          this._state++;
        }
        addItemLast(item) {
          if (!this._head && !this._tail) {
            this._head = item;
          } else if (!this._tail) {
            throw new Error("Invalid list");
          } else {
            item.previous = this._tail;
            this._tail.next = item;
          }
          this._tail = item;
          this._state++;
        }
        removeItem(item) {
          if (item === this._head && item === this._tail) {
            this._head = void 0;
            this._tail = void 0;
          } else if (item === this._head) {
            if (!item.next) {
              throw new Error("Invalid list");
            }
            item.next.previous = void 0;
            this._head = item.next;
          } else if (item === this._tail) {
            if (!item.previous) {
              throw new Error("Invalid list");
            }
            item.previous.next = void 0;
            this._tail = item.previous;
          } else {
            const next = item.next;
            const previous = item.previous;
            if (!next || !previous) {
              throw new Error("Invalid list");
            }
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = void 0;
          this._state++;
        }
        touch(item, touch) {
          if (!this._head || !this._tail) {
            throw new Error("Invalid list");
          }
          if (touch !== Touch.First && touch !== Touch.Last) {
            return;
          }
          if (touch === Touch.First) {
            if (item === this._head) {
              return;
            }
            const next = item.next;
            const previous = item.previous;
            if (item === this._tail) {
              previous.next = void 0;
              this._tail = previous;
            } else {
              next.previous = previous;
              previous.next = next;
            }
            item.previous = void 0;
            item.next = this._head;
            this._head.previous = item;
            this._head = item;
            this._state++;
          } else if (touch === Touch.Last) {
            if (item === this._tail) {
              return;
            }
            const next = item.next;
            const previous = item.previous;
            if (item === this._head) {
              next.previous = void 0;
              this._head = next;
            } else {
              next.previous = previous;
              previous.next = next;
            }
            item.next = void 0;
            item.previous = this._tail;
            this._tail.next = item;
            this._tail = item;
            this._state++;
          }
        }
        toJSON() {
          const data = [];
          this.forEach((value, key) => {
            data.push([key, value]);
          });
          return data;
        }
        fromJSON(data) {
          this.clear();
          for (const [key, value] of data) {
            this.set(key, value);
          }
        }
      };
      exports2.LinkedMap = LinkedMap2;
      var LRUCache2 = class extends LinkedMap2 {
        constructor(limit, ratio = 1) {
          super();
          this._limit = limit;
          this._ratio = Math.min(Math.max(0, ratio), 1);
        }
        get limit() {
          return this._limit;
        }
        set limit(limit) {
          this._limit = limit;
          this.checkTrim();
        }
        get ratio() {
          return this._ratio;
        }
        set ratio(ratio) {
          this._ratio = Math.min(Math.max(0, ratio), 1);
          this.checkTrim();
        }
        get(key, touch = Touch.AsNew) {
          return super.get(key, touch);
        }
        peek(key) {
          return super.get(key, Touch.None);
        }
        set(key, value) {
          super.set(key, value, Touch.Last);
          this.checkTrim();
          return this;
        }
        checkTrim() {
          if (this.size > this._limit) {
            this.trimOld(Math.round(this._limit * this._ratio));
          }
        }
      };
      exports2.LRUCache = LRUCache2;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/cancellation.js
  var require_cancellation = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/cancellation.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.CancellationTokenSource = exports2.CancellationToken = void 0;
      var ral_1 = require_ral();
      var Is = require_is();
      var events_1 = require_events();
      var CancellationToken2;
      (function(CancellationToken3) {
        CancellationToken3.None = Object.freeze({
          isCancellationRequested: false,
          onCancellationRequested: events_1.Event.None
        });
        CancellationToken3.Cancelled = Object.freeze({
          isCancellationRequested: true,
          onCancellationRequested: events_1.Event.None
        });
        function is(value) {
          const candidate = value;
          return candidate && (candidate === CancellationToken3.None || candidate === CancellationToken3.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
        }
        CancellationToken3.is = is;
      })(CancellationToken2 = exports2.CancellationToken || (exports2.CancellationToken = {}));
      var shortcutEvent2 = Object.freeze(function(callback, context) {
        const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
        return { dispose() {
          handle.dispose();
        } };
      });
      var MutableToken2 = class {
        constructor() {
          this._isCancelled = false;
        }
        cancel() {
          if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
              this._emitter.fire(void 0);
              this.dispose();
            }
          }
        }
        get isCancellationRequested() {
          return this._isCancelled;
        }
        get onCancellationRequested() {
          if (this._isCancelled) {
            return shortcutEvent2;
          }
          if (!this._emitter) {
            this._emitter = new events_1.Emitter();
          }
          return this._emitter.event;
        }
        dispose() {
          if (this._emitter) {
            this._emitter.dispose();
            this._emitter = void 0;
          }
        }
      };
      var CancellationTokenSource3 = class {
        get token() {
          if (!this._token) {
            this._token = new MutableToken2();
          }
          return this._token;
        }
        cancel() {
          if (!this._token) {
            this._token = CancellationToken2.Cancelled;
          } else {
            this._token.cancel();
          }
        }
        dispose() {
          if (!this._token) {
            this._token = CancellationToken2.None;
          } else if (this._token instanceof MutableToken2) {
            this._token.dispose();
          }
        }
      };
      exports2.CancellationTokenSource = CancellationTokenSource3;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/messageReader.js
  var require_messageReader = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/messageReader.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = void 0;
      var ral_1 = require_ral();
      var Is = require_is();
      var events_1 = require_events();
      var MessageReader;
      (function(MessageReader2) {
        function is(value) {
          let candidate = value;
          return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
        }
        MessageReader2.is = is;
      })(MessageReader = exports2.MessageReader || (exports2.MessageReader = {}));
      var AbstractMessageReader = class {
        constructor() {
          this.errorEmitter = new events_1.Emitter();
          this.closeEmitter = new events_1.Emitter();
          this.partialMessageEmitter = new events_1.Emitter();
        }
        dispose() {
          this.errorEmitter.dispose();
          this.closeEmitter.dispose();
        }
        get onError() {
          return this.errorEmitter.event;
        }
        fireError(error) {
          this.errorEmitter.fire(this.asError(error));
        }
        get onClose() {
          return this.closeEmitter.event;
        }
        fireClose() {
          this.closeEmitter.fire(void 0);
        }
        get onPartialMessage() {
          return this.partialMessageEmitter.event;
        }
        firePartialMessage(info) {
          this.partialMessageEmitter.fire(info);
        }
        asError(error) {
          if (error instanceof Error) {
            return error;
          } else {
            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
          }
        }
      };
      exports2.AbstractMessageReader = AbstractMessageReader;
      var ResolvedMessageReaderOptions;
      (function(ResolvedMessageReaderOptions2) {
        function fromOptions(options) {
          let charset;
          let result;
          let contentDecoder;
          const contentDecoders = /* @__PURE__ */ new Map();
          let contentTypeDecoder;
          const contentTypeDecoders = /* @__PURE__ */ new Map();
          if (options === void 0 || typeof options === "string") {
            charset = options ?? "utf-8";
          } else {
            charset = options.charset ?? "utf-8";
            if (options.contentDecoder !== void 0) {
              contentDecoder = options.contentDecoder;
              contentDecoders.set(contentDecoder.name, contentDecoder);
            }
            if (options.contentDecoders !== void 0) {
              for (const decoder of options.contentDecoders) {
                contentDecoders.set(decoder.name, decoder);
              }
            }
            if (options.contentTypeDecoder !== void 0) {
              contentTypeDecoder = options.contentTypeDecoder;
              contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
            }
            if (options.contentTypeDecoders !== void 0) {
              for (const decoder of options.contentTypeDecoders) {
                contentTypeDecoders.set(decoder.name, decoder);
              }
            }
          }
          if (contentTypeDecoder === void 0) {
            contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
          }
          return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
        }
        ResolvedMessageReaderOptions2.fromOptions = fromOptions;
      })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
      var ReadableStreamMessageReader = class extends AbstractMessageReader {
        constructor(readable, options) {
          super();
          this.readable = readable;
          this.options = ResolvedMessageReaderOptions.fromOptions(options);
          this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
          this._partialMessageTimeout = 1e4;
          this.nextMessageLength = -1;
          this.messageToken = 0;
        }
        set partialMessageTimeout(timeout) {
          this._partialMessageTimeout = timeout;
        }
        get partialMessageTimeout() {
          return this._partialMessageTimeout;
        }
        listen(callback) {
          this.nextMessageLength = -1;
          this.messageToken = 0;
          this.partialMessageTimer = void 0;
          this.callback = callback;
          const result = this.readable.onData((data) => {
            this.onData(data);
          });
          this.readable.onError((error) => this.fireError(error));
          this.readable.onClose(() => this.fireClose());
          return result;
        }
        onData(data) {
          this.buffer.append(data);
          while (true) {
            if (this.nextMessageLength === -1) {
              const headers = this.buffer.tryReadHeaders();
              if (!headers) {
                return;
              }
              const contentLength = headers.get("Content-Length");
              if (!contentLength) {
                throw new Error("Header must provide a Content-Length property.");
              }
              const length = parseInt(contentLength);
              if (isNaN(length)) {
                throw new Error("Content-Length value must be a number.");
              }
              this.nextMessageLength = length;
            }
            const body = this.buffer.tryReadBody(this.nextMessageLength);
            if (body === void 0) {
              this.setPartialMessageTimer();
              return;
            }
            this.clearPartialMessageTimer();
            this.nextMessageLength = -1;
            let p;
            if (this.options.contentDecoder !== void 0) {
              p = this.options.contentDecoder.decode(body);
            } else {
              p = Promise.resolve(body);
            }
            p.then((value) => {
              this.options.contentTypeDecoder.decode(value, this.options).then((msg) => {
                this.callback(msg);
              }, (error) => {
                this.fireError(error);
              });
            }, (error) => {
              this.fireError(error);
            });
          }
        }
        clearPartialMessageTimer() {
          if (this.partialMessageTimer) {
            this.partialMessageTimer.dispose();
            this.partialMessageTimer = void 0;
          }
        }
        setPartialMessageTimer() {
          this.clearPartialMessageTimer();
          if (this._partialMessageTimeout <= 0) {
            return;
          }
          this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
            this.partialMessageTimer = void 0;
            if (token === this.messageToken) {
              this.firePartialMessage({ messageToken: token, waitingTime: timeout });
              this.setPartialMessageTimer();
            }
          }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
        }
      };
      exports2.ReadableStreamMessageReader = ReadableStreamMessageReader;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/semaphore.js
  var require_semaphore = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/semaphore.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Semaphore = void 0;
      var ral_1 = require_ral();
      var Semaphore = class {
        constructor(capacity = 1) {
          if (capacity <= 0) {
            throw new Error("Capacity must be greater than 0");
          }
          this._capacity = capacity;
          this._active = 0;
          this._waiting = [];
        }
        lock(thunk) {
          return new Promise((resolve2, reject) => {
            this._waiting.push({ thunk, resolve: resolve2, reject });
            this.runNext();
          });
        }
        get active() {
          return this._active;
        }
        runNext() {
          if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
          }
          (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
        }
        doRunNext() {
          if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
          }
          const next = this._waiting.shift();
          this._active++;
          if (this._active > this._capacity) {
            throw new Error(`To many thunks active`);
          }
          try {
            const result = next.thunk();
            if (result instanceof Promise) {
              result.then((value) => {
                this._active--;
                next.resolve(value);
                this.runNext();
              }, (err) => {
                this._active--;
                next.reject(err);
                this.runNext();
              });
            } else {
              this._active--;
              next.resolve(result);
              this.runNext();
            }
          } catch (err) {
            this._active--;
            next.reject(err);
            this.runNext();
          }
        }
      };
      exports2.Semaphore = Semaphore;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/messageWriter.js
  var require_messageWriter = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/messageWriter.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = void 0;
      var ral_1 = require_ral();
      var Is = require_is();
      var semaphore_1 = require_semaphore();
      var events_1 = require_events();
      var ContentLength = "Content-Length: ";
      var CRLF = "\r\n";
      var MessageWriter;
      (function(MessageWriter2) {
        function is(value) {
          let candidate = value;
          return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
        }
        MessageWriter2.is = is;
      })(MessageWriter = exports2.MessageWriter || (exports2.MessageWriter = {}));
      var AbstractMessageWriter = class {
        constructor() {
          this.errorEmitter = new events_1.Emitter();
          this.closeEmitter = new events_1.Emitter();
        }
        dispose() {
          this.errorEmitter.dispose();
          this.closeEmitter.dispose();
        }
        get onError() {
          return this.errorEmitter.event;
        }
        fireError(error, message, count) {
          this.errorEmitter.fire([this.asError(error), message, count]);
        }
        get onClose() {
          return this.closeEmitter.event;
        }
        fireClose() {
          this.closeEmitter.fire(void 0);
        }
        asError(error) {
          if (error instanceof Error) {
            return error;
          } else {
            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
          }
        }
      };
      exports2.AbstractMessageWriter = AbstractMessageWriter;
      var ResolvedMessageWriterOptions;
      (function(ResolvedMessageWriterOptions2) {
        function fromOptions(options) {
          if (options === void 0 || typeof options === "string") {
            return { charset: options ?? "utf-8", contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
          } else {
            return { charset: options.charset ?? "utf-8", contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
          }
        }
        ResolvedMessageWriterOptions2.fromOptions = fromOptions;
      })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
      var WriteableStreamMessageWriter = class extends AbstractMessageWriter {
        constructor(writable, options) {
          super();
          this.writable = writable;
          this.options = ResolvedMessageWriterOptions.fromOptions(options);
          this.errorCount = 0;
          this.writeSemaphore = new semaphore_1.Semaphore(1);
          this.writable.onError((error) => this.fireError(error));
          this.writable.onClose(() => this.fireClose());
        }
        async write(msg) {
          return this.writeSemaphore.lock(async () => {
            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
              if (this.options.contentEncoder !== void 0) {
                return this.options.contentEncoder.encode(buffer);
              } else {
                return buffer;
              }
            });
            return payload.then((buffer) => {
              const headers = [];
              headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
              headers.push(CRLF);
              return this.doWrite(msg, headers, buffer);
            }, (error) => {
              this.fireError(error);
              throw error;
            });
          });
        }
        async doWrite(msg, headers, data) {
          try {
            await this.writable.write(headers.join(""), "ascii");
            return this.writable.write(data);
          } catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
          }
        }
        handleError(error, msg) {
          this.errorCount++;
          this.fireError(error, msg, this.errorCount);
        }
        end() {
          this.writable.end();
        }
      };
      exports2.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/connection.js
  var require_connection = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/connection.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createMessageConnection = exports2.ConnectionOptions = exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.ConnectionStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.TraceValues = exports2.Trace = exports2.NullLogger = exports2.ProgressType = exports2.ProgressToken = void 0;
      var ral_1 = require_ral();
      var Is = require_is();
      var messages_1 = require_messages();
      var linkedMap_1 = require_linkedMap();
      var events_1 = require_events();
      var cancellation_1 = require_cancellation();
      var CancelNotification;
      (function(CancelNotification2) {
        CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
      })(CancelNotification || (CancelNotification = {}));
      var ProgressToken;
      (function(ProgressToken2) {
        function is(value) {
          return typeof value === "string" || typeof value === "number";
        }
        ProgressToken2.is = is;
      })(ProgressToken = exports2.ProgressToken || (exports2.ProgressToken = {}));
      var ProgressNotification;
      (function(ProgressNotification2) {
        ProgressNotification2.type = new messages_1.NotificationType("$/progress");
      })(ProgressNotification || (ProgressNotification = {}));
      var ProgressType = class {
        constructor() {
        }
      };
      exports2.ProgressType = ProgressType;
      var StarRequestHandler;
      (function(StarRequestHandler2) {
        function is(value) {
          return Is.func(value);
        }
        StarRequestHandler2.is = is;
      })(StarRequestHandler || (StarRequestHandler = {}));
      exports2.NullLogger = Object.freeze({
        error: () => {
        },
        warn: () => {
        },
        info: () => {
        },
        log: () => {
        }
      });
      var Trace;
      (function(Trace2) {
        Trace2[Trace2["Off"] = 0] = "Off";
        Trace2[Trace2["Messages"] = 1] = "Messages";
        Trace2[Trace2["Compact"] = 2] = "Compact";
        Trace2[Trace2["Verbose"] = 3] = "Verbose";
      })(Trace = exports2.Trace || (exports2.Trace = {}));
      var TraceValues;
      (function(TraceValues2) {
        TraceValues2.Off = "off";
        TraceValues2.Messages = "messages";
        TraceValues2.Compact = "compact";
        TraceValues2.Verbose = "verbose";
      })(TraceValues = exports2.TraceValues || (exports2.TraceValues = {}));
      (function(Trace2) {
        function fromString(value) {
          if (!Is.string(value)) {
            return Trace2.Off;
          }
          value = value.toLowerCase();
          switch (value) {
            case "off":
              return Trace2.Off;
            case "messages":
              return Trace2.Messages;
            case "compact":
              return Trace2.Compact;
            case "verbose":
              return Trace2.Verbose;
            default:
              return Trace2.Off;
          }
        }
        Trace2.fromString = fromString;
        function toString(value) {
          switch (value) {
            case Trace2.Off:
              return "off";
            case Trace2.Messages:
              return "messages";
            case Trace2.Compact:
              return "compact";
            case Trace2.Verbose:
              return "verbose";
            default:
              return "off";
          }
        }
        Trace2.toString = toString;
      })(Trace = exports2.Trace || (exports2.Trace = {}));
      var TraceFormat;
      (function(TraceFormat2) {
        TraceFormat2["Text"] = "text";
        TraceFormat2["JSON"] = "json";
      })(TraceFormat = exports2.TraceFormat || (exports2.TraceFormat = {}));
      (function(TraceFormat2) {
        function fromString(value) {
          if (!Is.string(value)) {
            return TraceFormat2.Text;
          }
          value = value.toLowerCase();
          if (value === "json") {
            return TraceFormat2.JSON;
          } else {
            return TraceFormat2.Text;
          }
        }
        TraceFormat2.fromString = fromString;
      })(TraceFormat = exports2.TraceFormat || (exports2.TraceFormat = {}));
      var SetTraceNotification;
      (function(SetTraceNotification2) {
        SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
      })(SetTraceNotification = exports2.SetTraceNotification || (exports2.SetTraceNotification = {}));
      var LogTraceNotification;
      (function(LogTraceNotification2) {
        LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
      })(LogTraceNotification = exports2.LogTraceNotification || (exports2.LogTraceNotification = {}));
      var ConnectionErrors;
      (function(ConnectionErrors2) {
        ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
        ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
        ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
      })(ConnectionErrors = exports2.ConnectionErrors || (exports2.ConnectionErrors = {}));
      var ConnectionError = class extends Error {
        constructor(code, message) {
          super(message);
          this.code = code;
          Object.setPrototypeOf(this, ConnectionError.prototype);
        }
      };
      exports2.ConnectionError = ConnectionError;
      var ConnectionStrategy;
      (function(ConnectionStrategy2) {
        function is(value) {
          const candidate = value;
          return candidate && Is.func(candidate.cancelUndispatched);
        }
        ConnectionStrategy2.is = is;
      })(ConnectionStrategy = exports2.ConnectionStrategy || (exports2.ConnectionStrategy = {}));
      var CancellationReceiverStrategy;
      (function(CancellationReceiverStrategy2) {
        CancellationReceiverStrategy2.Message = Object.freeze({
          createCancellationTokenSource(_) {
            return new cancellation_1.CancellationTokenSource();
          }
        });
        function is(value) {
          const candidate = value;
          return candidate && Is.func(candidate.createCancellationTokenSource);
        }
        CancellationReceiverStrategy2.is = is;
      })(CancellationReceiverStrategy = exports2.CancellationReceiverStrategy || (exports2.CancellationReceiverStrategy = {}));
      var CancellationSenderStrategy;
      (function(CancellationSenderStrategy2) {
        CancellationSenderStrategy2.Message = Object.freeze({
          sendCancellation(conn, id2) {
            return conn.sendNotification(CancelNotification.type, { id: id2 });
          },
          cleanup(_) {
          }
        });
        function is(value) {
          const candidate = value;
          return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
        }
        CancellationSenderStrategy2.is = is;
      })(CancellationSenderStrategy = exports2.CancellationSenderStrategy || (exports2.CancellationSenderStrategy = {}));
      var CancellationStrategy;
      (function(CancellationStrategy2) {
        CancellationStrategy2.Message = Object.freeze({
          receiver: CancellationReceiverStrategy.Message,
          sender: CancellationSenderStrategy.Message
        });
        function is(value) {
          const candidate = value;
          return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
        }
        CancellationStrategy2.is = is;
      })(CancellationStrategy = exports2.CancellationStrategy || (exports2.CancellationStrategy = {}));
      var ConnectionOptions;
      (function(ConnectionOptions2) {
        function is(value) {
          const candidate = value;
          return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy));
        }
        ConnectionOptions2.is = is;
      })(ConnectionOptions = exports2.ConnectionOptions || (exports2.ConnectionOptions = {}));
      var ConnectionState;
      (function(ConnectionState2) {
        ConnectionState2[ConnectionState2["New"] = 1] = "New";
        ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
        ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
        ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
      })(ConnectionState || (ConnectionState = {}));
      function createMessageConnection(messageReader, messageWriter, _logger, options) {
        const logger = _logger !== void 0 ? _logger : exports2.NullLogger;
        let sequenceNumber = 0;
        let notificationSequenceNumber = 0;
        let unknownResponseSequenceNumber = 0;
        const version2 = "2.0";
        let starRequestHandler = void 0;
        const requestHandlers = /* @__PURE__ */ new Map();
        let starNotificationHandler = void 0;
        const notificationHandlers = /* @__PURE__ */ new Map();
        const progressHandlers = /* @__PURE__ */ new Map();
        let timer;
        let messageQueue = new linkedMap_1.LinkedMap();
        let responsePromises = /* @__PURE__ */ new Map();
        let knownCanceledRequests = /* @__PURE__ */ new Set();
        let requestTokens = /* @__PURE__ */ new Map();
        let trace = Trace.Off;
        let traceFormat = TraceFormat.Text;
        let tracer;
        let state = ConnectionState.New;
        const errorEmitter = new events_1.Emitter();
        const closeEmitter = new events_1.Emitter();
        const unhandledNotificationEmitter = new events_1.Emitter();
        const unhandledProgressEmitter = new events_1.Emitter();
        const disposeEmitter = new events_1.Emitter();
        const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
        function createRequestQueueKey(id2) {
          if (id2 === null) {
            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
          }
          return "req-" + id2.toString();
        }
        function createResponseQueueKey(id2) {
          if (id2 === null) {
            return "res-unknown-" + (++unknownResponseSequenceNumber).toString();
          } else {
            return "res-" + id2.toString();
          }
        }
        function createNotificationQueueKey() {
          return "not-" + (++notificationSequenceNumber).toString();
        }
        function addMessageToQueue(queue, message) {
          if (messages_1.Message.isRequest(message)) {
            queue.set(createRequestQueueKey(message.id), message);
          } else if (messages_1.Message.isResponse(message)) {
            queue.set(createResponseQueueKey(message.id), message);
          } else {
            queue.set(createNotificationQueueKey(), message);
          }
        }
        function cancelUndispatched(_message) {
          return void 0;
        }
        function isListening() {
          return state === ConnectionState.Listening;
        }
        function isClosed() {
          return state === ConnectionState.Closed;
        }
        function isDisposed() {
          return state === ConnectionState.Disposed;
        }
        function closeHandler() {
          if (state === ConnectionState.New || state === ConnectionState.Listening) {
            state = ConnectionState.Closed;
            closeEmitter.fire(void 0);
          }
        }
        function readErrorHandler(error) {
          errorEmitter.fire([error, void 0, void 0]);
        }
        function writeErrorHandler(data) {
          errorEmitter.fire(data);
        }
        messageReader.onClose(closeHandler);
        messageReader.onError(readErrorHandler);
        messageWriter.onClose(closeHandler);
        messageWriter.onError(writeErrorHandler);
        function triggerMessageQueue() {
          if (timer || messageQueue.size === 0) {
            return;
          }
          timer = (0, ral_1.default)().timer.setImmediate(() => {
            timer = void 0;
            processMessageQueue();
          });
        }
        function processMessageQueue() {
          if (messageQueue.size === 0) {
            return;
          }
          const message = messageQueue.shift();
          try {
            if (messages_1.Message.isRequest(message)) {
              handleRequest(message);
            } else if (messages_1.Message.isNotification(message)) {
              handleNotification(message);
            } else if (messages_1.Message.isResponse(message)) {
              handleResponse(message);
            } else {
              handleInvalidMessage(message);
            }
          } finally {
            triggerMessageQueue();
          }
        }
        const callback = (message) => {
          try {
            if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
              const cancelId = message.params.id;
              const key = createRequestQueueKey(cancelId);
              const toCancel = messageQueue.get(key);
              if (messages_1.Message.isRequest(toCancel)) {
                const strategy = options?.connectionStrategy;
                const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                if (response && (response.error !== void 0 || response.result !== void 0)) {
                  messageQueue.delete(key);
                  requestTokens.delete(cancelId);
                  response.id = toCancel.id;
                  traceSendingResponse(response, message.method, Date.now());
                  messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
                  return;
                }
              }
              const cancellationToken = requestTokens.get(cancelId);
              if (cancellationToken !== void 0) {
                cancellationToken.cancel();
                traceReceivedNotification(message);
                return;
              } else {
                knownCanceledRequests.add(cancelId);
              }
            }
            addMessageToQueue(messageQueue, message);
          } finally {
            triggerMessageQueue();
          }
        };
        function handleRequest(requestMessage) {
          if (isDisposed()) {
            return;
          }
          function reply(resultOrError, method, startTime2) {
            const message = {
              jsonrpc: version2,
              id: requestMessage.id
            };
            if (resultOrError instanceof messages_1.ResponseError) {
              message.error = resultOrError.toJson();
            } else {
              message.result = resultOrError === void 0 ? null : resultOrError;
            }
            traceSendingResponse(message, method, startTime2);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
          }
          function replyError(error, method, startTime2) {
            const message = {
              jsonrpc: version2,
              id: requestMessage.id,
              error: error.toJson()
            };
            traceSendingResponse(message, method, startTime2);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
          }
          function replySuccess(result, method, startTime2) {
            if (result === void 0) {
              result = null;
            }
            const message = {
              jsonrpc: version2,
              id: requestMessage.id,
              result
            };
            traceSendingResponse(message, method, startTime2);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
          }
          traceReceivedRequest(requestMessage);
          const element = requestHandlers.get(requestMessage.method);
          let type;
          let requestHandler;
          if (element) {
            type = element.type;
            requestHandler = element.handler;
          }
          const startTime = Date.now();
          if (requestHandler || starRequestHandler) {
            const tokenKey = requestMessage.id ?? String(Date.now());
            const cancellationSource = cancellationStrategy.receiver.createCancellationTokenSource(tokenKey);
            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
              cancellationSource.cancel();
            }
            if (requestMessage.id !== null) {
              requestTokens.set(tokenKey, cancellationSource);
            }
            try {
              let handlerResult;
              if (requestHandler) {
                if (requestMessage.params === void 0) {
                  if (type !== void 0 && type.numberOfParams !== 0) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                    return;
                  }
                  handlerResult = requestHandler(cancellationSource.token);
                } else if (Array.isArray(requestMessage.params)) {
                  if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byName) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                    return;
                  }
                  handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
                } else {
                  if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                    return;
                  }
                  handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
                }
              } else if (starRequestHandler) {
                handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
              }
              const promise = handlerResult;
              if (!handlerResult) {
                requestTokens.delete(tokenKey);
                replySuccess(handlerResult, requestMessage.method, startTime);
              } else if (promise.then) {
                promise.then((resultOrError) => {
                  requestTokens.delete(tokenKey);
                  reply(resultOrError, requestMessage.method, startTime);
                }, (error) => {
                  requestTokens.delete(tokenKey);
                  if (error instanceof messages_1.ResponseError) {
                    replyError(error, requestMessage.method, startTime);
                  } else if (error && Is.string(error.message)) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                  } else {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                  }
                });
              } else {
                requestTokens.delete(tokenKey);
                reply(handlerResult, requestMessage.method, startTime);
              }
            } catch (error) {
              requestTokens.delete(tokenKey);
              if (error instanceof messages_1.ResponseError) {
                reply(error, requestMessage.method, startTime);
              } else if (error && Is.string(error.message)) {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
              } else {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
              }
            }
          } else {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
          }
        }
        function handleResponse(responseMessage) {
          if (isDisposed()) {
            return;
          }
          if (responseMessage.id === null) {
            if (responseMessage.error) {
              logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
            } else {
              logger.error(`Received response message without id. No further error information provided.`);
            }
          } else {
            const key = responseMessage.id;
            const responsePromise = responsePromises.get(key);
            traceReceivedResponse(responseMessage, responsePromise);
            if (responsePromise !== void 0) {
              responsePromises.delete(key);
              try {
                if (responseMessage.error) {
                  const error = responseMessage.error;
                  responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                } else if (responseMessage.result !== void 0) {
                  responsePromise.resolve(responseMessage.result);
                } else {
                  throw new Error("Should never happen.");
                }
              } catch (error) {
                if (error.message) {
                  logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                } else {
                  logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                }
              }
            }
          }
        }
        function handleNotification(message) {
          if (isDisposed()) {
            return;
          }
          let type = void 0;
          let notificationHandler;
          if (message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            knownCanceledRequests.delete(cancelId);
            traceReceivedNotification(message);
            return;
          } else {
            const element = notificationHandlers.get(message.method);
            if (element) {
              notificationHandler = element.handler;
              type = element.type;
            }
          }
          if (notificationHandler || starNotificationHandler) {
            try {
              traceReceivedNotification(message);
              if (notificationHandler) {
                if (message.params === void 0) {
                  if (type !== void 0) {
                    if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                      logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                    }
                  }
                  notificationHandler();
                } else if (Array.isArray(message.params)) {
                  const params = message.params;
                  if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                    notificationHandler({ token: params[0], value: params[1] });
                  } else {
                    if (type !== void 0) {
                      if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                        logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                      }
                      if (type.numberOfParams !== message.params.length) {
                        logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                      }
                    }
                    notificationHandler(...params);
                  }
                } else {
                  if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                    logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                  }
                  notificationHandler(message.params);
                }
              } else if (starNotificationHandler) {
                starNotificationHandler(message.method, message.params);
              }
            } catch (error) {
              if (error.message) {
                logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
              } else {
                logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
              }
            }
          } else {
            unhandledNotificationEmitter.fire(message);
          }
        }
        function handleInvalidMessage(message) {
          if (!message) {
            logger.error("Received empty message.");
            return;
          }
          logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
          const responseMessage = message;
          if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
            const key = responseMessage.id;
            const responseHandler = responsePromises.get(key);
            if (responseHandler) {
              responseHandler.reject(new Error("The received response has neither a result nor an error property."));
            }
          }
        }
        function stringifyTrace(params) {
          if (params === void 0 || params === null) {
            return void 0;
          }
          switch (trace) {
            case Trace.Verbose:
              return JSON.stringify(params, null, 4);
            case Trace.Compact:
              return JSON.stringify(params);
            default:
              return void 0;
          }
        }
        function traceSendingRequest(message) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            }
            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
          } else {
            logLSPMessage("send-request", message);
          }
        }
        function traceSendingNotification(message) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.params) {
                data = `Params: ${stringifyTrace(message.params)}

`;
              } else {
                data = "No parameters provided.\n\n";
              }
            }
            tracer.log(`Sending notification '${message.method}'.`, data);
          } else {
            logLSPMessage("send-notification", message);
          }
        }
        function traceSendingResponse(message, method, startTime) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.error && message.error.data) {
                data = `Error data: ${stringifyTrace(message.error.data)}

`;
              } else {
                if (message.result) {
                  data = `Result: ${stringifyTrace(message.result)}

`;
                } else if (message.error === void 0) {
                  data = "No result returned.\n\n";
                }
              }
            }
            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
          } else {
            logLSPMessage("send-response", message);
          }
        }
        function traceReceivedRequest(message) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            }
            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
          } else {
            logLSPMessage("receive-request", message);
          }
        }
        function traceReceivedNotification(message) {
          if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.params) {
                data = `Params: ${stringifyTrace(message.params)}

`;
              } else {
                data = "No parameters provided.\n\n";
              }
            }
            tracer.log(`Received notification '${message.method}'.`, data);
          } else {
            logLSPMessage("receive-notification", message);
          }
        }
        function traceReceivedResponse(message, responsePromise) {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          if (traceFormat === TraceFormat.Text) {
            let data = void 0;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
              if (message.error && message.error.data) {
                data = `Error data: ${stringifyTrace(message.error.data)}

`;
              } else {
                if (message.result) {
                  data = `Result: ${stringifyTrace(message.result)}

`;
                } else if (message.error === void 0) {
                  data = "No result returned.\n\n";
                }
              }
            }
            if (responsePromise) {
              const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
              tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
            } else {
              tracer.log(`Received response ${message.id} without active response promise.`, data);
            }
          } else {
            logLSPMessage("receive-response", message);
          }
        }
        function logLSPMessage(type, message) {
          if (!tracer || trace === Trace.Off) {
            return;
          }
          const lspMessage = {
            isLSPMessage: true,
            type,
            message,
            timestamp: Date.now()
          };
          tracer.log(lspMessage);
        }
        function throwIfClosedOrDisposed() {
          if (isClosed()) {
            throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
          }
          if (isDisposed()) {
            throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
          }
        }
        function throwIfListening() {
          if (isListening()) {
            throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
          }
        }
        function throwIfNotListening() {
          if (!isListening()) {
            throw new Error("Call listen() first.");
          }
        }
        function undefinedToNull(param) {
          if (param === void 0) {
            return null;
          } else {
            return param;
          }
        }
        function nullToUndefined(param) {
          if (param === null) {
            return void 0;
          } else {
            return param;
          }
        }
        function isNamedParam(param) {
          return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
        }
        function computeSingleParam(parameterStructures, param) {
          switch (parameterStructures) {
            case messages_1.ParameterStructures.auto:
              if (isNamedParam(param)) {
                return nullToUndefined(param);
              } else {
                return [undefinedToNull(param)];
              }
            case messages_1.ParameterStructures.byName:
              if (!isNamedParam(param)) {
                throw new Error(`Received parameters by name but param is not an object literal.`);
              }
              return nullToUndefined(param);
            case messages_1.ParameterStructures.byPosition:
              return [undefinedToNull(param)];
            default:
              throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
          }
        }
        function computeMessageParams(type, params) {
          let result;
          const numberOfParams = type.numberOfParams;
          switch (numberOfParams) {
            case 0:
              result = void 0;
              break;
            case 1:
              result = computeSingleParam(type.parameterStructures, params[0]);
              break;
            default:
              result = [];
              for (let i = 0; i < params.length && i < numberOfParams; i++) {
                result.push(undefinedToNull(params[i]));
              }
              if (params.length < numberOfParams) {
                for (let i = params.length; i < numberOfParams; i++) {
                  result.push(null);
                }
              }
              break;
          }
          return result;
        }
        const connection = {
          sendNotification: (type, ...args) => {
            throwIfClosedOrDisposed();
            let method;
            let messageParams;
            if (Is.string(type)) {
              method = type;
              const first = args[0];
              let paramStart = 0;
              let parameterStructures = messages_1.ParameterStructures.auto;
              if (messages_1.ParameterStructures.is(first)) {
                paramStart = 1;
                parameterStructures = first;
              }
              let paramEnd = args.length;
              const numberOfParams = paramEnd - paramStart;
              switch (numberOfParams) {
                case 0:
                  messageParams = void 0;
                  break;
                case 1:
                  messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                  break;
                default:
                  if (parameterStructures === messages_1.ParameterStructures.byName) {
                    throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                  }
                  messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                  break;
              }
            } else {
              const params = args;
              method = type.method;
              messageParams = computeMessageParams(type, params);
            }
            const notificationMessage = {
              jsonrpc: version2,
              method,
              params: messageParams
            };
            traceSendingNotification(notificationMessage);
            return messageWriter.write(notificationMessage).catch(() => logger.error(`Sending notification failed.`));
          },
          onNotification: (type, handler) => {
            throwIfClosedOrDisposed();
            let method;
            if (Is.func(type)) {
              starNotificationHandler = type;
            } else if (handler) {
              if (Is.string(type)) {
                method = type;
                notificationHandlers.set(type, { type: void 0, handler });
              } else {
                method = type.method;
                notificationHandlers.set(type.method, { type, handler });
              }
            }
            return {
              dispose: () => {
                if (method !== void 0) {
                  notificationHandlers.delete(method);
                } else {
                  starNotificationHandler = void 0;
                }
              }
            };
          },
          onProgress: (_type, token, handler) => {
            if (progressHandlers.has(token)) {
              throw new Error(`Progress handler for token ${token} already registered`);
            }
            progressHandlers.set(token, handler);
            return {
              dispose: () => {
                progressHandlers.delete(token);
              }
            };
          },
          sendProgress: (_type, token, value) => {
            return connection.sendNotification(ProgressNotification.type, { token, value });
          },
          onUnhandledProgress: unhandledProgressEmitter.event,
          sendRequest: (type, ...args) => {
            throwIfClosedOrDisposed();
            throwIfNotListening();
            let method;
            let messageParams;
            let token = void 0;
            if (Is.string(type)) {
              method = type;
              const first = args[0];
              const last = args[args.length - 1];
              let paramStart = 0;
              let parameterStructures = messages_1.ParameterStructures.auto;
              if (messages_1.ParameterStructures.is(first)) {
                paramStart = 1;
                parameterStructures = first;
              }
              let paramEnd = args.length;
              if (cancellation_1.CancellationToken.is(last)) {
                paramEnd = paramEnd - 1;
                token = last;
              }
              const numberOfParams = paramEnd - paramStart;
              switch (numberOfParams) {
                case 0:
                  messageParams = void 0;
                  break;
                case 1:
                  messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                  break;
                default:
                  if (parameterStructures === messages_1.ParameterStructures.byName) {
                    throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                  }
                  messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                  break;
              }
            } else {
              const params = args;
              method = type.method;
              messageParams = computeMessageParams(type, params);
              const numberOfParams = type.numberOfParams;
              token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
            }
            const id2 = sequenceNumber++;
            let disposable;
            if (token) {
              disposable = token.onCancellationRequested(() => {
                const p = cancellationStrategy.sender.sendCancellation(connection, id2);
                if (p === void 0) {
                  logger.log(`Received no promise from cancellation strategy when cancelling id ${id2}`);
                  return Promise.resolve();
                } else {
                  return p.catch(() => {
                    logger.log(`Sending cancellation messages for id ${id2} failed`);
                  });
                }
              });
            }
            const result = new Promise((resolve2, reject) => {
              const requestMessage = {
                jsonrpc: version2,
                id: id2,
                method,
                params: messageParams
              };
              const resolveWithCleanup = (r) => {
                resolve2(r);
                cancellationStrategy.sender.cleanup(id2);
                disposable?.dispose();
              };
              const rejectWithCleanup = (r) => {
                reject(r);
                cancellationStrategy.sender.cleanup(id2);
                disposable?.dispose();
              };
              let responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
              traceSendingRequest(requestMessage);
              try {
                messageWriter.write(requestMessage).catch(() => logger.error(`Sending request failed.`));
              } catch (e) {
                responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : "Unknown reason"));
                responsePromise = null;
              }
              if (responsePromise) {
                responsePromises.set(id2, responsePromise);
              }
            });
            return result;
          },
          onRequest: (type, handler) => {
            throwIfClosedOrDisposed();
            let method = null;
            if (StarRequestHandler.is(type)) {
              method = void 0;
              starRequestHandler = type;
            } else if (Is.string(type)) {
              method = null;
              if (handler !== void 0) {
                method = type;
                requestHandlers.set(type, { handler, type: void 0 });
              }
            } else {
              if (handler !== void 0) {
                method = type.method;
                requestHandlers.set(type.method, { type, handler });
              }
            }
            return {
              dispose: () => {
                if (method === null) {
                  return;
                }
                if (method !== void 0) {
                  requestHandlers.delete(method);
                } else {
                  starRequestHandler = void 0;
                }
              }
            };
          },
          hasPendingResponse: () => {
            return responsePromises.size > 0;
          },
          trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
            let _sendNotification = false;
            let _traceFormat = TraceFormat.Text;
            if (sendNotificationOrTraceOptions !== void 0) {
              if (Is.boolean(sendNotificationOrTraceOptions)) {
                _sendNotification = sendNotificationOrTraceOptions;
              } else {
                _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
              }
            }
            trace = _value;
            traceFormat = _traceFormat;
            if (trace === Trace.Off) {
              tracer = void 0;
            } else {
              tracer = _tracer;
            }
            if (_sendNotification && !isClosed() && !isDisposed()) {
              await connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
            }
          },
          onError: errorEmitter.event,
          onClose: closeEmitter.event,
          onUnhandledNotification: unhandledNotificationEmitter.event,
          onDispose: disposeEmitter.event,
          end: () => {
            messageWriter.end();
          },
          dispose: () => {
            if (isDisposed()) {
              return;
            }
            state = ConnectionState.Disposed;
            disposeEmitter.fire(void 0);
            const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, "Pending response rejected since connection got disposed");
            for (const promise of responsePromises.values()) {
              promise.reject(error);
            }
            responsePromises = /* @__PURE__ */ new Map();
            requestTokens = /* @__PURE__ */ new Map();
            knownCanceledRequests = /* @__PURE__ */ new Set();
            messageQueue = new linkedMap_1.LinkedMap();
            if (Is.func(messageWriter.dispose)) {
              messageWriter.dispose();
            }
            if (Is.func(messageReader.dispose)) {
              messageReader.dispose();
            }
          },
          listen: () => {
            throwIfClosedOrDisposed();
            throwIfListening();
            state = ConnectionState.Listening;
            messageReader.listen(callback);
          },
          inspect: () => {
            (0, ral_1.default)().console.log("inspect");
          }
        };
        connection.onNotification(LogTraceNotification.type, (params) => {
          if (trace === Trace.Off || !tracer) {
            return;
          }
          const verbose = trace === Trace.Verbose || trace === Trace.Compact;
          tracer.log(params.message, verbose ? params.verbose : void 0);
        });
        connection.onNotification(ProgressNotification.type, (params) => {
          const handler = progressHandlers.get(params.token);
          if (handler) {
            handler(params.value);
          } else {
            unhandledProgressEmitter.fire(params);
          }
        });
        return connection;
      }
      exports2.createMessageConnection = createMessageConnection;
    }
  });

  // node_modules/vscode-jsonrpc/lib/common/api.js
  var require_api = __commonJS({
    "node_modules/vscode-jsonrpc/lib/common/api.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TraceFormat = exports2.TraceValues = exports2.Trace = exports2.ProgressType = exports2.ProgressToken = exports2.createMessageConnection = exports2.NullLogger = exports2.ConnectionOptions = exports2.ConnectionStrategy = exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = exports2.CancellationToken = exports2.CancellationTokenSource = exports2.Emitter = exports2.Event = exports2.Disposable = exports2.LRUCache = exports2.Touch = exports2.LinkedMap = exports2.ParameterStructures = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.ErrorCodes = exports2.ResponseError = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType0 = exports2.RequestType = exports2.Message = exports2.RAL = void 0;
      exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = void 0;
      var messages_1 = require_messages();
      Object.defineProperty(exports2, "Message", { enumerable: true, get: function() {
        return messages_1.Message;
      } });
      Object.defineProperty(exports2, "RequestType", { enumerable: true, get: function() {
        return messages_1.RequestType;
      } });
      Object.defineProperty(exports2, "RequestType0", { enumerable: true, get: function() {
        return messages_1.RequestType0;
      } });
      Object.defineProperty(exports2, "RequestType1", { enumerable: true, get: function() {
        return messages_1.RequestType1;
      } });
      Object.defineProperty(exports2, "RequestType2", { enumerable: true, get: function() {
        return messages_1.RequestType2;
      } });
      Object.defineProperty(exports2, "RequestType3", { enumerable: true, get: function() {
        return messages_1.RequestType3;
      } });
      Object.defineProperty(exports2, "RequestType4", { enumerable: true, get: function() {
        return messages_1.RequestType4;
      } });
      Object.defineProperty(exports2, "RequestType5", { enumerable: true, get: function() {
        return messages_1.RequestType5;
      } });
      Object.defineProperty(exports2, "RequestType6", { enumerable: true, get: function() {
        return messages_1.RequestType6;
      } });
      Object.defineProperty(exports2, "RequestType7", { enumerable: true, get: function() {
        return messages_1.RequestType7;
      } });
      Object.defineProperty(exports2, "RequestType8", { enumerable: true, get: function() {
        return messages_1.RequestType8;
      } });
      Object.defineProperty(exports2, "RequestType9", { enumerable: true, get: function() {
        return messages_1.RequestType9;
      } });
      Object.defineProperty(exports2, "ResponseError", { enumerable: true, get: function() {
        return messages_1.ResponseError;
      } });
      Object.defineProperty(exports2, "ErrorCodes", { enumerable: true, get: function() {
        return messages_1.ErrorCodes;
      } });
      Object.defineProperty(exports2, "NotificationType", { enumerable: true, get: function() {
        return messages_1.NotificationType;
      } });
      Object.defineProperty(exports2, "NotificationType0", { enumerable: true, get: function() {
        return messages_1.NotificationType0;
      } });
      Object.defineProperty(exports2, "NotificationType1", { enumerable: true, get: function() {
        return messages_1.NotificationType1;
      } });
      Object.defineProperty(exports2, "NotificationType2", { enumerable: true, get: function() {
        return messages_1.NotificationType2;
      } });
      Object.defineProperty(exports2, "NotificationType3", { enumerable: true, get: function() {
        return messages_1.NotificationType3;
      } });
      Object.defineProperty(exports2, "NotificationType4", { enumerable: true, get: function() {
        return messages_1.NotificationType4;
      } });
      Object.defineProperty(exports2, "NotificationType5", { enumerable: true, get: function() {
        return messages_1.NotificationType5;
      } });
      Object.defineProperty(exports2, "NotificationType6", { enumerable: true, get: function() {
        return messages_1.NotificationType6;
      } });
      Object.defineProperty(exports2, "NotificationType7", { enumerable: true, get: function() {
        return messages_1.NotificationType7;
      } });
      Object.defineProperty(exports2, "NotificationType8", { enumerable: true, get: function() {
        return messages_1.NotificationType8;
      } });
      Object.defineProperty(exports2, "NotificationType9", { enumerable: true, get: function() {
        return messages_1.NotificationType9;
      } });
      Object.defineProperty(exports2, "ParameterStructures", { enumerable: true, get: function() {
        return messages_1.ParameterStructures;
      } });
      var linkedMap_1 = require_linkedMap();
      Object.defineProperty(exports2, "LinkedMap", { enumerable: true, get: function() {
        return linkedMap_1.LinkedMap;
      } });
      Object.defineProperty(exports2, "LRUCache", { enumerable: true, get: function() {
        return linkedMap_1.LRUCache;
      } });
      Object.defineProperty(exports2, "Touch", { enumerable: true, get: function() {
        return linkedMap_1.Touch;
      } });
      var disposable_1 = require_disposable();
      Object.defineProperty(exports2, "Disposable", { enumerable: true, get: function() {
        return disposable_1.Disposable;
      } });
      var events_1 = require_events();
      Object.defineProperty(exports2, "Event", { enumerable: true, get: function() {
        return events_1.Event;
      } });
      Object.defineProperty(exports2, "Emitter", { enumerable: true, get: function() {
        return events_1.Emitter;
      } });
      var cancellation_1 = require_cancellation();
      Object.defineProperty(exports2, "CancellationTokenSource", { enumerable: true, get: function() {
        return cancellation_1.CancellationTokenSource;
      } });
      Object.defineProperty(exports2, "CancellationToken", { enumerable: true, get: function() {
        return cancellation_1.CancellationToken;
      } });
      var messageReader_1 = require_messageReader();
      Object.defineProperty(exports2, "MessageReader", { enumerable: true, get: function() {
        return messageReader_1.MessageReader;
      } });
      Object.defineProperty(exports2, "AbstractMessageReader", { enumerable: true, get: function() {
        return messageReader_1.AbstractMessageReader;
      } });
      Object.defineProperty(exports2, "ReadableStreamMessageReader", { enumerable: true, get: function() {
        return messageReader_1.ReadableStreamMessageReader;
      } });
      var messageWriter_1 = require_messageWriter();
      Object.defineProperty(exports2, "MessageWriter", { enumerable: true, get: function() {
        return messageWriter_1.MessageWriter;
      } });
      Object.defineProperty(exports2, "AbstractMessageWriter", { enumerable: true, get: function() {
        return messageWriter_1.AbstractMessageWriter;
      } });
      Object.defineProperty(exports2, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
        return messageWriter_1.WriteableStreamMessageWriter;
      } });
      var connection_1 = require_connection();
      Object.defineProperty(exports2, "ConnectionStrategy", { enumerable: true, get: function() {
        return connection_1.ConnectionStrategy;
      } });
      Object.defineProperty(exports2, "ConnectionOptions", { enumerable: true, get: function() {
        return connection_1.ConnectionOptions;
      } });
      Object.defineProperty(exports2, "NullLogger", { enumerable: true, get: function() {
        return connection_1.NullLogger;
      } });
      Object.defineProperty(exports2, "createMessageConnection", { enumerable: true, get: function() {
        return connection_1.createMessageConnection;
      } });
      Object.defineProperty(exports2, "ProgressToken", { enumerable: true, get: function() {
        return connection_1.ProgressToken;
      } });
      Object.defineProperty(exports2, "ProgressType", { enumerable: true, get: function() {
        return connection_1.ProgressType;
      } });
      Object.defineProperty(exports2, "Trace", { enumerable: true, get: function() {
        return connection_1.Trace;
      } });
      Object.defineProperty(exports2, "TraceValues", { enumerable: true, get: function() {
        return connection_1.TraceValues;
      } });
      Object.defineProperty(exports2, "TraceFormat", { enumerable: true, get: function() {
        return connection_1.TraceFormat;
      } });
      Object.defineProperty(exports2, "SetTraceNotification", { enumerable: true, get: function() {
        return connection_1.SetTraceNotification;
      } });
      Object.defineProperty(exports2, "LogTraceNotification", { enumerable: true, get: function() {
        return connection_1.LogTraceNotification;
      } });
      Object.defineProperty(exports2, "ConnectionErrors", { enumerable: true, get: function() {
        return connection_1.ConnectionErrors;
      } });
      Object.defineProperty(exports2, "ConnectionError", { enumerable: true, get: function() {
        return connection_1.ConnectionError;
      } });
      Object.defineProperty(exports2, "CancellationReceiverStrategy", { enumerable: true, get: function() {
        return connection_1.CancellationReceiverStrategy;
      } });
      Object.defineProperty(exports2, "CancellationSenderStrategy", { enumerable: true, get: function() {
        return connection_1.CancellationSenderStrategy;
      } });
      Object.defineProperty(exports2, "CancellationStrategy", { enumerable: true, get: function() {
        return connection_1.CancellationStrategy;
      } });
      var ral_1 = require_ral();
      exports2.RAL = ral_1.default;
    }
  });

  // node_modules/vscode-jsonrpc/lib/browser/main.js
  var require_main = __commonJS({
    "node_modules/vscode-jsonrpc/lib/browser/main.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createMessageConnection = exports2.BrowserMessageWriter = exports2.BrowserMessageReader = void 0;
      var ril_1 = require_ril();
      ril_1.default.install();
      var api_1 = require_api();
      __exportStar(require_api(), exports2);
      var BrowserMessageReader = class extends api_1.AbstractMessageReader {
        constructor(context) {
          super();
          this._onData = new api_1.Emitter();
          this._messageListener = (event) => {
            this._onData.fire(event.data);
          };
          context.addEventListener("error", (event) => this.fireError(event));
          context.onmessage = this._messageListener;
        }
        listen(callback) {
          return this._onData.event(callback);
        }
      };
      exports2.BrowserMessageReader = BrowserMessageReader;
      var BrowserMessageWriter = class extends api_1.AbstractMessageWriter {
        constructor(context) {
          super();
          this.context = context;
          this.errorCount = 0;
          context.addEventListener("error", (event) => this.fireError(event));
        }
        write(msg) {
          try {
            this.context.postMessage(msg);
            return Promise.resolve();
          } catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
          }
        }
        handleError(error, msg) {
          this.errorCount++;
          this.fireError(error, msg, this.errorCount);
        }
        end() {
        }
      };
      exports2.BrowserMessageWriter = BrowserMessageWriter;
      function createMessageConnection(reader, writer, logger, options) {
        if (logger === void 0) {
          logger = api_1.NullLogger;
        }
        if (api_1.ConnectionStrategy.is(options)) {
          options = { connectionStrategy: options };
        }
        return (0, api_1.createMessageConnection)(reader, writer, logger, options);
      }
      exports2.createMessageConnection = createMessageConnection;
    }
  });

  // node_modules/vscode-jsonrpc/browser.js
  var require_browser = __commonJS({
    "node_modules/vscode-jsonrpc/browser.js"(exports2, module2) {
      "use strict";
      module2.exports = require_main();
    }
  });

  // node_modules/vscode-languageserver-types/lib/umd/main.js
  var require_main2 = __commonJS({
    "node_modules/vscode-languageserver-types/lib/umd/main.js"(exports2, module2) {
      (function(factory) {
        if (typeof module2 === "object" && typeof module2.exports === "object") {
          var v = factory(__require, exports2);
          if (v !== void 0)
            module2.exports = v;
        } else if (typeof define === "function" && define.amd) {
          define(["require", "exports"], factory);
        }
      })(function(require2, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.TextDocument = exports3.EOL = exports3.WorkspaceFolder = exports3.InlayHint = exports3.InlayHintLabelPart = exports3.InlayHintKind = exports3.InlineValueContext = exports3.InlineValueEvaluatableExpression = exports3.InlineValueVariableLookup = exports3.InlineValueText = exports3.SemanticTokens = exports3.SemanticTokenModifiers = exports3.SemanticTokenTypes = exports3.SelectionRange = exports3.DocumentLink = exports3.FormattingOptions = exports3.CodeLens = exports3.CodeAction = exports3.CodeActionContext = exports3.CodeActionTriggerKind = exports3.CodeActionKind = exports3.DocumentSymbol = exports3.WorkspaceSymbol = exports3.SymbolInformation = exports3.SymbolTag = exports3.SymbolKind = exports3.DocumentHighlight = exports3.DocumentHighlightKind = exports3.SignatureInformation = exports3.ParameterInformation = exports3.Hover = exports3.MarkedString = exports3.CompletionList = exports3.CompletionItem = exports3.CompletionItemLabelDetails = exports3.InsertTextMode = exports3.InsertReplaceEdit = exports3.CompletionItemTag = exports3.InsertTextFormat = exports3.CompletionItemKind = exports3.MarkupContent = exports3.MarkupKind = exports3.TextDocumentItem = exports3.OptionalVersionedTextDocumentIdentifier = exports3.VersionedTextDocumentIdentifier = exports3.TextDocumentIdentifier = exports3.WorkspaceChange = exports3.WorkspaceEdit = exports3.DeleteFile = exports3.RenameFile = exports3.CreateFile = exports3.TextDocumentEdit = exports3.AnnotatedTextEdit = exports3.ChangeAnnotationIdentifier = exports3.ChangeAnnotation = exports3.TextEdit = exports3.Command = exports3.Diagnostic = exports3.CodeDescription = exports3.DiagnosticTag = exports3.DiagnosticSeverity = exports3.DiagnosticRelatedInformation = exports3.FoldingRange = exports3.FoldingRangeKind = exports3.ColorPresentation = exports3.ColorInformation = exports3.Color = exports3.LocationLink = exports3.Location = exports3.Range = exports3.Position = exports3.uinteger = exports3.integer = exports3.URI = exports3.DocumentUri = void 0;
        var DocumentUri;
        (function(DocumentUri2) {
          function is(value) {
            return typeof value === "string";
          }
          DocumentUri2.is = is;
        })(DocumentUri = exports3.DocumentUri || (exports3.DocumentUri = {}));
        var URI2;
        (function(URI3) {
          function is(value) {
            return typeof value === "string";
          }
          URI3.is = is;
        })(URI2 = exports3.URI || (exports3.URI = {}));
        var integer;
        (function(integer2) {
          integer2.MIN_VALUE = -2147483648;
          integer2.MAX_VALUE = 2147483647;
          function is(value) {
            return typeof value === "number" && integer2.MIN_VALUE <= value && value <= integer2.MAX_VALUE;
          }
          integer2.is = is;
        })(integer = exports3.integer || (exports3.integer = {}));
        var uinteger;
        (function(uinteger2) {
          uinteger2.MIN_VALUE = 0;
          uinteger2.MAX_VALUE = 2147483647;
          function is(value) {
            return typeof value === "number" && uinteger2.MIN_VALUE <= value && value <= uinteger2.MAX_VALUE;
          }
          uinteger2.is = is;
        })(uinteger = exports3.uinteger || (exports3.uinteger = {}));
        var Position4;
        (function(Position5) {
          function create(line, character) {
            if (line === Number.MAX_VALUE) {
              line = uinteger.MAX_VALUE;
            }
            if (character === Number.MAX_VALUE) {
              character = uinteger.MAX_VALUE;
            }
            return { line, character };
          }
          Position5.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
          }
          Position5.is = is;
        })(Position4 = exports3.Position || (exports3.Position = {}));
        var Range4;
        (function(Range5) {
          function create(one, two, three, four) {
            if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
              return { start: Position4.create(one, two), end: Position4.create(three, four) };
            } else if (Position4.is(one) && Position4.is(two)) {
              return { start: one, end: two };
            } else {
              throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
            }
          }
          Range5.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Position4.is(candidate.start) && Position4.is(candidate.end);
          }
          Range5.is = is;
        })(Range4 = exports3.Range || (exports3.Range = {}));
        var Location4;
        (function(Location5) {
          function create(uri, range) {
            return { uri, range };
          }
          Location5.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Range4.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
          }
          Location5.is = is;
        })(Location4 = exports3.Location || (exports3.Location = {}));
        var LocationLink;
        (function(LocationLink2) {
          function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
            return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
          }
          LocationLink2.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Range4.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range4.is(candidate.targetSelectionRange) && (Range4.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
          }
          LocationLink2.is = is;
        })(LocationLink = exports3.LocationLink || (exports3.LocationLink = {}));
        var Color4;
        (function(Color5) {
          function create(red, green, blue, alpha) {
            return {
              red,
              green,
              blue,
              alpha
            };
          }
          Color5.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
          }
          Color5.is = is;
        })(Color4 = exports3.Color || (exports3.Color = {}));
        var ColorInformation4;
        (function(ColorInformation5) {
          function create(range, color) {
            return {
              range,
              color
            };
          }
          ColorInformation5.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Range4.is(candidate.range) && Color4.is(candidate.color);
          }
          ColorInformation5.is = is;
        })(ColorInformation4 = exports3.ColorInformation || (exports3.ColorInformation = {}));
        var ColorPresentation4;
        (function(ColorPresentation5) {
          function create(label, textEdit, additionalTextEdits) {
            return {
              label,
              textEdit,
              additionalTextEdits
            };
          }
          ColorPresentation5.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit4.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit4.is));
          }
          ColorPresentation5.is = is;
        })(ColorPresentation4 = exports3.ColorPresentation || (exports3.ColorPresentation = {}));
        var FoldingRangeKind3;
        (function(FoldingRangeKind4) {
          FoldingRangeKind4.Comment = "comment";
          FoldingRangeKind4.Imports = "imports";
          FoldingRangeKind4.Region = "region";
        })(FoldingRangeKind3 = exports3.FoldingRangeKind || (exports3.FoldingRangeKind = {}));
        var FoldingRange4;
        (function(FoldingRange5) {
          function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
            var result = {
              startLine,
              endLine
            };
            if (Is.defined(startCharacter)) {
              result.startCharacter = startCharacter;
            }
            if (Is.defined(endCharacter)) {
              result.endCharacter = endCharacter;
            }
            if (Is.defined(kind)) {
              result.kind = kind;
            }
            if (Is.defined(collapsedText)) {
              result.collapsedText = collapsedText;
            }
            return result;
          }
          FoldingRange5.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
          }
          FoldingRange5.is = is;
        })(FoldingRange4 = exports3.FoldingRange || (exports3.FoldingRange = {}));
        var DiagnosticRelatedInformation4;
        (function(DiagnosticRelatedInformation5) {
          function create(location, message) {
            return {
              location,
              message
            };
          }
          DiagnosticRelatedInformation5.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Location4.is(candidate.location) && Is.string(candidate.message);
          }
          DiagnosticRelatedInformation5.is = is;
        })(DiagnosticRelatedInformation4 = exports3.DiagnosticRelatedInformation || (exports3.DiagnosticRelatedInformation = {}));
        var DiagnosticSeverity3;
        (function(DiagnosticSeverity4) {
          DiagnosticSeverity4.Error = 1;
          DiagnosticSeverity4.Warning = 2;
          DiagnosticSeverity4.Information = 3;
          DiagnosticSeverity4.Hint = 4;
        })(DiagnosticSeverity3 = exports3.DiagnosticSeverity || (exports3.DiagnosticSeverity = {}));
        var DiagnosticTag3;
        (function(DiagnosticTag4) {
          DiagnosticTag4.Unnecessary = 1;
          DiagnosticTag4.Deprecated = 2;
        })(DiagnosticTag3 = exports3.DiagnosticTag || (exports3.DiagnosticTag = {}));
        var CodeDescription;
        (function(CodeDescription2) {
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.string(candidate.href);
          }
          CodeDescription2.is = is;
        })(CodeDescription = exports3.CodeDescription || (exports3.CodeDescription = {}));
        var Diagnostic4;
        (function(Diagnostic5) {
          function create(range, message, severity, code, source, relatedInformation) {
            var result = { range, message };
            if (Is.defined(severity)) {
              result.severity = severity;
            }
            if (Is.defined(code)) {
              result.code = code;
            }
            if (Is.defined(source)) {
              result.source = source;
            }
            if (Is.defined(relatedInformation)) {
              result.relatedInformation = relatedInformation;
            }
            return result;
          }
          Diagnostic5.create = create;
          function is(value) {
            var _a4;
            var candidate = value;
            return Is.defined(candidate) && Range4.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a4 = candidate.codeDescription) === null || _a4 === void 0 ? void 0 : _a4.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation4.is));
          }
          Diagnostic5.is = is;
        })(Diagnostic4 = exports3.Diagnostic || (exports3.Diagnostic = {}));
        var Command;
        (function(Command2) {
          function create(title, command) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
              args[_i - 2] = arguments[_i];
            }
            var result = { title, command };
            if (Is.defined(args) && args.length > 0) {
              result.arguments = args;
            }
            return result;
          }
          Command2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
          }
          Command2.is = is;
        })(Command = exports3.Command || (exports3.Command = {}));
        var TextEdit4;
        (function(TextEdit5) {
          function replace(range, newText) {
            return { range, newText };
          }
          TextEdit5.replace = replace;
          function insert(position, newText) {
            return { range: { start: position, end: position }, newText };
          }
          TextEdit5.insert = insert;
          function del(range) {
            return { range, newText: "" };
          }
          TextEdit5.del = del;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range4.is(candidate.range);
          }
          TextEdit5.is = is;
        })(TextEdit4 = exports3.TextEdit || (exports3.TextEdit = {}));
        var ChangeAnnotation;
        (function(ChangeAnnotation2) {
          function create(label, needsConfirmation, description) {
            var result = { label };
            if (needsConfirmation !== void 0) {
              result.needsConfirmation = needsConfirmation;
            }
            if (description !== void 0) {
              result.description = description;
            }
            return result;
          }
          ChangeAnnotation2.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
          }
          ChangeAnnotation2.is = is;
        })(ChangeAnnotation = exports3.ChangeAnnotation || (exports3.ChangeAnnotation = {}));
        var ChangeAnnotationIdentifier;
        (function(ChangeAnnotationIdentifier2) {
          function is(value) {
            var candidate = value;
            return Is.string(candidate);
          }
          ChangeAnnotationIdentifier2.is = is;
        })(ChangeAnnotationIdentifier = exports3.ChangeAnnotationIdentifier || (exports3.ChangeAnnotationIdentifier = {}));
        var AnnotatedTextEdit;
        (function(AnnotatedTextEdit2) {
          function replace(range, newText, annotation) {
            return { range, newText, annotationId: annotation };
          }
          AnnotatedTextEdit2.replace = replace;
          function insert(position, newText, annotation) {
            return { range: { start: position, end: position }, newText, annotationId: annotation };
          }
          AnnotatedTextEdit2.insert = insert;
          function del(range, annotation) {
            return { range, newText: "", annotationId: annotation };
          }
          AnnotatedTextEdit2.del = del;
          function is(value) {
            var candidate = value;
            return TextEdit4.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
          }
          AnnotatedTextEdit2.is = is;
        })(AnnotatedTextEdit = exports3.AnnotatedTextEdit || (exports3.AnnotatedTextEdit = {}));
        var TextDocumentEdit;
        (function(TextDocumentEdit2) {
          function create(textDocument, edits) {
            return { textDocument, edits };
          }
          TextDocumentEdit2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
          }
          TextDocumentEdit2.is = is;
        })(TextDocumentEdit = exports3.TextDocumentEdit || (exports3.TextDocumentEdit = {}));
        var CreateFile;
        (function(CreateFile2) {
          function create(uri, options, annotation) {
            var result = {
              kind: "create",
              uri
            };
            if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
              result.options = options;
            }
            if (annotation !== void 0) {
              result.annotationId = annotation;
            }
            return result;
          }
          CreateFile2.create = create;
          function is(value) {
            var candidate = value;
            return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
          }
          CreateFile2.is = is;
        })(CreateFile = exports3.CreateFile || (exports3.CreateFile = {}));
        var RenameFile;
        (function(RenameFile2) {
          function create(oldUri, newUri, options, annotation) {
            var result = {
              kind: "rename",
              oldUri,
              newUri
            };
            if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
              result.options = options;
            }
            if (annotation !== void 0) {
              result.annotationId = annotation;
            }
            return result;
          }
          RenameFile2.create = create;
          function is(value) {
            var candidate = value;
            return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
          }
          RenameFile2.is = is;
        })(RenameFile = exports3.RenameFile || (exports3.RenameFile = {}));
        var DeleteFile;
        (function(DeleteFile2) {
          function create(uri, options, annotation) {
            var result = {
              kind: "delete",
              uri
            };
            if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
              result.options = options;
            }
            if (annotation !== void 0) {
              result.annotationId = annotation;
            }
            return result;
          }
          DeleteFile2.create = create;
          function is(value) {
            var candidate = value;
            return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
          }
          DeleteFile2.is = is;
        })(DeleteFile = exports3.DeleteFile || (exports3.DeleteFile = {}));
        var WorkspaceEdit4;
        (function(WorkspaceEdit5) {
          function is(value) {
            var candidate = value;
            return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
              if (Is.string(change.kind)) {
                return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
              } else {
                return TextDocumentEdit.is(change);
              }
            }));
          }
          WorkspaceEdit5.is = is;
        })(WorkspaceEdit4 = exports3.WorkspaceEdit || (exports3.WorkspaceEdit = {}));
        var TextEditChangeImpl = (
          /** @class */
          function() {
            function TextEditChangeImpl2(edits, changeAnnotations) {
              this.edits = edits;
              this.changeAnnotations = changeAnnotations;
            }
            TextEditChangeImpl2.prototype.insert = function(position, newText, annotation) {
              var edit;
              var id2;
              if (annotation === void 0) {
                edit = TextEdit4.insert(position, newText);
              } else if (ChangeAnnotationIdentifier.is(annotation)) {
                id2 = annotation;
                edit = AnnotatedTextEdit.insert(position, newText, annotation);
              } else {
                this.assertChangeAnnotations(this.changeAnnotations);
                id2 = this.changeAnnotations.manage(annotation);
                edit = AnnotatedTextEdit.insert(position, newText, id2);
              }
              this.edits.push(edit);
              if (id2 !== void 0) {
                return id2;
              }
            };
            TextEditChangeImpl2.prototype.replace = function(range, newText, annotation) {
              var edit;
              var id2;
              if (annotation === void 0) {
                edit = TextEdit4.replace(range, newText);
              } else if (ChangeAnnotationIdentifier.is(annotation)) {
                id2 = annotation;
                edit = AnnotatedTextEdit.replace(range, newText, annotation);
              } else {
                this.assertChangeAnnotations(this.changeAnnotations);
                id2 = this.changeAnnotations.manage(annotation);
                edit = AnnotatedTextEdit.replace(range, newText, id2);
              }
              this.edits.push(edit);
              if (id2 !== void 0) {
                return id2;
              }
            };
            TextEditChangeImpl2.prototype.delete = function(range, annotation) {
              var edit;
              var id2;
              if (annotation === void 0) {
                edit = TextEdit4.del(range);
              } else if (ChangeAnnotationIdentifier.is(annotation)) {
                id2 = annotation;
                edit = AnnotatedTextEdit.del(range, annotation);
              } else {
                this.assertChangeAnnotations(this.changeAnnotations);
                id2 = this.changeAnnotations.manage(annotation);
                edit = AnnotatedTextEdit.del(range, id2);
              }
              this.edits.push(edit);
              if (id2 !== void 0) {
                return id2;
              }
            };
            TextEditChangeImpl2.prototype.add = function(edit) {
              this.edits.push(edit);
            };
            TextEditChangeImpl2.prototype.all = function() {
              return this.edits;
            };
            TextEditChangeImpl2.prototype.clear = function() {
              this.edits.splice(0, this.edits.length);
            };
            TextEditChangeImpl2.prototype.assertChangeAnnotations = function(value) {
              if (value === void 0) {
                throw new Error("Text edit change is not configured to manage change annotations.");
              }
            };
            return TextEditChangeImpl2;
          }()
        );
        var ChangeAnnotations = (
          /** @class */
          function() {
            function ChangeAnnotations2(annotations) {
              this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;
              this._counter = 0;
              this._size = 0;
            }
            ChangeAnnotations2.prototype.all = function() {
              return this._annotations;
            };
            Object.defineProperty(ChangeAnnotations2.prototype, "size", {
              get: function() {
                return this._size;
              },
              enumerable: false,
              configurable: true
            });
            ChangeAnnotations2.prototype.manage = function(idOrAnnotation, annotation) {
              var id2;
              if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
                id2 = idOrAnnotation;
              } else {
                id2 = this.nextId();
                annotation = idOrAnnotation;
              }
              if (this._annotations[id2] !== void 0) {
                throw new Error("Id ".concat(id2, " is already in use."));
              }
              if (annotation === void 0) {
                throw new Error("No annotation provided for id ".concat(id2));
              }
              this._annotations[id2] = annotation;
              this._size++;
              return id2;
            };
            ChangeAnnotations2.prototype.nextId = function() {
              this._counter++;
              return this._counter.toString();
            };
            return ChangeAnnotations2;
          }()
        );
        var WorkspaceChange = (
          /** @class */
          function() {
            function WorkspaceChange2(workspaceEdit) {
              var _this = this;
              this._textEditChanges = /* @__PURE__ */ Object.create(null);
              if (workspaceEdit !== void 0) {
                this._workspaceEdit = workspaceEdit;
                if (workspaceEdit.documentChanges) {
                  this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                  workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                  workspaceEdit.documentChanges.forEach(function(change) {
                    if (TextDocumentEdit.is(change)) {
                      var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                      _this._textEditChanges[change.textDocument.uri] = textEditChange;
                    }
                  });
                } else if (workspaceEdit.changes) {
                  Object.keys(workspaceEdit.changes).forEach(function(key) {
                    var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                    _this._textEditChanges[key] = textEditChange;
                  });
                }
              } else {
                this._workspaceEdit = {};
              }
            }
            Object.defineProperty(WorkspaceChange2.prototype, "edit", {
              /**
               * Returns the underlying [WorkspaceEdit](#WorkspaceEdit) literal
               * use to be returned from a workspace edit operation like rename.
               */
              get: function() {
                this.initDocumentChanges();
                if (this._changeAnnotations !== void 0) {
                  if (this._changeAnnotations.size === 0) {
                    this._workspaceEdit.changeAnnotations = void 0;
                  } else {
                    this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                  }
                }
                return this._workspaceEdit;
              },
              enumerable: false,
              configurable: true
            });
            WorkspaceChange2.prototype.getTextEditChange = function(key) {
              if (OptionalVersionedTextDocumentIdentifier.is(key)) {
                this.initDocumentChanges();
                if (this._workspaceEdit.documentChanges === void 0) {
                  throw new Error("Workspace edit is not configured for document changes.");
                }
                var textDocument = { uri: key.uri, version: key.version };
                var result = this._textEditChanges[textDocument.uri];
                if (!result) {
                  var edits = [];
                  var textDocumentEdit = {
                    textDocument,
                    edits
                  };
                  this._workspaceEdit.documentChanges.push(textDocumentEdit);
                  result = new TextEditChangeImpl(edits, this._changeAnnotations);
                  this._textEditChanges[textDocument.uri] = result;
                }
                return result;
              } else {
                this.initChanges();
                if (this._workspaceEdit.changes === void 0) {
                  throw new Error("Workspace edit is not configured for normal text edit changes.");
                }
                var result = this._textEditChanges[key];
                if (!result) {
                  var edits = [];
                  this._workspaceEdit.changes[key] = edits;
                  result = new TextEditChangeImpl(edits);
                  this._textEditChanges[key] = result;
                }
                return result;
              }
            };
            WorkspaceChange2.prototype.initDocumentChanges = function() {
              if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
                this._changeAnnotations = new ChangeAnnotations();
                this._workspaceEdit.documentChanges = [];
                this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
              }
            };
            WorkspaceChange2.prototype.initChanges = function() {
              if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
                this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
              }
            };
            WorkspaceChange2.prototype.createFile = function(uri, optionsOrAnnotation, options) {
              this.initDocumentChanges();
              if (this._workspaceEdit.documentChanges === void 0) {
                throw new Error("Workspace edit is not configured for document changes.");
              }
              var annotation;
              if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                annotation = optionsOrAnnotation;
              } else {
                options = optionsOrAnnotation;
              }
              var operation;
              var id2;
              if (annotation === void 0) {
                operation = CreateFile.create(uri, options);
              } else {
                id2 = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                operation = CreateFile.create(uri, options, id2);
              }
              this._workspaceEdit.documentChanges.push(operation);
              if (id2 !== void 0) {
                return id2;
              }
            };
            WorkspaceChange2.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
              this.initDocumentChanges();
              if (this._workspaceEdit.documentChanges === void 0) {
                throw new Error("Workspace edit is not configured for document changes.");
              }
              var annotation;
              if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                annotation = optionsOrAnnotation;
              } else {
                options = optionsOrAnnotation;
              }
              var operation;
              var id2;
              if (annotation === void 0) {
                operation = RenameFile.create(oldUri, newUri, options);
              } else {
                id2 = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                operation = RenameFile.create(oldUri, newUri, options, id2);
              }
              this._workspaceEdit.documentChanges.push(operation);
              if (id2 !== void 0) {
                return id2;
              }
            };
            WorkspaceChange2.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
              this.initDocumentChanges();
              if (this._workspaceEdit.documentChanges === void 0) {
                throw new Error("Workspace edit is not configured for document changes.");
              }
              var annotation;
              if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                annotation = optionsOrAnnotation;
              } else {
                options = optionsOrAnnotation;
              }
              var operation;
              var id2;
              if (annotation === void 0) {
                operation = DeleteFile.create(uri, options);
              } else {
                id2 = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                operation = DeleteFile.create(uri, options, id2);
              }
              this._workspaceEdit.documentChanges.push(operation);
              if (id2 !== void 0) {
                return id2;
              }
            };
            return WorkspaceChange2;
          }()
        );
        exports3.WorkspaceChange = WorkspaceChange;
        var TextDocumentIdentifier;
        (function(TextDocumentIdentifier2) {
          function create(uri) {
            return { uri };
          }
          TextDocumentIdentifier2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.uri);
          }
          TextDocumentIdentifier2.is = is;
        })(TextDocumentIdentifier = exports3.TextDocumentIdentifier || (exports3.TextDocumentIdentifier = {}));
        var VersionedTextDocumentIdentifier;
        (function(VersionedTextDocumentIdentifier2) {
          function create(uri, version2) {
            return { uri, version: version2 };
          }
          VersionedTextDocumentIdentifier2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
          }
          VersionedTextDocumentIdentifier2.is = is;
        })(VersionedTextDocumentIdentifier = exports3.VersionedTextDocumentIdentifier || (exports3.VersionedTextDocumentIdentifier = {}));
        var OptionalVersionedTextDocumentIdentifier;
        (function(OptionalVersionedTextDocumentIdentifier2) {
          function create(uri, version2) {
            return { uri, version: version2 };
          }
          OptionalVersionedTextDocumentIdentifier2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
          }
          OptionalVersionedTextDocumentIdentifier2.is = is;
        })(OptionalVersionedTextDocumentIdentifier = exports3.OptionalVersionedTextDocumentIdentifier || (exports3.OptionalVersionedTextDocumentIdentifier = {}));
        var TextDocumentItem;
        (function(TextDocumentItem2) {
          function create(uri, languageId, version2, text) {
            return { uri, languageId, version: version2, text };
          }
          TextDocumentItem2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
          }
          TextDocumentItem2.is = is;
        })(TextDocumentItem = exports3.TextDocumentItem || (exports3.TextDocumentItem = {}));
        var MarkupKind;
        (function(MarkupKind2) {
          MarkupKind2.PlainText = "plaintext";
          MarkupKind2.Markdown = "markdown";
          function is(value) {
            var candidate = value;
            return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;
          }
          MarkupKind2.is = is;
        })(MarkupKind = exports3.MarkupKind || (exports3.MarkupKind = {}));
        var MarkupContent;
        (function(MarkupContent2) {
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
          }
          MarkupContent2.is = is;
        })(MarkupContent = exports3.MarkupContent || (exports3.MarkupContent = {}));
        var CompletionItemKind3;
        (function(CompletionItemKind4) {
          CompletionItemKind4.Text = 1;
          CompletionItemKind4.Method = 2;
          CompletionItemKind4.Function = 3;
          CompletionItemKind4.Constructor = 4;
          CompletionItemKind4.Field = 5;
          CompletionItemKind4.Variable = 6;
          CompletionItemKind4.Class = 7;
          CompletionItemKind4.Interface = 8;
          CompletionItemKind4.Module = 9;
          CompletionItemKind4.Property = 10;
          CompletionItemKind4.Unit = 11;
          CompletionItemKind4.Value = 12;
          CompletionItemKind4.Enum = 13;
          CompletionItemKind4.Keyword = 14;
          CompletionItemKind4.Snippet = 15;
          CompletionItemKind4.Color = 16;
          CompletionItemKind4.File = 17;
          CompletionItemKind4.Reference = 18;
          CompletionItemKind4.Folder = 19;
          CompletionItemKind4.EnumMember = 20;
          CompletionItemKind4.Constant = 21;
          CompletionItemKind4.Struct = 22;
          CompletionItemKind4.Event = 23;
          CompletionItemKind4.Operator = 24;
          CompletionItemKind4.TypeParameter = 25;
        })(CompletionItemKind3 = exports3.CompletionItemKind || (exports3.CompletionItemKind = {}));
        var InsertTextFormat;
        (function(InsertTextFormat2) {
          InsertTextFormat2.PlainText = 1;
          InsertTextFormat2.Snippet = 2;
        })(InsertTextFormat = exports3.InsertTextFormat || (exports3.InsertTextFormat = {}));
        var CompletionItemTag3;
        (function(CompletionItemTag4) {
          CompletionItemTag4.Deprecated = 1;
        })(CompletionItemTag3 = exports3.CompletionItemTag || (exports3.CompletionItemTag = {}));
        var InsertReplaceEdit;
        (function(InsertReplaceEdit2) {
          function create(newText, insert, replace) {
            return { newText, insert, replace };
          }
          InsertReplaceEdit2.create = create;
          function is(value) {
            var candidate = value;
            return candidate && Is.string(candidate.newText) && Range4.is(candidate.insert) && Range4.is(candidate.replace);
          }
          InsertReplaceEdit2.is = is;
        })(InsertReplaceEdit = exports3.InsertReplaceEdit || (exports3.InsertReplaceEdit = {}));
        var InsertTextMode;
        (function(InsertTextMode2) {
          InsertTextMode2.asIs = 1;
          InsertTextMode2.adjustIndentation = 2;
        })(InsertTextMode = exports3.InsertTextMode || (exports3.InsertTextMode = {}));
        var CompletionItemLabelDetails;
        (function(CompletionItemLabelDetails2) {
          function is(value) {
            var candidate = value;
            return candidate && (Is.string(candidate.detail) || candidate.detail === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
          }
          CompletionItemLabelDetails2.is = is;
        })(CompletionItemLabelDetails = exports3.CompletionItemLabelDetails || (exports3.CompletionItemLabelDetails = {}));
        var CompletionItem4;
        (function(CompletionItem5) {
          function create(label) {
            return { label };
          }
          CompletionItem5.create = create;
        })(CompletionItem4 = exports3.CompletionItem || (exports3.CompletionItem = {}));
        var CompletionList4;
        (function(CompletionList5) {
          function create(items, isIncomplete) {
            return { items: items ? items : [], isIncomplete: !!isIncomplete };
          }
          CompletionList5.create = create;
        })(CompletionList4 = exports3.CompletionList || (exports3.CompletionList = {}));
        var MarkedString;
        (function(MarkedString2) {
          function fromPlainText(plainText) {
            return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
          }
          MarkedString2.fromPlainText = fromPlainText;
          function is(value) {
            var candidate = value;
            return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
          }
          MarkedString2.is = is;
        })(MarkedString = exports3.MarkedString || (exports3.MarkedString = {}));
        var Hover4;
        (function(Hover5) {
          function is(value) {
            var candidate = value;
            return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range4.is(value.range));
          }
          Hover5.is = is;
        })(Hover4 = exports3.Hover || (exports3.Hover = {}));
        var ParameterInformation4;
        (function(ParameterInformation5) {
          function create(label, documentation) {
            return documentation ? { label, documentation } : { label };
          }
          ParameterInformation5.create = create;
        })(ParameterInformation4 = exports3.ParameterInformation || (exports3.ParameterInformation = {}));
        var SignatureInformation4;
        (function(SignatureInformation5) {
          function create(label, documentation) {
            var parameters = [];
            for (var _i = 2; _i < arguments.length; _i++) {
              parameters[_i - 2] = arguments[_i];
            }
            var result = { label };
            if (Is.defined(documentation)) {
              result.documentation = documentation;
            }
            if (Is.defined(parameters)) {
              result.parameters = parameters;
            } else {
              result.parameters = [];
            }
            return result;
          }
          SignatureInformation5.create = create;
        })(SignatureInformation4 = exports3.SignatureInformation || (exports3.SignatureInformation = {}));
        var DocumentHighlightKind3;
        (function(DocumentHighlightKind4) {
          DocumentHighlightKind4.Text = 1;
          DocumentHighlightKind4.Read = 2;
          DocumentHighlightKind4.Write = 3;
        })(DocumentHighlightKind3 = exports3.DocumentHighlightKind || (exports3.DocumentHighlightKind = {}));
        var DocumentHighlight4;
        (function(DocumentHighlight5) {
          function create(range, kind) {
            var result = { range };
            if (Is.number(kind)) {
              result.kind = kind;
            }
            return result;
          }
          DocumentHighlight5.create = create;
        })(DocumentHighlight4 = exports3.DocumentHighlight || (exports3.DocumentHighlight = {}));
        var SymbolKind3;
        (function(SymbolKind4) {
          SymbolKind4.File = 1;
          SymbolKind4.Module = 2;
          SymbolKind4.Namespace = 3;
          SymbolKind4.Package = 4;
          SymbolKind4.Class = 5;
          SymbolKind4.Method = 6;
          SymbolKind4.Property = 7;
          SymbolKind4.Field = 8;
          SymbolKind4.Constructor = 9;
          SymbolKind4.Enum = 10;
          SymbolKind4.Interface = 11;
          SymbolKind4.Function = 12;
          SymbolKind4.Variable = 13;
          SymbolKind4.Constant = 14;
          SymbolKind4.String = 15;
          SymbolKind4.Number = 16;
          SymbolKind4.Boolean = 17;
          SymbolKind4.Array = 18;
          SymbolKind4.Object = 19;
          SymbolKind4.Key = 20;
          SymbolKind4.Null = 21;
          SymbolKind4.EnumMember = 22;
          SymbolKind4.Struct = 23;
          SymbolKind4.Event = 24;
          SymbolKind4.Operator = 25;
          SymbolKind4.TypeParameter = 26;
        })(SymbolKind3 = exports3.SymbolKind || (exports3.SymbolKind = {}));
        var SymbolTag3;
        (function(SymbolTag4) {
          SymbolTag4.Deprecated = 1;
        })(SymbolTag3 = exports3.SymbolTag || (exports3.SymbolTag = {}));
        var SymbolInformation4;
        (function(SymbolInformation5) {
          function create(name, kind, range, uri, containerName) {
            var result = {
              name,
              kind,
              location: { uri, range }
            };
            if (containerName) {
              result.containerName = containerName;
            }
            return result;
          }
          SymbolInformation5.create = create;
        })(SymbolInformation4 = exports3.SymbolInformation || (exports3.SymbolInformation = {}));
        var WorkspaceSymbol;
        (function(WorkspaceSymbol2) {
          function create(name, kind, uri, range) {
            return range !== void 0 ? { name, kind, location: { uri, range } } : { name, kind, location: { uri } };
          }
          WorkspaceSymbol2.create = create;
        })(WorkspaceSymbol = exports3.WorkspaceSymbol || (exports3.WorkspaceSymbol = {}));
        var DocumentSymbol4;
        (function(DocumentSymbol5) {
          function create(name, detail, kind, range, selectionRange, children) {
            var result = {
              name,
              detail,
              kind,
              range,
              selectionRange
            };
            if (children !== void 0) {
              result.children = children;
            }
            return result;
          }
          DocumentSymbol5.create = create;
          function is(value) {
            var candidate = value;
            return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range4.is(candidate.range) && Range4.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
          }
          DocumentSymbol5.is = is;
        })(DocumentSymbol4 = exports3.DocumentSymbol || (exports3.DocumentSymbol = {}));
        var CodeActionKind4;
        (function(CodeActionKind5) {
          CodeActionKind5.Empty = "";
          CodeActionKind5.QuickFix = "quickfix";
          CodeActionKind5.Refactor = "refactor";
          CodeActionKind5.RefactorExtract = "refactor.extract";
          CodeActionKind5.RefactorInline = "refactor.inline";
          CodeActionKind5.RefactorRewrite = "refactor.rewrite";
          CodeActionKind5.Source = "source";
          CodeActionKind5.SourceOrganizeImports = "source.organizeImports";
          CodeActionKind5.SourceFixAll = "source.fixAll";
        })(CodeActionKind4 = exports3.CodeActionKind || (exports3.CodeActionKind = {}));
        var CodeActionTriggerKind3;
        (function(CodeActionTriggerKind4) {
          CodeActionTriggerKind4.Invoked = 1;
          CodeActionTriggerKind4.Automatic = 2;
        })(CodeActionTriggerKind3 = exports3.CodeActionTriggerKind || (exports3.CodeActionTriggerKind = {}));
        var CodeActionContext;
        (function(CodeActionContext2) {
          function create(diagnostics, only, triggerKind) {
            var result = { diagnostics };
            if (only !== void 0 && only !== null) {
              result.only = only;
            }
            if (triggerKind !== void 0 && triggerKind !== null) {
              result.triggerKind = triggerKind;
            }
            return result;
          }
          CodeActionContext2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic4.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind3.Invoked || candidate.triggerKind === CodeActionTriggerKind3.Automatic);
          }
          CodeActionContext2.is = is;
        })(CodeActionContext = exports3.CodeActionContext || (exports3.CodeActionContext = {}));
        var CodeAction4;
        (function(CodeAction5) {
          function create(title, kindOrCommandOrEdit, kind) {
            var result = { title };
            var checkKind = true;
            if (typeof kindOrCommandOrEdit === "string") {
              checkKind = false;
              result.kind = kindOrCommandOrEdit;
            } else if (Command.is(kindOrCommandOrEdit)) {
              result.command = kindOrCommandOrEdit;
            } else {
              result.edit = kindOrCommandOrEdit;
            }
            if (checkKind && kind !== void 0) {
              result.kind = kind;
            }
            return result;
          }
          CodeAction5.create = create;
          function is(value) {
            var candidate = value;
            return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic4.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit4.is(candidate.edit));
          }
          CodeAction5.is = is;
        })(CodeAction4 = exports3.CodeAction || (exports3.CodeAction = {}));
        var CodeLens4;
        (function(CodeLens5) {
          function create(range, data) {
            var result = { range };
            if (Is.defined(data)) {
              result.data = data;
            }
            return result;
          }
          CodeLens5.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Range4.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
          }
          CodeLens5.is = is;
        })(CodeLens4 = exports3.CodeLens || (exports3.CodeLens = {}));
        var FormattingOptions;
        (function(FormattingOptions2) {
          function create(tabSize, insertSpaces) {
            return { tabSize, insertSpaces };
          }
          FormattingOptions2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
          }
          FormattingOptions2.is = is;
        })(FormattingOptions = exports3.FormattingOptions || (exports3.FormattingOptions = {}));
        var DocumentLink4;
        (function(DocumentLink5) {
          function create(range, target, data) {
            return { range, target, data };
          }
          DocumentLink5.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Range4.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
          }
          DocumentLink5.is = is;
        })(DocumentLink4 = exports3.DocumentLink || (exports3.DocumentLink = {}));
        var SelectionRange4;
        (function(SelectionRange5) {
          function create(range, parent) {
            return { range, parent };
          }
          SelectionRange5.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Range4.is(candidate.range) && (candidate.parent === void 0 || SelectionRange5.is(candidate.parent));
          }
          SelectionRange5.is = is;
        })(SelectionRange4 = exports3.SelectionRange || (exports3.SelectionRange = {}));
        var SemanticTokenTypes;
        (function(SemanticTokenTypes2) {
          SemanticTokenTypes2["namespace"] = "namespace";
          SemanticTokenTypes2["type"] = "type";
          SemanticTokenTypes2["class"] = "class";
          SemanticTokenTypes2["enum"] = "enum";
          SemanticTokenTypes2["interface"] = "interface";
          SemanticTokenTypes2["struct"] = "struct";
          SemanticTokenTypes2["typeParameter"] = "typeParameter";
          SemanticTokenTypes2["parameter"] = "parameter";
          SemanticTokenTypes2["variable"] = "variable";
          SemanticTokenTypes2["property"] = "property";
          SemanticTokenTypes2["enumMember"] = "enumMember";
          SemanticTokenTypes2["event"] = "event";
          SemanticTokenTypes2["function"] = "function";
          SemanticTokenTypes2["method"] = "method";
          SemanticTokenTypes2["macro"] = "macro";
          SemanticTokenTypes2["keyword"] = "keyword";
          SemanticTokenTypes2["modifier"] = "modifier";
          SemanticTokenTypes2["comment"] = "comment";
          SemanticTokenTypes2["string"] = "string";
          SemanticTokenTypes2["number"] = "number";
          SemanticTokenTypes2["regexp"] = "regexp";
          SemanticTokenTypes2["operator"] = "operator";
          SemanticTokenTypes2["decorator"] = "decorator";
        })(SemanticTokenTypes = exports3.SemanticTokenTypes || (exports3.SemanticTokenTypes = {}));
        var SemanticTokenModifiers;
        (function(SemanticTokenModifiers2) {
          SemanticTokenModifiers2["declaration"] = "declaration";
          SemanticTokenModifiers2["definition"] = "definition";
          SemanticTokenModifiers2["readonly"] = "readonly";
          SemanticTokenModifiers2["static"] = "static";
          SemanticTokenModifiers2["deprecated"] = "deprecated";
          SemanticTokenModifiers2["abstract"] = "abstract";
          SemanticTokenModifiers2["async"] = "async";
          SemanticTokenModifiers2["modification"] = "modification";
          SemanticTokenModifiers2["documentation"] = "documentation";
          SemanticTokenModifiers2["defaultLibrary"] = "defaultLibrary";
        })(SemanticTokenModifiers = exports3.SemanticTokenModifiers || (exports3.SemanticTokenModifiers = {}));
        var SemanticTokens3;
        (function(SemanticTokens4) {
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
          }
          SemanticTokens4.is = is;
        })(SemanticTokens3 = exports3.SemanticTokens || (exports3.SemanticTokens = {}));
        var InlineValueText4;
        (function(InlineValueText5) {
          function create(range, text) {
            return { range, text };
          }
          InlineValueText5.create = create;
          function is(value) {
            var candidate = value;
            return candidate !== void 0 && candidate !== null && Range4.is(candidate.range) && Is.string(candidate.text);
          }
          InlineValueText5.is = is;
        })(InlineValueText4 = exports3.InlineValueText || (exports3.InlineValueText = {}));
        var InlineValueVariableLookup4;
        (function(InlineValueVariableLookup5) {
          function create(range, variableName, caseSensitiveLookup) {
            return { range, variableName, caseSensitiveLookup };
          }
          InlineValueVariableLookup5.create = create;
          function is(value) {
            var candidate = value;
            return candidate !== void 0 && candidate !== null && Range4.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === void 0);
          }
          InlineValueVariableLookup5.is = is;
        })(InlineValueVariableLookup4 = exports3.InlineValueVariableLookup || (exports3.InlineValueVariableLookup = {}));
        var InlineValueEvaluatableExpression4;
        (function(InlineValueEvaluatableExpression5) {
          function create(range, expression) {
            return { range, expression };
          }
          InlineValueEvaluatableExpression5.create = create;
          function is(value) {
            var candidate = value;
            return candidate !== void 0 && candidate !== null && Range4.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === void 0);
          }
          InlineValueEvaluatableExpression5.is = is;
        })(InlineValueEvaluatableExpression4 = exports3.InlineValueEvaluatableExpression || (exports3.InlineValueEvaluatableExpression = {}));
        var InlineValueContext3;
        (function(InlineValueContext4) {
          function create(frameId, stoppedLocation) {
            return { frameId, stoppedLocation };
          }
          InlineValueContext4.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Range4.is(value.stoppedLocation);
          }
          InlineValueContext4.is = is;
        })(InlineValueContext3 = exports3.InlineValueContext || (exports3.InlineValueContext = {}));
        var InlayHintKind3;
        (function(InlayHintKind4) {
          InlayHintKind4.Type = 1;
          InlayHintKind4.Parameter = 2;
          function is(value) {
            return value === 1 || value === 2;
          }
          InlayHintKind4.is = is;
        })(InlayHintKind3 = exports3.InlayHintKind || (exports3.InlayHintKind = {}));
        var InlayHintLabelPart4;
        (function(InlayHintLabelPart5) {
          function create(value) {
            return { value };
          }
          InlayHintLabelPart5.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === void 0 || Location4.is(candidate.location)) && (candidate.command === void 0 || Command.is(candidate.command));
          }
          InlayHintLabelPart5.is = is;
        })(InlayHintLabelPart4 = exports3.InlayHintLabelPart || (exports3.InlayHintLabelPart = {}));
        var InlayHint4;
        (function(InlayHint5) {
          function create(position, label, kind) {
            var result = { position, label };
            if (kind !== void 0) {
              result.kind = kind;
            }
            return result;
          }
          InlayHint5.create = create;
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Position4.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart4.is)) && (candidate.kind === void 0 || InlayHintKind3.is(candidate.kind)) && candidate.textEdits === void 0 || Is.typedArray(candidate.textEdits, TextEdit4.is) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || Is.boolean(candidate.paddingRight));
          }
          InlayHint5.is = is;
        })(InlayHint4 = exports3.InlayHint || (exports3.InlayHint = {}));
        var WorkspaceFolder;
        (function(WorkspaceFolder2) {
          function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && URI2.is(candidate.uri) && Is.string(candidate.name);
          }
          WorkspaceFolder2.is = is;
        })(WorkspaceFolder = exports3.WorkspaceFolder || (exports3.WorkspaceFolder = {}));
        exports3.EOL = ["\n", "\r\n", "\r"];
        var TextDocument;
        (function(TextDocument2) {
          function create(uri, languageId, version2, content) {
            return new FullTextDocument(uri, languageId, version2, content);
          }
          TextDocument2.create = create;
          function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
          }
          TextDocument2.is = is;
          function applyEdits(document2, edits) {
            var text = document2.getText();
            var sortedEdits = mergeSort(edits, function(a, b) {
              var diff = a.range.start.line - b.range.start.line;
              if (diff === 0) {
                return a.range.start.character - b.range.start.character;
              }
              return diff;
            });
            var lastModifiedOffset = text.length;
            for (var i = sortedEdits.length - 1; i >= 0; i--) {
              var e = sortedEdits[i];
              var startOffset = document2.offsetAt(e.range.start);
              var endOffset = document2.offsetAt(e.range.end);
              if (endOffset <= lastModifiedOffset) {
                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
              } else {
                throw new Error("Overlapping edit");
              }
              lastModifiedOffset = startOffset;
            }
            return text;
          }
          TextDocument2.applyEdits = applyEdits;
          function mergeSort(data, compare2) {
            if (data.length <= 1) {
              return data;
            }
            var p = data.length / 2 | 0;
            var left = data.slice(0, p);
            var right = data.slice(p);
            mergeSort(left, compare2);
            mergeSort(right, compare2);
            var leftIdx = 0;
            var rightIdx = 0;
            var i = 0;
            while (leftIdx < left.length && rightIdx < right.length) {
              var ret = compare2(left[leftIdx], right[rightIdx]);
              if (ret <= 0) {
                data[i++] = left[leftIdx++];
              } else {
                data[i++] = right[rightIdx++];
              }
            }
            while (leftIdx < left.length) {
              data[i++] = left[leftIdx++];
            }
            while (rightIdx < right.length) {
              data[i++] = right[rightIdx++];
            }
            return data;
          }
        })(TextDocument = exports3.TextDocument || (exports3.TextDocument = {}));
        var FullTextDocument = (
          /** @class */
          function() {
            function FullTextDocument2(uri, languageId, version2, content) {
              this._uri = uri;
              this._languageId = languageId;
              this._version = version2;
              this._content = content;
              this._lineOffsets = void 0;
            }
            Object.defineProperty(FullTextDocument2.prototype, "uri", {
              get: function() {
                return this._uri;
              },
              enumerable: false,
              configurable: true
            });
            Object.defineProperty(FullTextDocument2.prototype, "languageId", {
              get: function() {
                return this._languageId;
              },
              enumerable: false,
              configurable: true
            });
            Object.defineProperty(FullTextDocument2.prototype, "version", {
              get: function() {
                return this._version;
              },
              enumerable: false,
              configurable: true
            });
            FullTextDocument2.prototype.getText = function(range) {
              if (range) {
                var start = this.offsetAt(range.start);
                var end = this.offsetAt(range.end);
                return this._content.substring(start, end);
              }
              return this._content;
            };
            FullTextDocument2.prototype.update = function(event, version2) {
              this._content = event.text;
              this._version = version2;
              this._lineOffsets = void 0;
            };
            FullTextDocument2.prototype.getLineOffsets = function() {
              if (this._lineOffsets === void 0) {
                var lineOffsets = [];
                var text = this._content;
                var isLineStart = true;
                for (var i = 0; i < text.length; i++) {
                  if (isLineStart) {
                    lineOffsets.push(i);
                    isLineStart = false;
                  }
                  var ch = text.charAt(i);
                  isLineStart = ch === "\r" || ch === "\n";
                  if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
                    i++;
                  }
                }
                if (isLineStart && text.length > 0) {
                  lineOffsets.push(text.length);
                }
                this._lineOffsets = lineOffsets;
              }
              return this._lineOffsets;
            };
            FullTextDocument2.prototype.positionAt = function(offset) {
              offset = Math.max(Math.min(offset, this._content.length), 0);
              var lineOffsets = this.getLineOffsets();
              var low = 0, high = lineOffsets.length;
              if (high === 0) {
                return Position4.create(0, offset);
              }
              while (low < high) {
                var mid = Math.floor((low + high) / 2);
                if (lineOffsets[mid] > offset) {
                  high = mid;
                } else {
                  low = mid + 1;
                }
              }
              var line = low - 1;
              return Position4.create(line, offset - lineOffsets[line]);
            };
            FullTextDocument2.prototype.offsetAt = function(position) {
              var lineOffsets = this.getLineOffsets();
              if (position.line >= lineOffsets.length) {
                return this._content.length;
              } else if (position.line < 0) {
                return 0;
              }
              var lineOffset = lineOffsets[position.line];
              var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
              return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
            };
            Object.defineProperty(FullTextDocument2.prototype, "lineCount", {
              get: function() {
                return this.getLineOffsets().length;
              },
              enumerable: false,
              configurable: true
            });
            return FullTextDocument2;
          }()
        );
        var Is;
        (function(Is2) {
          var toString = Object.prototype.toString;
          function defined(value) {
            return typeof value !== "undefined";
          }
          Is2.defined = defined;
          function undefined2(value) {
            return typeof value === "undefined";
          }
          Is2.undefined = undefined2;
          function boolean2(value) {
            return value === true || value === false;
          }
          Is2.boolean = boolean2;
          function string(value) {
            return toString.call(value) === "[object String]";
          }
          Is2.string = string;
          function number(value) {
            return toString.call(value) === "[object Number]";
          }
          Is2.number = number;
          function numberRange(value, min, max) {
            return toString.call(value) === "[object Number]" && min <= value && value <= max;
          }
          Is2.numberRange = numberRange;
          function integer2(value) {
            return toString.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
          }
          Is2.integer = integer2;
          function uinteger2(value) {
            return toString.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
          }
          Is2.uinteger = uinteger2;
          function func(value) {
            return toString.call(value) === "[object Function]";
          }
          Is2.func = func;
          function objectLiteral(value) {
            return value !== null && typeof value === "object";
          }
          Is2.objectLiteral = objectLiteral;
          function typedArray(value, check) {
            return Array.isArray(value) && value.every(check);
          }
          Is2.typedArray = typedArray;
        })(Is || (Is = {}));
      });
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/messages.js
  var require_messages2 = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/messages.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ProtocolNotificationType = exports2.ProtocolNotificationType0 = exports2.ProtocolRequestType = exports2.ProtocolRequestType0 = exports2.RegistrationType = exports2.MessageDirection = void 0;
      var vscode_jsonrpc_1 = require_main();
      var MessageDirection;
      (function(MessageDirection2) {
        MessageDirection2["clientToServer"] = "clientToServer";
        MessageDirection2["serverToClient"] = "serverToClient";
        MessageDirection2["both"] = "both";
      })(MessageDirection = exports2.MessageDirection || (exports2.MessageDirection = {}));
      var RegistrationType = class {
        constructor(method) {
          this.method = method;
        }
      };
      exports2.RegistrationType = RegistrationType;
      var ProtocolRequestType0 = class extends vscode_jsonrpc_1.RequestType0 {
        constructor(method) {
          super(method);
        }
      };
      exports2.ProtocolRequestType0 = ProtocolRequestType0;
      var ProtocolRequestType = class extends vscode_jsonrpc_1.RequestType {
        constructor(method) {
          super(method, vscode_jsonrpc_1.ParameterStructures.byName);
        }
      };
      exports2.ProtocolRequestType = ProtocolRequestType;
      var ProtocolNotificationType0 = class extends vscode_jsonrpc_1.NotificationType0 {
        constructor(method) {
          super(method);
        }
      };
      exports2.ProtocolNotificationType0 = ProtocolNotificationType0;
      var ProtocolNotificationType = class extends vscode_jsonrpc_1.NotificationType {
        constructor(method) {
          super(method, vscode_jsonrpc_1.ParameterStructures.byName);
        }
      };
      exports2.ProtocolNotificationType = ProtocolNotificationType;
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/utils/is.js
  var require_is2 = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/utils/is.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.objectLiteral = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
      function boolean2(value) {
        return value === true || value === false;
      }
      exports2.boolean = boolean2;
      function string(value) {
        return typeof value === "string" || value instanceof String;
      }
      exports2.string = string;
      function number(value) {
        return typeof value === "number" || value instanceof Number;
      }
      exports2.number = number;
      function error(value) {
        return value instanceof Error;
      }
      exports2.error = error;
      function func(value) {
        return typeof value === "function";
      }
      exports2.func = func;
      function array(value) {
        return Array.isArray(value);
      }
      exports2.array = array;
      function stringArray(value) {
        return array(value) && value.every((elem) => string(elem));
      }
      exports2.stringArray = stringArray;
      function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
      }
      exports2.typedArray = typedArray;
      function objectLiteral(value) {
        return value !== null && typeof value === "object";
      }
      exports2.objectLiteral = objectLiteral;
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js
  var require_protocol_implementation = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ImplementationRequest = void 0;
      var messages_1 = require_messages2();
      var ImplementationRequest;
      (function(ImplementationRequest2) {
        ImplementationRequest2.method = "textDocument/implementation";
        ImplementationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        ImplementationRequest2.type = new messages_1.ProtocolRequestType(ImplementationRequest2.method);
      })(ImplementationRequest = exports2.ImplementationRequest || (exports2.ImplementationRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js
  var require_protocol_typeDefinition = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TypeDefinitionRequest = void 0;
      var messages_1 = require_messages2();
      var TypeDefinitionRequest;
      (function(TypeDefinitionRequest2) {
        TypeDefinitionRequest2.method = "textDocument/typeDefinition";
        TypeDefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        TypeDefinitionRequest2.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest2.method);
      })(TypeDefinitionRequest = exports2.TypeDefinitionRequest || (exports2.TypeDefinitionRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js
  var require_protocol_workspaceFolder = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = void 0;
      var messages_1 = require_messages2();
      var WorkspaceFoldersRequest;
      (function(WorkspaceFoldersRequest2) {
        WorkspaceFoldersRequest2.method = "workspace/workspaceFolders";
        WorkspaceFoldersRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        WorkspaceFoldersRequest2.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest2.method);
      })(WorkspaceFoldersRequest = exports2.WorkspaceFoldersRequest || (exports2.WorkspaceFoldersRequest = {}));
      var DidChangeWorkspaceFoldersNotification;
      (function(DidChangeWorkspaceFoldersNotification2) {
        DidChangeWorkspaceFoldersNotification2.method = "workspace/didChangeWorkspaceFolders";
        DidChangeWorkspaceFoldersNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidChangeWorkspaceFoldersNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification2.method);
      })(DidChangeWorkspaceFoldersNotification = exports2.DidChangeWorkspaceFoldersNotification || (exports2.DidChangeWorkspaceFoldersNotification = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js
  var require_protocol_configuration = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ConfigurationRequest = void 0;
      var messages_1 = require_messages2();
      var ConfigurationRequest;
      (function(ConfigurationRequest2) {
        ConfigurationRequest2.method = "workspace/configuration";
        ConfigurationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        ConfigurationRequest2.type = new messages_1.ProtocolRequestType(ConfigurationRequest2.method);
      })(ConfigurationRequest = exports2.ConfigurationRequest || (exports2.ConfigurationRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js
  var require_protocol_colorProvider = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ColorPresentationRequest = exports2.DocumentColorRequest = void 0;
      var messages_1 = require_messages2();
      var DocumentColorRequest;
      (function(DocumentColorRequest2) {
        DocumentColorRequest2.method = "textDocument/documentColor";
        DocumentColorRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentColorRequest2.type = new messages_1.ProtocolRequestType(DocumentColorRequest2.method);
      })(DocumentColorRequest = exports2.DocumentColorRequest || (exports2.DocumentColorRequest = {}));
      var ColorPresentationRequest;
      (function(ColorPresentationRequest2) {
        ColorPresentationRequest2.method = "textDocument/colorPresentation";
        ColorPresentationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        ColorPresentationRequest2.type = new messages_1.ProtocolRequestType(ColorPresentationRequest2.method);
      })(ColorPresentationRequest = exports2.ColorPresentationRequest || (exports2.ColorPresentationRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js
  var require_protocol_foldingRange = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FoldingRangeRequest = void 0;
      var messages_1 = require_messages2();
      var FoldingRangeRequest;
      (function(FoldingRangeRequest2) {
        FoldingRangeRequest2.method = "textDocument/foldingRange";
        FoldingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        FoldingRangeRequest2.type = new messages_1.ProtocolRequestType(FoldingRangeRequest2.method);
      })(FoldingRangeRequest = exports2.FoldingRangeRequest || (exports2.FoldingRangeRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js
  var require_protocol_declaration = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DeclarationRequest = void 0;
      var messages_1 = require_messages2();
      var DeclarationRequest;
      (function(DeclarationRequest2) {
        DeclarationRequest2.method = "textDocument/declaration";
        DeclarationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DeclarationRequest2.type = new messages_1.ProtocolRequestType(DeclarationRequest2.method);
      })(DeclarationRequest = exports2.DeclarationRequest || (exports2.DeclarationRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js
  var require_protocol_selectionRange = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SelectionRangeRequest = void 0;
      var messages_1 = require_messages2();
      var SelectionRangeRequest;
      (function(SelectionRangeRequest2) {
        SelectionRangeRequest2.method = "textDocument/selectionRange";
        SelectionRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        SelectionRangeRequest2.type = new messages_1.ProtocolRequestType(SelectionRangeRequest2.method);
      })(SelectionRangeRequest = exports2.SelectionRangeRequest || (exports2.SelectionRangeRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js
  var require_protocol_progress = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = void 0;
      var vscode_jsonrpc_1 = require_main();
      var messages_1 = require_messages2();
      var WorkDoneProgress;
      (function(WorkDoneProgress2) {
        WorkDoneProgress2.type = new vscode_jsonrpc_1.ProgressType();
        function is(value) {
          return value === WorkDoneProgress2.type;
        }
        WorkDoneProgress2.is = is;
      })(WorkDoneProgress = exports2.WorkDoneProgress || (exports2.WorkDoneProgress = {}));
      var WorkDoneProgressCreateRequest;
      (function(WorkDoneProgressCreateRequest2) {
        WorkDoneProgressCreateRequest2.method = "window/workDoneProgress/create";
        WorkDoneProgressCreateRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        WorkDoneProgressCreateRequest2.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest2.method);
      })(WorkDoneProgressCreateRequest = exports2.WorkDoneProgressCreateRequest || (exports2.WorkDoneProgressCreateRequest = {}));
      var WorkDoneProgressCancelNotification;
      (function(WorkDoneProgressCancelNotification2) {
        WorkDoneProgressCancelNotification2.method = "window/workDoneProgress/cancel";
        WorkDoneProgressCancelNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        WorkDoneProgressCancelNotification2.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification2.method);
      })(WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCancelNotification || (exports2.WorkDoneProgressCancelNotification = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js
  var require_protocol_callHierarchy = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.CallHierarchyPrepareRequest = void 0;
      var messages_1 = require_messages2();
      var CallHierarchyPrepareRequest;
      (function(CallHierarchyPrepareRequest2) {
        CallHierarchyPrepareRequest2.method = "textDocument/prepareCallHierarchy";
        CallHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CallHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest2.method);
      })(CallHierarchyPrepareRequest = exports2.CallHierarchyPrepareRequest || (exports2.CallHierarchyPrepareRequest = {}));
      var CallHierarchyIncomingCallsRequest;
      (function(CallHierarchyIncomingCallsRequest2) {
        CallHierarchyIncomingCallsRequest2.method = "callHierarchy/incomingCalls";
        CallHierarchyIncomingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CallHierarchyIncomingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest2.method);
      })(CallHierarchyIncomingCallsRequest = exports2.CallHierarchyIncomingCallsRequest || (exports2.CallHierarchyIncomingCallsRequest = {}));
      var CallHierarchyOutgoingCallsRequest;
      (function(CallHierarchyOutgoingCallsRequest2) {
        CallHierarchyOutgoingCallsRequest2.method = "callHierarchy/outgoingCalls";
        CallHierarchyOutgoingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CallHierarchyOutgoingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest2.method);
      })(CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyOutgoingCallsRequest || (exports2.CallHierarchyOutgoingCallsRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js
  var require_protocol_semanticTokens = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.SemanticTokensRegistrationType = exports2.TokenFormat = void 0;
      var messages_1 = require_messages2();
      var TokenFormat;
      (function(TokenFormat2) {
        TokenFormat2.Relative = "relative";
      })(TokenFormat = exports2.TokenFormat || (exports2.TokenFormat = {}));
      var SemanticTokensRegistrationType;
      (function(SemanticTokensRegistrationType2) {
        SemanticTokensRegistrationType2.method = "textDocument/semanticTokens";
        SemanticTokensRegistrationType2.type = new messages_1.RegistrationType(SemanticTokensRegistrationType2.method);
      })(SemanticTokensRegistrationType = exports2.SemanticTokensRegistrationType || (exports2.SemanticTokensRegistrationType = {}));
      var SemanticTokensRequest;
      (function(SemanticTokensRequest2) {
        SemanticTokensRequest2.method = "textDocument/semanticTokens/full";
        SemanticTokensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        SemanticTokensRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRequest2.method);
        SemanticTokensRequest2.registrationMethod = SemanticTokensRegistrationType.method;
      })(SemanticTokensRequest = exports2.SemanticTokensRequest || (exports2.SemanticTokensRequest = {}));
      var SemanticTokensDeltaRequest;
      (function(SemanticTokensDeltaRequest2) {
        SemanticTokensDeltaRequest2.method = "textDocument/semanticTokens/full/delta";
        SemanticTokensDeltaRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        SemanticTokensDeltaRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest2.method);
        SemanticTokensDeltaRequest2.registrationMethod = SemanticTokensRegistrationType.method;
      })(SemanticTokensDeltaRequest = exports2.SemanticTokensDeltaRequest || (exports2.SemanticTokensDeltaRequest = {}));
      var SemanticTokensRangeRequest;
      (function(SemanticTokensRangeRequest2) {
        SemanticTokensRangeRequest2.method = "textDocument/semanticTokens/range";
        SemanticTokensRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        SemanticTokensRangeRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest2.method);
        SemanticTokensRangeRequest2.registrationMethod = SemanticTokensRegistrationType.method;
      })(SemanticTokensRangeRequest = exports2.SemanticTokensRangeRequest || (exports2.SemanticTokensRangeRequest = {}));
      var SemanticTokensRefreshRequest;
      (function(SemanticTokensRefreshRequest2) {
        SemanticTokensRefreshRequest2.method = `workspace/semanticTokens/refresh`;
        SemanticTokensRefreshRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        SemanticTokensRefreshRequest2.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest2.method);
      })(SemanticTokensRefreshRequest = exports2.SemanticTokensRefreshRequest || (exports2.SemanticTokensRefreshRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js
  var require_protocol_showDocument = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ShowDocumentRequest = void 0;
      var messages_1 = require_messages2();
      var ShowDocumentRequest;
      (function(ShowDocumentRequest2) {
        ShowDocumentRequest2.method = "window/showDocument";
        ShowDocumentRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        ShowDocumentRequest2.type = new messages_1.ProtocolRequestType(ShowDocumentRequest2.method);
      })(ShowDocumentRequest = exports2.ShowDocumentRequest || (exports2.ShowDocumentRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js
  var require_protocol_linkedEditingRange = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LinkedEditingRangeRequest = void 0;
      var messages_1 = require_messages2();
      var LinkedEditingRangeRequest;
      (function(LinkedEditingRangeRequest2) {
        LinkedEditingRangeRequest2.method = "textDocument/linkedEditingRange";
        LinkedEditingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        LinkedEditingRangeRequest2.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest2.method);
      })(LinkedEditingRangeRequest = exports2.LinkedEditingRangeRequest || (exports2.LinkedEditingRangeRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js
  var require_protocol_fileOperations = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.DidRenameFilesNotification = exports2.WillRenameFilesRequest = exports2.DidCreateFilesNotification = exports2.WillCreateFilesRequest = exports2.FileOperationPatternKind = void 0;
      var messages_1 = require_messages2();
      var FileOperationPatternKind;
      (function(FileOperationPatternKind2) {
        FileOperationPatternKind2.file = "file";
        FileOperationPatternKind2.folder = "folder";
      })(FileOperationPatternKind = exports2.FileOperationPatternKind || (exports2.FileOperationPatternKind = {}));
      var WillCreateFilesRequest;
      (function(WillCreateFilesRequest2) {
        WillCreateFilesRequest2.method = "workspace/willCreateFiles";
        WillCreateFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        WillCreateFilesRequest2.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest2.method);
      })(WillCreateFilesRequest = exports2.WillCreateFilesRequest || (exports2.WillCreateFilesRequest = {}));
      var DidCreateFilesNotification;
      (function(DidCreateFilesNotification2) {
        DidCreateFilesNotification2.method = "workspace/didCreateFiles";
        DidCreateFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidCreateFilesNotification2.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification2.method);
      })(DidCreateFilesNotification = exports2.DidCreateFilesNotification || (exports2.DidCreateFilesNotification = {}));
      var WillRenameFilesRequest;
      (function(WillRenameFilesRequest2) {
        WillRenameFilesRequest2.method = "workspace/willRenameFiles";
        WillRenameFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        WillRenameFilesRequest2.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest2.method);
      })(WillRenameFilesRequest = exports2.WillRenameFilesRequest || (exports2.WillRenameFilesRequest = {}));
      var DidRenameFilesNotification;
      (function(DidRenameFilesNotification2) {
        DidRenameFilesNotification2.method = "workspace/didRenameFiles";
        DidRenameFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidRenameFilesNotification2.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification2.method);
      })(DidRenameFilesNotification = exports2.DidRenameFilesNotification || (exports2.DidRenameFilesNotification = {}));
      var DidDeleteFilesNotification;
      (function(DidDeleteFilesNotification2) {
        DidDeleteFilesNotification2.method = "workspace/didDeleteFiles";
        DidDeleteFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidDeleteFilesNotification2.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification2.method);
      })(DidDeleteFilesNotification = exports2.DidDeleteFilesNotification || (exports2.DidDeleteFilesNotification = {}));
      var WillDeleteFilesRequest;
      (function(WillDeleteFilesRequest2) {
        WillDeleteFilesRequest2.method = "workspace/willDeleteFiles";
        WillDeleteFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        WillDeleteFilesRequest2.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest2.method);
      })(WillDeleteFilesRequest = exports2.WillDeleteFilesRequest || (exports2.WillDeleteFilesRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js
  var require_protocol_moniker = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = void 0;
      var messages_1 = require_messages2();
      var UniquenessLevel;
      (function(UniquenessLevel2) {
        UniquenessLevel2.document = "document";
        UniquenessLevel2.project = "project";
        UniquenessLevel2.group = "group";
        UniquenessLevel2.scheme = "scheme";
        UniquenessLevel2.global = "global";
      })(UniquenessLevel = exports2.UniquenessLevel || (exports2.UniquenessLevel = {}));
      var MonikerKind;
      (function(MonikerKind2) {
        MonikerKind2.$import = "import";
        MonikerKind2.$export = "export";
        MonikerKind2.local = "local";
      })(MonikerKind = exports2.MonikerKind || (exports2.MonikerKind = {}));
      var MonikerRequest;
      (function(MonikerRequest2) {
        MonikerRequest2.method = "textDocument/moniker";
        MonikerRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        MonikerRequest2.type = new messages_1.ProtocolRequestType(MonikerRequest2.method);
      })(MonikerRequest = exports2.MonikerRequest || (exports2.MonikerRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js
  var require_protocol_typeHierarchy = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TypeHierarchySubtypesRequest = exports2.TypeHierarchySupertypesRequest = exports2.TypeHierarchyPrepareRequest = void 0;
      var messages_1 = require_messages2();
      var TypeHierarchyPrepareRequest;
      (function(TypeHierarchyPrepareRequest2) {
        TypeHierarchyPrepareRequest2.method = "textDocument/prepareTypeHierarchy";
        TypeHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        TypeHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest2.method);
      })(TypeHierarchyPrepareRequest = exports2.TypeHierarchyPrepareRequest || (exports2.TypeHierarchyPrepareRequest = {}));
      var TypeHierarchySupertypesRequest;
      (function(TypeHierarchySupertypesRequest2) {
        TypeHierarchySupertypesRequest2.method = "typeHierarchy/supertypes";
        TypeHierarchySupertypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        TypeHierarchySupertypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest2.method);
      })(TypeHierarchySupertypesRequest = exports2.TypeHierarchySupertypesRequest || (exports2.TypeHierarchySupertypesRequest = {}));
      var TypeHierarchySubtypesRequest;
      (function(TypeHierarchySubtypesRequest2) {
        TypeHierarchySubtypesRequest2.method = "typeHierarchy/subtypes";
        TypeHierarchySubtypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        TypeHierarchySubtypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest2.method);
      })(TypeHierarchySubtypesRequest = exports2.TypeHierarchySubtypesRequest || (exports2.TypeHierarchySubtypesRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js
  var require_protocol_inlineValue = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.InlineValueRefreshRequest = exports2.InlineValueRequest = void 0;
      var messages_1 = require_messages2();
      var InlineValueRequest;
      (function(InlineValueRequest2) {
        InlineValueRequest2.method = "textDocument/inlineValue";
        InlineValueRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        InlineValueRequest2.type = new messages_1.ProtocolRequestType(InlineValueRequest2.method);
      })(InlineValueRequest = exports2.InlineValueRequest || (exports2.InlineValueRequest = {}));
      var InlineValueRefreshRequest;
      (function(InlineValueRefreshRequest2) {
        InlineValueRefreshRequest2.method = `workspace/inlineValue/refresh`;
        InlineValueRefreshRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        InlineValueRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest2.method);
      })(InlineValueRefreshRequest = exports2.InlineValueRefreshRequest || (exports2.InlineValueRefreshRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js
  var require_protocol_inlayHint = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.InlayHintRefreshRequest = exports2.InlayHintResolveRequest = exports2.InlayHintRequest = void 0;
      var messages_1 = require_messages2();
      var InlayHintRequest;
      (function(InlayHintRequest2) {
        InlayHintRequest2.method = "textDocument/inlayHint";
        InlayHintRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        InlayHintRequest2.type = new messages_1.ProtocolRequestType(InlayHintRequest2.method);
      })(InlayHintRequest = exports2.InlayHintRequest || (exports2.InlayHintRequest = {}));
      var InlayHintResolveRequest;
      (function(InlayHintResolveRequest2) {
        InlayHintResolveRequest2.method = "inlayHint/resolve";
        InlayHintResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        InlayHintResolveRequest2.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest2.method);
      })(InlayHintResolveRequest = exports2.InlayHintResolveRequest || (exports2.InlayHintResolveRequest = {}));
      var InlayHintRefreshRequest;
      (function(InlayHintRefreshRequest2) {
        InlayHintRefreshRequest2.method = `workspace/inlayHint/refresh`;
        InlayHintRefreshRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        InlayHintRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest2.method);
      })(InlayHintRefreshRequest = exports2.InlayHintRefreshRequest || (exports2.InlayHintRefreshRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js
  var require_protocol_diagnostic = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DiagnosticRefreshRequest = exports2.WorkspaceDiagnosticRequest = exports2.DocumentDiagnosticRequest = exports2.DocumentDiagnosticReportKind = exports2.DiagnosticServerCancellationData = void 0;
      var vscode_jsonrpc_1 = require_main();
      var Is = require_is2();
      var messages_1 = require_messages2();
      var DiagnosticServerCancellationData;
      (function(DiagnosticServerCancellationData2) {
        function is(value) {
          const candidate = value;
          return candidate && Is.boolean(candidate.retriggerRequest);
        }
        DiagnosticServerCancellationData2.is = is;
      })(DiagnosticServerCancellationData = exports2.DiagnosticServerCancellationData || (exports2.DiagnosticServerCancellationData = {}));
      var DocumentDiagnosticReportKind;
      (function(DocumentDiagnosticReportKind2) {
        DocumentDiagnosticReportKind2.Full = "full";
        DocumentDiagnosticReportKind2.Unchanged = "unchanged";
      })(DocumentDiagnosticReportKind = exports2.DocumentDiagnosticReportKind || (exports2.DocumentDiagnosticReportKind = {}));
      var DocumentDiagnosticRequest;
      (function(DocumentDiagnosticRequest2) {
        DocumentDiagnosticRequest2.method = "textDocument/diagnostic";
        DocumentDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentDiagnosticRequest2.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest2.method);
        DocumentDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
      })(DocumentDiagnosticRequest = exports2.DocumentDiagnosticRequest || (exports2.DocumentDiagnosticRequest = {}));
      var WorkspaceDiagnosticRequest;
      (function(WorkspaceDiagnosticRequest2) {
        WorkspaceDiagnosticRequest2.method = "workspace/diagnostic";
        WorkspaceDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        WorkspaceDiagnosticRequest2.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest2.method);
        WorkspaceDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
      })(WorkspaceDiagnosticRequest = exports2.WorkspaceDiagnosticRequest || (exports2.WorkspaceDiagnosticRequest = {}));
      var DiagnosticRefreshRequest;
      (function(DiagnosticRefreshRequest2) {
        DiagnosticRefreshRequest2.method = `workspace/diagnostic/refresh`;
        DiagnosticRefreshRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DiagnosticRefreshRequest2.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest2.method);
      })(DiagnosticRefreshRequest = exports2.DiagnosticRefreshRequest || (exports2.DiagnosticRefreshRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js
  var require_protocol_notebook = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DidCloseNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification = exports2.NotebookCellArrayChange = exports2.DidOpenNotebookDocumentNotification = exports2.NotebookDocumentSyncRegistrationType = exports2.NotebookDocument = exports2.NotebookCell = exports2.ExecutionSummary = exports2.NotebookCellKind = void 0;
      var vscode_languageserver_types_1 = require_main2();
      var Is = require_is2();
      var messages_1 = require_messages2();
      var NotebookCellKind3;
      (function(NotebookCellKind4) {
        NotebookCellKind4.Markup = 1;
        NotebookCellKind4.Code = 2;
        function is(value) {
          return value === 1 || value === 2;
        }
        NotebookCellKind4.is = is;
      })(NotebookCellKind3 = exports2.NotebookCellKind || (exports2.NotebookCellKind = {}));
      var ExecutionSummary;
      (function(ExecutionSummary2) {
        function create(executionOrder, success) {
          const result = { executionOrder };
          if (success === true || success === false) {
            result.success = success;
          }
          return result;
        }
        ExecutionSummary2.create = create;
        function is(value) {
          const candidate = value;
          return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === void 0 || Is.boolean(candidate.success));
        }
        ExecutionSummary2.is = is;
        function equals3(one, other) {
          if (one === other) {
            return true;
          }
          if (one === null || one === void 0 || other === null || other === void 0) {
            return false;
          }
          return one.executionOrder === other.executionOrder && one.success === other.success;
        }
        ExecutionSummary2.equals = equals3;
      })(ExecutionSummary = exports2.ExecutionSummary || (exports2.ExecutionSummary = {}));
      var NotebookCell;
      (function(NotebookCell2) {
        function create(kind, document2) {
          return { kind, document: document2 };
        }
        NotebookCell2.create = create;
        function is(value) {
          const candidate = value;
          return Is.objectLiteral(candidate) && NotebookCellKind3.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) && (candidate.metadata === void 0 || Is.objectLiteral(candidate.metadata));
        }
        NotebookCell2.is = is;
        function diff(one, two) {
          const result = /* @__PURE__ */ new Set();
          if (one.document !== two.document) {
            result.add("document");
          }
          if (one.kind !== two.kind) {
            result.add("kind");
          }
          if (one.executionSummary !== two.executionSummary) {
            result.add("executionSummary");
          }
          if ((one.metadata !== void 0 || two.metadata !== void 0) && !equalsMetadata(one.metadata, two.metadata)) {
            result.add("metadata");
          }
          if ((one.executionSummary !== void 0 || two.executionSummary !== void 0) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
            result.add("executionSummary");
          }
          return result;
        }
        NotebookCell2.diff = diff;
        function equalsMetadata(one, other) {
          if (one === other) {
            return true;
          }
          if (one === null || one === void 0 || other === null || other === void 0) {
            return false;
          }
          if (typeof one !== typeof other) {
            return false;
          }
          if (typeof one !== "object") {
            return false;
          }
          const oneArray = Array.isArray(one);
          const otherArray = Array.isArray(other);
          if (oneArray !== otherArray) {
            return false;
          }
          if (oneArray && otherArray) {
            if (one.length !== other.length) {
              return false;
            }
            for (let i = 0; i < one.length; i++) {
              if (!equalsMetadata(one[i], other[i])) {
                return false;
              }
            }
          }
          if (Is.objectLiteral(one) && Is.objectLiteral(other)) {
            const oneKeys = Object.keys(one);
            const otherKeys = Object.keys(other);
            if (oneKeys.length !== otherKeys.length) {
              return false;
            }
            oneKeys.sort();
            otherKeys.sort();
            if (!equalsMetadata(oneKeys, otherKeys)) {
              return false;
            }
            for (let i = 0; i < oneKeys.length; i++) {
              const prop = oneKeys[i];
              if (!equalsMetadata(one[prop], other[prop])) {
                return false;
              }
            }
          }
          return true;
        }
      })(NotebookCell = exports2.NotebookCell || (exports2.NotebookCell = {}));
      var NotebookDocument;
      (function(NotebookDocument2) {
        function create(uri, notebookType, version2, cells) {
          return { uri, notebookType, version: version2, cells };
        }
        NotebookDocument2.create = create;
        function is(value) {
          const candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is.typedArray(candidate.cells, NotebookCell.is);
        }
        NotebookDocument2.is = is;
      })(NotebookDocument = exports2.NotebookDocument || (exports2.NotebookDocument = {}));
      var NotebookDocumentSyncRegistrationType;
      (function(NotebookDocumentSyncRegistrationType2) {
        NotebookDocumentSyncRegistrationType2.method = "notebookDocument/sync";
        NotebookDocumentSyncRegistrationType2.messageDirection = messages_1.MessageDirection.clientToServer;
        NotebookDocumentSyncRegistrationType2.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType2.method);
      })(NotebookDocumentSyncRegistrationType = exports2.NotebookDocumentSyncRegistrationType || (exports2.NotebookDocumentSyncRegistrationType = {}));
      var DidOpenNotebookDocumentNotification;
      (function(DidOpenNotebookDocumentNotification2) {
        DidOpenNotebookDocumentNotification2.method = "notebookDocument/didOpen";
        DidOpenNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidOpenNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification2.method);
        DidOpenNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
      })(DidOpenNotebookDocumentNotification = exports2.DidOpenNotebookDocumentNotification || (exports2.DidOpenNotebookDocumentNotification = {}));
      var NotebookCellArrayChange;
      (function(NotebookCellArrayChange2) {
        function is(value) {
          const candidate = value;
          return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === void 0 || Is.typedArray(candidate.cells, NotebookCell.is));
        }
        NotebookCellArrayChange2.is = is;
        function create(start, deleteCount, cells) {
          const result = { start, deleteCount };
          if (cells !== void 0) {
            result.cells = cells;
          }
          return result;
        }
        NotebookCellArrayChange2.create = create;
      })(NotebookCellArrayChange = exports2.NotebookCellArrayChange || (exports2.NotebookCellArrayChange = {}));
      var DidChangeNotebookDocumentNotification;
      (function(DidChangeNotebookDocumentNotification2) {
        DidChangeNotebookDocumentNotification2.method = "notebookDocument/didChange";
        DidChangeNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidChangeNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification2.method);
        DidChangeNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
      })(DidChangeNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification || (exports2.DidChangeNotebookDocumentNotification = {}));
      var DidSaveNotebookDocumentNotification;
      (function(DidSaveNotebookDocumentNotification2) {
        DidSaveNotebookDocumentNotification2.method = "notebookDocument/didSave";
        DidSaveNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidSaveNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification2.method);
        DidSaveNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
      })(DidSaveNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification || (exports2.DidSaveNotebookDocumentNotification = {}));
      var DidCloseNotebookDocumentNotification;
      (function(DidCloseNotebookDocumentNotification2) {
        DidCloseNotebookDocumentNotification2.method = "notebookDocument/didClose";
        DidCloseNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidCloseNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification2.method);
        DidCloseNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
      })(DidCloseNotebookDocumentNotification = exports2.DidCloseNotebookDocumentNotification || (exports2.DidCloseNotebookDocumentNotification = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/protocol.js
  var require_protocol = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/protocol.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.WorkspaceSymbolRequest = exports2.CodeActionResolveRequest = exports2.CodeActionRequest = exports2.DocumentSymbolRequest = exports2.DocumentHighlightRequest = exports2.ReferencesRequest = exports2.DefinitionRequest = exports2.SignatureHelpRequest = exports2.SignatureHelpTriggerKind = exports2.HoverRequest = exports2.CompletionResolveRequest = exports2.CompletionRequest = exports2.CompletionTriggerKind = exports2.PublishDiagnosticsNotification = exports2.WatchKind = exports2.RelativePattern = exports2.FileChangeType = exports2.DidChangeWatchedFilesNotification = exports2.WillSaveTextDocumentWaitUntilRequest = exports2.WillSaveTextDocumentNotification = exports2.TextDocumentSaveReason = exports2.DidSaveTextDocumentNotification = exports2.DidCloseTextDocumentNotification = exports2.DidChangeTextDocumentNotification = exports2.TextDocumentContentChangeEvent = exports2.DidOpenTextDocumentNotification = exports2.TextDocumentSyncKind = exports2.TelemetryEventNotification = exports2.LogMessageNotification = exports2.ShowMessageRequest = exports2.ShowMessageNotification = exports2.MessageType = exports2.DidChangeConfigurationNotification = exports2.ExitNotification = exports2.ShutdownRequest = exports2.InitializedNotification = exports2.InitializeErrorCodes = exports2.InitializeRequest = exports2.WorkDoneProgressOptions = exports2.TextDocumentRegistrationOptions = exports2.StaticRegistrationOptions = exports2.PositionEncodingKind = exports2.FailureHandlingKind = exports2.ResourceOperationKind = exports2.UnregistrationRequest = exports2.RegistrationRequest = exports2.DocumentSelector = exports2.NotebookCellTextDocumentFilter = exports2.NotebookDocumentFilter = exports2.TextDocumentFilter = void 0;
      exports2.TypeHierarchySubtypesRequest = exports2.TypeHierarchyPrepareRequest = exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.WillRenameFilesRequest = exports2.DidRenameFilesNotification = exports2.WillCreateFilesRequest = exports2.DidCreateFilesNotification = exports2.FileOperationPatternKind = exports2.LinkedEditingRangeRequest = exports2.ShowDocumentRequest = exports2.SemanticTokensRegistrationType = exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.TokenFormat = exports2.CallHierarchyPrepareRequest = exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = exports2.SelectionRangeRequest = exports2.DeclarationRequest = exports2.FoldingRangeRequest = exports2.ColorPresentationRequest = exports2.DocumentColorRequest = exports2.ConfigurationRequest = exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = exports2.TypeDefinitionRequest = exports2.ImplementationRequest = exports2.ApplyWorkspaceEditRequest = exports2.ExecuteCommandRequest = exports2.PrepareRenameRequest = exports2.RenameRequest = exports2.PrepareSupportDefaultBehavior = exports2.DocumentOnTypeFormattingRequest = exports2.DocumentRangeFormattingRequest = exports2.DocumentFormattingRequest = exports2.DocumentLinkResolveRequest = exports2.DocumentLinkRequest = exports2.CodeLensRefreshRequest = exports2.CodeLensResolveRequest = exports2.CodeLensRequest = exports2.WorkspaceSymbolResolveRequest = void 0;
      exports2.DidCloseNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification = exports2.NotebookCellArrayChange = exports2.DidOpenNotebookDocumentNotification = exports2.NotebookDocumentSyncRegistrationType = exports2.NotebookDocument = exports2.NotebookCell = exports2.ExecutionSummary = exports2.NotebookCellKind = exports2.DiagnosticRefreshRequest = exports2.WorkspaceDiagnosticRequest = exports2.DocumentDiagnosticRequest = exports2.DocumentDiagnosticReportKind = exports2.DiagnosticServerCancellationData = exports2.InlayHintRefreshRequest = exports2.InlayHintResolveRequest = exports2.InlayHintRequest = exports2.InlineValueRefreshRequest = exports2.InlineValueRequest = exports2.TypeHierarchySupertypesRequest = void 0;
      var messages_1 = require_messages2();
      var vscode_languageserver_types_1 = require_main2();
      var Is = require_is2();
      var protocol_implementation_1 = require_protocol_implementation();
      Object.defineProperty(exports2, "ImplementationRequest", { enumerable: true, get: function() {
        return protocol_implementation_1.ImplementationRequest;
      } });
      var protocol_typeDefinition_1 = require_protocol_typeDefinition();
      Object.defineProperty(exports2, "TypeDefinitionRequest", { enumerable: true, get: function() {
        return protocol_typeDefinition_1.TypeDefinitionRequest;
      } });
      var protocol_workspaceFolder_1 = require_protocol_workspaceFolder();
      Object.defineProperty(exports2, "WorkspaceFoldersRequest", { enumerable: true, get: function() {
        return protocol_workspaceFolder_1.WorkspaceFoldersRequest;
      } });
      Object.defineProperty(exports2, "DidChangeWorkspaceFoldersNotification", { enumerable: true, get: function() {
        return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification;
      } });
      var protocol_configuration_1 = require_protocol_configuration();
      Object.defineProperty(exports2, "ConfigurationRequest", { enumerable: true, get: function() {
        return protocol_configuration_1.ConfigurationRequest;
      } });
      var protocol_colorProvider_1 = require_protocol_colorProvider();
      Object.defineProperty(exports2, "DocumentColorRequest", { enumerable: true, get: function() {
        return protocol_colorProvider_1.DocumentColorRequest;
      } });
      Object.defineProperty(exports2, "ColorPresentationRequest", { enumerable: true, get: function() {
        return protocol_colorProvider_1.ColorPresentationRequest;
      } });
      var protocol_foldingRange_1 = require_protocol_foldingRange();
      Object.defineProperty(exports2, "FoldingRangeRequest", { enumerable: true, get: function() {
        return protocol_foldingRange_1.FoldingRangeRequest;
      } });
      var protocol_declaration_1 = require_protocol_declaration();
      Object.defineProperty(exports2, "DeclarationRequest", { enumerable: true, get: function() {
        return protocol_declaration_1.DeclarationRequest;
      } });
      var protocol_selectionRange_1 = require_protocol_selectionRange();
      Object.defineProperty(exports2, "SelectionRangeRequest", { enumerable: true, get: function() {
        return protocol_selectionRange_1.SelectionRangeRequest;
      } });
      var protocol_progress_1 = require_protocol_progress();
      Object.defineProperty(exports2, "WorkDoneProgress", { enumerable: true, get: function() {
        return protocol_progress_1.WorkDoneProgress;
      } });
      Object.defineProperty(exports2, "WorkDoneProgressCreateRequest", { enumerable: true, get: function() {
        return protocol_progress_1.WorkDoneProgressCreateRequest;
      } });
      Object.defineProperty(exports2, "WorkDoneProgressCancelNotification", { enumerable: true, get: function() {
        return protocol_progress_1.WorkDoneProgressCancelNotification;
      } });
      var protocol_callHierarchy_1 = require_protocol_callHierarchy();
      Object.defineProperty(exports2, "CallHierarchyIncomingCallsRequest", { enumerable: true, get: function() {
        return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
      } });
      Object.defineProperty(exports2, "CallHierarchyOutgoingCallsRequest", { enumerable: true, get: function() {
        return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
      } });
      Object.defineProperty(exports2, "CallHierarchyPrepareRequest", { enumerable: true, get: function() {
        return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
      } });
      var protocol_semanticTokens_1 = require_protocol_semanticTokens();
      Object.defineProperty(exports2, "TokenFormat", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.TokenFormat;
      } });
      Object.defineProperty(exports2, "SemanticTokensRequest", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.SemanticTokensRequest;
      } });
      Object.defineProperty(exports2, "SemanticTokensDeltaRequest", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
      } });
      Object.defineProperty(exports2, "SemanticTokensRangeRequest", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.SemanticTokensRangeRequest;
      } });
      Object.defineProperty(exports2, "SemanticTokensRefreshRequest", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
      } });
      Object.defineProperty(exports2, "SemanticTokensRegistrationType", { enumerable: true, get: function() {
        return protocol_semanticTokens_1.SemanticTokensRegistrationType;
      } });
      var protocol_showDocument_1 = require_protocol_showDocument();
      Object.defineProperty(exports2, "ShowDocumentRequest", { enumerable: true, get: function() {
        return protocol_showDocument_1.ShowDocumentRequest;
      } });
      var protocol_linkedEditingRange_1 = require_protocol_linkedEditingRange();
      Object.defineProperty(exports2, "LinkedEditingRangeRequest", { enumerable: true, get: function() {
        return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
      } });
      var protocol_fileOperations_1 = require_protocol_fileOperations();
      Object.defineProperty(exports2, "FileOperationPatternKind", { enumerable: true, get: function() {
        return protocol_fileOperations_1.FileOperationPatternKind;
      } });
      Object.defineProperty(exports2, "DidCreateFilesNotification", { enumerable: true, get: function() {
        return protocol_fileOperations_1.DidCreateFilesNotification;
      } });
      Object.defineProperty(exports2, "WillCreateFilesRequest", { enumerable: true, get: function() {
        return protocol_fileOperations_1.WillCreateFilesRequest;
      } });
      Object.defineProperty(exports2, "DidRenameFilesNotification", { enumerable: true, get: function() {
        return protocol_fileOperations_1.DidRenameFilesNotification;
      } });
      Object.defineProperty(exports2, "WillRenameFilesRequest", { enumerable: true, get: function() {
        return protocol_fileOperations_1.WillRenameFilesRequest;
      } });
      Object.defineProperty(exports2, "DidDeleteFilesNotification", { enumerable: true, get: function() {
        return protocol_fileOperations_1.DidDeleteFilesNotification;
      } });
      Object.defineProperty(exports2, "WillDeleteFilesRequest", { enumerable: true, get: function() {
        return protocol_fileOperations_1.WillDeleteFilesRequest;
      } });
      var protocol_moniker_1 = require_protocol_moniker();
      Object.defineProperty(exports2, "UniquenessLevel", { enumerable: true, get: function() {
        return protocol_moniker_1.UniquenessLevel;
      } });
      Object.defineProperty(exports2, "MonikerKind", { enumerable: true, get: function() {
        return protocol_moniker_1.MonikerKind;
      } });
      Object.defineProperty(exports2, "MonikerRequest", { enumerable: true, get: function() {
        return protocol_moniker_1.MonikerRequest;
      } });
      var protocol_typeHierarchy_1 = require_protocol_typeHierarchy();
      Object.defineProperty(exports2, "TypeHierarchyPrepareRequest", { enumerable: true, get: function() {
        return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest;
      } });
      Object.defineProperty(exports2, "TypeHierarchySubtypesRequest", { enumerable: true, get: function() {
        return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest;
      } });
      Object.defineProperty(exports2, "TypeHierarchySupertypesRequest", { enumerable: true, get: function() {
        return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest;
      } });
      var protocol_inlineValue_1 = require_protocol_inlineValue();
      Object.defineProperty(exports2, "InlineValueRequest", { enumerable: true, get: function() {
        return protocol_inlineValue_1.InlineValueRequest;
      } });
      Object.defineProperty(exports2, "InlineValueRefreshRequest", { enumerable: true, get: function() {
        return protocol_inlineValue_1.InlineValueRefreshRequest;
      } });
      var protocol_inlayHint_1 = require_protocol_inlayHint();
      Object.defineProperty(exports2, "InlayHintRequest", { enumerable: true, get: function() {
        return protocol_inlayHint_1.InlayHintRequest;
      } });
      Object.defineProperty(exports2, "InlayHintResolveRequest", { enumerable: true, get: function() {
        return protocol_inlayHint_1.InlayHintResolveRequest;
      } });
      Object.defineProperty(exports2, "InlayHintRefreshRequest", { enumerable: true, get: function() {
        return protocol_inlayHint_1.InlayHintRefreshRequest;
      } });
      var protocol_diagnostic_1 = require_protocol_diagnostic();
      Object.defineProperty(exports2, "DiagnosticServerCancellationData", { enumerable: true, get: function() {
        return protocol_diagnostic_1.DiagnosticServerCancellationData;
      } });
      Object.defineProperty(exports2, "DocumentDiagnosticReportKind", { enumerable: true, get: function() {
        return protocol_diagnostic_1.DocumentDiagnosticReportKind;
      } });
      Object.defineProperty(exports2, "DocumentDiagnosticRequest", { enumerable: true, get: function() {
        return protocol_diagnostic_1.DocumentDiagnosticRequest;
      } });
      Object.defineProperty(exports2, "WorkspaceDiagnosticRequest", { enumerable: true, get: function() {
        return protocol_diagnostic_1.WorkspaceDiagnosticRequest;
      } });
      Object.defineProperty(exports2, "DiagnosticRefreshRequest", { enumerable: true, get: function() {
        return protocol_diagnostic_1.DiagnosticRefreshRequest;
      } });
      var protocol_notebook_1 = require_protocol_notebook();
      Object.defineProperty(exports2, "NotebookCellKind", { enumerable: true, get: function() {
        return protocol_notebook_1.NotebookCellKind;
      } });
      Object.defineProperty(exports2, "ExecutionSummary", { enumerable: true, get: function() {
        return protocol_notebook_1.ExecutionSummary;
      } });
      Object.defineProperty(exports2, "NotebookCell", { enumerable: true, get: function() {
        return protocol_notebook_1.NotebookCell;
      } });
      Object.defineProperty(exports2, "NotebookDocument", { enumerable: true, get: function() {
        return protocol_notebook_1.NotebookDocument;
      } });
      Object.defineProperty(exports2, "NotebookDocumentSyncRegistrationType", { enumerable: true, get: function() {
        return protocol_notebook_1.NotebookDocumentSyncRegistrationType;
      } });
      Object.defineProperty(exports2, "DidOpenNotebookDocumentNotification", { enumerable: true, get: function() {
        return protocol_notebook_1.DidOpenNotebookDocumentNotification;
      } });
      Object.defineProperty(exports2, "NotebookCellArrayChange", { enumerable: true, get: function() {
        return protocol_notebook_1.NotebookCellArrayChange;
      } });
      Object.defineProperty(exports2, "DidChangeNotebookDocumentNotification", { enumerable: true, get: function() {
        return protocol_notebook_1.DidChangeNotebookDocumentNotification;
      } });
      Object.defineProperty(exports2, "DidSaveNotebookDocumentNotification", { enumerable: true, get: function() {
        return protocol_notebook_1.DidSaveNotebookDocumentNotification;
      } });
      Object.defineProperty(exports2, "DidCloseNotebookDocumentNotification", { enumerable: true, get: function() {
        return protocol_notebook_1.DidCloseNotebookDocumentNotification;
      } });
      var TextDocumentFilter;
      (function(TextDocumentFilter2) {
        function is(value) {
          const candidate = value;
          return Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);
        }
        TextDocumentFilter2.is = is;
      })(TextDocumentFilter = exports2.TextDocumentFilter || (exports2.TextDocumentFilter = {}));
      var NotebookDocumentFilter;
      (function(NotebookDocumentFilter2) {
        function is(value) {
          const candidate = value;
          return Is.objectLiteral(candidate) && (Is.string(candidate.notebookType) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
        }
        NotebookDocumentFilter2.is = is;
      })(NotebookDocumentFilter = exports2.NotebookDocumentFilter || (exports2.NotebookDocumentFilter = {}));
      var NotebookCellTextDocumentFilter;
      (function(NotebookCellTextDocumentFilter2) {
        function is(value) {
          const candidate = value;
          return Is.objectLiteral(candidate) && (Is.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook)) && (candidate.language === void 0 || Is.string(candidate.language));
        }
        NotebookCellTextDocumentFilter2.is = is;
      })(NotebookCellTextDocumentFilter = exports2.NotebookCellTextDocumentFilter || (exports2.NotebookCellTextDocumentFilter = {}));
      var DocumentSelector;
      (function(DocumentSelector2) {
        function is(value) {
          if (!Array.isArray(value)) {
            return false;
          }
          for (let elem of value) {
            if (!Is.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
              return false;
            }
          }
          return true;
        }
        DocumentSelector2.is = is;
      })(DocumentSelector = exports2.DocumentSelector || (exports2.DocumentSelector = {}));
      var RegistrationRequest;
      (function(RegistrationRequest2) {
        RegistrationRequest2.method = "client/registerCapability";
        RegistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        RegistrationRequest2.type = new messages_1.ProtocolRequestType(RegistrationRequest2.method);
      })(RegistrationRequest = exports2.RegistrationRequest || (exports2.RegistrationRequest = {}));
      var UnregistrationRequest;
      (function(UnregistrationRequest2) {
        UnregistrationRequest2.method = "client/unregisterCapability";
        UnregistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        UnregistrationRequest2.type = new messages_1.ProtocolRequestType(UnregistrationRequest2.method);
      })(UnregistrationRequest = exports2.UnregistrationRequest || (exports2.UnregistrationRequest = {}));
      var ResourceOperationKind;
      (function(ResourceOperationKind2) {
        ResourceOperationKind2.Create = "create";
        ResourceOperationKind2.Rename = "rename";
        ResourceOperationKind2.Delete = "delete";
      })(ResourceOperationKind = exports2.ResourceOperationKind || (exports2.ResourceOperationKind = {}));
      var FailureHandlingKind;
      (function(FailureHandlingKind2) {
        FailureHandlingKind2.Abort = "abort";
        FailureHandlingKind2.Transactional = "transactional";
        FailureHandlingKind2.TextOnlyTransactional = "textOnlyTransactional";
        FailureHandlingKind2.Undo = "undo";
      })(FailureHandlingKind = exports2.FailureHandlingKind || (exports2.FailureHandlingKind = {}));
      var PositionEncodingKind;
      (function(PositionEncodingKind2) {
        PositionEncodingKind2.UTF8 = "utf-8";
        PositionEncodingKind2.UTF16 = "utf-16";
        PositionEncodingKind2.UTF32 = "utf-32";
      })(PositionEncodingKind = exports2.PositionEncodingKind || (exports2.PositionEncodingKind = {}));
      var StaticRegistrationOptions;
      (function(StaticRegistrationOptions2) {
        function hasId(value) {
          const candidate = value;
          return candidate && Is.string(candidate.id) && candidate.id.length > 0;
        }
        StaticRegistrationOptions2.hasId = hasId;
      })(StaticRegistrationOptions = exports2.StaticRegistrationOptions || (exports2.StaticRegistrationOptions = {}));
      var TextDocumentRegistrationOptions;
      (function(TextDocumentRegistrationOptions2) {
        function is(value) {
          const candidate = value;
          return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
        }
        TextDocumentRegistrationOptions2.is = is;
      })(TextDocumentRegistrationOptions = exports2.TextDocumentRegistrationOptions || (exports2.TextDocumentRegistrationOptions = {}));
      var WorkDoneProgressOptions;
      (function(WorkDoneProgressOptions2) {
        function is(value) {
          const candidate = value;
          return Is.objectLiteral(candidate) && (candidate.workDoneProgress === void 0 || Is.boolean(candidate.workDoneProgress));
        }
        WorkDoneProgressOptions2.is = is;
        function hasWorkDoneProgress(value) {
          const candidate = value;
          return candidate && Is.boolean(candidate.workDoneProgress);
        }
        WorkDoneProgressOptions2.hasWorkDoneProgress = hasWorkDoneProgress;
      })(WorkDoneProgressOptions = exports2.WorkDoneProgressOptions || (exports2.WorkDoneProgressOptions = {}));
      var InitializeRequest;
      (function(InitializeRequest2) {
        InitializeRequest2.method = "initialize";
        InitializeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        InitializeRequest2.type = new messages_1.ProtocolRequestType(InitializeRequest2.method);
      })(InitializeRequest = exports2.InitializeRequest || (exports2.InitializeRequest = {}));
      var InitializeErrorCodes;
      (function(InitializeErrorCodes2) {
        InitializeErrorCodes2.unknownProtocolVersion = 1;
      })(InitializeErrorCodes = exports2.InitializeErrorCodes || (exports2.InitializeErrorCodes = {}));
      var InitializedNotification;
      (function(InitializedNotification2) {
        InitializedNotification2.method = "initialized";
        InitializedNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        InitializedNotification2.type = new messages_1.ProtocolNotificationType(InitializedNotification2.method);
      })(InitializedNotification = exports2.InitializedNotification || (exports2.InitializedNotification = {}));
      var ShutdownRequest;
      (function(ShutdownRequest2) {
        ShutdownRequest2.method = "shutdown";
        ShutdownRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        ShutdownRequest2.type = new messages_1.ProtocolRequestType0(ShutdownRequest2.method);
      })(ShutdownRequest = exports2.ShutdownRequest || (exports2.ShutdownRequest = {}));
      var ExitNotification;
      (function(ExitNotification2) {
        ExitNotification2.method = "exit";
        ExitNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        ExitNotification2.type = new messages_1.ProtocolNotificationType0(ExitNotification2.method);
      })(ExitNotification = exports2.ExitNotification || (exports2.ExitNotification = {}));
      var DidChangeConfigurationNotification;
      (function(DidChangeConfigurationNotification2) {
        DidChangeConfigurationNotification2.method = "workspace/didChangeConfiguration";
        DidChangeConfigurationNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidChangeConfigurationNotification2.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification2.method);
      })(DidChangeConfigurationNotification = exports2.DidChangeConfigurationNotification || (exports2.DidChangeConfigurationNotification = {}));
      var MessageType;
      (function(MessageType2) {
        MessageType2.Error = 1;
        MessageType2.Warning = 2;
        MessageType2.Info = 3;
        MessageType2.Log = 4;
      })(MessageType = exports2.MessageType || (exports2.MessageType = {}));
      var ShowMessageNotification;
      (function(ShowMessageNotification2) {
        ShowMessageNotification2.method = "window/showMessage";
        ShowMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
        ShowMessageNotification2.type = new messages_1.ProtocolNotificationType(ShowMessageNotification2.method);
      })(ShowMessageNotification = exports2.ShowMessageNotification || (exports2.ShowMessageNotification = {}));
      var ShowMessageRequest;
      (function(ShowMessageRequest2) {
        ShowMessageRequest2.method = "window/showMessageRequest";
        ShowMessageRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        ShowMessageRequest2.type = new messages_1.ProtocolRequestType(ShowMessageRequest2.method);
      })(ShowMessageRequest = exports2.ShowMessageRequest || (exports2.ShowMessageRequest = {}));
      var LogMessageNotification;
      (function(LogMessageNotification2) {
        LogMessageNotification2.method = "window/logMessage";
        LogMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
        LogMessageNotification2.type = new messages_1.ProtocolNotificationType(LogMessageNotification2.method);
      })(LogMessageNotification = exports2.LogMessageNotification || (exports2.LogMessageNotification = {}));
      var TelemetryEventNotification;
      (function(TelemetryEventNotification2) {
        TelemetryEventNotification2.method = "telemetry/event";
        TelemetryEventNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
        TelemetryEventNotification2.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification2.method);
      })(TelemetryEventNotification = exports2.TelemetryEventNotification || (exports2.TelemetryEventNotification = {}));
      var TextDocumentSyncKind;
      (function(TextDocumentSyncKind2) {
        TextDocumentSyncKind2.None = 0;
        TextDocumentSyncKind2.Full = 1;
        TextDocumentSyncKind2.Incremental = 2;
      })(TextDocumentSyncKind = exports2.TextDocumentSyncKind || (exports2.TextDocumentSyncKind = {}));
      var DidOpenTextDocumentNotification;
      (function(DidOpenTextDocumentNotification2) {
        DidOpenTextDocumentNotification2.method = "textDocument/didOpen";
        DidOpenTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidOpenTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification2.method);
      })(DidOpenTextDocumentNotification = exports2.DidOpenTextDocumentNotification || (exports2.DidOpenTextDocumentNotification = {}));
      var TextDocumentContentChangeEvent;
      (function(TextDocumentContentChangeEvent2) {
        function isIncremental(event) {
          let candidate = event;
          return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
        }
        TextDocumentContentChangeEvent2.isIncremental = isIncremental;
        function isFull(event) {
          let candidate = event;
          return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
        }
        TextDocumentContentChangeEvent2.isFull = isFull;
      })(TextDocumentContentChangeEvent = exports2.TextDocumentContentChangeEvent || (exports2.TextDocumentContentChangeEvent = {}));
      var DidChangeTextDocumentNotification;
      (function(DidChangeTextDocumentNotification2) {
        DidChangeTextDocumentNotification2.method = "textDocument/didChange";
        DidChangeTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidChangeTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification2.method);
      })(DidChangeTextDocumentNotification = exports2.DidChangeTextDocumentNotification || (exports2.DidChangeTextDocumentNotification = {}));
      var DidCloseTextDocumentNotification;
      (function(DidCloseTextDocumentNotification2) {
        DidCloseTextDocumentNotification2.method = "textDocument/didClose";
        DidCloseTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidCloseTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification2.method);
      })(DidCloseTextDocumentNotification = exports2.DidCloseTextDocumentNotification || (exports2.DidCloseTextDocumentNotification = {}));
      var DidSaveTextDocumentNotification;
      (function(DidSaveTextDocumentNotification2) {
        DidSaveTextDocumentNotification2.method = "textDocument/didSave";
        DidSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification2.method);
      })(DidSaveTextDocumentNotification = exports2.DidSaveTextDocumentNotification || (exports2.DidSaveTextDocumentNotification = {}));
      var TextDocumentSaveReason3;
      (function(TextDocumentSaveReason4) {
        TextDocumentSaveReason4.Manual = 1;
        TextDocumentSaveReason4.AfterDelay = 2;
        TextDocumentSaveReason4.FocusOut = 3;
      })(TextDocumentSaveReason3 = exports2.TextDocumentSaveReason || (exports2.TextDocumentSaveReason = {}));
      var WillSaveTextDocumentNotification;
      (function(WillSaveTextDocumentNotification2) {
        WillSaveTextDocumentNotification2.method = "textDocument/willSave";
        WillSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        WillSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification2.method);
      })(WillSaveTextDocumentNotification = exports2.WillSaveTextDocumentNotification || (exports2.WillSaveTextDocumentNotification = {}));
      var WillSaveTextDocumentWaitUntilRequest;
      (function(WillSaveTextDocumentWaitUntilRequest2) {
        WillSaveTextDocumentWaitUntilRequest2.method = "textDocument/willSaveWaitUntil";
        WillSaveTextDocumentWaitUntilRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        WillSaveTextDocumentWaitUntilRequest2.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest2.method);
      })(WillSaveTextDocumentWaitUntilRequest = exports2.WillSaveTextDocumentWaitUntilRequest || (exports2.WillSaveTextDocumentWaitUntilRequest = {}));
      var DidChangeWatchedFilesNotification;
      (function(DidChangeWatchedFilesNotification2) {
        DidChangeWatchedFilesNotification2.method = "workspace/didChangeWatchedFiles";
        DidChangeWatchedFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
        DidChangeWatchedFilesNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification2.method);
      })(DidChangeWatchedFilesNotification = exports2.DidChangeWatchedFilesNotification || (exports2.DidChangeWatchedFilesNotification = {}));
      var FileChangeType3;
      (function(FileChangeType4) {
        FileChangeType4.Created = 1;
        FileChangeType4.Changed = 2;
        FileChangeType4.Deleted = 3;
      })(FileChangeType3 = exports2.FileChangeType || (exports2.FileChangeType = {}));
      var RelativePattern4;
      (function(RelativePattern5) {
        function is(value) {
          const candidate = value;
          return Is.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is.string(candidate.pattern);
        }
        RelativePattern5.is = is;
      })(RelativePattern4 = exports2.RelativePattern || (exports2.RelativePattern = {}));
      var WatchKind;
      (function(WatchKind2) {
        WatchKind2.Create = 1;
        WatchKind2.Change = 2;
        WatchKind2.Delete = 4;
      })(WatchKind = exports2.WatchKind || (exports2.WatchKind = {}));
      var PublishDiagnosticsNotification;
      (function(PublishDiagnosticsNotification2) {
        PublishDiagnosticsNotification2.method = "textDocument/publishDiagnostics";
        PublishDiagnosticsNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
        PublishDiagnosticsNotification2.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification2.method);
      })(PublishDiagnosticsNotification = exports2.PublishDiagnosticsNotification || (exports2.PublishDiagnosticsNotification = {}));
      var CompletionTriggerKind3;
      (function(CompletionTriggerKind4) {
        CompletionTriggerKind4.Invoked = 1;
        CompletionTriggerKind4.TriggerCharacter = 2;
        CompletionTriggerKind4.TriggerForIncompleteCompletions = 3;
      })(CompletionTriggerKind3 = exports2.CompletionTriggerKind || (exports2.CompletionTriggerKind = {}));
      var CompletionRequest;
      (function(CompletionRequest2) {
        CompletionRequest2.method = "textDocument/completion";
        CompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CompletionRequest2.type = new messages_1.ProtocolRequestType(CompletionRequest2.method);
      })(CompletionRequest = exports2.CompletionRequest || (exports2.CompletionRequest = {}));
      var CompletionResolveRequest;
      (function(CompletionResolveRequest2) {
        CompletionResolveRequest2.method = "completionItem/resolve";
        CompletionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CompletionResolveRequest2.type = new messages_1.ProtocolRequestType(CompletionResolveRequest2.method);
      })(CompletionResolveRequest = exports2.CompletionResolveRequest || (exports2.CompletionResolveRequest = {}));
      var HoverRequest;
      (function(HoverRequest2) {
        HoverRequest2.method = "textDocument/hover";
        HoverRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        HoverRequest2.type = new messages_1.ProtocolRequestType(HoverRequest2.method);
      })(HoverRequest = exports2.HoverRequest || (exports2.HoverRequest = {}));
      var SignatureHelpTriggerKind3;
      (function(SignatureHelpTriggerKind4) {
        SignatureHelpTriggerKind4.Invoked = 1;
        SignatureHelpTriggerKind4.TriggerCharacter = 2;
        SignatureHelpTriggerKind4.ContentChange = 3;
      })(SignatureHelpTriggerKind3 = exports2.SignatureHelpTriggerKind || (exports2.SignatureHelpTriggerKind = {}));
      var SignatureHelpRequest;
      (function(SignatureHelpRequest2) {
        SignatureHelpRequest2.method = "textDocument/signatureHelp";
        SignatureHelpRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        SignatureHelpRequest2.type = new messages_1.ProtocolRequestType(SignatureHelpRequest2.method);
      })(SignatureHelpRequest = exports2.SignatureHelpRequest || (exports2.SignatureHelpRequest = {}));
      var DefinitionRequest;
      (function(DefinitionRequest2) {
        DefinitionRequest2.method = "textDocument/definition";
        DefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DefinitionRequest2.type = new messages_1.ProtocolRequestType(DefinitionRequest2.method);
      })(DefinitionRequest = exports2.DefinitionRequest || (exports2.DefinitionRequest = {}));
      var ReferencesRequest;
      (function(ReferencesRequest2) {
        ReferencesRequest2.method = "textDocument/references";
        ReferencesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        ReferencesRequest2.type = new messages_1.ProtocolRequestType(ReferencesRequest2.method);
      })(ReferencesRequest = exports2.ReferencesRequest || (exports2.ReferencesRequest = {}));
      var DocumentHighlightRequest;
      (function(DocumentHighlightRequest2) {
        DocumentHighlightRequest2.method = "textDocument/documentHighlight";
        DocumentHighlightRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentHighlightRequest2.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest2.method);
      })(DocumentHighlightRequest = exports2.DocumentHighlightRequest || (exports2.DocumentHighlightRequest = {}));
      var DocumentSymbolRequest;
      (function(DocumentSymbolRequest2) {
        DocumentSymbolRequest2.method = "textDocument/documentSymbol";
        DocumentSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentSymbolRequest2.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest2.method);
      })(DocumentSymbolRequest = exports2.DocumentSymbolRequest || (exports2.DocumentSymbolRequest = {}));
      var CodeActionRequest;
      (function(CodeActionRequest2) {
        CodeActionRequest2.method = "textDocument/codeAction";
        CodeActionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CodeActionRequest2.type = new messages_1.ProtocolRequestType(CodeActionRequest2.method);
      })(CodeActionRequest = exports2.CodeActionRequest || (exports2.CodeActionRequest = {}));
      var CodeActionResolveRequest;
      (function(CodeActionResolveRequest2) {
        CodeActionResolveRequest2.method = "codeAction/resolve";
        CodeActionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CodeActionResolveRequest2.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest2.method);
      })(CodeActionResolveRequest = exports2.CodeActionResolveRequest || (exports2.CodeActionResolveRequest = {}));
      var WorkspaceSymbolRequest;
      (function(WorkspaceSymbolRequest2) {
        WorkspaceSymbolRequest2.method = "workspace/symbol";
        WorkspaceSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        WorkspaceSymbolRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest2.method);
      })(WorkspaceSymbolRequest = exports2.WorkspaceSymbolRequest || (exports2.WorkspaceSymbolRequest = {}));
      var WorkspaceSymbolResolveRequest;
      (function(WorkspaceSymbolResolveRequest2) {
        WorkspaceSymbolResolveRequest2.method = "workspaceSymbol/resolve";
        WorkspaceSymbolResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        WorkspaceSymbolResolveRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest2.method);
      })(WorkspaceSymbolResolveRequest = exports2.WorkspaceSymbolResolveRequest || (exports2.WorkspaceSymbolResolveRequest = {}));
      var CodeLensRequest;
      (function(CodeLensRequest2) {
        CodeLensRequest2.method = "textDocument/codeLens";
        CodeLensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CodeLensRequest2.type = new messages_1.ProtocolRequestType(CodeLensRequest2.method);
      })(CodeLensRequest = exports2.CodeLensRequest || (exports2.CodeLensRequest = {}));
      var CodeLensResolveRequest;
      (function(CodeLensResolveRequest2) {
        CodeLensResolveRequest2.method = "codeLens/resolve";
        CodeLensResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        CodeLensResolveRequest2.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest2.method);
      })(CodeLensResolveRequest = exports2.CodeLensResolveRequest || (exports2.CodeLensResolveRequest = {}));
      var CodeLensRefreshRequest;
      (function(CodeLensRefreshRequest2) {
        CodeLensRefreshRequest2.method = `workspace/codeLens/refresh`;
        CodeLensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        CodeLensRefreshRequest2.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest2.method);
      })(CodeLensRefreshRequest = exports2.CodeLensRefreshRequest || (exports2.CodeLensRefreshRequest = {}));
      var DocumentLinkRequest;
      (function(DocumentLinkRequest2) {
        DocumentLinkRequest2.method = "textDocument/documentLink";
        DocumentLinkRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentLinkRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkRequest2.method);
      })(DocumentLinkRequest = exports2.DocumentLinkRequest || (exports2.DocumentLinkRequest = {}));
      var DocumentLinkResolveRequest;
      (function(DocumentLinkResolveRequest2) {
        DocumentLinkResolveRequest2.method = "documentLink/resolve";
        DocumentLinkResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentLinkResolveRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest2.method);
      })(DocumentLinkResolveRequest = exports2.DocumentLinkResolveRequest || (exports2.DocumentLinkResolveRequest = {}));
      var DocumentFormattingRequest;
      (function(DocumentFormattingRequest2) {
        DocumentFormattingRequest2.method = "textDocument/formatting";
        DocumentFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest2.method);
      })(DocumentFormattingRequest = exports2.DocumentFormattingRequest || (exports2.DocumentFormattingRequest = {}));
      var DocumentRangeFormattingRequest;
      (function(DocumentRangeFormattingRequest2) {
        DocumentRangeFormattingRequest2.method = "textDocument/rangeFormatting";
        DocumentRangeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentRangeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest2.method);
      })(DocumentRangeFormattingRequest = exports2.DocumentRangeFormattingRequest || (exports2.DocumentRangeFormattingRequest = {}));
      var DocumentOnTypeFormattingRequest;
      (function(DocumentOnTypeFormattingRequest2) {
        DocumentOnTypeFormattingRequest2.method = "textDocument/onTypeFormatting";
        DocumentOnTypeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        DocumentOnTypeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest2.method);
      })(DocumentOnTypeFormattingRequest = exports2.DocumentOnTypeFormattingRequest || (exports2.DocumentOnTypeFormattingRequest = {}));
      var PrepareSupportDefaultBehavior;
      (function(PrepareSupportDefaultBehavior2) {
        PrepareSupportDefaultBehavior2.Identifier = 1;
      })(PrepareSupportDefaultBehavior = exports2.PrepareSupportDefaultBehavior || (exports2.PrepareSupportDefaultBehavior = {}));
      var RenameRequest;
      (function(RenameRequest2) {
        RenameRequest2.method = "textDocument/rename";
        RenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        RenameRequest2.type = new messages_1.ProtocolRequestType(RenameRequest2.method);
      })(RenameRequest = exports2.RenameRequest || (exports2.RenameRequest = {}));
      var PrepareRenameRequest;
      (function(PrepareRenameRequest2) {
        PrepareRenameRequest2.method = "textDocument/prepareRename";
        PrepareRenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        PrepareRenameRequest2.type = new messages_1.ProtocolRequestType(PrepareRenameRequest2.method);
      })(PrepareRenameRequest = exports2.PrepareRenameRequest || (exports2.PrepareRenameRequest = {}));
      var ExecuteCommandRequest;
      (function(ExecuteCommandRequest2) {
        ExecuteCommandRequest2.method = "workspace/executeCommand";
        ExecuteCommandRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
        ExecuteCommandRequest2.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest2.method);
      })(ExecuteCommandRequest = exports2.ExecuteCommandRequest || (exports2.ExecuteCommandRequest = {}));
      var ApplyWorkspaceEditRequest;
      (function(ApplyWorkspaceEditRequest2) {
        ApplyWorkspaceEditRequest2.method = "workspace/applyEdit";
        ApplyWorkspaceEditRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
        ApplyWorkspaceEditRequest2.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
      })(ApplyWorkspaceEditRequest = exports2.ApplyWorkspaceEditRequest || (exports2.ApplyWorkspaceEditRequest = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/connection.js
  var require_connection2 = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/connection.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createProtocolConnection = void 0;
      var vscode_jsonrpc_1 = require_main();
      function createProtocolConnection(input, output, logger, options) {
        if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
          options = { connectionStrategy: options };
        }
        return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
      }
      exports2.createProtocolConnection = createProtocolConnection;
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/common/api.js
  var require_api2 = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/common/api.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LSPErrorCodes = exports2.createProtocolConnection = void 0;
      __exportStar(require_main(), exports2);
      __exportStar(require_main2(), exports2);
      __exportStar(require_messages2(), exports2);
      __exportStar(require_protocol(), exports2);
      var connection_1 = require_connection2();
      Object.defineProperty(exports2, "createProtocolConnection", { enumerable: true, get: function() {
        return connection_1.createProtocolConnection;
      } });
      var LSPErrorCodes;
      (function(LSPErrorCodes2) {
        LSPErrorCodes2.lspReservedErrorRangeStart = -32899;
        LSPErrorCodes2.RequestFailed = -32803;
        LSPErrorCodes2.ServerCancelled = -32802;
        LSPErrorCodes2.ContentModified = -32801;
        LSPErrorCodes2.RequestCancelled = -32800;
        LSPErrorCodes2.lspReservedErrorRangeEnd = -32800;
      })(LSPErrorCodes = exports2.LSPErrorCodes || (exports2.LSPErrorCodes = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/lib/browser/main.js
  var require_main3 = __commonJS({
    "node_modules/vscode-languageserver-protocol/lib/browser/main.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createProtocolConnection = void 0;
      var browser_1 = require_browser();
      __exportStar(require_browser(), exports2);
      __exportStar(require_api2(), exports2);
      function createProtocolConnection(reader, writer, logger, options) {
        return (0, browser_1.createMessageConnection)(reader, writer, logger, options);
      }
      exports2.createProtocolConnection = createProtocolConnection;
    }
  });

  // node_modules/vscode-languageserver/lib/common/semanticTokens.js
  var require_semanticTokens = __commonJS({
    "node_modules/vscode-languageserver/lib/common/semanticTokens.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SemanticTokensBuilder = exports2.SemanticTokensDiff = exports2.SemanticTokensFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main3();
      var SemanticTokensFeature = (Base) => {
        return class extends Base {
          get semanticTokens() {
            return {
              refresh: () => {
                return this.connection.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRefreshRequest.type);
              },
              on: (handler) => {
                const type = vscode_languageserver_protocol_1.SemanticTokensRequest.type;
                return this.connection.onRequest(type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                });
              },
              onDelta: (handler) => {
                const type = vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type;
                return this.connection.onRequest(type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                });
              },
              onRange: (handler) => {
                const type = vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type;
                return this.connection.onRequest(type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                });
              }
            };
          }
        };
      };
      exports2.SemanticTokensFeature = SemanticTokensFeature;
      var SemanticTokensDiff = class {
        constructor(originalSequence, modifiedSequence) {
          this.originalSequence = originalSequence;
          this.modifiedSequence = modifiedSequence;
        }
        computeDiff() {
          const originalLength = this.originalSequence.length;
          const modifiedLength = this.modifiedSequence.length;
          let startIndex = 0;
          while (startIndex < modifiedLength && startIndex < originalLength && this.originalSequence[startIndex] === this.modifiedSequence[startIndex]) {
            startIndex++;
          }
          if (startIndex < modifiedLength && startIndex < originalLength) {
            let originalEndIndex = originalLength - 1;
            let modifiedEndIndex = modifiedLength - 1;
            while (originalEndIndex >= startIndex && modifiedEndIndex >= startIndex && this.originalSequence[originalEndIndex] === this.modifiedSequence[modifiedEndIndex]) {
              originalEndIndex--;
              modifiedEndIndex--;
            }
            if (originalEndIndex < startIndex || modifiedEndIndex < startIndex) {
              originalEndIndex++;
              modifiedEndIndex++;
            }
            const deleteCount = originalEndIndex - startIndex + 1;
            const newData = this.modifiedSequence.slice(startIndex, modifiedEndIndex + 1);
            if (newData.length === 1 && newData[0] === this.originalSequence[originalEndIndex]) {
              return [
                { start: startIndex, deleteCount: deleteCount - 1 }
              ];
            } else {
              return [
                { start: startIndex, deleteCount, data: newData }
              ];
            }
          } else if (startIndex < modifiedLength) {
            return [
              { start: startIndex, deleteCount: 0, data: this.modifiedSequence.slice(startIndex) }
            ];
          } else if (startIndex < originalLength) {
            return [
              { start: startIndex, deleteCount: originalLength - startIndex }
            ];
          } else {
            return [];
          }
        }
      };
      exports2.SemanticTokensDiff = SemanticTokensDiff;
      var SemanticTokensBuilder3 = class {
        constructor() {
          this._prevData = void 0;
          this.initialize();
        }
        initialize() {
          this._id = Date.now();
          this._prevLine = 0;
          this._prevChar = 0;
          this._data = [];
          this._dataLen = 0;
        }
        push(line, char, length, tokenType, tokenModifiers) {
          let pushLine = line;
          let pushChar = char;
          if (this._dataLen > 0) {
            pushLine -= this._prevLine;
            if (pushLine === 0) {
              pushChar -= this._prevChar;
            }
          }
          this._data[this._dataLen++] = pushLine;
          this._data[this._dataLen++] = pushChar;
          this._data[this._dataLen++] = length;
          this._data[this._dataLen++] = tokenType;
          this._data[this._dataLen++] = tokenModifiers;
          this._prevLine = line;
          this._prevChar = char;
        }
        get id() {
          return this._id.toString();
        }
        previousResult(id2) {
          if (this.id === id2) {
            this._prevData = this._data;
          }
          this.initialize();
        }
        build() {
          this._prevData = void 0;
          return {
            resultId: this.id,
            data: this._data
          };
        }
        canBuildEdits() {
          return this._prevData !== void 0;
        }
        buildEdits() {
          if (this._prevData !== void 0) {
            return {
              resultId: this.id,
              edits: new SemanticTokensDiff(this._prevData, this._data).computeDiff()
            };
          } else {
            return this.build();
          }
        }
      };
      exports2.SemanticTokensBuilder = SemanticTokensBuilder3;
    }
  });

  // node_modules/vscode-languageserver/lib/common/textDocuments.js
  var require_textDocuments = __commonJS({
    "node_modules/vscode-languageserver/lib/common/textDocuments.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TextDocuments = void 0;
      var vscode_languageserver_protocol_1 = require_main3();
      var TextDocuments = class {
        /**
         * Create a new text document manager.
         */
        constructor(configuration) {
          this._configuration = configuration;
          this._syncedDocuments = /* @__PURE__ */ new Map();
          this._onDidChangeContent = new vscode_languageserver_protocol_1.Emitter();
          this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
          this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
          this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
          this._onWillSave = new vscode_languageserver_protocol_1.Emitter();
        }
        /**
         * An event that fires when a text document managed by this manager
         * has been opened.
         */
        get onDidOpen() {
          return this._onDidOpen.event;
        }
        /**
         * An event that fires when a text document managed by this manager
         * has been opened or the content changes.
         */
        get onDidChangeContent() {
          return this._onDidChangeContent.event;
        }
        /**
         * An event that fires when a text document managed by this manager
         * will be saved.
         */
        get onWillSave() {
          return this._onWillSave.event;
        }
        /**
         * Sets a handler that will be called if a participant wants to provide
         * edits during a text document save.
         */
        onWillSaveWaitUntil(handler) {
          this._willSaveWaitUntil = handler;
        }
        /**
         * An event that fires when a text document managed by this manager
         * has been saved.
         */
        get onDidSave() {
          return this._onDidSave.event;
        }
        /**
         * An event that fires when a text document managed by this manager
         * has been closed.
         */
        get onDidClose() {
          return this._onDidClose.event;
        }
        /**
         * Returns the document for the given URI. Returns undefined if
         * the document is not managed by this instance.
         *
         * @param uri The text document's URI to retrieve.
         * @return the text document or `undefined`.
         */
        get(uri) {
          return this._syncedDocuments.get(uri);
        }
        /**
         * Returns all text documents managed by this instance.
         *
         * @return all text documents.
         */
        all() {
          return Array.from(this._syncedDocuments.values());
        }
        /**
         * Returns the URIs of all text documents managed by this instance.
         *
         * @return the URI's of all text documents.
         */
        keys() {
          return Array.from(this._syncedDocuments.keys());
        }
        /**
         * Listens for `low level` notification on the given connection to
         * update the text documents managed by this instance.
         *
         * Please note that the connection only provides handlers not an event model. Therefore
         * listening on a connection will overwrite the following handlers on a connection:
         * `onDidOpenTextDocument`, `onDidChangeTextDocument`, `onDidCloseTextDocument`,
         * `onWillSaveTextDocument`, `onWillSaveTextDocumentWaitUntil` and `onDidSaveTextDocument`.
         *
         * Use the corresponding events on the TextDocuments instance instead.
         *
         * @param connection The connection to listen on.
         */
        listen(connection) {
          connection.__textDocumentSync = vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental;
          const disposables = [];
          disposables.push(connection.onDidOpenTextDocument((event) => {
            const td = event.textDocument;
            const document2 = this._configuration.create(td.uri, td.languageId, td.version, td.text);
            this._syncedDocuments.set(td.uri, document2);
            const toFire = Object.freeze({ document: document2 });
            this._onDidOpen.fire(toFire);
            this._onDidChangeContent.fire(toFire);
          }));
          disposables.push(connection.onDidChangeTextDocument((event) => {
            const td = event.textDocument;
            const changes = event.contentChanges;
            if (changes.length === 0) {
              return;
            }
            const { version: version2 } = td;
            if (version2 === null || version2 === void 0) {
              throw new Error(`Received document change event for ${td.uri} without valid version identifier`);
            }
            let syncedDocument = this._syncedDocuments.get(td.uri);
            if (syncedDocument !== void 0) {
              syncedDocument = this._configuration.update(syncedDocument, changes, version2);
              this._syncedDocuments.set(td.uri, syncedDocument);
              this._onDidChangeContent.fire(Object.freeze({ document: syncedDocument }));
            }
          }));
          disposables.push(connection.onDidCloseTextDocument((event) => {
            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
            if (syncedDocument !== void 0) {
              this._syncedDocuments.delete(event.textDocument.uri);
              this._onDidClose.fire(Object.freeze({ document: syncedDocument }));
            }
          }));
          disposables.push(connection.onWillSaveTextDocument((event) => {
            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
            if (syncedDocument !== void 0) {
              this._onWillSave.fire(Object.freeze({ document: syncedDocument, reason: event.reason }));
            }
          }));
          disposables.push(connection.onWillSaveTextDocumentWaitUntil((event, token) => {
            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
            if (syncedDocument !== void 0 && this._willSaveWaitUntil) {
              return this._willSaveWaitUntil(Object.freeze({ document: syncedDocument, reason: event.reason }), token);
            } else {
              return [];
            }
          }));
          disposables.push(connection.onDidSaveTextDocument((event) => {
            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
            if (syncedDocument !== void 0) {
              this._onDidSave.fire(Object.freeze({ document: syncedDocument }));
            }
          }));
          return vscode_languageserver_protocol_1.Disposable.create(() => {
            disposables.forEach((disposable) => disposable.dispose());
          });
        }
      };
      exports2.TextDocuments = TextDocuments;
    }
  });

  // node_modules/vscode-languageserver/lib/common/notebook.js
  var require_notebook = __commonJS({
    "node_modules/vscode-languageserver/lib/common/notebook.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.NotebookDocuments = exports2.NotebookSyncFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main3();
      var textDocuments_1 = require_textDocuments();
      var NotebookSyncFeature = (Base) => {
        return class extends Base {
          get synchronization() {
            return {
              onDidOpenNotebookDocument: (handler) => {
                return this.connection.onNotification(vscode_languageserver_protocol_1.DidOpenNotebookDocumentNotification.type, (params) => {
                  handler(params);
                });
              },
              onDidChangeNotebookDocument: (handler) => {
                return this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeNotebookDocumentNotification.type, (params) => {
                  handler(params);
                });
              },
              onDidSaveNotebookDocument: (handler) => {
                return this.connection.onNotification(vscode_languageserver_protocol_1.DidSaveNotebookDocumentNotification.type, (params) => {
                  handler(params);
                });
              },
              onDidCloseNotebookDocument: (handler) => {
                return this.connection.onNotification(vscode_languageserver_protocol_1.DidCloseNotebookDocumentNotification.type, (params) => {
                  handler(params);
                });
              }
            };
          }
        };
      };
      exports2.NotebookSyncFeature = NotebookSyncFeature;
      var CellTextDocumentConnection = class {
        onDidOpenTextDocument(handler) {
          this.openHandler = handler;
          return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.openHandler = void 0;
          });
        }
        openTextDocument(params) {
          this.openHandler && this.openHandler(params);
        }
        onDidChangeTextDocument(handler) {
          this.changeHandler = handler;
          return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.changeHandler = handler;
          });
        }
        changeTextDocument(params) {
          this.changeHandler && this.changeHandler(params);
        }
        onDidCloseTextDocument(handler) {
          this.closeHandler = handler;
          return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.closeHandler = void 0;
          });
        }
        closeTextDocument(params) {
          this.closeHandler && this.closeHandler(params);
        }
        onWillSaveTextDocument() {
          return CellTextDocumentConnection.NULL_DISPOSE;
        }
        onWillSaveTextDocumentWaitUntil() {
          return CellTextDocumentConnection.NULL_DISPOSE;
        }
        onDidSaveTextDocument() {
          return CellTextDocumentConnection.NULL_DISPOSE;
        }
      };
      CellTextDocumentConnection.NULL_DISPOSE = Object.freeze({ dispose: () => {
      } });
      var NotebookDocuments = class {
        constructor(configurationOrTextDocuments) {
          if (configurationOrTextDocuments instanceof textDocuments_1.TextDocuments) {
            this._cellTextDocuments = configurationOrTextDocuments;
          } else {
            this._cellTextDocuments = new textDocuments_1.TextDocuments(configurationOrTextDocuments);
          }
          this.notebookDocuments = /* @__PURE__ */ new Map();
          this.notebookCellMap = /* @__PURE__ */ new Map();
          this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
          this._onDidChange = new vscode_languageserver_protocol_1.Emitter();
          this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
          this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
        }
        get cellTextDocuments() {
          return this._cellTextDocuments;
        }
        getCellTextDocument(cell) {
          return this._cellTextDocuments.get(cell.document);
        }
        getNotebookDocument(uri) {
          return this.notebookDocuments.get(uri);
        }
        getNotebookCell(uri) {
          const value = this.notebookCellMap.get(uri);
          return value && value[0];
        }
        findNotebookDocumentForCell(cell) {
          const key = typeof cell === "string" ? cell : cell.document;
          const value = this.notebookCellMap.get(key);
          return value && value[1];
        }
        get onDidOpen() {
          return this._onDidOpen.event;
        }
        get onDidSave() {
          return this._onDidSave.event;
        }
        get onDidChange() {
          return this._onDidChange.event;
        }
        get onDidClose() {
          return this._onDidClose.event;
        }
        /**
         * Listens for `low level` notification on the given connection to
         * update the notebook documents managed by this instance.
         *
         * Please note that the connection only provides handlers not an event model. Therefore
         * listening on a connection will overwrite the following handlers on a connection:
         * `onDidOpenNotebookDocument`, `onDidChangeNotebookDocument`, `onDidSaveNotebookDocument`,
         *  and `onDidCloseNotebookDocument`.
         *
         * @param connection The connection to listen on.
         */
        listen(connection) {
          const cellTextDocumentConnection = new CellTextDocumentConnection();
          const disposables = [];
          disposables.push(this.cellTextDocuments.listen(cellTextDocumentConnection));
          disposables.push(connection.notebooks.synchronization.onDidOpenNotebookDocument((params) => {
            this.notebookDocuments.set(params.notebookDocument.uri, params.notebookDocument);
            for (const cellTextDocument of params.cellTextDocuments) {
              cellTextDocumentConnection.openTextDocument({ textDocument: cellTextDocument });
            }
            this.updateCellMap(params.notebookDocument);
            this._onDidOpen.fire(params.notebookDocument);
          }));
          disposables.push(connection.notebooks.synchronization.onDidChangeNotebookDocument((params) => {
            const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
            if (notebookDocument === void 0) {
              return;
            }
            notebookDocument.version = params.notebookDocument.version;
            const oldMetadata = notebookDocument.metadata;
            let metadataChanged = false;
            const change = params.change;
            if (change.metadata !== void 0) {
              metadataChanged = true;
              notebookDocument.metadata = change.metadata;
            }
            const opened = [];
            const closed = [];
            const data = [];
            const text = [];
            if (change.cells !== void 0) {
              const changedCells = change.cells;
              if (changedCells.structure !== void 0) {
                const array = changedCells.structure.array;
                notebookDocument.cells.splice(array.start, array.deleteCount, ...array.cells !== void 0 ? array.cells : []);
                if (changedCells.structure.didOpen !== void 0) {
                  for (const open of changedCells.structure.didOpen) {
                    cellTextDocumentConnection.openTextDocument({ textDocument: open });
                    opened.push(open.uri);
                  }
                }
                if (changedCells.structure.didClose) {
                  for (const close of changedCells.structure.didClose) {
                    cellTextDocumentConnection.closeTextDocument({ textDocument: close });
                    closed.push(close.uri);
                  }
                }
              }
              if (changedCells.data !== void 0) {
                const cellUpdates = new Map(changedCells.data.map((cell) => [cell.document, cell]));
                for (let i = 0; i <= notebookDocument.cells.length; i++) {
                  const change2 = cellUpdates.get(notebookDocument.cells[i].document);
                  if (change2 !== void 0) {
                    const old = notebookDocument.cells.splice(i, 1, change2);
                    data.push({ old: old[0], new: change2 });
                    cellUpdates.delete(change2.document);
                    if (cellUpdates.size === 0) {
                      break;
                    }
                  }
                }
              }
              if (changedCells.textContent !== void 0) {
                for (const cellTextDocument of changedCells.textContent) {
                  cellTextDocumentConnection.changeTextDocument({ textDocument: cellTextDocument.document, contentChanges: cellTextDocument.changes });
                  text.push(cellTextDocument.document.uri);
                }
              }
            }
            this.updateCellMap(notebookDocument);
            const changeEvent = { notebookDocument };
            if (metadataChanged) {
              changeEvent.metadata = { old: oldMetadata, new: notebookDocument.metadata };
            }
            const added = [];
            for (const open of opened) {
              added.push(this.getNotebookCell(open));
            }
            const removed = [];
            for (const close of closed) {
              removed.push(this.getNotebookCell(close));
            }
            const textContent = [];
            for (const change2 of text) {
              textContent.push(this.getNotebookCell(change2));
            }
            if (added.length > 0 || removed.length > 0 || data.length > 0 || textContent.length > 0) {
              changeEvent.cells = { added, removed, changed: { data, textContent } };
            }
            if (changeEvent.metadata !== void 0 || changeEvent.cells !== void 0) {
              this._onDidChange.fire(changeEvent);
            }
          }));
          disposables.push(connection.notebooks.synchronization.onDidSaveNotebookDocument((params) => {
            const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
            if (notebookDocument === void 0) {
              return;
            }
            this._onDidSave.fire(notebookDocument);
          }));
          disposables.push(connection.notebooks.synchronization.onDidCloseNotebookDocument((params) => {
            const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
            if (notebookDocument === void 0) {
              return;
            }
            this._onDidClose.fire(notebookDocument);
            for (const cellTextDocument of params.cellTextDocuments) {
              cellTextDocumentConnection.closeTextDocument({ textDocument: cellTextDocument });
            }
            this.notebookDocuments.delete(params.notebookDocument.uri);
            for (const cell of notebookDocument.cells) {
              this.notebookCellMap.delete(cell.document);
            }
          }));
          return vscode_languageserver_protocol_1.Disposable.create(() => {
            disposables.forEach((disposable) => disposable.dispose());
          });
        }
        updateCellMap(notebookDocument) {
          for (const cell of notebookDocument.cells) {
            this.notebookCellMap.set(cell.document, [cell, notebookDocument]);
          }
        }
      };
      exports2.NotebookDocuments = NotebookDocuments;
    }
  });

  // node_modules/vscode-languageserver/lib/common/utils/is.js
  var require_is3 = __commonJS({
    "node_modules/vscode-languageserver/lib/common/utils/is.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.thenable = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
      function boolean2(value) {
        return value === true || value === false;
      }
      exports2.boolean = boolean2;
      function string(value) {
        return typeof value === "string" || value instanceof String;
      }
      exports2.string = string;
      function number(value) {
        return typeof value === "number" || value instanceof Number;
      }
      exports2.number = number;
      function error(value) {
        return value instanceof Error;
      }
      exports2.error = error;
      function func(value) {
        return typeof value === "function";
      }
      exports2.func = func;
      function array(value) {
        return Array.isArray(value);
      }
      exports2.array = array;
      function stringArray(value) {
        return array(value) && value.every((elem) => string(elem));
      }
      exports2.stringArray = stringArray;
      function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
      }
      exports2.typedArray = typedArray;
      function thenable(value) {
        return value && func(value.then);
      }
      exports2.thenable = thenable;
    }
  });

  // node_modules/vscode-languageserver/lib/common/utils/uuid.js
  var require_uuid = __commonJS({
    "node_modules/vscode-languageserver/lib/common/utils/uuid.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.generateUuid = exports2.parse = exports2.isUUID = exports2.v4 = exports2.empty = void 0;
      var ValueUUID = class {
        constructor(_value) {
          this._value = _value;
        }
        asHex() {
          return this._value;
        }
        equals(other) {
          return this.asHex() === other.asHex();
        }
      };
      var V4UUID = class extends ValueUUID {
        constructor() {
          super([
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            "-",
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            "-",
            "4",
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            "-",
            V4UUID._oneOf(V4UUID._timeHighBits),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            "-",
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex()
          ].join(""));
        }
        static _oneOf(array) {
          return array[Math.floor(array.length * Math.random())];
        }
        static _randomHex() {
          return V4UUID._oneOf(V4UUID._chars);
        }
      };
      V4UUID._chars = ["0", "1", "2", "3", "4", "5", "6", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
      V4UUID._timeHighBits = ["8", "9", "a", "b"];
      exports2.empty = new ValueUUID("00000000-0000-0000-0000-000000000000");
      function v4() {
        return new V4UUID();
      }
      exports2.v4 = v4;
      var _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
      function isUUID(value) {
        return _UUIDPattern.test(value);
      }
      exports2.isUUID = isUUID;
      function parse2(value) {
        if (!isUUID(value)) {
          throw new Error("invalid uuid");
        }
        return new ValueUUID(value);
      }
      exports2.parse = parse2;
      function generateUuid2() {
        return v4().asHex();
      }
      exports2.generateUuid = generateUuid2;
    }
  });

  // node_modules/vscode-languageserver/lib/common/progress.js
  var require_progress = __commonJS({
    "node_modules/vscode-languageserver/lib/common/progress.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.attachPartialResult = exports2.ProgressFeature = exports2.attachWorkDone = void 0;
      var vscode_languageserver_protocol_1 = require_main3();
      var uuid_1 = require_uuid();
      var WorkDoneProgressReporterImpl = class {
        constructor(_connection, _token) {
          this._connection = _connection;
          this._token = _token;
          WorkDoneProgressReporterImpl.Instances.set(this._token, this);
        }
        begin(title, percentage, message, cancellable) {
          let param = {
            kind: "begin",
            title,
            percentage,
            message,
            cancellable
          };
          this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
        }
        report(arg0, arg1) {
          let param = {
            kind: "report"
          };
          if (typeof arg0 === "number") {
            param.percentage = arg0;
            if (arg1 !== void 0) {
              param.message = arg1;
            }
          } else {
            param.message = arg0;
          }
          this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
        }
        done() {
          WorkDoneProgressReporterImpl.Instances.delete(this._token);
          this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, { kind: "end" });
        }
      };
      WorkDoneProgressReporterImpl.Instances = /* @__PURE__ */ new Map();
      var WorkDoneProgressServerReporterImpl = class extends WorkDoneProgressReporterImpl {
        constructor(connection, token) {
          super(connection, token);
          this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
        }
        get token() {
          return this._source.token;
        }
        done() {
          this._source.dispose();
          super.done();
        }
        cancel() {
          this._source.cancel();
        }
      };
      var NullProgressReporter = class {
        constructor() {
        }
        begin() {
        }
        report() {
        }
        done() {
        }
      };
      var NullProgressServerReporter = class extends NullProgressReporter {
        constructor() {
          super();
          this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
        }
        get token() {
          return this._source.token;
        }
        done() {
          this._source.dispose();
        }
        cancel() {
          this._source.cancel();
        }
      };
      function attachWorkDone(connection, params) {
        if (params === void 0 || params.workDoneToken === void 0) {
          return new NullProgressReporter();
        }
        const token = params.workDoneToken;
        delete params.workDoneToken;
        return new WorkDoneProgressReporterImpl(connection, token);
      }
      exports2.attachWorkDone = attachWorkDone;
      var ProgressFeature = (Base) => {
        return class extends Base {
          constructor() {
            super();
            this._progressSupported = false;
          }
          initialize(capabilities) {
            super.initialize(capabilities);
            if (capabilities?.window?.workDoneProgress === true) {
              this._progressSupported = true;
              this.connection.onNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, (params) => {
                let progress = WorkDoneProgressReporterImpl.Instances.get(params.token);
                if (progress instanceof WorkDoneProgressServerReporterImpl || progress instanceof NullProgressServerReporter) {
                  progress.cancel();
                }
              });
            }
          }
          attachWorkDoneProgress(token) {
            if (token === void 0) {
              return new NullProgressReporter();
            } else {
              return new WorkDoneProgressReporterImpl(this.connection, token);
            }
          }
          createWorkDoneProgress() {
            if (this._progressSupported) {
              const token = (0, uuid_1.generateUuid)();
              return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, { token }).then(() => {
                const result = new WorkDoneProgressServerReporterImpl(this.connection, token);
                return result;
              });
            } else {
              return Promise.resolve(new NullProgressServerReporter());
            }
          }
        };
      };
      exports2.ProgressFeature = ProgressFeature;
      var ResultProgress;
      (function(ResultProgress2) {
        ResultProgress2.type = new vscode_languageserver_protocol_1.ProgressType();
      })(ResultProgress || (ResultProgress = {}));
      var ResultProgressReporterImpl = class {
        constructor(_connection, _token) {
          this._connection = _connection;
          this._token = _token;
        }
        report(data) {
          this._connection.sendProgress(ResultProgress.type, this._token, data);
        }
      };
      function attachPartialResult(connection, params) {
        if (params === void 0 || params.partialResultToken === void 0) {
          return void 0;
        }
        const token = params.partialResultToken;
        delete params.partialResultToken;
        return new ResultProgressReporterImpl(connection, token);
      }
      exports2.attachPartialResult = attachPartialResult;
    }
  });

  // node_modules/vscode-languageserver/lib/common/configuration.js
  var require_configuration = __commonJS({
    "node_modules/vscode-languageserver/lib/common/configuration.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ConfigurationFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main3();
      var Is = require_is3();
      var ConfigurationFeature = (Base) => {
        return class extends Base {
          getConfiguration(arg) {
            if (!arg) {
              return this._getConfiguration({});
            } else if (Is.string(arg)) {
              return this._getConfiguration({ section: arg });
            } else {
              return this._getConfiguration(arg);
            }
          }
          _getConfiguration(arg) {
            let params = {
              items: Array.isArray(arg) ? arg : [arg]
            };
            return this.connection.sendRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, params).then((result) => {
              if (Array.isArray(result)) {
                return Array.isArray(arg) ? result : result[0];
              } else {
                return Array.isArray(arg) ? [] : null;
              }
            });
          }
        };
      };
      exports2.ConfigurationFeature = ConfigurationFeature;
    }
  });

  // node_modules/vscode-languageserver/lib/common/workspaceFolder.js
  var require_workspaceFolder = __commonJS({
    "node_modules/vscode-languageserver/lib/common/workspaceFolder.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.WorkspaceFoldersFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main3();
      var WorkspaceFoldersFeature = (Base) => {
        return class extends Base {
          constructor() {
            super();
            this._notificationIsAutoRegistered = false;
          }
          initialize(capabilities) {
            super.initialize(capabilities);
            let workspaceCapabilities = capabilities.workspace;
            if (workspaceCapabilities && workspaceCapabilities.workspaceFolders) {
              this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol_1.Emitter();
              this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, (params) => {
                this._onDidChangeWorkspaceFolders.fire(params.event);
              });
            }
          }
          fillServerCapabilities(capabilities) {
            super.fillServerCapabilities(capabilities);
            const changeNotifications = capabilities.workspace?.workspaceFolders?.changeNotifications;
            this._notificationIsAutoRegistered = changeNotifications === true || typeof changeNotifications === "string";
          }
          getWorkspaceFolders() {
            return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type);
          }
          get onDidChangeWorkspaceFolders() {
            if (!this._onDidChangeWorkspaceFolders) {
              throw new Error("Client doesn't support sending workspace folder change events.");
            }
            if (!this._notificationIsAutoRegistered && !this._unregistration) {
              this._unregistration = this.connection.client.register(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type);
            }
            return this._onDidChangeWorkspaceFolders.event;
          }
        };
      };
      exports2.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
    }
  });

  // node_modules/vscode-languageserver/lib/common/callHierarchy.js
  var require_callHierarchy = __commonJS({
    "node_modules/vscode-languageserver/lib/common/callHierarchy.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.CallHierarchyFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main3();
      var CallHierarchyFeature = (Base) => {
        return class extends Base {
          get callHierarchy() {
            return {
              onPrepare: (handler) => {
                return this.connection.onRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
                });
              },
              onIncomingCalls: (handler) => {
                const type = vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type;
                return this.connection.onRequest(type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                });
              },
              onOutgoingCalls: (handler) => {
                const type = vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type;
                return this.connection.onRequest(type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                });
              }
            };
          }
        };
      };
      exports2.CallHierarchyFeature = CallHierarchyFeature;
    }
  });

  // node_modules/vscode-languageserver/lib/common/showDocument.js
  var require_showDocument = __commonJS({
    "node_modules/vscode-languageserver/lib/common/showDocument.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ShowDocumentFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main3();
      var ShowDocumentFeature = (Base) => {
        return class extends Base {
          showDocument(params) {
            return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, params);
          }
        };
      };
      exports2.ShowDocumentFeature = ShowDocumentFeature;
    }
  });

  // node_modules/vscode-languageserver/lib/common/fileOperations.js
  var require_fileOperations = __commonJS({
    "node_modules/vscode-languageserver/lib/common/fileOperations.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FileOperationsFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main3();
      var FileOperationsFeature = (Base) => {
        return class extends Base {
          onDidCreateFiles(handler) {
            return this.connection.onNotification(vscode_languageserver_protocol_1.DidCreateFilesNotification.type, (params) => {
              handler(params);
            });
          }
          onDidRenameFiles(handler) {
            return this.connection.onNotification(vscode_languageserver_protocol_1.DidRenameFilesNotification.type, (params) => {
              handler(params);
            });
          }
          onDidDeleteFiles(handler) {
            return this.connection.onNotification(vscode_languageserver_protocol_1.DidDeleteFilesNotification.type, (params) => {
              handler(params);
            });
          }
          onWillCreateFiles(handler) {
            return this.connection.onRequest(vscode_languageserver_protocol_1.WillCreateFilesRequest.type, (params, cancel) => {
              return handler(params, cancel);
            });
          }
          onWillRenameFiles(handler) {
            return this.connection.onRequest(vscode_languageserver_protocol_1.WillRenameFilesRequest.type, (params, cancel) => {
              return handler(params, cancel);
            });
          }
          onWillDeleteFiles(handler) {
            return this.connection.onRequest(vscode_languageserver_protocol_1.WillDeleteFilesRequest.type, (params, cancel) => {
              return handler(params, cancel);
            });
          }
        };
      };
      exports2.FileOperationsFeature = FileOperationsFeature;
    }
  });

  // node_modules/vscode-languageserver/lib/common/linkedEditingRange.js
  var require_linkedEditingRange = __commonJS({
    "node_modules/vscode-languageserver/lib/common/linkedEditingRange.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LinkedEditingRangeFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main3();
      var LinkedEditingRangeFeature = (Base) => {
        return class extends Base {
          onLinkedEditingRange(handler) {
            return this.connection.onRequest(vscode_languageserver_protocol_1.LinkedEditingRangeRequest.type, (params, cancel) => {
              return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
            });
          }
        };
      };
      exports2.LinkedEditingRangeFeature = LinkedEditingRangeFeature;
    }
  });

  // node_modules/vscode-languageserver/lib/common/typeHierarchy.js
  var require_typeHierarchy = __commonJS({
    "node_modules/vscode-languageserver/lib/common/typeHierarchy.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TypeHierarchyFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main3();
      var TypeHierarchyFeature = (Base) => {
        return class extends Base {
          get typeHierarchy() {
            return {
              onPrepare: (handler) => {
                return this.connection.onRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
                });
              },
              onSupertypes: (handler) => {
                const type = vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type;
                return this.connection.onRequest(type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                });
              },
              onSubtypes: (handler) => {
                const type = vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type;
                return this.connection.onRequest(type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                });
              }
            };
          }
        };
      };
      exports2.TypeHierarchyFeature = TypeHierarchyFeature;
    }
  });

  // node_modules/vscode-languageserver/lib/common/inlineValue.js
  var require_inlineValue = __commonJS({
    "node_modules/vscode-languageserver/lib/common/inlineValue.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.InlineValueFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main3();
      var InlineValueFeature = (Base) => {
        return class extends Base {
          get inlineValue() {
            return {
              refresh: () => {
                return this.connection.sendRequest(vscode_languageserver_protocol_1.InlineValueRefreshRequest.type);
              },
              on: (handler) => {
                return this.connection.onRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params));
                });
              }
            };
          }
        };
      };
      exports2.InlineValueFeature = InlineValueFeature;
    }
  });

  // node_modules/vscode-languageserver/lib/common/inlayHint.js
  var require_inlayHint = __commonJS({
    "node_modules/vscode-languageserver/lib/common/inlayHint.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.InlayHintFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main3();
      var InlayHintFeature = (Base) => {
        return class extends Base {
          get inlayHint() {
            return {
              refresh: () => {
                return this.connection.sendRequest(vscode_languageserver_protocol_1.InlayHintRefreshRequest.type);
              },
              on: (handler) => {
                return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params));
                });
              },
              resolve: (handler) => {
                return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, (params, cancel) => {
                  return handler(params, cancel);
                });
              }
            };
          }
        };
      };
      exports2.InlayHintFeature = InlayHintFeature;
    }
  });

  // node_modules/vscode-languageserver/lib/common/diagnostic.js
  var require_diagnostic = __commonJS({
    "node_modules/vscode-languageserver/lib/common/diagnostic.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DiagnosticFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main3();
      var DiagnosticFeature = (Base) => {
        return class extends Base {
          get diagnostics() {
            return {
              refresh: () => {
                return this.connection.sendRequest(vscode_languageserver_protocol_1.DiagnosticRefreshRequest.type);
              },
              on: (handler) => {
                return this.connection.onRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.partialResult, params));
                });
              },
              onWorkspace: (handler) => {
                return this.connection.onRequest(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.partialResult, params));
                });
              }
            };
          }
        };
      };
      exports2.DiagnosticFeature = DiagnosticFeature;
    }
  });

  // node_modules/vscode-languageserver/lib/common/moniker.js
  var require_moniker = __commonJS({
    "node_modules/vscode-languageserver/lib/common/moniker.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.MonikerFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main3();
      var MonikerFeature = (Base) => {
        return class extends Base {
          get moniker() {
            return {
              on: (handler) => {
                const type = vscode_languageserver_protocol_1.MonikerRequest.type;
                return this.connection.onRequest(type, (params, cancel) => {
                  return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                });
              }
            };
          }
        };
      };
      exports2.MonikerFeature = MonikerFeature;
    }
  });

  // node_modules/vscode-languageserver/lib/common/server.js
  var require_server = __commonJS({
    "node_modules/vscode-languageserver/lib/common/server.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createConnection = exports2.combineFeatures = exports2.combineNotebooksFeatures = exports2.combineLanguagesFeatures = exports2.combineWorkspaceFeatures = exports2.combineWindowFeatures = exports2.combineClientFeatures = exports2.combineTracerFeatures = exports2.combineTelemetryFeatures = exports2.combineConsoleFeatures = exports2._NotebooksImpl = exports2._LanguagesImpl = exports2.BulkUnregistration = exports2.BulkRegistration = exports2.ErrorMessageTracker = void 0;
      var vscode_languageserver_protocol_1 = require_main3();
      var Is = require_is3();
      var UUID = require_uuid();
      var progress_1 = require_progress();
      var configuration_1 = require_configuration();
      var workspaceFolder_1 = require_workspaceFolder();
      var callHierarchy_1 = require_callHierarchy();
      var semanticTokens_1 = require_semanticTokens();
      var showDocument_1 = require_showDocument();
      var fileOperations_1 = require_fileOperations();
      var linkedEditingRange_1 = require_linkedEditingRange();
      var typeHierarchy_1 = require_typeHierarchy();
      var inlineValue_1 = require_inlineValue();
      var inlayHint_1 = require_inlayHint();
      var diagnostic_1 = require_diagnostic();
      var notebook_1 = require_notebook();
      var moniker_1 = require_moniker();
      function null2Undefined(value) {
        if (value === null) {
          return void 0;
        }
        return value;
      }
      var ErrorMessageTracker = class {
        constructor() {
          this._messages = /* @__PURE__ */ Object.create(null);
        }
        /**
         * Add a message to the tracker.
         *
         * @param message The message to add.
         */
        add(message) {
          let count = this._messages[message];
          if (!count) {
            count = 0;
          }
          count++;
          this._messages[message] = count;
        }
        /**
         * Send all tracked messages to the connection's window.
         *
         * @param connection The connection established between client and server.
         */
        sendErrors(connection) {
          Object.keys(this._messages).forEach((message) => {
            connection.window.showErrorMessage(message);
          });
        }
      };
      exports2.ErrorMessageTracker = ErrorMessageTracker;
      var RemoteConsoleImpl = class {
        constructor() {
        }
        rawAttach(connection) {
          this._rawConnection = connection;
        }
        attach(connection) {
          this._connection = connection;
        }
        get connection() {
          if (!this._connection) {
            throw new Error("Remote is not attached to a connection yet.");
          }
          return this._connection;
        }
        fillServerCapabilities(_capabilities) {
        }
        initialize(_capabilities) {
        }
        error(message) {
          this.send(vscode_languageserver_protocol_1.MessageType.Error, message);
        }
        warn(message) {
          this.send(vscode_languageserver_protocol_1.MessageType.Warning, message);
        }
        info(message) {
          this.send(vscode_languageserver_protocol_1.MessageType.Info, message);
        }
        log(message) {
          this.send(vscode_languageserver_protocol_1.MessageType.Log, message);
        }
        send(type, message) {
          if (this._rawConnection) {
            this._rawConnection.sendNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, { type, message }).catch(() => {
              (0, vscode_languageserver_protocol_1.RAL)().console.error(`Sending log message failed`);
            });
          }
        }
      };
      var _RemoteWindowImpl = class {
        constructor() {
        }
        attach(connection) {
          this._connection = connection;
        }
        get connection() {
          if (!this._connection) {
            throw new Error("Remote is not attached to a connection yet.");
          }
          return this._connection;
        }
        initialize(_capabilities) {
        }
        fillServerCapabilities(_capabilities) {
        }
        showErrorMessage(message, ...actions) {
          let params = { type: vscode_languageserver_protocol_1.MessageType.Error, message, actions };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
        }
        showWarningMessage(message, ...actions) {
          let params = { type: vscode_languageserver_protocol_1.MessageType.Warning, message, actions };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
        }
        showInformationMessage(message, ...actions) {
          let params = { type: vscode_languageserver_protocol_1.MessageType.Info, message, actions };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
        }
      };
      var RemoteWindowImpl = (0, showDocument_1.ShowDocumentFeature)((0, progress_1.ProgressFeature)(_RemoteWindowImpl));
      var BulkRegistration;
      (function(BulkRegistration2) {
        function create() {
          return new BulkRegistrationImpl();
        }
        BulkRegistration2.create = create;
      })(BulkRegistration = exports2.BulkRegistration || (exports2.BulkRegistration = {}));
      var BulkRegistrationImpl = class {
        constructor() {
          this._registrations = [];
          this._registered = /* @__PURE__ */ new Set();
        }
        add(type, registerOptions) {
          const method = Is.string(type) ? type : type.method;
          if (this._registered.has(method)) {
            throw new Error(`${method} is already added to this registration`);
          }
          const id2 = UUID.generateUuid();
          this._registrations.push({
            id: id2,
            method,
            registerOptions: registerOptions || {}
          });
          this._registered.add(method);
        }
        asRegistrationParams() {
          return {
            registrations: this._registrations
          };
        }
      };
      var BulkUnregistration;
      (function(BulkUnregistration2) {
        function create() {
          return new BulkUnregistrationImpl(void 0, []);
        }
        BulkUnregistration2.create = create;
      })(BulkUnregistration = exports2.BulkUnregistration || (exports2.BulkUnregistration = {}));
      var BulkUnregistrationImpl = class {
        constructor(_connection, unregistrations) {
          this._connection = _connection;
          this._unregistrations = /* @__PURE__ */ new Map();
          unregistrations.forEach((unregistration) => {
            this._unregistrations.set(unregistration.method, unregistration);
          });
        }
        get isAttached() {
          return !!this._connection;
        }
        attach(connection) {
          this._connection = connection;
        }
        add(unregistration) {
          this._unregistrations.set(unregistration.method, unregistration);
        }
        dispose() {
          let unregistrations = [];
          for (let unregistration of this._unregistrations.values()) {
            unregistrations.push(unregistration);
          }
          let params = {
            unregisterations: unregistrations
          };
          this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
            this._connection.console.info(`Bulk unregistration failed.`);
          });
        }
        disposeSingle(arg) {
          const method = Is.string(arg) ? arg : arg.method;
          const unregistration = this._unregistrations.get(method);
          if (!unregistration) {
            return false;
          }
          let params = {
            unregisterations: [unregistration]
          };
          this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(() => {
            this._unregistrations.delete(method);
          }, (_error) => {
            this._connection.console.info(`Un-registering request handler for ${unregistration.id} failed.`);
          });
          return true;
        }
      };
      var RemoteClientImpl = class {
        attach(connection) {
          this._connection = connection;
        }
        get connection() {
          if (!this._connection) {
            throw new Error("Remote is not attached to a connection yet.");
          }
          return this._connection;
        }
        initialize(_capabilities) {
        }
        fillServerCapabilities(_capabilities) {
        }
        register(typeOrRegistrations, registerOptionsOrType, registerOptions) {
          if (typeOrRegistrations instanceof BulkRegistrationImpl) {
            return this.registerMany(typeOrRegistrations);
          } else if (typeOrRegistrations instanceof BulkUnregistrationImpl) {
            return this.registerSingle1(typeOrRegistrations, registerOptionsOrType, registerOptions);
          } else {
            return this.registerSingle2(typeOrRegistrations, registerOptionsOrType);
          }
        }
        registerSingle1(unregistration, type, registerOptions) {
          const method = Is.string(type) ? type : type.method;
          const id2 = UUID.generateUuid();
          let params = {
            registrations: [{ id: id2, method, registerOptions: registerOptions || {} }]
          };
          if (!unregistration.isAttached) {
            unregistration.attach(this.connection);
          }
          return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
            unregistration.add({ id: id2, method });
            return unregistration;
          }, (_error) => {
            this.connection.console.info(`Registering request handler for ${method} failed.`);
            return Promise.reject(_error);
          });
        }
        registerSingle2(type, registerOptions) {
          const method = Is.string(type) ? type : type.method;
          const id2 = UUID.generateUuid();
          let params = {
            registrations: [{ id: id2, method, registerOptions: registerOptions || {} }]
          };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
            return vscode_languageserver_protocol_1.Disposable.create(() => {
              this.unregisterSingle(id2, method).catch(() => {
                this.connection.console.info(`Un-registering capability with id ${id2} failed.`);
              });
            });
          }, (_error) => {
            this.connection.console.info(`Registering request handler for ${method} failed.`);
            return Promise.reject(_error);
          });
        }
        unregisterSingle(id2, method) {
          let params = {
            unregisterations: [{ id: id2, method }]
          };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
            this.connection.console.info(`Un-registering request handler for ${id2} failed.`);
          });
        }
        registerMany(registrations) {
          let params = registrations.asRegistrationParams();
          return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then(() => {
            return new BulkUnregistrationImpl(this._connection, params.registrations.map((registration) => {
              return { id: registration.id, method: registration.method };
            }));
          }, (_error) => {
            this.connection.console.info(`Bulk registration failed.`);
            return Promise.reject(_error);
          });
        }
      };
      var _RemoteWorkspaceImpl = class {
        constructor() {
        }
        attach(connection) {
          this._connection = connection;
        }
        get connection() {
          if (!this._connection) {
            throw new Error("Remote is not attached to a connection yet.");
          }
          return this._connection;
        }
        initialize(_capabilities) {
        }
        fillServerCapabilities(_capabilities) {
        }
        applyEdit(paramOrEdit) {
          function isApplyWorkspaceEditParams(value) {
            return value && !!value.edit;
          }
          let params = isApplyWorkspaceEditParams(paramOrEdit) ? paramOrEdit : { edit: paramOrEdit };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params);
        }
      };
      var RemoteWorkspaceImpl = (0, fileOperations_1.FileOperationsFeature)((0, workspaceFolder_1.WorkspaceFoldersFeature)((0, configuration_1.ConfigurationFeature)(_RemoteWorkspaceImpl)));
      var TracerImpl = class {
        constructor() {
          this._trace = vscode_languageserver_protocol_1.Trace.Off;
        }
        attach(connection) {
          this._connection = connection;
        }
        get connection() {
          if (!this._connection) {
            throw new Error("Remote is not attached to a connection yet.");
          }
          return this._connection;
        }
        initialize(_capabilities) {
        }
        fillServerCapabilities(_capabilities) {
        }
        set trace(value) {
          this._trace = value;
        }
        log(message, verbose) {
          if (this._trace === vscode_languageserver_protocol_1.Trace.Off) {
            return;
          }
          this.connection.sendNotification(vscode_languageserver_protocol_1.LogTraceNotification.type, {
            message,
            verbose: this._trace === vscode_languageserver_protocol_1.Trace.Verbose ? verbose : void 0
          }).catch(() => {
          });
        }
      };
      var TelemetryImpl = class {
        constructor() {
        }
        attach(connection) {
          this._connection = connection;
        }
        get connection() {
          if (!this._connection) {
            throw new Error("Remote is not attached to a connection yet.");
          }
          return this._connection;
        }
        initialize(_capabilities) {
        }
        fillServerCapabilities(_capabilities) {
        }
        logEvent(data) {
          this.connection.sendNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, data).catch(() => {
            this.connection.console.log(`Sending TelemetryEventNotification failed`);
          });
        }
      };
      var _LanguagesImpl = class {
        constructor() {
        }
        attach(connection) {
          this._connection = connection;
        }
        get connection() {
          if (!this._connection) {
            throw new Error("Remote is not attached to a connection yet.");
          }
          return this._connection;
        }
        initialize(_capabilities) {
        }
        fillServerCapabilities(_capabilities) {
        }
        attachWorkDoneProgress(params) {
          return (0, progress_1.attachWorkDone)(this.connection, params);
        }
        attachPartialResultProgress(_type, params) {
          return (0, progress_1.attachPartialResult)(this.connection, params);
        }
      };
      exports2._LanguagesImpl = _LanguagesImpl;
      var LanguagesImpl = (0, moniker_1.MonikerFeature)((0, diagnostic_1.DiagnosticFeature)((0, inlayHint_1.InlayHintFeature)((0, inlineValue_1.InlineValueFeature)((0, typeHierarchy_1.TypeHierarchyFeature)((0, linkedEditingRange_1.LinkedEditingRangeFeature)((0, semanticTokens_1.SemanticTokensFeature)((0, callHierarchy_1.CallHierarchyFeature)(_LanguagesImpl))))))));
      var _NotebooksImpl = class {
        constructor() {
        }
        attach(connection) {
          this._connection = connection;
        }
        get connection() {
          if (!this._connection) {
            throw new Error("Remote is not attached to a connection yet.");
          }
          return this._connection;
        }
        initialize(_capabilities) {
        }
        fillServerCapabilities(_capabilities) {
        }
        attachWorkDoneProgress(params) {
          return (0, progress_1.attachWorkDone)(this.connection, params);
        }
        attachPartialResultProgress(_type, params) {
          return (0, progress_1.attachPartialResult)(this.connection, params);
        }
      };
      exports2._NotebooksImpl = _NotebooksImpl;
      var NotebooksImpl = (0, notebook_1.NotebookSyncFeature)(_NotebooksImpl);
      function combineConsoleFeatures(one, two) {
        return function(Base) {
          return two(one(Base));
        };
      }
      exports2.combineConsoleFeatures = combineConsoleFeatures;
      function combineTelemetryFeatures(one, two) {
        return function(Base) {
          return two(one(Base));
        };
      }
      exports2.combineTelemetryFeatures = combineTelemetryFeatures;
      function combineTracerFeatures(one, two) {
        return function(Base) {
          return two(one(Base));
        };
      }
      exports2.combineTracerFeatures = combineTracerFeatures;
      function combineClientFeatures(one, two) {
        return function(Base) {
          return two(one(Base));
        };
      }
      exports2.combineClientFeatures = combineClientFeatures;
      function combineWindowFeatures(one, two) {
        return function(Base) {
          return two(one(Base));
        };
      }
      exports2.combineWindowFeatures = combineWindowFeatures;
      function combineWorkspaceFeatures(one, two) {
        return function(Base) {
          return two(one(Base));
        };
      }
      exports2.combineWorkspaceFeatures = combineWorkspaceFeatures;
      function combineLanguagesFeatures(one, two) {
        return function(Base) {
          return two(one(Base));
        };
      }
      exports2.combineLanguagesFeatures = combineLanguagesFeatures;
      function combineNotebooksFeatures(one, two) {
        return function(Base) {
          return two(one(Base));
        };
      }
      exports2.combineNotebooksFeatures = combineNotebooksFeatures;
      function combineFeatures(one, two) {
        function combine(one2, two2, func) {
          if (one2 && two2) {
            return func(one2, two2);
          } else if (one2) {
            return one2;
          } else {
            return two2;
          }
        }
        let result = {
          __brand: "features",
          console: combine(one.console, two.console, combineConsoleFeatures),
          tracer: combine(one.tracer, two.tracer, combineTracerFeatures),
          telemetry: combine(one.telemetry, two.telemetry, combineTelemetryFeatures),
          client: combine(one.client, two.client, combineClientFeatures),
          window: combine(one.window, two.window, combineWindowFeatures),
          workspace: combine(one.workspace, two.workspace, combineWorkspaceFeatures),
          languages: combine(one.languages, two.languages, combineLanguagesFeatures),
          notebooks: combine(one.notebooks, two.notebooks, combineNotebooksFeatures)
        };
        return result;
      }
      exports2.combineFeatures = combineFeatures;
      function createConnection(connectionFactory, watchDog, factories) {
        const logger = factories && factories.console ? new (factories.console(RemoteConsoleImpl))() : new RemoteConsoleImpl();
        const connection = connectionFactory(logger);
        logger.rawAttach(connection);
        const tracer = factories && factories.tracer ? new (factories.tracer(TracerImpl))() : new TracerImpl();
        const telemetry = factories && factories.telemetry ? new (factories.telemetry(TelemetryImpl))() : new TelemetryImpl();
        const client = factories && factories.client ? new (factories.client(RemoteClientImpl))() : new RemoteClientImpl();
        const remoteWindow = factories && factories.window ? new (factories.window(RemoteWindowImpl))() : new RemoteWindowImpl();
        const workspace2 = factories && factories.workspace ? new (factories.workspace(RemoteWorkspaceImpl))() : new RemoteWorkspaceImpl();
        const languages2 = factories && factories.languages ? new (factories.languages(LanguagesImpl))() : new LanguagesImpl();
        const notebooks2 = factories && factories.notebooks ? new (factories.notebooks(NotebooksImpl))() : new NotebooksImpl();
        const allRemotes = [logger, tracer, telemetry, client, remoteWindow, workspace2, languages2, notebooks2];
        function asPromise(value) {
          if (value instanceof Promise) {
            return value;
          } else if (Is.thenable(value)) {
            return new Promise((resolve2, reject) => {
              value.then((resolved) => resolve2(resolved), (error) => reject(error));
            });
          } else {
            return Promise.resolve(value);
          }
        }
        let shutdownHandler = void 0;
        let initializeHandler = void 0;
        let exitHandler = void 0;
        let protocolConnection = {
          listen: () => connection.listen(),
          sendRequest: (type, ...params) => connection.sendRequest(Is.string(type) ? type : type.method, ...params),
          onRequest: (type, handler) => connection.onRequest(type, handler),
          sendNotification: (type, param) => {
            const method = Is.string(type) ? type : type.method;
            if (arguments.length === 1) {
              return connection.sendNotification(method);
            } else {
              return connection.sendNotification(method, param);
            }
          },
          onNotification: (type, handler) => connection.onNotification(type, handler),
          onProgress: connection.onProgress,
          sendProgress: connection.sendProgress,
          onInitialize: (handler) => {
            initializeHandler = handler;
            return {
              dispose: () => {
                initializeHandler = void 0;
              }
            };
          },
          onInitialized: (handler) => connection.onNotification(vscode_languageserver_protocol_1.InitializedNotification.type, handler),
          onShutdown: (handler) => {
            shutdownHandler = handler;
            return {
              dispose: () => {
                shutdownHandler = void 0;
              }
            };
          },
          onExit: (handler) => {
            exitHandler = handler;
            return {
              dispose: () => {
                exitHandler = void 0;
              }
            };
          },
          get console() {
            return logger;
          },
          get telemetry() {
            return telemetry;
          },
          get tracer() {
            return tracer;
          },
          get client() {
            return client;
          },
          get window() {
            return remoteWindow;
          },
          get workspace() {
            return workspace2;
          },
          get languages() {
            return languages2;
          },
          get notebooks() {
            return notebooks2;
          },
          onDidChangeConfiguration: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, handler),
          onDidChangeWatchedFiles: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, handler),
          __textDocumentSync: void 0,
          onDidOpenTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, handler),
          onDidChangeTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, handler),
          onDidCloseTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, handler),
          onWillSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, handler),
          onWillSaveTextDocumentWaitUntil: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, handler),
          onDidSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, handler),
          sendDiagnostics: (params) => connection.sendNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params),
          onHover: (handler) => connection.onRequest(vscode_languageserver_protocol_1.HoverRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), void 0);
          }),
          onCompletion: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
          }),
          onCompletionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, handler),
          onSignatureHelp: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), void 0);
          }),
          onDeclaration: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
          }),
          onDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
          }),
          onTypeDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
          }),
          onImplementation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
          }),
          onReferences: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
          }),
          onDocumentHighlight: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
          }),
          onDocumentSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
          }),
          onWorkspaceSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
          }),
          onWorkspaceSymbolResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, handler),
          onCodeAction: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
          }),
          onCodeActionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, (params, cancel) => {
            return handler(params, cancel);
          }),
          onCodeLens: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
          }),
          onCodeLensResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, (params, cancel) => {
            return handler(params, cancel);
          }),
          onDocumentFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), void 0);
          }),
          onDocumentRangeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), void 0);
          }),
          onDocumentOnTypeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, (params, cancel) => {
            return handler(params, cancel);
          }),
          onRenameRequest: (handler) => connection.onRequest(vscode_languageserver_protocol_1.RenameRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), void 0);
          }),
          onPrepareRename: (handler) => connection.onRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, (params, cancel) => {
            return handler(params, cancel);
          }),
          onDocumentLinks: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
          }),
          onDocumentLinkResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, (params, cancel) => {
            return handler(params, cancel);
          }),
          onDocumentColor: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
          }),
          onColorPresentation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
          }),
          onFoldingRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
          }),
          onSelectionRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
          }),
          onExecuteCommand: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, (params, cancel) => {
            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), void 0);
          }),
          dispose: () => connection.dispose()
        };
        for (let remote of allRemotes) {
          remote.attach(protocolConnection);
        }
        connection.onRequest(vscode_languageserver_protocol_1.InitializeRequest.type, (params) => {
          watchDog.initialize(params);
          if (Is.string(params.trace)) {
            tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.trace);
          }
          for (let remote of allRemotes) {
            remote.initialize(params.capabilities);
          }
          if (initializeHandler) {
            let result = initializeHandler(params, new vscode_languageserver_protocol_1.CancellationTokenSource().token, (0, progress_1.attachWorkDone)(connection, params), void 0);
            return asPromise(result).then((value) => {
              if (value instanceof vscode_languageserver_protocol_1.ResponseError) {
                return value;
              }
              let result2 = value;
              if (!result2) {
                result2 = { capabilities: {} };
              }
              let capabilities = result2.capabilities;
              if (!capabilities) {
                capabilities = {};
                result2.capabilities = capabilities;
              }
              if (capabilities.textDocumentSync === void 0 || capabilities.textDocumentSync === null) {
                capabilities.textDocumentSync = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
              } else if (!Is.number(capabilities.textDocumentSync) && !Is.number(capabilities.textDocumentSync.change)) {
                capabilities.textDocumentSync.change = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
              }
              for (let remote of allRemotes) {
                remote.fillServerCapabilities(capabilities);
              }
              return result2;
            });
          } else {
            let result = { capabilities: { textDocumentSync: vscode_languageserver_protocol_1.TextDocumentSyncKind.None } };
            for (let remote of allRemotes) {
              remote.fillServerCapabilities(result.capabilities);
            }
            return result;
          }
        });
        connection.onRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, () => {
          watchDog.shutdownReceived = true;
          if (shutdownHandler) {
            return shutdownHandler(new vscode_languageserver_protocol_1.CancellationTokenSource().token);
          } else {
            return void 0;
          }
        });
        connection.onNotification(vscode_languageserver_protocol_1.ExitNotification.type, () => {
          try {
            if (exitHandler) {
              exitHandler();
            }
          } finally {
            if (watchDog.shutdownReceived) {
              watchDog.exit(0);
            } else {
              watchDog.exit(1);
            }
          }
        });
        connection.onNotification(vscode_languageserver_protocol_1.SetTraceNotification.type, (params) => {
          tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.value);
        });
        return protocolConnection;
      }
      exports2.createConnection = createConnection;
    }
  });

  // node_modules/vscode-languageserver/lib/common/api.js
  var require_api3 = __commonJS({
    "node_modules/vscode-languageserver/lib/common/api.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ProposedFeatures = exports2.NotebookDocuments = exports2.TextDocuments = exports2.SemanticTokensBuilder = void 0;
      var semanticTokens_1 = require_semanticTokens();
      Object.defineProperty(exports2, "SemanticTokensBuilder", { enumerable: true, get: function() {
        return semanticTokens_1.SemanticTokensBuilder;
      } });
      __exportStar(require_main3(), exports2);
      var textDocuments_1 = require_textDocuments();
      Object.defineProperty(exports2, "TextDocuments", { enumerable: true, get: function() {
        return textDocuments_1.TextDocuments;
      } });
      var notebook_1 = require_notebook();
      Object.defineProperty(exports2, "NotebookDocuments", { enumerable: true, get: function() {
        return notebook_1.NotebookDocuments;
      } });
      __exportStar(require_server(), exports2);
      var ProposedFeatures;
      (function(ProposedFeatures2) {
        ProposedFeatures2.all = {
          __brand: "features"
        };
      })(ProposedFeatures = exports2.ProposedFeatures || (exports2.ProposedFeatures = {}));
    }
  });

  // node_modules/vscode-languageserver-protocol/browser.js
  var require_browser2 = __commonJS({
    "node_modules/vscode-languageserver-protocol/browser.js"(exports2, module2) {
      "use strict";
      module2.exports = require_main3();
    }
  });

  // node_modules/vscode-languageserver/lib/browser/main.js
  var require_main4 = __commonJS({
    "node_modules/vscode-languageserver/lib/browser/main.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createConnection = void 0;
      var api_1 = require_api3();
      __exportStar(require_browser2(), exports2);
      __exportStar(require_api3(), exports2);
      var _shutdownReceived = false;
      var watchDog = {
        initialize: (_params) => {
        },
        get shutdownReceived() {
          return _shutdownReceived;
        },
        set shutdownReceived(value) {
          _shutdownReceived = value;
        },
        exit: (_code) => {
        }
      };
      function createConnection(arg1, arg2, arg3, arg4) {
        let factories;
        let reader;
        let writer;
        let options;
        if (arg1 !== void 0 && arg1.__brand === "features") {
          factories = arg1;
          arg1 = arg2;
          arg2 = arg3;
          arg3 = arg4;
        }
        if (api_1.ConnectionStrategy.is(arg1) || api_1.ConnectionOptions.is(arg1)) {
          options = arg1;
        } else {
          reader = arg1;
          writer = arg2;
          options = arg3;
        }
        const connectionFactory = (logger) => {
          return (0, api_1.createProtocolConnection)(reader, writer, logger, options);
        };
        return (0, api_1.createConnection)(connectionFactory, watchDog, factories);
      }
      exports2.createConnection = createConnection;
    }
  });

  // node_modules/vscode-languageserver-textdocument/lib/umd/main.js
  var require_main5 = __commonJS({
    "node_modules/vscode-languageserver-textdocument/lib/umd/main.js"(exports2, module2) {
      var __spreadArray = exports2 && exports2.__spreadArray || function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      (function(factory) {
        if (typeof module2 === "object" && typeof module2.exports === "object") {
          var v = factory(__require, exports2);
          if (v !== void 0)
            module2.exports = v;
        } else if (typeof define === "function" && define.amd) {
          define(["require", "exports"], factory);
        }
      })(function(require2, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.TextDocument = void 0;
        var FullTextDocument = (
          /** @class */
          function() {
            function FullTextDocument2(uri, languageId, version2, content) {
              this._uri = uri;
              this._languageId = languageId;
              this._version = version2;
              this._content = content;
              this._lineOffsets = void 0;
            }
            Object.defineProperty(FullTextDocument2.prototype, "uri", {
              get: function() {
                return this._uri;
              },
              enumerable: false,
              configurable: true
            });
            Object.defineProperty(FullTextDocument2.prototype, "languageId", {
              get: function() {
                return this._languageId;
              },
              enumerable: false,
              configurable: true
            });
            Object.defineProperty(FullTextDocument2.prototype, "version", {
              get: function() {
                return this._version;
              },
              enumerable: false,
              configurable: true
            });
            FullTextDocument2.prototype.getText = function(range) {
              if (range) {
                var start = this.offsetAt(range.start);
                var end = this.offsetAt(range.end);
                return this._content.substring(start, end);
              }
              return this._content;
            };
            FullTextDocument2.prototype.update = function(changes, version2) {
              for (var _i = 0, changes_1 = changes; _i < changes_1.length; _i++) {
                var change = changes_1[_i];
                if (FullTextDocument2.isIncremental(change)) {
                  var range = getWellformedRange(change.range);
                  var startOffset = this.offsetAt(range.start);
                  var endOffset = this.offsetAt(range.end);
                  this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
                  var startLine = Math.max(range.start.line, 0);
                  var endLine = Math.max(range.end.line, 0);
                  var lineOffsets = this._lineOffsets;
                  var addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
                  if (endLine - startLine === addedLineOffsets.length) {
                    for (var i = 0, len = addedLineOffsets.length; i < len; i++) {
                      lineOffsets[i + startLine + 1] = addedLineOffsets[i];
                    }
                  } else {
                    if (addedLineOffsets.length < 1e4) {
                      lineOffsets.splice.apply(lineOffsets, __spreadArray([startLine + 1, endLine - startLine], addedLineOffsets, false));
                    } else {
                      this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
                    }
                  }
                  var diff = change.text.length - (endOffset - startOffset);
                  if (diff !== 0) {
                    for (var i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
                      lineOffsets[i] = lineOffsets[i] + diff;
                    }
                  }
                } else if (FullTextDocument2.isFull(change)) {
                  this._content = change.text;
                  this._lineOffsets = void 0;
                } else {
                  throw new Error("Unknown change event received");
                }
              }
              this._version = version2;
            };
            FullTextDocument2.prototype.getLineOffsets = function() {
              if (this._lineOffsets === void 0) {
                this._lineOffsets = computeLineOffsets(this._content, true);
              }
              return this._lineOffsets;
            };
            FullTextDocument2.prototype.positionAt = function(offset) {
              offset = Math.max(Math.min(offset, this._content.length), 0);
              var lineOffsets = this.getLineOffsets();
              var low = 0, high = lineOffsets.length;
              if (high === 0) {
                return { line: 0, character: offset };
              }
              while (low < high) {
                var mid = Math.floor((low + high) / 2);
                if (lineOffsets[mid] > offset) {
                  high = mid;
                } else {
                  low = mid + 1;
                }
              }
              var line = low - 1;
              return { line, character: offset - lineOffsets[line] };
            };
            FullTextDocument2.prototype.offsetAt = function(position) {
              var lineOffsets = this.getLineOffsets();
              if (position.line >= lineOffsets.length) {
                return this._content.length;
              } else if (position.line < 0) {
                return 0;
              }
              var lineOffset = lineOffsets[position.line];
              var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
              return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
            };
            Object.defineProperty(FullTextDocument2.prototype, "lineCount", {
              get: function() {
                return this.getLineOffsets().length;
              },
              enumerable: false,
              configurable: true
            });
            FullTextDocument2.isIncremental = function(event) {
              var candidate = event;
              return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
            };
            FullTextDocument2.isFull = function(event) {
              var candidate = event;
              return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
            };
            return FullTextDocument2;
          }()
        );
        var TextDocument;
        (function(TextDocument2) {
          function create(uri, languageId, version2, content) {
            return new FullTextDocument(uri, languageId, version2, content);
          }
          TextDocument2.create = create;
          function update(document2, changes, version2) {
            if (document2 instanceof FullTextDocument) {
              document2.update(changes, version2);
              return document2;
            } else {
              throw new Error("TextDocument.update: document must be created by TextDocument.create");
            }
          }
          TextDocument2.update = update;
          function applyEdits(document2, edits) {
            var text = document2.getText();
            var sortedEdits = mergeSort(edits.map(getWellformedEdit), function(a, b) {
              var diff = a.range.start.line - b.range.start.line;
              if (diff === 0) {
                return a.range.start.character - b.range.start.character;
              }
              return diff;
            });
            var lastModifiedOffset = 0;
            var spans = [];
            for (var _i = 0, sortedEdits_1 = sortedEdits; _i < sortedEdits_1.length; _i++) {
              var e = sortedEdits_1[_i];
              var startOffset = document2.offsetAt(e.range.start);
              if (startOffset < lastModifiedOffset) {
                throw new Error("Overlapping edit");
              } else if (startOffset > lastModifiedOffset) {
                spans.push(text.substring(lastModifiedOffset, startOffset));
              }
              if (e.newText.length) {
                spans.push(e.newText);
              }
              lastModifiedOffset = document2.offsetAt(e.range.end);
            }
            spans.push(text.substr(lastModifiedOffset));
            return spans.join("");
          }
          TextDocument2.applyEdits = applyEdits;
        })(TextDocument = exports3.TextDocument || (exports3.TextDocument = {}));
        function mergeSort(data, compare2) {
          if (data.length <= 1) {
            return data;
          }
          var p = data.length / 2 | 0;
          var left = data.slice(0, p);
          var right = data.slice(p);
          mergeSort(left, compare2);
          mergeSort(right, compare2);
          var leftIdx = 0;
          var rightIdx = 0;
          var i = 0;
          while (leftIdx < left.length && rightIdx < right.length) {
            var ret = compare2(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
              data[i++] = left[leftIdx++];
            } else {
              data[i++] = right[rightIdx++];
            }
          }
          while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
          }
          while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
          }
          return data;
        }
        function computeLineOffsets(text, isAtLineStart, textOffset) {
          if (textOffset === void 0) {
            textOffset = 0;
          }
          var result = isAtLineStart ? [textOffset] : [];
          for (var i = 0; i < text.length; i++) {
            var ch = text.charCodeAt(i);
            if (ch === 13 || ch === 10) {
              if (ch === 13 && i + 1 < text.length && text.charCodeAt(i + 1) === 10) {
                i++;
              }
              result.push(textOffset + i + 1);
            }
          }
          return result;
        }
        function getWellformedRange(range) {
          var start = range.start;
          var end = range.end;
          if (start.line > end.line || start.line === end.line && start.character > end.character) {
            return { start: end, end: start };
          }
          return range;
        }
        function getWellformedEdit(textEdit) {
          var range = getWellformedRange(textEdit.range);
          if (range !== textEdit.range) {
            return { newText: textEdit.newText, range };
          }
          return textEdit;
        }
      });
    }
  });

  // node_modules/langium/lib/syntax-tree.js
  var require_syntax_tree = __commonJS({
    "node_modules/langium/lib/syntax-tree.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.isRootCstNode = exports2.isLeafCstNode = exports2.isCompositeCstNode = exports2.AbstractAstReflection = exports2.isLinkingError = exports2.isAstNodeDescription = exports2.isReference = exports2.isAstNode = void 0;
      function isAstNode(obj) {
        return typeof obj === "object" && obj !== null && typeof obj.$type === "string";
      }
      exports2.isAstNode = isAstNode;
      function isReference(obj) {
        return typeof obj === "object" && obj !== null && typeof obj.$refText === "string";
      }
      exports2.isReference = isReference;
      function isAstNodeDescription(obj) {
        return typeof obj === "object" && obj !== null && typeof obj.name === "string" && typeof obj.type === "string" && typeof obj.path === "string";
      }
      exports2.isAstNodeDescription = isAstNodeDescription;
      function isLinkingError(obj) {
        return typeof obj === "object" && obj !== null && isAstNode(obj.container) && isReference(obj.reference) && typeof obj.message === "string";
      }
      exports2.isLinkingError = isLinkingError;
      var AbstractAstReflection = class {
        constructor() {
          this.subtypes = {};
          this.allSubtypes = {};
        }
        isInstance(node, type) {
          return isAstNode(node) && this.isSubtype(node.$type, type);
        }
        isSubtype(subtype, supertype) {
          if (subtype === supertype) {
            return true;
          }
          let nested = this.subtypes[subtype];
          if (!nested) {
            nested = this.subtypes[subtype] = {};
          }
          const existing = nested[supertype];
          if (existing !== void 0) {
            return existing;
          } else {
            const result = this.computeIsSubtype(subtype, supertype);
            nested[supertype] = result;
            return result;
          }
        }
        getAllSubTypes(type) {
          const existing = this.allSubtypes[type];
          if (existing) {
            return existing;
          } else {
            const allTypes = this.getAllTypes();
            const types = [];
            for (const possibleSubType of allTypes) {
              if (this.isSubtype(possibleSubType, type)) {
                types.push(possibleSubType);
              }
            }
            this.allSubtypes[type] = types;
            return types;
          }
        }
      };
      exports2.AbstractAstReflection = AbstractAstReflection;
      function isCompositeCstNode(node) {
        return typeof node === "object" && node !== null && "children" in node;
      }
      exports2.isCompositeCstNode = isCompositeCstNode;
      function isLeafCstNode(node) {
        return typeof node === "object" && node !== null && "tokenType" in node;
      }
      exports2.isLeafCstNode = isLeafCstNode;
      function isRootCstNode(node) {
        return isCompositeCstNode(node) && "fullText" in node;
      }
      exports2.isRootCstNode = isRootCstNode;
    }
  });

  // node_modules/langium/lib/utils/stream.js
  var require_stream = __commonJS({
    "node_modules/langium/lib/utils/stream.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Reduction = exports2.TreeStreamImpl = exports2.stream = exports2.DONE_RESULT = exports2.EMPTY_STREAM = exports2.StreamImpl = void 0;
      var StreamImpl = class {
        constructor(startFn, nextFn) {
          this.startFn = startFn;
          this.nextFn = nextFn;
        }
        iterator() {
          const iterator = {
            state: this.startFn(),
            next: () => this.nextFn(iterator.state),
            [Symbol.iterator]: () => iterator
          };
          return iterator;
        }
        [Symbol.iterator]() {
          return this.iterator();
        }
        isEmpty() {
          const iterator = this.iterator();
          return Boolean(iterator.next().done);
        }
        count() {
          const iterator = this.iterator();
          let count = 0;
          let next = iterator.next();
          while (!next.done) {
            count++;
            next = iterator.next();
          }
          return count;
        }
        toArray() {
          const result = [];
          const iterator = this.iterator();
          let next;
          do {
            next = iterator.next();
            if (next.value !== void 0) {
              result.push(next.value);
            }
          } while (!next.done);
          return result;
        }
        toSet() {
          return new Set(this);
        }
        toMap(keyFn, valueFn) {
          const entryStream = this.map((element) => [
            keyFn ? keyFn(element) : element,
            valueFn ? valueFn(element) : element
          ]);
          return new Map(entryStream);
        }
        toString() {
          return this.join();
        }
        concat(other) {
          const iterator = other[Symbol.iterator]();
          return new StreamImpl(() => ({ first: this.startFn(), firstDone: false }), (state) => {
            let result;
            if (!state.firstDone) {
              do {
                result = this.nextFn(state.first);
                if (!result.done) {
                  return result;
                }
              } while (!result.done);
              state.firstDone = true;
            }
            do {
              result = iterator.next();
              if (!result.done) {
                return result;
              }
            } while (!result.done);
            return exports2.DONE_RESULT;
          });
        }
        join(separator = ",") {
          const iterator = this.iterator();
          let value = "";
          let result;
          let addSeparator = false;
          do {
            result = iterator.next();
            if (!result.done) {
              if (addSeparator) {
                value += separator;
              }
              value += toString(result.value);
            }
            addSeparator = true;
          } while (!result.done);
          return value;
        }
        indexOf(searchElement, fromIndex = 0) {
          const iterator = this.iterator();
          let index = 0;
          let next = iterator.next();
          while (!next.done) {
            if (index >= fromIndex && next.value === searchElement) {
              return index;
            }
            next = iterator.next();
            index++;
          }
          return -1;
        }
        every(predicate) {
          const iterator = this.iterator();
          let next = iterator.next();
          while (!next.done) {
            if (!predicate(next.value)) {
              return false;
            }
            next = iterator.next();
          }
          return true;
        }
        some(predicate) {
          const iterator = this.iterator();
          let next = iterator.next();
          while (!next.done) {
            if (predicate(next.value)) {
              return true;
            }
            next = iterator.next();
          }
          return false;
        }
        forEach(callbackfn) {
          const iterator = this.iterator();
          let index = 0;
          let next = iterator.next();
          while (!next.done) {
            callbackfn(next.value, index);
            next = iterator.next();
            index++;
          }
        }
        map(callbackfn) {
          return new StreamImpl(this.startFn, (state) => {
            const { done, value } = this.nextFn(state);
            if (done) {
              return exports2.DONE_RESULT;
            } else {
              return { done: false, value: callbackfn(value) };
            }
          });
        }
        filter(predicate) {
          return new StreamImpl(this.startFn, (state) => {
            let result;
            do {
              result = this.nextFn(state);
              if (!result.done && predicate(result.value)) {
                return result;
              }
            } while (!result.done);
            return exports2.DONE_RESULT;
          });
        }
        nonNullable() {
          return this.filter((e) => e !== void 0 && e !== null);
        }
        reduce(callbackfn, initialValue) {
          const iterator = this.iterator();
          let previousValue = initialValue;
          let next = iterator.next();
          while (!next.done) {
            if (previousValue === void 0) {
              previousValue = next.value;
            } else {
              previousValue = callbackfn(previousValue, next.value);
            }
            next = iterator.next();
          }
          return previousValue;
        }
        reduceRight(callbackfn, initialValue) {
          return this.recursiveReduce(this.iterator(), callbackfn, initialValue);
        }
        recursiveReduce(iterator, callbackfn, initialValue) {
          const next = iterator.next();
          if (next.done) {
            return initialValue;
          }
          const previousValue = this.recursiveReduce(iterator, callbackfn, initialValue);
          if (previousValue === void 0) {
            return next.value;
          }
          return callbackfn(previousValue, next.value);
        }
        find(predicate) {
          const iterator = this.iterator();
          let next = iterator.next();
          while (!next.done) {
            if (predicate(next.value)) {
              return next.value;
            }
            next = iterator.next();
          }
          return void 0;
        }
        findIndex(predicate) {
          const iterator = this.iterator();
          let index = 0;
          let next = iterator.next();
          while (!next.done) {
            if (predicate(next.value)) {
              return index;
            }
            next = iterator.next();
            index++;
          }
          return -1;
        }
        includes(searchElement) {
          const iterator = this.iterator();
          let next = iterator.next();
          while (!next.done) {
            if (next.value === searchElement) {
              return true;
            }
            next = iterator.next();
          }
          return false;
        }
        flatMap(callbackfn) {
          return new StreamImpl(() => ({ this: this.startFn() }), (state) => {
            do {
              if (state.iterator) {
                const next = state.iterator.next();
                if (next.done) {
                  state.iterator = void 0;
                } else {
                  return next;
                }
              }
              const { done, value } = this.nextFn(state.this);
              if (!done) {
                const mapped = callbackfn(value);
                if (isIterable(mapped)) {
                  state.iterator = mapped[Symbol.iterator]();
                } else {
                  return { done: false, value: mapped };
                }
              }
            } while (state.iterator);
            return exports2.DONE_RESULT;
          });
        }
        flat(depth) {
          if (depth === void 0) {
            depth = 1;
          }
          if (depth <= 0) {
            return this;
          }
          const stream2 = depth > 1 ? this.flat(depth - 1) : this;
          return new StreamImpl(() => ({ this: stream2.startFn() }), (state) => {
            do {
              if (state.iterator) {
                const next = state.iterator.next();
                if (next.done) {
                  state.iterator = void 0;
                } else {
                  return next;
                }
              }
              const { done, value } = stream2.nextFn(state.this);
              if (!done) {
                if (isIterable(value)) {
                  state.iterator = value[Symbol.iterator]();
                } else {
                  return { done: false, value };
                }
              }
            } while (state.iterator);
            return exports2.DONE_RESULT;
          });
        }
        head() {
          const iterator = this.iterator();
          const result = iterator.next();
          if (result.done) {
            return void 0;
          }
          return result.value;
        }
        tail(skipCount = 1) {
          return new StreamImpl(() => {
            const state = this.startFn();
            for (let i = 0; i < skipCount; i++) {
              const next = this.nextFn(state);
              if (next.done) {
                return state;
              }
            }
            return state;
          }, this.nextFn);
        }
        limit(maxSize) {
          return new StreamImpl(() => ({ size: 0, state: this.startFn() }), (state) => {
            state.size++;
            if (state.size > maxSize) {
              return exports2.DONE_RESULT;
            }
            return this.nextFn(state.state);
          });
        }
        distinct(by) {
          const set = /* @__PURE__ */ new Set();
          return this.filter((e) => {
            const value = by ? by(e) : e;
            if (set.has(value)) {
              return false;
            } else {
              set.add(value);
              return true;
            }
          });
        }
        exclude(other, key) {
          const otherKeySet = /* @__PURE__ */ new Set();
          for (const item of other) {
            const value = key ? key(item) : item;
            otherKeySet.add(value);
          }
          return this.filter((e) => {
            const ownKey = key ? key(e) : e;
            return !otherKeySet.has(ownKey);
          });
        }
      };
      exports2.StreamImpl = StreamImpl;
      function toString(item) {
        if (typeof item === "string") {
          return item;
        }
        if (typeof item === "undefined") {
          return "undefined";
        }
        if (typeof item.toString === "function") {
          return item.toString();
        }
        return Object.prototype.toString.call(item);
      }
      function isIterable(obj) {
        return !!obj && typeof obj[Symbol.iterator] === "function";
      }
      exports2.EMPTY_STREAM = new StreamImpl(() => void 0, () => exports2.DONE_RESULT);
      exports2.DONE_RESULT = Object.freeze({ done: true, value: void 0 });
      function stream(...collections) {
        if (collections.length === 1) {
          const collection = collections[0];
          if (collection instanceof StreamImpl) {
            return collection;
          }
          if (isIterable(collection)) {
            return new StreamImpl(() => collection[Symbol.iterator](), (iterator) => iterator.next());
          }
          if (typeof collection.length === "number") {
            return new StreamImpl(() => ({ index: 0 }), (state) => {
              if (state.index < collection.length) {
                return { done: false, value: collection[state.index++] };
              } else {
                return exports2.DONE_RESULT;
              }
            });
          }
        }
        if (collections.length > 1) {
          return new StreamImpl(() => ({ collIndex: 0, arrIndex: 0 }), (state) => {
            do {
              if (state.iterator) {
                const next = state.iterator.next();
                if (!next.done) {
                  return next;
                }
                state.iterator = void 0;
              }
              if (state.array) {
                if (state.arrIndex < state.array.length) {
                  return { done: false, value: state.array[state.arrIndex++] };
                }
                state.array = void 0;
                state.arrIndex = 0;
              }
              if (state.collIndex < collections.length) {
                const collection = collections[state.collIndex++];
                if (isIterable(collection)) {
                  state.iterator = collection[Symbol.iterator]();
                } else if (collection && typeof collection.length === "number") {
                  state.array = collection;
                }
              }
            } while (state.iterator || state.array || state.collIndex < collections.length);
            return exports2.DONE_RESULT;
          });
        }
        return exports2.EMPTY_STREAM;
      }
      exports2.stream = stream;
      var TreeStreamImpl = class extends StreamImpl {
        constructor(root, children, options) {
          super(() => ({
            iterators: (options === null || options === void 0 ? void 0 : options.includeRoot) ? [[root][Symbol.iterator]()] : [children(root)[Symbol.iterator]()],
            pruned: false
          }), (state) => {
            if (state.pruned) {
              state.iterators.pop();
              state.pruned = false;
            }
            while (state.iterators.length > 0) {
              const iterator = state.iterators[state.iterators.length - 1];
              const next = iterator.next();
              if (next.done) {
                state.iterators.pop();
              } else {
                state.iterators.push(children(next.value)[Symbol.iterator]());
                return next;
              }
            }
            return exports2.DONE_RESULT;
          });
        }
        iterator() {
          const iterator = {
            state: this.startFn(),
            next: () => this.nextFn(iterator.state),
            prune: () => {
              iterator.state.pruned = true;
            },
            [Symbol.iterator]: () => iterator
          };
          return iterator;
        }
      };
      exports2.TreeStreamImpl = TreeStreamImpl;
      var Reduction;
      (function(Reduction2) {
        function sum(stream2) {
          return stream2.reduce((a, b) => a + b, 0);
        }
        Reduction2.sum = sum;
        function product(stream2) {
          return stream2.reduce((a, b) => a * b, 0);
        }
        Reduction2.product = product;
        function min(stream2) {
          return stream2.reduce((a, b) => Math.min(a, b));
        }
        Reduction2.min = min;
        function max(stream2) {
          return stream2.reduce((a, b) => Math.max(a, b));
        }
        Reduction2.max = max;
      })(Reduction = exports2.Reduction || (exports2.Reduction = {}));
    }
  });

  // node_modules/langium/lib/utils/cst-util.js
  var require_cst_util = __commonJS({
    "node_modules/langium/lib/utils/cst-util.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getInteriorNodes = exports2.getStartlineNode = exports2.getNextNode = exports2.getPreviousNode = exports2.findLeafNodeAtOffset = exports2.isCommentNode = exports2.findCommentNode = exports2.findDeclarationNodeAtOffset = exports2.DefaultNameRegexp = exports2.inRange = exports2.compareRange = exports2.RangeComparison = exports2.toDocumentSegment = exports2.tokenToRange = exports2.isCstChildNode = exports2.flattenCst = exports2.streamCst = void 0;
      var syntax_tree_1 = require_syntax_tree();
      var stream_1 = require_stream();
      function streamCst(node) {
        return new stream_1.TreeStreamImpl(node, (element) => {
          if ((0, syntax_tree_1.isCompositeCstNode)(element)) {
            return element.children;
          } else {
            return [];
          }
        }, { includeRoot: true });
      }
      exports2.streamCst = streamCst;
      function flattenCst(node) {
        return streamCst(node).filter(syntax_tree_1.isLeafCstNode);
      }
      exports2.flattenCst = flattenCst;
      function isCstChildNode(child, parent) {
        while (child.parent) {
          child = child.parent;
          if (child === parent) {
            return true;
          }
        }
        return false;
      }
      exports2.isCstChildNode = isCstChildNode;
      function tokenToRange(token) {
        return {
          start: {
            character: token.startColumn - 1,
            line: token.startLine - 1
          },
          end: {
            character: token.endColumn,
            line: token.endLine - 1
          }
        };
      }
      exports2.tokenToRange = tokenToRange;
      function toDocumentSegment(node) {
        if (!node) {
          return void 0;
        }
        const { offset, end, range } = node;
        return {
          range,
          offset,
          end,
          length: end - offset
        };
      }
      exports2.toDocumentSegment = toDocumentSegment;
      var RangeComparison;
      (function(RangeComparison2) {
        RangeComparison2[RangeComparison2["Before"] = 0] = "Before";
        RangeComparison2[RangeComparison2["After"] = 1] = "After";
        RangeComparison2[RangeComparison2["OverlapFront"] = 2] = "OverlapFront";
        RangeComparison2[RangeComparison2["OverlapBack"] = 3] = "OverlapBack";
        RangeComparison2[RangeComparison2["Inside"] = 4] = "Inside";
      })(RangeComparison = exports2.RangeComparison || (exports2.RangeComparison = {}));
      function compareRange(range, to) {
        if (range.end.line < to.start.line || range.end.line === to.start.line && range.end.character < range.start.character) {
          return RangeComparison.Before;
        } else if (range.start.line > to.end.line || range.start.line === to.end.line && range.start.character > to.end.character) {
          return RangeComparison.After;
        }
        const startInside = range.start.line > to.start.line || range.start.line === to.start.line && range.start.character >= to.start.character;
        const endInside = range.end.line < to.end.line || range.end.line === to.end.line && range.end.character <= to.end.character;
        if (startInside && endInside) {
          return RangeComparison.Inside;
        } else if (startInside) {
          return RangeComparison.OverlapBack;
        } else {
          return RangeComparison.OverlapFront;
        }
      }
      exports2.compareRange = compareRange;
      function inRange(range, to) {
        const comparison = compareRange(range, to);
        return comparison > RangeComparison.After;
      }
      exports2.inRange = inRange;
      exports2.DefaultNameRegexp = /^[\w\p{L}]$/u;
      function findDeclarationNodeAtOffset(cstNode, offset, nameRegexp = exports2.DefaultNameRegexp) {
        if (cstNode) {
          if (offset > 0) {
            const localOffset = offset - cstNode.offset;
            const textAtOffset = cstNode.text.charAt(localOffset);
            if (!nameRegexp.test(textAtOffset)) {
              offset--;
            }
          }
          return findLeafNodeAtOffset(cstNode, offset);
        }
        return void 0;
      }
      exports2.findDeclarationNodeAtOffset = findDeclarationNodeAtOffset;
      function findCommentNode(cstNode, commentNames) {
        if (cstNode) {
          const previous = getPreviousNode(cstNode, true);
          if (previous && isCommentNode(previous, commentNames)) {
            return previous;
          }
          if ((0, syntax_tree_1.isRootCstNode)(cstNode)) {
            const endIndex = cstNode.children.findIndex((e) => !e.hidden);
            for (let i = endIndex - 1; i >= 0; i--) {
              const child = cstNode.children[i];
              if (isCommentNode(child, commentNames)) {
                return child;
              }
            }
          }
        }
        return void 0;
      }
      exports2.findCommentNode = findCommentNode;
      function isCommentNode(cstNode, commentNames) {
        return (0, syntax_tree_1.isLeafCstNode)(cstNode) && commentNames.includes(cstNode.tokenType.name);
      }
      exports2.isCommentNode = isCommentNode;
      function findLeafNodeAtOffset(node, offset) {
        if ((0, syntax_tree_1.isLeafCstNode)(node)) {
          return node;
        } else if ((0, syntax_tree_1.isCompositeCstNode)(node)) {
          let firstChild = 0;
          let lastChild = node.children.length - 1;
          while (firstChild < lastChild) {
            const middleChild = Math.floor((firstChild + lastChild) / 2);
            const n = node.children[middleChild];
            if (n.offset > offset) {
              lastChild = middleChild - 1;
            } else if (n.end <= offset) {
              firstChild = middleChild + 1;
            } else {
              return findLeafNodeAtOffset(n, offset);
            }
          }
          if (firstChild === lastChild) {
            return findLeafNodeAtOffset(node.children[firstChild], offset);
          }
        }
        return void 0;
      }
      exports2.findLeafNodeAtOffset = findLeafNodeAtOffset;
      function getPreviousNode(node, hidden = true) {
        while (node.parent) {
          const parent = node.parent;
          let index = parent.children.indexOf(node);
          while (index > 0) {
            index--;
            const previous = parent.children[index];
            if (hidden || !previous.hidden) {
              return previous;
            }
          }
          node = parent;
        }
        return void 0;
      }
      exports2.getPreviousNode = getPreviousNode;
      function getNextNode(node, hidden = true) {
        while (node.parent) {
          const parent = node.parent;
          let index = parent.children.indexOf(node);
          const last = parent.children.length - 1;
          while (index < last) {
            index++;
            const next = parent.children[index];
            if (hidden || !next.hidden) {
              return next;
            }
          }
          node = parent;
        }
        return void 0;
      }
      exports2.getNextNode = getNextNode;
      function getStartlineNode(node) {
        if (node.range.start.character === 0) {
          return node;
        }
        const line = node.range.start.line;
        let last = node;
        let index;
        while (node.parent) {
          const parent = node.parent;
          const selfIndex = index !== null && index !== void 0 ? index : parent.children.indexOf(node);
          if (selfIndex === 0) {
            node = parent;
            index = void 0;
          } else {
            index = selfIndex - 1;
            node = parent.children[index];
          }
          if (node.range.start.line !== line) {
            break;
          }
          last = node;
        }
        return last;
      }
      exports2.getStartlineNode = getStartlineNode;
      function getInteriorNodes(start, end) {
        const commonParent = getCommonParent(start, end);
        if (!commonParent) {
          return [];
        }
        return commonParent.parent.children.slice(commonParent.a + 1, commonParent.b);
      }
      exports2.getInteriorNodes = getInteriorNodes;
      function getCommonParent(a, b) {
        const aParents = getParentChain(a);
        const bParents = getParentChain(b);
        let current;
        for (let i = 0; i < aParents.length && i < bParents.length; i++) {
          const aParent = aParents[i];
          const bParent = bParents[i];
          if (aParent.parent === bParent.parent) {
            current = {
              parent: aParent.parent,
              a: aParent.index,
              b: bParent.index
            };
          } else {
            break;
          }
        }
        return current;
      }
      function getParentChain(node) {
        const chain = [];
        while (node.parent) {
          const parent = node.parent;
          const index = parent.children.indexOf(node);
          chain.push({
            parent,
            index
          });
          node = parent;
        }
        return chain.reverse();
      }
    }
  });

  // node_modules/vscode-uri/lib/umd/index.js
  var require_umd = __commonJS({
    "node_modules/vscode-uri/lib/umd/index.js"(exports2, module2) {
      !function(t, e) {
        if ("object" == typeof exports2 && "object" == typeof module2)
          module2.exports = e();
        else if ("function" == typeof define && define.amd)
          define([], e);
        else {
          var r = e();
          for (var n in r)
            ("object" == typeof exports2 ? exports2 : t)[n] = r[n];
        }
      }(exports2, () => (() => {
        "use strict";
        var t = { 470: (t2) => {
          function e2(t3) {
            if ("string" != typeof t3)
              throw new TypeError("Path must be a string. Received " + JSON.stringify(t3));
          }
          function r2(t3, e3) {
            for (var r3, n3 = "", o = 0, i = -1, a = 0, s = 0; s <= t3.length; ++s) {
              if (s < t3.length)
                r3 = t3.charCodeAt(s);
              else {
                if (47 === r3)
                  break;
                r3 = 47;
              }
              if (47 === r3) {
                if (i === s - 1 || 1 === a)
                  ;
                else if (i !== s - 1 && 2 === a) {
                  if (n3.length < 2 || 2 !== o || 46 !== n3.charCodeAt(n3.length - 1) || 46 !== n3.charCodeAt(n3.length - 2)) {
                    if (n3.length > 2) {
                      var h = n3.lastIndexOf("/");
                      if (h !== n3.length - 1) {
                        -1 === h ? (n3 = "", o = 0) : o = (n3 = n3.slice(0, h)).length - 1 - n3.lastIndexOf("/"), i = s, a = 0;
                        continue;
                      }
                    } else if (2 === n3.length || 1 === n3.length) {
                      n3 = "", o = 0, i = s, a = 0;
                      continue;
                    }
                  }
                  e3 && (n3.length > 0 ? n3 += "/.." : n3 = "..", o = 2);
                } else
                  n3.length > 0 ? n3 += "/" + t3.slice(i + 1, s) : n3 = t3.slice(i + 1, s), o = s - i - 1;
                i = s, a = 0;
              } else
                46 === r3 && -1 !== a ? ++a : a = -1;
            }
            return n3;
          }
          var n2 = { resolve: function() {
            for (var t3, n3 = "", o = false, i = arguments.length - 1; i >= -1 && !o; i--) {
              var a;
              i >= 0 ? a = arguments[i] : (void 0 === t3 && (t3 = process.cwd()), a = t3), e2(a), 0 !== a.length && (n3 = a + "/" + n3, o = 47 === a.charCodeAt(0));
            }
            return n3 = r2(n3, !o), o ? n3.length > 0 ? "/" + n3 : "/" : n3.length > 0 ? n3 : ".";
          }, normalize: function(t3) {
            if (e2(t3), 0 === t3.length)
              return ".";
            var n3 = 47 === t3.charCodeAt(0), o = 47 === t3.charCodeAt(t3.length - 1);
            return 0 !== (t3 = r2(t3, !n3)).length || n3 || (t3 = "."), t3.length > 0 && o && (t3 += "/"), n3 ? "/" + t3 : t3;
          }, isAbsolute: function(t3) {
            return e2(t3), t3.length > 0 && 47 === t3.charCodeAt(0);
          }, join: function() {
            if (0 === arguments.length)
              return ".";
            for (var t3, r3 = 0; r3 < arguments.length; ++r3) {
              var o = arguments[r3];
              e2(o), o.length > 0 && (void 0 === t3 ? t3 = o : t3 += "/" + o);
            }
            return void 0 === t3 ? "." : n2.normalize(t3);
          }, relative: function(t3, r3) {
            if (e2(t3), e2(r3), t3 === r3)
              return "";
            if ((t3 = n2.resolve(t3)) === (r3 = n2.resolve(r3)))
              return "";
            for (var o = 1; o < t3.length && 47 === t3.charCodeAt(o); ++o)
              ;
            for (var i = t3.length, a = i - o, s = 1; s < r3.length && 47 === r3.charCodeAt(s); ++s)
              ;
            for (var h = r3.length - s, c = a < h ? a : h, f = -1, u = 0; u <= c; ++u) {
              if (u === c) {
                if (h > c) {
                  if (47 === r3.charCodeAt(s + u))
                    return r3.slice(s + u + 1);
                  if (0 === u)
                    return r3.slice(s + u);
                } else
                  a > c && (47 === t3.charCodeAt(o + u) ? f = u : 0 === u && (f = 0));
                break;
              }
              var l = t3.charCodeAt(o + u);
              if (l !== r3.charCodeAt(s + u))
                break;
              47 === l && (f = u);
            }
            var p = "";
            for (u = o + f + 1; u <= i; ++u)
              u !== i && 47 !== t3.charCodeAt(u) || (0 === p.length ? p += ".." : p += "/..");
            return p.length > 0 ? p + r3.slice(s + f) : (s += f, 47 === r3.charCodeAt(s) && ++s, r3.slice(s));
          }, _makeLong: function(t3) {
            return t3;
          }, dirname: function(t3) {
            if (e2(t3), 0 === t3.length)
              return ".";
            for (var r3 = t3.charCodeAt(0), n3 = 47 === r3, o = -1, i = true, a = t3.length - 1; a >= 1; --a)
              if (47 === (r3 = t3.charCodeAt(a))) {
                if (!i) {
                  o = a;
                  break;
                }
              } else
                i = false;
            return -1 === o ? n3 ? "/" : "." : n3 && 1 === o ? "//" : t3.slice(0, o);
          }, basename: function(t3, r3) {
            if (void 0 !== r3 && "string" != typeof r3)
              throw new TypeError('"ext" argument must be a string');
            e2(t3);
            var n3, o = 0, i = -1, a = true;
            if (void 0 !== r3 && r3.length > 0 && r3.length <= t3.length) {
              if (r3.length === t3.length && r3 === t3)
                return "";
              var s = r3.length - 1, h = -1;
              for (n3 = t3.length - 1; n3 >= 0; --n3) {
                var c = t3.charCodeAt(n3);
                if (47 === c) {
                  if (!a) {
                    o = n3 + 1;
                    break;
                  }
                } else
                  -1 === h && (a = false, h = n3 + 1), s >= 0 && (c === r3.charCodeAt(s) ? -1 == --s && (i = n3) : (s = -1, i = h));
              }
              return o === i ? i = h : -1 === i && (i = t3.length), t3.slice(o, i);
            }
            for (n3 = t3.length - 1; n3 >= 0; --n3)
              if (47 === t3.charCodeAt(n3)) {
                if (!a) {
                  o = n3 + 1;
                  break;
                }
              } else
                -1 === i && (a = false, i = n3 + 1);
            return -1 === i ? "" : t3.slice(o, i);
          }, extname: function(t3) {
            e2(t3);
            for (var r3 = -1, n3 = 0, o = -1, i = true, a = 0, s = t3.length - 1; s >= 0; --s) {
              var h = t3.charCodeAt(s);
              if (47 !== h)
                -1 === o && (i = false, o = s + 1), 46 === h ? -1 === r3 ? r3 = s : 1 !== a && (a = 1) : -1 !== r3 && (a = -1);
              else if (!i) {
                n3 = s + 1;
                break;
              }
            }
            return -1 === r3 || -1 === o || 0 === a || 1 === a && r3 === o - 1 && r3 === n3 + 1 ? "" : t3.slice(r3, o);
          }, format: function(t3) {
            if (null === t3 || "object" != typeof t3)
              throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t3);
            return function(t4, e3) {
              var r3 = e3.dir || e3.root, n3 = e3.base || (e3.name || "") + (e3.ext || "");
              return r3 ? r3 === e3.root ? r3 + n3 : r3 + "/" + n3 : n3;
            }(0, t3);
          }, parse: function(t3) {
            e2(t3);
            var r3 = { root: "", dir: "", base: "", ext: "", name: "" };
            if (0 === t3.length)
              return r3;
            var n3, o = t3.charCodeAt(0), i = 47 === o;
            i ? (r3.root = "/", n3 = 1) : n3 = 0;
            for (var a = -1, s = 0, h = -1, c = true, f = t3.length - 1, u = 0; f >= n3; --f)
              if (47 !== (o = t3.charCodeAt(f)))
                -1 === h && (c = false, h = f + 1), 46 === o ? -1 === a ? a = f : 1 !== u && (u = 1) : -1 !== a && (u = -1);
              else if (!c) {
                s = f + 1;
                break;
              }
            return -1 === a || -1 === h || 0 === u || 1 === u && a === h - 1 && a === s + 1 ? -1 !== h && (r3.base = r3.name = 0 === s && i ? t3.slice(1, h) : t3.slice(s, h)) : (0 === s && i ? (r3.name = t3.slice(1, a), r3.base = t3.slice(1, h)) : (r3.name = t3.slice(s, a), r3.base = t3.slice(s, h)), r3.ext = t3.slice(a, h)), s > 0 ? r3.dir = t3.slice(0, s - 1) : i && (r3.dir = "/"), r3;
          }, sep: "/", delimiter: ":", win32: null, posix: null };
          n2.posix = n2, t2.exports = n2;
        }, 674: (t2, e2) => {
          if (Object.defineProperty(e2, "__esModule", { value: true }), e2.isWindows = void 0, "object" == typeof process)
            e2.isWindows = "win32" === process.platform;
          else if ("object" == typeof navigator) {
            var r2 = navigator.userAgent;
            e2.isWindows = r2.indexOf("Windows") >= 0;
          }
        }, 796: function(t2, e2, r2) {
          var n2, o, i = this && this.__extends || (n2 = function(t3, e3) {
            return n2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e4) {
              t4.__proto__ = e4;
            } || function(t4, e4) {
              for (var r3 in e4)
                Object.prototype.hasOwnProperty.call(e4, r3) && (t4[r3] = e4[r3]);
            }, n2(t3, e3);
          }, function(t3, e3) {
            if ("function" != typeof e3 && null !== e3)
              throw new TypeError("Class extends value " + String(e3) + " is not a constructor or null");
            function r3() {
              this.constructor = t3;
            }
            n2(t3, e3), t3.prototype = null === e3 ? Object.create(e3) : (r3.prototype = e3.prototype, new r3());
          });
          Object.defineProperty(e2, "__esModule", { value: true }), e2.uriToFsPath = e2.URI = void 0;
          var a = r2(674), s = /^\w[\w\d+.-]*$/, h = /^\//, c = /^\/\//;
          function f(t3, e3) {
            if (!t3.scheme && e3)
              throw new Error('[UriError]: Scheme is missing: {scheme: "", authority: "'.concat(t3.authority, '", path: "').concat(t3.path, '", query: "').concat(t3.query, '", fragment: "').concat(t3.fragment, '"}'));
            if (t3.scheme && !s.test(t3.scheme))
              throw new Error("[UriError]: Scheme contains illegal characters.");
            if (t3.path) {
              if (t3.authority) {
                if (!h.test(t3.path))
                  throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
              } else if (c.test(t3.path))
                throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
            }
          }
          var u = "", l = "/", p = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/, d = function() {
            function t3(t4, e3, r3, n3, o2, i2) {
              void 0 === i2 && (i2 = false), "object" == typeof t4 ? (this.scheme = t4.scheme || u, this.authority = t4.authority || u, this.path = t4.path || u, this.query = t4.query || u, this.fragment = t4.fragment || u) : (this.scheme = function(t5, e4) {
                return t5 || e4 ? t5 : "file";
              }(t4, i2), this.authority = e3 || u, this.path = function(t5, e4) {
                switch (t5) {
                  case "https":
                  case "http":
                  case "file":
                    e4 ? e4[0] !== l && (e4 = l + e4) : e4 = l;
                }
                return e4;
              }(this.scheme, r3 || u), this.query = n3 || u, this.fragment = o2 || u, f(this, i2));
            }
            return t3.isUri = function(e3) {
              return e3 instanceof t3 || !!e3 && "string" == typeof e3.authority && "string" == typeof e3.fragment && "string" == typeof e3.path && "string" == typeof e3.query && "string" == typeof e3.scheme && "string" == typeof e3.fsPath && "function" == typeof e3.with && "function" == typeof e3.toString;
            }, Object.defineProperty(t3.prototype, "fsPath", { get: function() {
              return C(this, false);
            }, enumerable: false, configurable: true }), t3.prototype.with = function(t4) {
              if (!t4)
                return this;
              var e3 = t4.scheme, r3 = t4.authority, n3 = t4.path, o2 = t4.query, i2 = t4.fragment;
              return void 0 === e3 ? e3 = this.scheme : null === e3 && (e3 = u), void 0 === r3 ? r3 = this.authority : null === r3 && (r3 = u), void 0 === n3 ? n3 = this.path : null === n3 && (n3 = u), void 0 === o2 ? o2 = this.query : null === o2 && (o2 = u), void 0 === i2 ? i2 = this.fragment : null === i2 && (i2 = u), e3 === this.scheme && r3 === this.authority && n3 === this.path && o2 === this.query && i2 === this.fragment ? this : new v(e3, r3, n3, o2, i2);
            }, t3.parse = function(t4, e3) {
              void 0 === e3 && (e3 = false);
              var r3 = p.exec(t4);
              return r3 ? new v(r3[2] || u, x(r3[4] || u), x(r3[5] || u), x(r3[7] || u), x(r3[9] || u), e3) : new v(u, u, u, u, u);
            }, t3.file = function(t4) {
              var e3 = u;
              if (a.isWindows && (t4 = t4.replace(/\\/g, l)), t4[0] === l && t4[1] === l) {
                var r3 = t4.indexOf(l, 2);
                -1 === r3 ? (e3 = t4.substring(2), t4 = l) : (e3 = t4.substring(2, r3), t4 = t4.substring(r3) || l);
              }
              return new v("file", e3, t4, u, u);
            }, t3.from = function(t4) {
              var e3 = new v(t4.scheme, t4.authority, t4.path, t4.query, t4.fragment);
              return f(e3, true), e3;
            }, t3.prototype.toString = function(t4) {
              return void 0 === t4 && (t4 = false), A(this, t4);
            }, t3.prototype.toJSON = function() {
              return this;
            }, t3.revive = function(e3) {
              if (e3) {
                if (e3 instanceof t3)
                  return e3;
                var r3 = new v(e3);
                return r3._formatted = e3.external, r3._fsPath = e3._sep === g ? e3.fsPath : null, r3;
              }
              return e3;
            }, t3;
          }();
          e2.URI = d;
          var g = a.isWindows ? 1 : void 0, v = function(t3) {
            function e3() {
              var e4 = null !== t3 && t3.apply(this, arguments) || this;
              return e4._formatted = null, e4._fsPath = null, e4;
            }
            return i(e3, t3), Object.defineProperty(e3.prototype, "fsPath", { get: function() {
              return this._fsPath || (this._fsPath = C(this, false)), this._fsPath;
            }, enumerable: false, configurable: true }), e3.prototype.toString = function(t4) {
              return void 0 === t4 && (t4 = false), t4 ? A(this, true) : (this._formatted || (this._formatted = A(this, false)), this._formatted);
            }, e3.prototype.toJSON = function() {
              var t4 = { $mid: 1 };
              return this._fsPath && (t4.fsPath = this._fsPath, t4._sep = g), this._formatted && (t4.external = this._formatted), this.path && (t4.path = this.path), this.scheme && (t4.scheme = this.scheme), this.authority && (t4.authority = this.authority), this.query && (t4.query = this.query), this.fragment && (t4.fragment = this.fragment), t4;
            }, e3;
          }(d), y = ((o = {})[58] = "%3A", o[47] = "%2F", o[63] = "%3F", o[35] = "%23", o[91] = "%5B", o[93] = "%5D", o[64] = "%40", o[33] = "%21", o[36] = "%24", o[38] = "%26", o[39] = "%27", o[40] = "%28", o[41] = "%29", o[42] = "%2A", o[43] = "%2B", o[44] = "%2C", o[59] = "%3B", o[61] = "%3D", o[32] = "%20", o);
          function m(t3, e3, r3) {
            for (var n3 = void 0, o2 = -1, i2 = 0; i2 < t3.length; i2++) {
              var a2 = t3.charCodeAt(i2);
              if (a2 >= 97 && a2 <= 122 || a2 >= 65 && a2 <= 90 || a2 >= 48 && a2 <= 57 || 45 === a2 || 46 === a2 || 95 === a2 || 126 === a2 || e3 && 47 === a2 || r3 && 91 === a2 || r3 && 93 === a2 || r3 && 58 === a2)
                -1 !== o2 && (n3 += encodeURIComponent(t3.substring(o2, i2)), o2 = -1), void 0 !== n3 && (n3 += t3.charAt(i2));
              else {
                void 0 === n3 && (n3 = t3.substr(0, i2));
                var s2 = y[a2];
                void 0 !== s2 ? (-1 !== o2 && (n3 += encodeURIComponent(t3.substring(o2, i2)), o2 = -1), n3 += s2) : -1 === o2 && (o2 = i2);
              }
            }
            return -1 !== o2 && (n3 += encodeURIComponent(t3.substring(o2))), void 0 !== n3 ? n3 : t3;
          }
          function b(t3) {
            for (var e3 = void 0, r3 = 0; r3 < t3.length; r3++) {
              var n3 = t3.charCodeAt(r3);
              35 === n3 || 63 === n3 ? (void 0 === e3 && (e3 = t3.substr(0, r3)), e3 += y[n3]) : void 0 !== e3 && (e3 += t3[r3]);
            }
            return void 0 !== e3 ? e3 : t3;
          }
          function C(t3, e3) {
            var r3;
            return r3 = t3.authority && t3.path.length > 1 && "file" === t3.scheme ? "//".concat(t3.authority).concat(t3.path) : 47 === t3.path.charCodeAt(0) && (t3.path.charCodeAt(1) >= 65 && t3.path.charCodeAt(1) <= 90 || t3.path.charCodeAt(1) >= 97 && t3.path.charCodeAt(1) <= 122) && 58 === t3.path.charCodeAt(2) ? e3 ? t3.path.substr(1) : t3.path[1].toLowerCase() + t3.path.substr(2) : t3.path, a.isWindows && (r3 = r3.replace(/\//g, "\\")), r3;
          }
          function A(t3, e3) {
            var r3 = e3 ? b : m, n3 = "", o2 = t3.scheme, i2 = t3.authority, a2 = t3.path, s2 = t3.query, h2 = t3.fragment;
            if (o2 && (n3 += o2, n3 += ":"), (i2 || "file" === o2) && (n3 += l, n3 += l), i2) {
              var c2 = i2.indexOf("@");
              if (-1 !== c2) {
                var f2 = i2.substr(0, c2);
                i2 = i2.substr(c2 + 1), -1 === (c2 = f2.lastIndexOf(":")) ? n3 += r3(f2, false, false) : (n3 += r3(f2.substr(0, c2), false, false), n3 += ":", n3 += r3(f2.substr(c2 + 1), false, true)), n3 += "@";
              }
              -1 === (c2 = (i2 = i2.toLowerCase()).lastIndexOf(":")) ? n3 += r3(i2, false, true) : (n3 += r3(i2.substr(0, c2), false, true), n3 += i2.substr(c2));
            }
            if (a2) {
              if (a2.length >= 3 && 47 === a2.charCodeAt(0) && 58 === a2.charCodeAt(2))
                (u2 = a2.charCodeAt(1)) >= 65 && u2 <= 90 && (a2 = "/".concat(String.fromCharCode(u2 + 32), ":").concat(a2.substr(3)));
              else if (a2.length >= 2 && 58 === a2.charCodeAt(1)) {
                var u2;
                (u2 = a2.charCodeAt(0)) >= 65 && u2 <= 90 && (a2 = "".concat(String.fromCharCode(u2 + 32), ":").concat(a2.substr(2)));
              }
              n3 += r3(a2, true, false);
            }
            return s2 && (n3 += "?", n3 += r3(s2, false, false)), h2 && (n3 += "#", n3 += e3 ? h2 : m(h2, false, false)), n3;
          }
          function w(t3) {
            try {
              return decodeURIComponent(t3);
            } catch (e3) {
              return t3.length > 3 ? t3.substr(0, 3) + w(t3.substr(3)) : t3;
            }
          }
          e2.uriToFsPath = C;
          var _ = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
          function x(t3) {
            return t3.match(_) ? t3.replace(_, function(t4) {
              return w(t4);
            }) : t3;
          }
        }, 679: function(t2, e2, r2) {
          var n2 = this && this.__spreadArray || function(t3, e3, r3) {
            if (r3 || 2 === arguments.length)
              for (var n3, o2 = 0, i2 = e3.length; o2 < i2; o2++)
                !n3 && o2 in e3 || (n3 || (n3 = Array.prototype.slice.call(e3, 0, o2)), n3[o2] = e3[o2]);
            return t3.concat(n3 || Array.prototype.slice.call(e3));
          };
          Object.defineProperty(e2, "__esModule", { value: true }), e2.Utils = void 0;
          var o, i = r2(470), a = i.posix || i, s = "/";
          (o = e2.Utils || (e2.Utils = {})).joinPath = function(t3) {
            for (var e3 = [], r3 = 1; r3 < arguments.length; r3++)
              e3[r3 - 1] = arguments[r3];
            return t3.with({ path: a.join.apply(a, n2([t3.path], e3, false)) });
          }, o.resolvePath = function(t3) {
            for (var e3 = [], r3 = 1; r3 < arguments.length; r3++)
              e3[r3 - 1] = arguments[r3];
            var o2 = t3.path, i2 = false;
            o2[0] !== s && (o2 = s + o2, i2 = true);
            var h = a.resolve.apply(a, n2([o2], e3, false));
            return i2 && h[0] === s && !t3.authority && (h = h.substring(1)), t3.with({ path: h });
          }, o.dirname = function(t3) {
            if (0 === t3.path.length || t3.path === s)
              return t3;
            var e3 = a.dirname(t3.path);
            return 1 === e3.length && 46 === e3.charCodeAt(0) && (e3 = ""), t3.with({ path: e3 });
          }, o.basename = function(t3) {
            return a.basename(t3.path);
          }, o.extname = function(t3) {
            return a.extname(t3.path);
          };
        } }, e = {};
        function r(n2) {
          var o = e[n2];
          if (void 0 !== o)
            return o.exports;
          var i = e[n2] = { exports: {} };
          return t[n2].call(i.exports, i, i.exports, r), i.exports;
        }
        var n = {};
        return (() => {
          var t2 = n;
          Object.defineProperty(t2, "__esModule", { value: true }), t2.Utils = t2.URI = void 0;
          var e2 = r(796);
          Object.defineProperty(t2, "URI", { enumerable: true, get: function() {
            return e2.URI;
          } });
          var o = r(679);
          Object.defineProperty(t2, "Utils", { enumerable: true, get: function() {
            return o.Utils;
          } });
        })(), n;
      })());
    }
  });

  // node_modules/langium/lib/dependency-injection.js
  var require_dependency_injection = __commonJS({
    "node_modules/langium/lib/dependency-injection.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.eagerLoad = exports2.inject = void 0;
      function inject(module1, module22, module3, module4) {
        const module5 = [module1, module22, module3, module4].reduce(_merge, {});
        return _inject(module5);
      }
      exports2.inject = inject;
      var isProxy = Symbol("isProxy");
      function eagerLoad(item) {
        if (item && item[isProxy]) {
          for (const value of Object.values(item)) {
            eagerLoad(value);
          }
        }
        return item;
      }
      exports2.eagerLoad = eagerLoad;
      function _inject(module3, injector) {
        const proxy = new Proxy({}, {
          deleteProperty: () => false,
          get: (obj, prop) => _resolve(obj, prop, module3, injector || proxy),
          getOwnPropertyDescriptor: (obj, prop) => (_resolve(obj, prop, module3, injector || proxy), Object.getOwnPropertyDescriptor(obj, prop)),
          has: (_, prop) => prop in module3,
          ownKeys: () => [...Reflect.ownKeys(module3), isProxy]
          // used by for..in
        });
        proxy[isProxy] = true;
        return proxy;
      }
      var __requested__ = Symbol();
      function _resolve(obj, prop, module3, injector) {
        if (prop in obj) {
          if (obj[prop] instanceof Error) {
            throw new Error("Construction failure. Please make sure that your dependencies are constructable.", { cause: obj[prop] });
          }
          if (obj[prop] === __requested__) {
            throw new Error('Cycle detected. Please make "' + String(prop) + '" lazy. See https://langium.org/docs/di/cyclic-dependencies');
          }
          return obj[prop];
        } else if (prop in module3) {
          const value = module3[prop];
          obj[prop] = __requested__;
          try {
            obj[prop] = typeof value === "function" ? value(injector) : _inject(value, injector);
          } catch (error) {
            obj[prop] = error instanceof Error ? error : void 0;
            throw error;
          }
          return obj[prop];
        } else {
          return void 0;
        }
      }
      function _merge(target, source) {
        if (source) {
          for (const [key, value2] of Object.entries(source)) {
            if (value2 !== void 0) {
              const value1 = target[key];
              if (value1 !== null && value2 !== null && typeof value1 === "object" && typeof value2 === "object") {
                target[key] = _merge(value1, value2);
              } else {
                target[key] = value2;
              }
            }
          }
        }
        return target;
      }
    }
  });

  // node_modules/langium/lib/utils/collections.js
  var require_collections = __commonJS({
    "node_modules/langium/lib/utils/collections.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.MultiMap = void 0;
      var stream_1 = require_stream();
      var MultiMap = class {
        constructor(elements) {
          this.map = /* @__PURE__ */ new Map();
          if (elements) {
            for (const [key, value] of elements) {
              this.add(key, value);
            }
          }
        }
        /**
         * The total number of values in the multimap.
         */
        get size() {
          return stream_1.Reduction.sum((0, stream_1.stream)(this.map.values()).map((a) => a.length));
        }
        /**
         * Clear all entries in the multimap.
         */
        clear() {
          this.map.clear();
        }
        /**
         * Operates differently depending on whether a `value` is given:
         *  * With a value, this method deletes the specific key / value pair from the multimap.
         *  * Without a value, all values associated with the given key are deleted.
         *
         * @returns `true` if a value existed and has been removed, or `false` if the specified
         *     key / value does not exist.
         */
        delete(key, value) {
          if (value === void 0) {
            return this.map.delete(key);
          } else {
            const values = this.map.get(key);
            if (values) {
              const index = values.indexOf(value);
              if (index >= 0) {
                if (values.length === 1) {
                  this.map.delete(key);
                } else {
                  values.splice(index, 1);
                }
                return true;
              }
            }
            return false;
          }
        }
        /**
         * Returns an array of all values associated with the given key. If no value exists,
         * an empty array is returned.
         *
         * _Note:_ The returned array is assumed not to be modified. Use the `set` method to add a
         * value and `delete` to remove a value from the multimap.
         */
        get(key) {
          var _a4;
          return (_a4 = this.map.get(key)) !== null && _a4 !== void 0 ? _a4 : [];
        }
        /**
         * Operates differently depending on whether a `value` is given:
         *  * With a value, this method returns `true` if the specific key / value pair is present in the multimap.
         *  * Without a value, this method returns `true` if the given key is present in the multimap.
         */
        has(key, value) {
          if (value === void 0) {
            return this.map.has(key);
          } else {
            const values = this.map.get(key);
            if (values) {
              return values.indexOf(value) >= 0;
            }
            return false;
          }
        }
        /**
         * Add the given key / value pair to the multimap.
         */
        add(key, value) {
          if (this.map.has(key)) {
            this.map.get(key).push(value);
          } else {
            this.map.set(key, [value]);
          }
          return this;
        }
        /**
         * Add the given set of key / value pairs to the multimap.
         */
        addAll(key, values) {
          if (this.map.has(key)) {
            this.map.get(key).push(...values);
          } else {
            this.map.set(key, Array.from(values));
          }
          return this;
        }
        /**
         * Invokes the given callback function for every key / value pair in the multimap.
         */
        forEach(callbackfn) {
          this.map.forEach((array, key) => array.forEach((value) => callbackfn(value, key, this)));
        }
        /**
         * Returns an iterator of key, value pairs for every entry in the map.
         */
        [Symbol.iterator]() {
          return this.entries().iterator();
        }
        /**
         * Returns a stream of key, value pairs for every entry in the map.
         */
        entries() {
          return (0, stream_1.stream)(this.map.entries()).flatMap(([key, array]) => array.map((value) => [key, value]));
        }
        /**
         * Returns a stream of keys in the map.
         */
        keys() {
          return (0, stream_1.stream)(this.map.keys());
        }
        /**
         * Returns a stream of values in the map.
         */
        values() {
          return (0, stream_1.stream)(this.map.values()).flat();
        }
        /**
         * Returns a stream of key, value set pairs for every key in the map.
         */
        entriesGroupedByKey() {
          return (0, stream_1.stream)(this.map.entries());
        }
      };
      exports2.MultiMap = MultiMap;
    }
  });

  // node_modules/langium/lib/grammar/generated/ast.js
  var require_ast = __commonJS({
    "node_modules/langium/lib/grammar/generated/ast.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.isTypeAttribute = exports2.TypeAttribute = exports2.isType = exports2.Type = exports2.isTerminalRule = exports2.TerminalRule = exports2.isSimpleType = exports2.SimpleType = exports2.isReturnType = exports2.ReturnType = exports2.isReferenceType = exports2.ReferenceType = exports2.isParserRule = exports2.ParserRule = exports2.isParameterReference = exports2.ParameterReference = exports2.isParameter = exports2.Parameter = exports2.isNegation = exports2.Negation = exports2.isNamedArgument = exports2.NamedArgument = exports2.isLiteralCondition = exports2.LiteralCondition = exports2.isInterface = exports2.Interface = exports2.isInferredType = exports2.InferredType = exports2.isGrammarImport = exports2.GrammarImport = exports2.isGrammar = exports2.Grammar = exports2.isDisjunction = exports2.Disjunction = exports2.isConjunction = exports2.Conjunction = exports2.isArrayType = exports2.ArrayType = exports2.isAbstractElement = exports2.AbstractElement = exports2.isTypeDefinition = exports2.TypeDefinition = exports2.isPrimitiveType = exports2.isFeatureName = exports2.isCondition = exports2.Condition = exports2.isAbstractType = exports2.AbstractType = exports2.isAbstractRule = exports2.AbstractRule = void 0;
      exports2.reflection = exports2.LangiumGrammarAstReflection = exports2.isWildcard = exports2.Wildcard = exports2.isUntilToken = exports2.UntilToken = exports2.isUnorderedGroup = exports2.UnorderedGroup = exports2.isTerminalRuleCall = exports2.TerminalRuleCall = exports2.isTerminalGroup = exports2.TerminalGroup = exports2.isTerminalAlternatives = exports2.TerminalAlternatives = exports2.isRuleCall = exports2.RuleCall = exports2.isRegexToken = exports2.RegexToken = exports2.isNegatedToken = exports2.NegatedToken = exports2.isKeyword = exports2.Keyword = exports2.isGroup = exports2.Group = exports2.isCrossReference = exports2.CrossReference = exports2.isCharacterRange = exports2.CharacterRange = exports2.isAssignment = exports2.Assignment = exports2.isAlternatives = exports2.Alternatives = exports2.isAction = exports2.Action = exports2.isUnionType = exports2.UnionType = void 0;
      var syntax_tree_1 = require_syntax_tree();
      exports2.AbstractRule = "AbstractRule";
      function isAbstractRule(item) {
        return exports2.reflection.isInstance(item, exports2.AbstractRule);
      }
      exports2.isAbstractRule = isAbstractRule;
      exports2.AbstractType = "AbstractType";
      function isAbstractType(item) {
        return exports2.reflection.isInstance(item, exports2.AbstractType);
      }
      exports2.isAbstractType = isAbstractType;
      exports2.Condition = "Condition";
      function isCondition(item) {
        return exports2.reflection.isInstance(item, exports2.Condition);
      }
      exports2.isCondition = isCondition;
      function isFeatureName(item) {
        return isPrimitiveType(item) || item === "current" || item === "entry" || item === "extends" || item === "false" || item === "fragment" || item === "grammar" || item === "hidden" || item === "import" || item === "interface" || item === "returns" || item === "terminal" || item === "true" || item === "type" || item === "infer" || item === "infers" || item === "with" || typeof item === "string" && /\^?[_a-zA-Z][\w_]*/.test(item);
      }
      exports2.isFeatureName = isFeatureName;
      function isPrimitiveType(item) {
        return item === "string" || item === "number" || item === "boolean" || item === "Date" || item === "bigint";
      }
      exports2.isPrimitiveType = isPrimitiveType;
      exports2.TypeDefinition = "TypeDefinition";
      function isTypeDefinition(item) {
        return exports2.reflection.isInstance(item, exports2.TypeDefinition);
      }
      exports2.isTypeDefinition = isTypeDefinition;
      exports2.AbstractElement = "AbstractElement";
      function isAbstractElement(item) {
        return exports2.reflection.isInstance(item, exports2.AbstractElement);
      }
      exports2.isAbstractElement = isAbstractElement;
      exports2.ArrayType = "ArrayType";
      function isArrayType(item) {
        return exports2.reflection.isInstance(item, exports2.ArrayType);
      }
      exports2.isArrayType = isArrayType;
      exports2.Conjunction = "Conjunction";
      function isConjunction(item) {
        return exports2.reflection.isInstance(item, exports2.Conjunction);
      }
      exports2.isConjunction = isConjunction;
      exports2.Disjunction = "Disjunction";
      function isDisjunction(item) {
        return exports2.reflection.isInstance(item, exports2.Disjunction);
      }
      exports2.isDisjunction = isDisjunction;
      exports2.Grammar = "Grammar";
      function isGrammar(item) {
        return exports2.reflection.isInstance(item, exports2.Grammar);
      }
      exports2.isGrammar = isGrammar;
      exports2.GrammarImport = "GrammarImport";
      function isGrammarImport(item) {
        return exports2.reflection.isInstance(item, exports2.GrammarImport);
      }
      exports2.isGrammarImport = isGrammarImport;
      exports2.InferredType = "InferredType";
      function isInferredType(item) {
        return exports2.reflection.isInstance(item, exports2.InferredType);
      }
      exports2.isInferredType = isInferredType;
      exports2.Interface = "Interface";
      function isInterface(item) {
        return exports2.reflection.isInstance(item, exports2.Interface);
      }
      exports2.isInterface = isInterface;
      exports2.LiteralCondition = "LiteralCondition";
      function isLiteralCondition(item) {
        return exports2.reflection.isInstance(item, exports2.LiteralCondition);
      }
      exports2.isLiteralCondition = isLiteralCondition;
      exports2.NamedArgument = "NamedArgument";
      function isNamedArgument(item) {
        return exports2.reflection.isInstance(item, exports2.NamedArgument);
      }
      exports2.isNamedArgument = isNamedArgument;
      exports2.Negation = "Negation";
      function isNegation(item) {
        return exports2.reflection.isInstance(item, exports2.Negation);
      }
      exports2.isNegation = isNegation;
      exports2.Parameter = "Parameter";
      function isParameter(item) {
        return exports2.reflection.isInstance(item, exports2.Parameter);
      }
      exports2.isParameter = isParameter;
      exports2.ParameterReference = "ParameterReference";
      function isParameterReference(item) {
        return exports2.reflection.isInstance(item, exports2.ParameterReference);
      }
      exports2.isParameterReference = isParameterReference;
      exports2.ParserRule = "ParserRule";
      function isParserRule(item) {
        return exports2.reflection.isInstance(item, exports2.ParserRule);
      }
      exports2.isParserRule = isParserRule;
      exports2.ReferenceType = "ReferenceType";
      function isReferenceType(item) {
        return exports2.reflection.isInstance(item, exports2.ReferenceType);
      }
      exports2.isReferenceType = isReferenceType;
      exports2.ReturnType = "ReturnType";
      function isReturnType(item) {
        return exports2.reflection.isInstance(item, exports2.ReturnType);
      }
      exports2.isReturnType = isReturnType;
      exports2.SimpleType = "SimpleType";
      function isSimpleType(item) {
        return exports2.reflection.isInstance(item, exports2.SimpleType);
      }
      exports2.isSimpleType = isSimpleType;
      exports2.TerminalRule = "TerminalRule";
      function isTerminalRule(item) {
        return exports2.reflection.isInstance(item, exports2.TerminalRule);
      }
      exports2.isTerminalRule = isTerminalRule;
      exports2.Type = "Type";
      function isType(item) {
        return exports2.reflection.isInstance(item, exports2.Type);
      }
      exports2.isType = isType;
      exports2.TypeAttribute = "TypeAttribute";
      function isTypeAttribute(item) {
        return exports2.reflection.isInstance(item, exports2.TypeAttribute);
      }
      exports2.isTypeAttribute = isTypeAttribute;
      exports2.UnionType = "UnionType";
      function isUnionType(item) {
        return exports2.reflection.isInstance(item, exports2.UnionType);
      }
      exports2.isUnionType = isUnionType;
      exports2.Action = "Action";
      function isAction(item) {
        return exports2.reflection.isInstance(item, exports2.Action);
      }
      exports2.isAction = isAction;
      exports2.Alternatives = "Alternatives";
      function isAlternatives(item) {
        return exports2.reflection.isInstance(item, exports2.Alternatives);
      }
      exports2.isAlternatives = isAlternatives;
      exports2.Assignment = "Assignment";
      function isAssignment(item) {
        return exports2.reflection.isInstance(item, exports2.Assignment);
      }
      exports2.isAssignment = isAssignment;
      exports2.CharacterRange = "CharacterRange";
      function isCharacterRange(item) {
        return exports2.reflection.isInstance(item, exports2.CharacterRange);
      }
      exports2.isCharacterRange = isCharacterRange;
      exports2.CrossReference = "CrossReference";
      function isCrossReference(item) {
        return exports2.reflection.isInstance(item, exports2.CrossReference);
      }
      exports2.isCrossReference = isCrossReference;
      exports2.Group = "Group";
      function isGroup(item) {
        return exports2.reflection.isInstance(item, exports2.Group);
      }
      exports2.isGroup = isGroup;
      exports2.Keyword = "Keyword";
      function isKeyword(item) {
        return exports2.reflection.isInstance(item, exports2.Keyword);
      }
      exports2.isKeyword = isKeyword;
      exports2.NegatedToken = "NegatedToken";
      function isNegatedToken(item) {
        return exports2.reflection.isInstance(item, exports2.NegatedToken);
      }
      exports2.isNegatedToken = isNegatedToken;
      exports2.RegexToken = "RegexToken";
      function isRegexToken(item) {
        return exports2.reflection.isInstance(item, exports2.RegexToken);
      }
      exports2.isRegexToken = isRegexToken;
      exports2.RuleCall = "RuleCall";
      function isRuleCall(item) {
        return exports2.reflection.isInstance(item, exports2.RuleCall);
      }
      exports2.isRuleCall = isRuleCall;
      exports2.TerminalAlternatives = "TerminalAlternatives";
      function isTerminalAlternatives(item) {
        return exports2.reflection.isInstance(item, exports2.TerminalAlternatives);
      }
      exports2.isTerminalAlternatives = isTerminalAlternatives;
      exports2.TerminalGroup = "TerminalGroup";
      function isTerminalGroup(item) {
        return exports2.reflection.isInstance(item, exports2.TerminalGroup);
      }
      exports2.isTerminalGroup = isTerminalGroup;
      exports2.TerminalRuleCall = "TerminalRuleCall";
      function isTerminalRuleCall(item) {
        return exports2.reflection.isInstance(item, exports2.TerminalRuleCall);
      }
      exports2.isTerminalRuleCall = isTerminalRuleCall;
      exports2.UnorderedGroup = "UnorderedGroup";
      function isUnorderedGroup(item) {
        return exports2.reflection.isInstance(item, exports2.UnorderedGroup);
      }
      exports2.isUnorderedGroup = isUnorderedGroup;
      exports2.UntilToken = "UntilToken";
      function isUntilToken(item) {
        return exports2.reflection.isInstance(item, exports2.UntilToken);
      }
      exports2.isUntilToken = isUntilToken;
      exports2.Wildcard = "Wildcard";
      function isWildcard(item) {
        return exports2.reflection.isInstance(item, exports2.Wildcard);
      }
      exports2.isWildcard = isWildcard;
      var LangiumGrammarAstReflection = class extends syntax_tree_1.AbstractAstReflection {
        getAllTypes() {
          return ["AbstractElement", "AbstractRule", "AbstractType", "Action", "Alternatives", "ArrayType", "Assignment", "CharacterRange", "Condition", "Conjunction", "CrossReference", "Disjunction", "Grammar", "GrammarImport", "Group", "InferredType", "Interface", "Keyword", "LiteralCondition", "NamedArgument", "NegatedToken", "Negation", "Parameter", "ParameterReference", "ParserRule", "ReferenceType", "RegexToken", "ReturnType", "RuleCall", "SimpleType", "TerminalAlternatives", "TerminalGroup", "TerminalRule", "TerminalRuleCall", "Type", "TypeAttribute", "TypeDefinition", "UnionType", "UnorderedGroup", "UntilToken", "Wildcard"];
        }
        computeIsSubtype(subtype, supertype) {
          switch (subtype) {
            case exports2.Action: {
              return this.isSubtype(exports2.AbstractElement, supertype) || this.isSubtype(exports2.AbstractType, supertype);
            }
            case exports2.Alternatives:
            case exports2.Assignment:
            case exports2.CharacterRange:
            case exports2.CrossReference:
            case exports2.Group:
            case exports2.Keyword:
            case exports2.NegatedToken:
            case exports2.RegexToken:
            case exports2.RuleCall:
            case exports2.TerminalAlternatives:
            case exports2.TerminalGroup:
            case exports2.TerminalRuleCall:
            case exports2.UnorderedGroup:
            case exports2.UntilToken:
            case exports2.Wildcard: {
              return this.isSubtype(exports2.AbstractElement, supertype);
            }
            case exports2.ArrayType:
            case exports2.ReferenceType:
            case exports2.SimpleType:
            case exports2.UnionType: {
              return this.isSubtype(exports2.TypeDefinition, supertype);
            }
            case exports2.Conjunction:
            case exports2.Disjunction:
            case exports2.LiteralCondition:
            case exports2.Negation:
            case exports2.ParameterReference: {
              return this.isSubtype(exports2.Condition, supertype);
            }
            case exports2.Interface:
            case exports2.Type: {
              return this.isSubtype(exports2.AbstractType, supertype);
            }
            case exports2.ParserRule: {
              return this.isSubtype(exports2.AbstractRule, supertype) || this.isSubtype(exports2.AbstractType, supertype);
            }
            case exports2.TerminalRule: {
              return this.isSubtype(exports2.AbstractRule, supertype);
            }
            default: {
              return false;
            }
          }
        }
        getReferenceType(refInfo) {
          const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
          switch (referenceId) {
            case "Action:type":
            case "CrossReference:type":
            case "Interface:superTypes":
            case "ParserRule:returnType":
            case "SimpleType:typeRef": {
              return exports2.AbstractType;
            }
            case "Grammar:hiddenTokens":
            case "ParserRule:hiddenTokens":
            case "RuleCall:rule": {
              return exports2.AbstractRule;
            }
            case "Grammar:usedGrammars": {
              return exports2.Grammar;
            }
            case "NamedArgument:parameter":
            case "ParameterReference:parameter": {
              return exports2.Parameter;
            }
            case "TerminalRuleCall:rule": {
              return exports2.TerminalRule;
            }
            default: {
              throw new Error(`${referenceId} is not a valid reference id.`);
            }
          }
        }
        getTypeMetaData(type) {
          switch (type) {
            case "Grammar": {
              return {
                name: "Grammar",
                mandatory: [
                  { name: "definesHiddenTokens", type: "boolean" },
                  { name: "hiddenTokens", type: "array" },
                  { name: "imports", type: "array" },
                  { name: "interfaces", type: "array" },
                  { name: "isDeclared", type: "boolean" },
                  { name: "rules", type: "array" },
                  { name: "types", type: "array" },
                  { name: "usedGrammars", type: "array" }
                ]
              };
            }
            case "Interface": {
              return {
                name: "Interface",
                mandatory: [
                  { name: "attributes", type: "array" },
                  { name: "superTypes", type: "array" }
                ]
              };
            }
            case "LiteralCondition": {
              return {
                name: "LiteralCondition",
                mandatory: [
                  { name: "true", type: "boolean" }
                ]
              };
            }
            case "NamedArgument": {
              return {
                name: "NamedArgument",
                mandatory: [
                  { name: "calledByName", type: "boolean" }
                ]
              };
            }
            case "ParserRule": {
              return {
                name: "ParserRule",
                mandatory: [
                  { name: "definesHiddenTokens", type: "boolean" },
                  { name: "entry", type: "boolean" },
                  { name: "fragment", type: "boolean" },
                  { name: "hiddenTokens", type: "array" },
                  { name: "parameters", type: "array" },
                  { name: "wildcard", type: "boolean" }
                ]
              };
            }
            case "TerminalRule": {
              return {
                name: "TerminalRule",
                mandatory: [
                  { name: "fragment", type: "boolean" },
                  { name: "hidden", type: "boolean" }
                ]
              };
            }
            case "TypeAttribute": {
              return {
                name: "TypeAttribute",
                mandatory: [
                  { name: "isOptional", type: "boolean" }
                ]
              };
            }
            case "UnionType": {
              return {
                name: "UnionType",
                mandatory: [
                  { name: "types", type: "array" }
                ]
              };
            }
            case "Alternatives": {
              return {
                name: "Alternatives",
                mandatory: [
                  { name: "elements", type: "array" }
                ]
              };
            }
            case "CrossReference": {
              return {
                name: "CrossReference",
                mandatory: [
                  { name: "deprecatedSyntax", type: "boolean" }
                ]
              };
            }
            case "Group": {
              return {
                name: "Group",
                mandatory: [
                  { name: "elements", type: "array" }
                ]
              };
            }
            case "RuleCall": {
              return {
                name: "RuleCall",
                mandatory: [
                  { name: "arguments", type: "array" }
                ]
              };
            }
            case "TerminalAlternatives": {
              return {
                name: "TerminalAlternatives",
                mandatory: [
                  { name: "elements", type: "array" }
                ]
              };
            }
            case "TerminalGroup": {
              return {
                name: "TerminalGroup",
                mandatory: [
                  { name: "elements", type: "array" }
                ]
              };
            }
            case "UnorderedGroup": {
              return {
                name: "UnorderedGroup",
                mandatory: [
                  { name: "elements", type: "array" }
                ]
              };
            }
            default: {
              return {
                name: type,
                mandatory: []
              };
            }
          }
        }
      };
      exports2.LangiumGrammarAstReflection = LangiumGrammarAstReflection;
      exports2.reflection = new LangiumGrammarAstReflection();
    }
  });

  // node_modules/langium/lib/utils/ast-util.js
  var require_ast_util = __commonJS({
    "node_modules/langium/lib/utils/ast-util.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.copyAstNode = exports2.findLocalReferences = exports2.streamReferences = exports2.streamAst = exports2.streamAllContents = exports2.streamContents = exports2.findRootNode = exports2.getDocument = exports2.hasContainerOfType = exports2.getContainerOfType = exports2.linkContentToContainer = void 0;
      var syntax_tree_1 = require_syntax_tree();
      var stream_1 = require_stream();
      var cst_util_1 = require_cst_util();
      function linkContentToContainer(node) {
        for (const [name, value] of Object.entries(node)) {
          if (!name.startsWith("$")) {
            if (Array.isArray(value)) {
              value.forEach((item, index) => {
                if ((0, syntax_tree_1.isAstNode)(item)) {
                  item.$container = node;
                  item.$containerProperty = name;
                  item.$containerIndex = index;
                }
              });
            } else if ((0, syntax_tree_1.isAstNode)(value)) {
              value.$container = node;
              value.$containerProperty = name;
            }
          }
        }
      }
      exports2.linkContentToContainer = linkContentToContainer;
      function getContainerOfType(node, typePredicate) {
        let item = node;
        while (item) {
          if (typePredicate(item)) {
            return item;
          }
          item = item.$container;
        }
        return void 0;
      }
      exports2.getContainerOfType = getContainerOfType;
      function hasContainerOfType(node, predicate) {
        let item = node;
        while (item) {
          if (predicate(item)) {
            return true;
          }
          item = item.$container;
        }
        return false;
      }
      exports2.hasContainerOfType = hasContainerOfType;
      function getDocument(node) {
        const rootNode = findRootNode(node);
        const result = rootNode.$document;
        if (!result) {
          throw new Error("AST node has no document.");
        }
        return result;
      }
      exports2.getDocument = getDocument;
      function findRootNode(node) {
        while (node.$container) {
          node = node.$container;
        }
        return node;
      }
      exports2.findRootNode = findRootNode;
      function streamContents(node, options) {
        if (!node) {
          throw new Error("Node must be an AstNode.");
        }
        const range = options === null || options === void 0 ? void 0 : options.range;
        return new stream_1.StreamImpl(() => ({
          keys: Object.keys(node),
          keyIndex: 0,
          arrayIndex: 0
        }), (state) => {
          while (state.keyIndex < state.keys.length) {
            const property = state.keys[state.keyIndex];
            if (!property.startsWith("$")) {
              const value = node[property];
              if ((0, syntax_tree_1.isAstNode)(value)) {
                state.keyIndex++;
                if (isAstNodeInRange(value, range)) {
                  return { done: false, value };
                }
              } else if (Array.isArray(value)) {
                while (state.arrayIndex < value.length) {
                  const index = state.arrayIndex++;
                  const element = value[index];
                  if ((0, syntax_tree_1.isAstNode)(element) && isAstNodeInRange(element, range)) {
                    return { done: false, value: element };
                  }
                }
                state.arrayIndex = 0;
              }
            }
            state.keyIndex++;
          }
          return stream_1.DONE_RESULT;
        });
      }
      exports2.streamContents = streamContents;
      function streamAllContents(root, options) {
        if (!root) {
          throw new Error("Root node must be an AstNode.");
        }
        return new stream_1.TreeStreamImpl(root, (node) => streamContents(node, options));
      }
      exports2.streamAllContents = streamAllContents;
      function streamAst(root, options) {
        if (!root) {
          throw new Error("Root node must be an AstNode.");
        } else if ((options === null || options === void 0 ? void 0 : options.range) && !isAstNodeInRange(root, options.range)) {
          return new stream_1.TreeStreamImpl(root, () => []);
        }
        return new stream_1.TreeStreamImpl(root, (node) => streamContents(node, options), { includeRoot: true });
      }
      exports2.streamAst = streamAst;
      function isAstNodeInRange(astNode, range) {
        var _a4;
        if (!range) {
          return true;
        }
        const nodeRange = (_a4 = astNode.$cstNode) === null || _a4 === void 0 ? void 0 : _a4.range;
        if (!nodeRange) {
          return false;
        }
        return (0, cst_util_1.inRange)(nodeRange, range);
      }
      function streamReferences(node) {
        return new stream_1.StreamImpl(() => ({
          keys: Object.keys(node),
          keyIndex: 0,
          arrayIndex: 0
        }), (state) => {
          while (state.keyIndex < state.keys.length) {
            const property = state.keys[state.keyIndex];
            if (!property.startsWith("$")) {
              const value = node[property];
              if ((0, syntax_tree_1.isReference)(value)) {
                state.keyIndex++;
                return { done: false, value: { reference: value, container: node, property } };
              } else if (Array.isArray(value)) {
                while (state.arrayIndex < value.length) {
                  const index = state.arrayIndex++;
                  const element = value[index];
                  if ((0, syntax_tree_1.isReference)(element)) {
                    return { done: false, value: { reference: element, container: node, property, index } };
                  }
                }
                state.arrayIndex = 0;
              }
            }
            state.keyIndex++;
          }
          return stream_1.DONE_RESULT;
        });
      }
      exports2.streamReferences = streamReferences;
      function findLocalReferences(targetNode, lookup = getDocument(targetNode).parseResult.value) {
        const refs = [];
        streamAst(lookup).forEach((node) => {
          streamReferences(node).forEach((refInfo) => {
            if (refInfo.reference.ref === targetNode) {
              refs.push(refInfo.reference);
            }
          });
        });
        return (0, stream_1.stream)(refs);
      }
      exports2.findLocalReferences = findLocalReferences;
      function copyAstNode(node, buildReference) {
        const copy = { $type: node.$type };
        for (const [name, value] of Object.entries(node)) {
          if (!name.startsWith("$")) {
            if ((0, syntax_tree_1.isAstNode)(value)) {
              copy[name] = copyAstNode(value, buildReference);
            } else if ((0, syntax_tree_1.isReference)(value)) {
              copy[name] = buildReference(copy, name, value.$refNode, value.$refText);
            } else if (Array.isArray(value)) {
              const copiedArray = [];
              for (const element of value) {
                if ((0, syntax_tree_1.isAstNode)(element)) {
                  copiedArray.push(copyAstNode(element, buildReference));
                } else if ((0, syntax_tree_1.isReference)(element)) {
                  copiedArray.push(buildReference(copy, name, element.$refNode, element.$refText));
                } else {
                  copiedArray.push(element);
                }
              }
              copy[name] = copiedArray;
            } else {
              copy[name] = value;
            }
          }
        }
        linkContentToContainer(copy);
        return copy;
      }
      exports2.copyAstNode = copyAstNode;
    }
  });

  // node_modules/langium/lib/generator/generator-tracing.js
  var require_generator_tracing = __commonJS({
    "node_modules/langium/lib/generator/generator-tracing.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getSourceRegion = void 0;
      var ast_util_1 = require_ast_util();
      var grammar_util_1 = require_grammar_util();
      var stream_1 = require_stream();
      function getSourceRegion(sourceSpec) {
        var _a4, _b2;
        if (!sourceSpec) {
          return void 0;
        } else if ("astNode" in sourceSpec) {
          return getSourceRegionOfAstNode(sourceSpec);
        } else if (Array.isArray(sourceSpec)) {
          return sourceSpec.reduce(mergeDocumentSegment, void 0);
        } else {
          const sourceRegion = sourceSpec;
          const sourceFileURIviaCstNode = isCstNode(sourceRegion) ? getDocumentURIOrUndefined((_b2 = (_a4 = sourceRegion === null || sourceRegion === void 0 ? void 0 : sourceRegion.root) === null || _a4 === void 0 ? void 0 : _a4.element) !== null && _b2 !== void 0 ? _b2 : sourceRegion === null || sourceRegion === void 0 ? void 0 : sourceRegion.element) : void 0;
          return copyDocumentSegment(sourceRegion, sourceFileURIviaCstNode);
        }
      }
      exports2.getSourceRegion = getSourceRegion;
      function isCstNode(segment) {
        return typeof segment !== "undefined" && "element" in segment && "text" in segment;
      }
      function getDocumentURIOrUndefined(astNode) {
        try {
          return (0, ast_util_1.getDocument)(astNode).uri.toString();
        } catch (e) {
          return void 0;
        }
      }
      function getSourceRegionOfAstNode(sourceSpec) {
        var _a4, _b2;
        const { astNode, property, index } = sourceSpec !== null && sourceSpec !== void 0 ? sourceSpec : {};
        const textRegion = (_a4 = astNode === null || astNode === void 0 ? void 0 : astNode.$cstNode) !== null && _a4 !== void 0 ? _a4 : astNode === null || astNode === void 0 ? void 0 : astNode.$textRegion;
        if (astNode === void 0 || textRegion === void 0) {
          return void 0;
        } else if (property === void 0) {
          return copyDocumentSegment(textRegion, getDocumentURI(astNode));
        } else {
          const getSingleOrCompoundRegion = (regions) => {
            if (index !== void 0 && index > -1 && Array.isArray(astNode[property])) {
              return index < regions.length ? regions[index] : void 0;
            } else {
              return regions.reduce(mergeDocumentSegment, void 0);
            }
          };
          if ((_b2 = textRegion.assignments) === null || _b2 === void 0 ? void 0 : _b2[property]) {
            const region = getSingleOrCompoundRegion(textRegion.assignments[property]);
            return region && copyDocumentSegment(region, getDocumentURI(astNode));
          } else if (astNode.$cstNode) {
            const region = getSingleOrCompoundRegion((0, grammar_util_1.findNodesForProperty)(astNode.$cstNode, property));
            return region && copyDocumentSegment(region, getDocumentURI(astNode));
          } else {
            return void 0;
          }
        }
      }
      function getDocumentURI(astNode) {
        var _a4, _b2, _c2, _d;
        if (astNode.$cstNode) {
          return (_b2 = (_a4 = (0, ast_util_1.getDocument)(astNode)) === null || _a4 === void 0 ? void 0 : _a4.uri) === null || _b2 === void 0 ? void 0 : _b2.toString();
        } else if (astNode.$textRegion) {
          return astNode.$textRegion.documentURI || ((_d = (_c2 = new stream_1.TreeStreamImpl(astNode, (n) => n.$container ? [n.$container] : []).find((n) => {
            var _a5;
            return (_a5 = n.$textRegion) === null || _a5 === void 0 ? void 0 : _a5.documentURI;
          })) === null || _c2 === void 0 ? void 0 : _c2.$textRegion) === null || _d === void 0 ? void 0 : _d.documentURI);
        } else {
          return void 0;
        }
      }
      function copyDocumentSegment(region, fileURI) {
        var _a4, _b2;
        const result = {
          offset: region.offset,
          end: (_a4 = region.end) !== null && _a4 !== void 0 ? _a4 : region.offset + region.length,
          length: (_b2 = region.length) !== null && _b2 !== void 0 ? _b2 : region.end - region.offset
        };
        if (region.range) {
          result.range = region.range;
        }
        fileURI !== null && fileURI !== void 0 ? fileURI : fileURI = region.fileURI;
        if (fileURI) {
          result.fileURI = fileURI;
        }
        return result;
      }
      function mergeDocumentSegment(prev, curr) {
        var _a4, _b2;
        if (!prev) {
          return curr && copyDocumentSegment(curr);
        } else if (!curr) {
          return prev && copyDocumentSegment(prev);
        }
        const prevEnd = (_a4 = prev.end) !== null && _a4 !== void 0 ? _a4 : prev.offset + prev.length;
        const currEnd = (_b2 = curr.end) !== null && _b2 !== void 0 ? _b2 : curr.offset + curr.length;
        const offset = Math.min(prev.offset, curr.offset);
        const end = Math.max(prevEnd, currEnd);
        const length = end - offset;
        const result = {
          offset,
          end,
          length
        };
        if (prev.range && curr.range) {
          result.range = {
            start: curr.range.start.line < prev.range.start.line || curr.range.start.line === prev.range.start.line && curr.range.start.character < prev.range.start.character ? curr.range.start : prev.range.start,
            end: curr.range.end.line > prev.range.end.line || curr.range.end.line === prev.range.end.line && curr.range.end.character > prev.range.end.character ? curr.range.end : prev.range.end
          };
        }
        if (prev.fileURI || curr.fileURI) {
          const prevURI = prev.fileURI;
          const currURI = curr.fileURI;
          const fileURI = prevURI && currURI && prevURI !== currURI ? `<unmergable text regions of ${prevURI}, ${currURI}>` : prevURI !== null && prevURI !== void 0 ? prevURI : currURI;
          result.fileURI = fileURI;
        }
        return result;
      }
    }
  });

  // node_modules/langium/lib/generator/node-processor.js
  var require_node_processor = __commonJS({
    "node_modules/langium/lib/generator/node-processor.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.processGeneratorNode = void 0;
      var generator_node_1 = require_generator_node();
      var generator_tracing_1 = require_generator_tracing();
      var Context = class {
        constructor(defaultIndent) {
          this.defaultIndentation = "    ";
          this.pendingIndent = true;
          this.currentIndents = [];
          this.recentNonImmediateIndents = [];
          this.traceData = [];
          this.lines = [[]];
          if (typeof defaultIndent === "string") {
            this.defaultIndentation = defaultIndent;
          } else if (typeof defaultIndent === "number") {
            this.defaultIndentation = "".padStart(defaultIndent);
          }
        }
        get content() {
          return this.lines.map((e) => e.join("")).join("");
        }
        get currentLineNumber() {
          return this.lines.length - 1;
        }
        get currentLineContent() {
          return this.lines[this.currentLineNumber].join("");
        }
        get currentPosition() {
          return {
            offset: this.content.length,
            line: this.currentLineNumber,
            character: this.currentLineContent.length
          };
        }
        append(value, isIndent) {
          if (value.length > 0) {
            const beforePos = isIndent && this.currentPosition;
            this.lines[this.currentLineNumber].push(value);
            if (beforePos) {
              this.indentPendingTraceRegions(beforePos);
            }
          }
        }
        indentPendingTraceRegions(before) {
          for (let i = this.traceData.length - 1; i >= 0; i--) {
            const tr = this.traceData[i];
            if (tr.targetStart && tr.targetStart.offset === before.offset)
              tr.targetStart = this.currentPosition;
          }
        }
        increaseIndent(node) {
          this.currentIndents.push(node);
          if (!node.indentImmediately) {
            this.recentNonImmediateIndents.push(node);
          }
        }
        decreaseIndent() {
          this.currentIndents.pop();
        }
        get relevantIndents() {
          return this.currentIndents.filter((i) => !this.recentNonImmediateIndents.includes(i));
        }
        resetCurrentLine() {
          this.lines[this.currentLineNumber] = [];
        }
        addNewLine() {
          this.pendingIndent = true;
          this.lines.push([]);
          this.recentNonImmediateIndents.length = 0;
        }
        pushTraceRegion(sourceRegion) {
          const region = createTraceRegion(sourceRegion, this.currentPosition, (it) => {
            var _a4, _b2;
            return (_b2 = (_a4 = this.traceData[this.traceData.length - 1]) === null || _a4 === void 0 ? void 0 : _a4.children) === null || _b2 === void 0 ? void 0 : _b2.push(it);
          });
          this.traceData.push(region);
          return region;
        }
        popTraceRegion(expected) {
          const traceRegion = this.traceData.pop();
          this.assertTrue(traceRegion === expected, "Trace region mismatch!");
          return traceRegion;
        }
        getParentTraceSourceFileURI() {
          var _a4;
          for (let i = this.traceData.length - 1; i > -1; i--) {
            const fileUri = (_a4 = this.traceData[i].sourceRegion) === null || _a4 === void 0 ? void 0 : _a4.fileURI;
            if (fileUri)
              return fileUri;
          }
          return void 0;
        }
        assertTrue(condition, msg) {
          if (!condition) {
            throw new Error(msg);
          }
        }
      };
      function createTraceRegion(sourceRegion, targetStart, accept) {
        const result = {
          sourceRegion,
          targetRegion: void 0,
          children: [],
          targetStart,
          complete: (targetEnd) => {
            var _a4, _b2;
            result.targetRegion = {
              offset: result.targetStart.offset,
              end: targetEnd.offset,
              length: targetEnd.offset - result.targetStart.offset,
              range: {
                start: {
                  line: result.targetStart.line,
                  character: result.targetStart.character
                },
                end: {
                  line: targetEnd.line,
                  character: targetEnd.character
                }
              }
            };
            delete result.targetStart;
            if (((_a4 = result.children) === null || _a4 === void 0 ? void 0 : _a4.length) === 0) {
              delete result.children;
            }
            if ((_b2 = result.targetRegion) === null || _b2 === void 0 ? void 0 : _b2.length) {
              accept(result);
            }
            delete result.complete;
            return result;
          }
        };
        return result;
      }
      function processGeneratorNode(node, defaultIndentation) {
        const context = new Context(defaultIndentation);
        const trace = context.pushTraceRegion(void 0);
        processNodeInternal(node, context);
        context.popTraceRegion(trace);
        trace.complete && trace.complete(context.currentPosition);
        const singleChild = trace.children && trace.children.length === 1 ? trace.children[0] : void 0;
        const singleChildTargetRegion = singleChild === null || singleChild === void 0 ? void 0 : singleChild.targetRegion;
        const rootTargetRegion = trace.targetRegion;
        if (singleChildTargetRegion && singleChild.sourceRegion && singleChildTargetRegion.offset === rootTargetRegion.offset && singleChildTargetRegion.length === rootTargetRegion.length) {
          return { text: context.content, trace: singleChild };
        } else {
          return { text: context.content, trace };
        }
      }
      exports2.processGeneratorNode = processGeneratorNode;
      function processNodeInternal(node, context) {
        if (typeof node === "string") {
          processStringNode(node, context);
        } else if (node instanceof generator_node_1.IndentNode) {
          processIndentNode(node, context);
        } else if (node instanceof generator_node_1.CompositeGeneratorNode) {
          processCompositeNode(node, context);
        } else if (node instanceof generator_node_1.NewLineNode) {
          processNewLineNode(node, context);
        }
      }
      function hasContent(node, ctx) {
        if (typeof node === "string") {
          return node.length !== 0;
        } else if (node instanceof generator_node_1.CompositeGeneratorNode) {
          return node.contents.some((e) => hasContent(e, ctx));
        } else if (node instanceof generator_node_1.NewLineNode) {
          return !(node.ifNotEmpty && ctx.currentLineContent.length === 0);
        } else {
          return false;
        }
      }
      function processStringNode(node, context) {
        if (node) {
          if (context.pendingIndent) {
            handlePendingIndent(context, false);
          }
          context.append(node);
        }
      }
      function handlePendingIndent(ctx, endOfLine) {
        var _a4;
        let indent = "";
        for (const indentNode of ctx.relevantIndents.filter((e) => e.indentEmptyLines || !endOfLine)) {
          indent += (_a4 = indentNode.indentation) !== null && _a4 !== void 0 ? _a4 : ctx.defaultIndentation;
        }
        ctx.append(indent, true);
        ctx.pendingIndent = false;
      }
      function processCompositeNode(node, context) {
        let traceRegion = void 0;
        const sourceRegion = (0, generator_tracing_1.getSourceRegion)(node.tracedSource);
        if (sourceRegion) {
          traceRegion = context.pushTraceRegion(sourceRegion);
        }
        for (const child of node.contents) {
          processNodeInternal(child, context);
        }
        if (traceRegion) {
          context.popTraceRegion(traceRegion);
          const parentsFileURI = context.getParentTraceSourceFileURI();
          if (parentsFileURI && (sourceRegion === null || sourceRegion === void 0 ? void 0 : sourceRegion.fileURI) === parentsFileURI) {
            delete sourceRegion.fileURI;
          }
          traceRegion.complete && traceRegion.complete(context.currentPosition);
        }
      }
      function processIndentNode(node, context) {
        var _a4;
        if (hasContent(node, context)) {
          if (node.indentImmediately && !context.pendingIndent) {
            context.append((_a4 = node.indentation) !== null && _a4 !== void 0 ? _a4 : context.defaultIndentation, true);
          }
          try {
            context.increaseIndent(node);
            processCompositeNode(node, context);
          } finally {
            context.decreaseIndent();
          }
        }
      }
      function processNewLineNode(node, context) {
        if (node.ifNotEmpty && !hasNonWhitespace(context.currentLineContent)) {
          context.resetCurrentLine();
        } else {
          if (context.pendingIndent) {
            handlePendingIndent(context, true);
          }
          context.append(node.lineDelimiter);
          context.addNewLine();
        }
      }
      function hasNonWhitespace(text) {
        return text.trimStart() !== "";
      }
    }
  });

  // node_modules/langium/lib/generator/template-string.js
  var require_template_string = __commonJS({
    "node_modules/langium/lib/generator/template-string.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.normalizeEOL = exports2.findIndentation = exports2.NEWLINE_REGEXP = exports2.SNLE = exports2.expandToString = exports2.expandToStringWithNL = void 0;
      var generator_node_1 = require_generator_node();
      function expandToStringWithNL(staticParts, ...substitutions) {
        return expandToString(staticParts, ...substitutions) + generator_node_1.EOL;
      }
      exports2.expandToStringWithNL = expandToStringWithNL;
      function expandToString(staticParts, ...substitutions) {
        let lines = substitutions.reduce((acc, subst, i) => {
          var _a4;
          return acc + (subst === void 0 ? exports2.SNLE : align((0, generator_node_1.toString)(subst), acc)) + ((_a4 = staticParts[i + 1]) !== null && _a4 !== void 0 ? _a4 : "");
        }, staticParts[0]).split(exports2.NEWLINE_REGEXP).filter((l) => l.trim() !== exports2.SNLE).map((l) => l.replace(exports2.SNLE, "").trimRight());
        const containsLeadingLinebreak = lines.length > 1 && lines[0].trim().length === 0;
        lines = containsLeadingLinebreak ? lines.slice(1) : lines;
        const containsTrailingLinebreak = lines.length !== 0 && lines[lines.length - 1].trimRight().length === 0;
        lines = containsTrailingLinebreak ? lines.slice(0, lines.length - 1) : lines;
        const indent = findIndentation(lines);
        return lines.map((line) => line.slice(indent).trimRight()).join(generator_node_1.EOL);
      }
      exports2.expandToString = expandToString;
      exports2.SNLE = Object.freeze("__\xABSKIP^NEW^LINE^IF^EMPTY\xBB__");
      exports2.NEWLINE_REGEXP = /\r?\n/g;
      var nonWhitespace = /\S|$/;
      function align(subst, acc) {
        const length = Math.max(0, acc.length - acc.lastIndexOf("\n") - 1);
        const indent = " ".repeat(length);
        return subst.replace(exports2.NEWLINE_REGEXP, generator_node_1.EOL + indent);
      }
      function findIndentation(lines) {
        const indents = lines.filter((line) => line.length > 0).map((line) => line.search(nonWhitespace));
        const min = indents.length === 0 ? 0 : Math.min(...indents);
        return Math.max(0, min);
      }
      exports2.findIndentation = findIndentation;
      function normalizeEOL(input) {
        return input.replace(exports2.NEWLINE_REGEXP, generator_node_1.EOL);
      }
      exports2.normalizeEOL = normalizeEOL;
    }
  });

  // node_modules/langium/lib/generator/template-node.js
  var require_template_node = __commonJS({
    "node_modules/langium/lib/generator/template-node.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.expandTracedToNodeIf = exports2.expandTracedToNode = exports2.expandToNode = void 0;
      var generator_node_1 = require_generator_node();
      var template_string_1 = require_template_string();
      function expandToNode(staticParts, ...substitutions) {
        const templateProps = findIndentationAndTemplateStructure(staticParts);
        const splitAndMerged = splitTemplateLinesAndMergeWithSubstitutions(staticParts, substitutions, templateProps);
        return composeFinalGeneratorNode(splitAndMerged);
      }
      exports2.expandToNode = expandToNode;
      function expandTracedToNode(source, property, index) {
        return (staticParts, ...substitutions) => {
          return (0, generator_node_1.traceToNode)(source, property, index)(expandToNode(staticParts, ...substitutions));
        };
      }
      exports2.expandTracedToNode = expandTracedToNode;
      function expandTracedToNodeIf(condition, source, property, index) {
        return condition ? expandTracedToNode(typeof source === "function" ? source() : source, property, index) : () => void 0;
      }
      exports2.expandTracedToNodeIf = expandTracedToNodeIf;
      function findIndentationAndTemplateStructure(staticParts) {
        const lines = staticParts.join("_").split(template_string_1.NEWLINE_REGEXP);
        const omitFirstLine = lines.length > 1 && lines[0].trim().length === 0;
        const omitLastLine = omitFirstLine && lines.length > 1 && lines[lines.length - 1].trim().length === 0;
        if (lines.length === 1 || lines.length !== 0 && lines[0].trim().length !== 0 || lines.length === 2 && lines[1].trim().length === 0) {
          return {
            indentation: 0,
            omitFirstLine,
            omitLastLine,
            trimLastLine: lines.length !== 1 && lines[lines.length - 1].trim().length === 0
          };
        } else {
          let sliced = omitFirstLine ? lines.slice(1) : lines;
          sliced = omitLastLine ? sliced.slice(0, sliced.length - 1) : sliced;
          sliced = sliced.filter((e) => e.length !== 0);
          const indentation = (0, template_string_1.findIndentation)(sliced);
          return {
            indentation,
            omitFirstLine,
            // in the subsequent steps omit the last line only if it is empty or if it only contains white space of which the common indentation is not a valid prefix;
            //  in other words: keep the last line if it matches the common indentation (and maybe contains non-whitespace), a non-match may be due to mistaken usage of tabs and spaces
            omitLastLine: omitLastLine && (lines[lines.length - 1].length < indentation || !lines[lines.length - 1].startsWith(sliced[0].substring(0, indentation)))
          };
        }
      }
      function splitTemplateLinesAndMergeWithSubstitutions(staticParts, substitutions, { indentation, omitFirstLine, omitLastLine, trimLastLine }) {
        const splitAndMerged = [];
        staticParts.forEach((part, i) => {
          splitAndMerged.push(...part.split(template_string_1.NEWLINE_REGEXP).map((e, j) => j === 0 || e.length < indentation ? e : e.substring(indentation)).reduce(
            // treat the particular (potentially multiple) lines of the <i>th template segment (part),
            //  s.t. all the effective lines are collected and separated by the NEWLINE node
            // note: different reduce functions are provided for the initial template segment vs. the remaining segments
            i === 0 ? (result, line, j) => (
              // special handling of the initial template segment, which may contain line-breaks;
              //  suppresses the injection of unintended NEWLINE indicators for templates like
              //   expandToNode`
              //    someText
              //    ${something}
              //   `
              j === 0 ? omitFirstLine ? [] : [line] : j === 1 && result.length === 0 ? [line] : result.concat(NEWLINE, line)
            ) : (result, line, j) => (
              // handling of the remaining template segments
              j === 0 ? [line] : result.concat(NEWLINE, line)
            ),
            []
            // start with an empty array
          ).filter(
            (e) => !(typeof e === "string" && e.length === 0)
            // drop empty strings, they don't contribute anything but might confuse subsequent processing
          ).concat(
            // append the corresponding substitution after each segment (part),
            //  note that 'substitutions[i]' will be undefined for the last segment
            (0, generator_node_1.isGeneratorNode)(substitutions[i]) ? substitutions[i] : substitutions[i] !== void 0 ? { content: String(substitutions[i]) } : i < substitutions.length ? UNDEFINED_SEGMENT : []
            /* don't concat anything as we passed behind the last substitution, since 'i' enumerates the indices of 'staticParts',
                    but 'substitutions' has one entry less and 'substitutions[staticParts.length -1 ]' will always be undefined */
          ));
        });
        const splitAndMergedLength = splitAndMerged.length;
        const lastItem = splitAndMergedLength !== 0 ? splitAndMerged[splitAndMergedLength - 1] : void 0;
        if ((omitLastLine || trimLastLine) && typeof lastItem === "string" && lastItem.trim().length === 0) {
          if (omitFirstLine && splitAndMergedLength !== 1 && splitAndMerged[splitAndMergedLength - 2] === NEWLINE) {
            return splitAndMerged.slice(0, splitAndMergedLength - 2);
          } else {
            return splitAndMerged.slice(0, splitAndMergedLength - 1);
          }
        } else {
          return splitAndMerged;
        }
      }
      var NEWLINE = { isNewLine: true };
      var UNDEFINED_SEGMENT = { isUndefinedSegment: true };
      var isNewLineMarker = (nl) => nl === NEWLINE;
      var isUndefinedSegmentMarker = (us) => us === UNDEFINED_SEGMENT;
      var isSubstitutionWrapper = (s) => s.content !== void 0;
      function composeFinalGeneratorNode(splitAndMerged) {
        const result = splitAndMerged.reduce((res, segment, i) => isUndefinedSegmentMarker(segment) ? res : isNewLineMarker(segment) ? {
          // in case of a newLine marker append an 'ifNotEmpty' newLine by default, but
          //  append an unconditional newLine if and only if:
          //   * the template starts with the current line break, i.e. the first line is empty
          //   * the current newLine marker directly follows another one, i.e. the current line is empty
          //   * the current newline marker directly follows a substitution contributing a string (or some non-GeneratorNode being converted to a string)
          //   * the current newline marker directly follows a (template static) string that
          //      * is the initial token of the template
          //      * is the initial token of the line, maybe just indentation
          //      * follows a a substitution contributing a string (or some non-GeneratorNode being converted to a string), maybe is just irrelevant trailing whitespace
          // in particular do _not_ append an unconditional newLine if the last substitution of a line contributes 'undefined' or an instance of 'GeneratorNode'
          //  which may be a newline itself or be empty or (transitively) contain a trailing newline itself
          // node: i === 0
          //     || isNewLineMarker(splitAndMerged[i - 1]) || isSubstitutionWrapper(splitAndMerged[i - 1]) /* implies: typeof content === 'string', esp. !undefined */
          //     || typeof splitAndMerged[i - 1] === 'string' && (
          //         i === 1 || isNewLineMarker(splitAndMerged[i - 2]) || isSubstitutionWrapper(splitAndMerged[i - 2]) /* implies: typeof content === 'string', esp. !undefined */
          //     )
          //     ? res.node.appendNewLine() : res.node.appendNewLineIfNotEmpty()
          //
          // UPDATE cs: inverting the logic leads to the following, I hope I didn't miss anything:
          // in case of a newLine marker append an unconditional newLine by default, but
          //  append an 'ifNotEmpty' newLine if and only if:
          //   * the template doesn't start with a newLine marker and
          //      * the current newline marker directly follows a substitution contributing an `undefined` or an instance of 'GeneratorNode', or
          //      * the current newline marker directly follows a (template static) string (containing potentially unintended trailing whitespace)
          //          that in turn directly follows a substitution contributing an `undefined` or an instance of 'GeneratorNode'
          node: i !== 0 && (isUndefinedSegmentMarker(splitAndMerged[i - 1]) || (0, generator_node_1.isGeneratorNode)(splitAndMerged[i - 1])) || i > 1 && typeof splitAndMerged[i - 1] === "string" && (isUndefinedSegmentMarker(splitAndMerged[i - 2]) || (0, generator_node_1.isGeneratorNode)(splitAndMerged[i - 2])) ? res.node.appendNewLineIfNotEmpty() : res.node.appendNewLine()
        } : (() => {
          var _a4;
          const indent = (i === 0 || isNewLineMarker(splitAndMerged[i - 1])) && typeof segment === "string" && segment.length !== 0 ? "".padStart(segment.length - segment.trimStart().length) : "";
          const content = isSubstitutionWrapper(segment) ? segment.content : segment;
          let indented;
          return {
            node: res.indented ? res.node : indent.length !== 0 ? res.node.indent({ indentation: indent, indentImmediately: false, indentedChildren: (ind) => indented = ind.append(content) }) : res.node.append(content),
            indented: (
              // if an indentNode has been created in this cycle, just register it,
              //  otherwise check for a earlier registered indentNode and add the current segment to that one
              indented !== null && indented !== void 0 ? indented : (_a4 = res.indented) === null || _a4 === void 0 ? void 0 : _a4.append(content)
            )
          };
        })(), { node: new generator_node_1.CompositeGeneratorNode() });
        return result.node;
      }
    }
  });

  // node_modules/langium/lib/generator/generator-node.js
  var require_generator_node = __commonJS({
    "node_modules/langium/lib/generator/generator-node.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.NLEmpty = exports2.NL = exports2.NewLineNode = exports2.IndentNode = exports2.traceToNodeIf = exports2.traceToNode = exports2.CompositeGeneratorNode = exports2.toStringAndTrace = exports2.toString = exports2.isNewLineNode = exports2.isGeneratorNode = exports2.EOL = void 0;
      var syntax_tree_1 = require_syntax_tree();
      var node_processor_1 = require_node_processor();
      var template_node_1 = require_template_node();
      exports2.EOL = typeof process === "undefined" ? "\n" : process.platform === "win32" ? "\r\n" : "\n";
      function isGeneratorNode(node) {
        return node instanceof CompositeGeneratorNode || node instanceof IndentNode || node instanceof NewLineNode;
      }
      exports2.isGeneratorNode = isGeneratorNode;
      function isNewLineNode(node) {
        return node instanceof NewLineNode;
      }
      exports2.isNewLineNode = isNewLineNode;
      function toString(input, defaultIndentation) {
        if (isGeneratorNode(input))
          return (0, node_processor_1.processGeneratorNode)(input, defaultIndentation).text;
        else
          return String(input);
      }
      exports2.toString = toString;
      function toStringAndTrace(input, defaultIndentation) {
        return (0, node_processor_1.processGeneratorNode)(input, defaultIndentation);
      }
      exports2.toStringAndTrace = toStringAndTrace;
      var CompositeGeneratorNode = class {
        /**
         * Constructor.
         *
         * @param content a var arg mixture of `strings` and {@link GeneratorNode GeneratorNodes}
         *   describing the initial content of this {@link CompositeGeneratorNode}
         *
         * @example
         *   new CompositeGeneratorNode(
         *      'Hello World!', NL
         *   );
         */
        constructor(...content) {
          this.contents = [];
          this.append(...content);
        }
        isEmpty() {
          return this.contents.length === 0;
        }
        trace(source, property, index) {
          if ((0, syntax_tree_1.isAstNode)(source)) {
            this.tracedSource = { astNode: source, property, index };
            if (this.tracedSource.property === void 0 && this.tracedSource.index !== void 0 && this.tracedSource.index > -1) {
              throw new Error("Generation support: 'property' argument must not be 'undefined' if a non-negative value is assigned to 'index' in 'CompositeGeneratorNode.trace(...)'.");
            }
          } else {
            this.tracedSource = source;
          }
          return this;
        }
        /**
         * Appends `strings` and instances of {@link GeneratorNode} to `this` generator node.
         *
         * @param content a var arg mixture of `strings`, {@link GeneratorNode GeneratorNodes}, or single param
         *  functions that are immediately called with `this` node as argument, and which may append elements themselves.
         *
         * @returns `this` {@link CompositeGeneratorNode} for convenience.
         *
         * @example
         *   new CompositeGeneratorNode().append(
         *      'Hello', ' ', `${name}!`, NL, someOtherNode, 'NL', node => generateContent(node)
         *   ).append(
         *      'The end!'
         *   );
         */
        append(...content) {
          for (const arg of content) {
            if (typeof arg === "function") {
              arg(this);
            } else if (arg) {
              this.contents.push(arg);
            }
          }
          return this;
        }
        /**
         * Appends `strings` and instances of {@link GeneratorNode} to `this` generator node, if `condition` is equal to `true`.
         *
         * If `condition` is satisfied this method delegates to {@link append}, otherwise it returns just `this`.
         *
         * @param condition a boolean value indicating whether to append the elements of `args` to `this`.
         *
         * @param content a var arg mixture of `strings`, {@link GeneratorNode GeneratorNodes}, or single param
         *  functions that are immediately called with `this` node as argument, and which may append elements themselves.
         *
         * @returns `this` {@link CompositeGeneratorNode} for convenience.
         *
         * @example
         *   new CompositeGeneratorNode().append(
         *      'Hello World!'
         *   ).appendNewLine().appendIf(
         *      entity !== undefined, `Hello ${entity?.name}!`
         *   ).appendNewLineIfNotEmpty();
         */
        appendIf(condition, ...content) {
          return condition ? this.append(...content) : this;
        }
        /**
         * Appends a strict {@link NewLineNode} to `this` node.
         * Strict {@link NewLineNode}s yield mandatory linebreaks in the derived generated text.
         *
         * @returns `this` {@link CompositeGeneratorNode} for convenience.
         *
         * @example
         *   new CompositeGeneratorNode().append(
         *      'Hello World!'
         *   ).appendNewLine();
         */
        appendNewLine() {
          return this.append(exports2.NL);
        }
        /**
         * Appends a strict {@link NewLineNode} to `this` node, if `condition` is equal to `true`.
         * Strict {@link NewLineNode}s yield mandatory linebreaks in the derived generated text.
         *
         * @param condition a boolean value indicating whether to append a {@link NewLineNode} to `this`.
         *
         * @returns `this` {@link CompositeGeneratorNode} for convenience.
         *
         * @example
         *   new CompositeGeneratorNode().append(
         *      'Hello World!'
         *   ).appendNewLineIf(entity !== undefined).appendIf(
         *      entity !== undefined, `Hello ${entity?.name}!`
         *   )
         */
        appendNewLineIf(condition) {
          return condition ? this.append(exports2.NL) : this;
        }
        /**
         * Appends a soft {@link NewLineNode} to `this` node.
         * Soft {@link NewLineNode}s yield linebreaks in the derived generated text only if the preceding line is non-empty,
         * i.e. there are non-whitespace characters added to the generated text since the last linebreak.
         *
         * @returns `this` {@link CompositeGeneratorNode} for convenience.
         *
         * @example
         *   new CompositeGeneratorNode().appendIf(
         *      entity !== undefined, `Hello ${entity?.name}!`
         *   ).appendNewLineIfNotEmpty();
         */
        appendNewLineIfNotEmpty() {
          return this.append(exports2.NLEmpty);
        }
        /**
         * Appends a soft {@link NewLineNode} to `this` node, if `condition` is equal to `true`.
         * Soft {@link NewLineNode}s yield linebreaks in the derived generated text only if the preceding line is non-empty,
         * i.e. there are non-whitespace characters added to the generated text since the last linebreak.
         *
         * @param condition a boolean value indicating whether to append a {@link NewLineNode} to `this`.
         *
         * @returns `this` {@link CompositeGeneratorNode} for convenience.
         *
         * @example
         *   new CompositeGeneratorNode().append(
         *      entity.label ?? ''
         *   ).appendNewLineIfNotEmptyIf(entity.description !== undefined).append(
         *      entity.description
         *   )
         */
        appendNewLineIfNotEmptyIf(condition) {
          return condition ? this.appendNewLineIfNotEmpty() : this;
        }
        /**
         * Convenience method for appending content in form of a template to `this` generation node.
         *
         * See {@link expandToNode} for details.
         *
         * @returns `this` {@link CompositeGeneratorNode} for convenience.
         *
         * @example
         *   new CompositeGeneratorNode().appendTemplate
         *       `Hello World!`
         *   .appendNewLine()
         */
        appendTemplate(staticParts, ...substitutions) {
          return this.append((0, template_node_1.expandToNode)(staticParts, ...substitutions));
        }
        /**
         * Convenience method for appending content in form of a template to `this` generator node, if `condition` is equal to `true`.
         *
         * This method returns a tag function that takes the desired template and does the processing.
         *
         * If `condition` is satisfied the tagged template delegates to {@link appendTemplate}, otherwise it returns just `this`.
         *
         * See {@link expandToNode} for details.
         *
         * @param condition a boolean value indicating whether to append the template content to `this`.
         *
         * @returns a tag function behaving as described above, which in turn returns `this` {@link CompositeGeneratorNode} for convenience.
         *
         * @example
         *   new CompositeGeneratorNode().appendTemplate
         *       `Hello World!`
         *   .appendNewLine().appendTemplateIf(entity !== undefined)
         *       `Hello ${entity?.name}!`
         *   .appendNewLineIfNotEmpty()
         */
        appendTemplateIf(condition) {
          return condition ? (staticParts, ...substitutions) => this.appendTemplate(staticParts, ...substitutions) : () => this;
        }
        /**
         * Adds an area of indented text output.
         * The content to be indented can be provided as an array consisting of strings and/or generation nodes
         * (undefined is permitted), or via a callback offering the `indentingNode` to which the content shall be appended.
         * Alternatively, an object satisfying {@link IndentConfig} can be provided taking the children as Array or via
         * a callback as described previously via the `indentedChildren` property.
         *
         * The remaining properties of {@link IndentConfig} have the following effects:
         *  - `indentation`: a specific indentation length or string, defaults to the global indentation setting if omitted, see {@link toString},
         *  - `indentEmptyLines`: apply indentation to empty lines, defaults to `false`
         *  - `indentImmediately`: apply the indentation immediately starting at the first line, defaults to `true`, might be set to `false`
         *    if preceding content is not terminated by any `newline`. If `false` the indentation is inserted only after child `newline` nodes
         *    followed by further content.
         *
         * @param childrenOrConfig an {@link Array} or callback contributing the children, or a config object satisfying {@link IndentConfig} alternatively.
         *
         * @returns `this` {@link CompositeGeneratorNode} for convenience.
         *
         * @example
         *   new CompositeGeneratorNode().append(
         *       '{'
         *   ).indent(indentingNode =>
         *       indentingNode.append(
         *           'name:', name, ','
         *       ).appendNewLine().appendIf(description !== undefined,
         *           'description:', description
         *       ).appendNewLineIfNotEmpty()
         *   ).append(
         *       '}'
         *   );
         */
        indent(childrenOrConfig) {
          const { indentedChildren, indentation, indentEmptyLines, indentImmediately } = Array.isArray(childrenOrConfig) || typeof childrenOrConfig === "function" ? { indentedChildren: childrenOrConfig } : typeof childrenOrConfig === "object" ? childrenOrConfig : {};
          const node = new IndentNode(indentation, indentImmediately, indentEmptyLines);
          this.contents.push(node);
          if (Array.isArray(indentedChildren)) {
            node.append(...indentedChildren);
          } else if (indentedChildren) {
            node.append(indentedChildren);
          }
          return this;
        }
        // implementation:
        appendTraced(source, property, index) {
          return (content) => {
            return this.append(new CompositeGeneratorNode().trace(source, property, index).append(content));
          };
        }
        // implementation:
        appendTracedIf(condition, source, property, index) {
          return condition ? this.appendTraced(typeof source === "function" ? source() : source, property, index) : () => this;
        }
        // implementation:
        appendTracedTemplate(source, property, index) {
          return (staticParts, ...substitutions) => {
            return this.append((0, template_node_1.expandTracedToNode)(source, property, index)(staticParts, ...substitutions));
          };
        }
        // implementation:
        appendTracedTemplateIf(condition, source, property, index) {
          return condition ? this.appendTracedTemplate(typeof source === "function" ? source() : source, property, index) : () => this;
        }
      };
      exports2.CompositeGeneratorNode = CompositeGeneratorNode;
      function traceToNode(astNode, property, index) {
        return (content) => {
          if (content instanceof CompositeGeneratorNode && content.tracedSource === void 0) {
            return content.trace(astNode, property, index);
          } else {
            return new CompositeGeneratorNode().trace(astNode, property, index).append(content);
          }
        };
      }
      exports2.traceToNode = traceToNode;
      function traceToNodeIf(condition, source, property, index) {
        return condition ? traceToNode(typeof source === "function" ? source() : source, property, index) : () => void 0;
      }
      exports2.traceToNodeIf = traceToNodeIf;
      var IndentNode = class extends CompositeGeneratorNode {
        constructor(indentation, indentImmediately = true, indentEmptyLines = false) {
          super();
          this.indentImmediately = true;
          this.indentEmptyLines = false;
          if (typeof indentation === "string") {
            this.indentation = indentation;
          } else if (typeof indentation === "number") {
            this.indentation = "".padStart(indentation);
          }
          this.indentImmediately = indentImmediately;
          this.indentEmptyLines = indentEmptyLines;
        }
      };
      exports2.IndentNode = IndentNode;
      var NewLineNode = class {
        constructor(lineDelimiter, ifNotEmpty = false) {
          this.ifNotEmpty = false;
          this.lineDelimiter = lineDelimiter !== null && lineDelimiter !== void 0 ? lineDelimiter : exports2.EOL;
          this.ifNotEmpty = ifNotEmpty;
        }
      };
      exports2.NewLineNode = NewLineNode;
      exports2.NL = new NewLineNode();
      exports2.NLEmpty = new NewLineNode(void 0, true);
    }
  });

  // node_modules/langium/lib/grammar/type-system/type-collector/types.js
  var require_types = __commonJS({
    "node_modules/langium/lib/grammar/type-system/type-collector/types.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.isMandatoryPropertyType = exports2.propertyTypeToString = exports2.isTypeAssignable = exports2.TypeResolutionError = exports2.InterfaceType = exports2.UnionType = exports2.isInterfaceType = exports2.isUnionType = exports2.isStringType = exports2.isPrimitiveType = exports2.isValueType = exports2.flattenPropertyUnion = exports2.isPropertyUnion = exports2.isArrayType = exports2.isReferenceType = void 0;
      var generator_node_1 = require_generator_node();
      var types_util_1 = require_types_util();
      function isReferenceType(propertyType) {
        return "referenceType" in propertyType;
      }
      exports2.isReferenceType = isReferenceType;
      function isArrayType(propertyType) {
        return "elementType" in propertyType;
      }
      exports2.isArrayType = isArrayType;
      function isPropertyUnion(propertyType) {
        return "types" in propertyType;
      }
      exports2.isPropertyUnion = isPropertyUnion;
      function flattenPropertyUnion(propertyType) {
        if (isPropertyUnion(propertyType)) {
          const items = [];
          for (const type of propertyType.types) {
            items.push(...flattenPropertyUnion(type));
          }
          return items;
        } else {
          return [propertyType];
        }
      }
      exports2.flattenPropertyUnion = flattenPropertyUnion;
      function isValueType(propertyType) {
        return "value" in propertyType;
      }
      exports2.isValueType = isValueType;
      function isPrimitiveType(propertyType) {
        return "primitive" in propertyType;
      }
      exports2.isPrimitiveType = isPrimitiveType;
      function isStringType(propertyType) {
        return "string" in propertyType;
      }
      exports2.isStringType = isStringType;
      function isUnionType(type) {
        return type && "type" in type;
      }
      exports2.isUnionType = isUnionType;
      function isInterfaceType(type) {
        return type && "properties" in type;
      }
      exports2.isInterfaceType = isInterfaceType;
      var UnionType = class {
        constructor(name, options) {
          var _a4;
          this.superTypes = /* @__PURE__ */ new Set();
          this.subTypes = /* @__PURE__ */ new Set();
          this.containerTypes = /* @__PURE__ */ new Set();
          this.typeNames = /* @__PURE__ */ new Set();
          this.name = name;
          this.declared = (_a4 = options === null || options === void 0 ? void 0 : options.declared) !== null && _a4 !== void 0 ? _a4 : false;
          this.dataType = options === null || options === void 0 ? void 0 : options.dataType;
        }
        toAstTypesString(reflectionInfo) {
          const unionNode = new generator_node_1.CompositeGeneratorNode();
          unionNode.append(`export type ${this.name} = ${propertyTypeToString(this.type, "AstType")};`, generator_node_1.NL);
          if (reflectionInfo) {
            unionNode.append(generator_node_1.NL);
            pushReflectionInfo(unionNode, this.name);
          }
          if (this.dataType) {
            pushDataTypeReflectionInfo(unionNode, this);
          }
          return (0, generator_node_1.toString)(unionNode);
        }
        toDeclaredTypesString(reservedWords) {
          const unionNode = new generator_node_1.CompositeGeneratorNode();
          unionNode.append(`type ${escapeReservedWords(this.name, reservedWords)} = ${propertyTypeToString(this.type, "DeclaredType")};`, generator_node_1.NL);
          return (0, generator_node_1.toString)(unionNode);
        }
      };
      exports2.UnionType = UnionType;
      var InterfaceType = class {
        get superProperties() {
          return this.getSuperProperties(/* @__PURE__ */ new Set());
        }
        getSuperProperties(visited) {
          if (visited.has(this.name)) {
            return [];
          } else {
            visited.add(this.name);
          }
          const map = /* @__PURE__ */ new Map();
          for (const property of this.properties) {
            map.set(property.name, property);
          }
          for (const superType of this.interfaceSuperTypes) {
            const allSuperProperties = superType.getSuperProperties(visited);
            for (const superProp of allSuperProperties) {
              if (!map.has(superProp.name)) {
                map.set(superProp.name, superProp);
              }
            }
          }
          return Array.from(map.values());
        }
        get allProperties() {
          const map = new Map(this.superProperties.map((e) => [e.name, e]));
          for (const subType of this.subTypes) {
            this.getSubTypeProperties(subType, map, /* @__PURE__ */ new Set());
          }
          const superProps = Array.from(map.values());
          return superProps;
        }
        getSubTypeProperties(type, map, visited) {
          if (visited.has(this.name)) {
            return;
          } else {
            visited.add(this.name);
          }
          const props = isInterfaceType(type) ? type.properties : [];
          for (const prop of props) {
            if (!map.has(prop.name)) {
              map.set(prop.name, prop);
            }
          }
          for (const subType of type.subTypes) {
            this.getSubTypeProperties(subType, map, visited);
          }
        }
        get interfaceSuperTypes() {
          return Array.from(this.superTypes).filter((e) => e instanceof InterfaceType);
        }
        constructor(name, declared, abstract) {
          this.superTypes = /* @__PURE__ */ new Set();
          this.subTypes = /* @__PURE__ */ new Set();
          this.containerTypes = /* @__PURE__ */ new Set();
          this.typeNames = /* @__PURE__ */ new Set();
          this.declared = false;
          this.abstract = false;
          this.properties = [];
          this.name = name;
          this.declared = declared;
          this.abstract = abstract;
        }
        toAstTypesString(reflectionInfo) {
          const interfaceNode = new generator_node_1.CompositeGeneratorNode();
          const interfaceSuperTypes = this.interfaceSuperTypes.map((e) => e.name);
          const superTypes = interfaceSuperTypes.length > 0 ? (0, types_util_1.distinctAndSorted)([...interfaceSuperTypes]) : ["AstNode"];
          interfaceNode.append(`export interface ${this.name} extends ${superTypes.join(", ")} {`, generator_node_1.NL);
          interfaceNode.indent((body) => {
            if (this.containerTypes.size > 0) {
              body.append(`readonly $container: ${(0, types_util_1.distinctAndSorted)([...this.containerTypes].map((e) => e.name)).join(" | ")};`, generator_node_1.NL);
            }
            if (this.typeNames.size > 0) {
              body.append(`readonly $type: ${(0, types_util_1.distinctAndSorted)([...this.typeNames]).map((e) => `'${e}'`).join(" | ")};`, generator_node_1.NL);
            }
            pushProperties(body, this.properties, "AstType");
          });
          interfaceNode.append("}", generator_node_1.NL);
          if (reflectionInfo) {
            interfaceNode.append(generator_node_1.NL);
            pushReflectionInfo(interfaceNode, this.name);
          }
          return (0, generator_node_1.toString)(interfaceNode);
        }
        toDeclaredTypesString(reservedWords) {
          const interfaceNode = new generator_node_1.CompositeGeneratorNode();
          const name = escapeReservedWords(this.name, reservedWords);
          const superTypes = (0, types_util_1.distinctAndSorted)(this.interfaceSuperTypes.map((e) => e.name)).join(", ");
          interfaceNode.append(`interface ${name}${superTypes.length > 0 ? ` extends ${superTypes}` : ""} {`, generator_node_1.NL);
          interfaceNode.indent((body) => pushProperties(body, this.properties, "DeclaredType", reservedWords));
          interfaceNode.append("}", generator_node_1.NL);
          return (0, generator_node_1.toString)(interfaceNode);
        }
      };
      exports2.InterfaceType = InterfaceType;
      var TypeResolutionError = class extends Error {
        constructor(message, target) {
          super(message);
          this.name = "TypeResolutionError";
          this.target = target;
        }
      };
      exports2.TypeResolutionError = TypeResolutionError;
      function isTypeAssignable(from, to) {
        if (isPropertyUnion(from)) {
          return from.types.every((fromType) => isTypeAssignable(fromType, to));
        } else if (isPropertyUnion(to)) {
          return to.types.some((toType) => isTypeAssignable(from, toType));
        } else if (isValueType(to) && isUnionType(to.value)) {
          if (isValueType(from) && isUnionType(from.value) && to.value.name === from.value.name) {
            return true;
          }
          return isTypeAssignable(from, to.value.type);
        } else if (isReferenceType(from)) {
          return isReferenceType(to) && isTypeAssignable(from.referenceType, to.referenceType);
        } else if (isArrayType(from)) {
          return isArrayType(to) && isTypeAssignable(from.elementType, to.elementType);
        } else if (isValueType(from)) {
          if (isUnionType(from.value)) {
            return isTypeAssignable(from.value.type, to);
          }
          if (!isValueType(to)) {
            return false;
          }
          if (isUnionType(to.value)) {
            return isTypeAssignable(from, to.value.type);
          } else {
            return isInterfaceAssignable(from.value, to.value, /* @__PURE__ */ new Set());
          }
        } else if (isPrimitiveType(from)) {
          return isPrimitiveType(to) && from.primitive === to.primitive;
        } else if (isStringType(from)) {
          return isPrimitiveType(to) && to.primitive === "string" || isStringType(to) && to.string === from.string;
        }
        return false;
      }
      exports2.isTypeAssignable = isTypeAssignable;
      function isInterfaceAssignable(from, to, visited) {
        if (visited.has(from.name)) {
          return true;
        } else {
          visited.add(from.name);
        }
        if (from.name === to.name) {
          return true;
        }
        for (const superType of from.superTypes) {
          if (isInterfaceType(superType) && isInterfaceAssignable(superType, to, visited)) {
            return true;
          }
        }
        return false;
      }
      function propertyTypeToString(type, mode = "AstType") {
        if (isReferenceType(type)) {
          const refType = propertyTypeToString(type.referenceType, mode);
          return mode === "AstType" ? `Reference<${refType}>` : `@${typeParenthesis(type.referenceType, refType)}`;
        } else if (isArrayType(type)) {
          const arrayType = propertyTypeToString(type.elementType, mode);
          return mode === "AstType" ? `Array<${arrayType}>` : `${typeParenthesis(type.elementType, arrayType)}[]`;
        } else if (isPropertyUnion(type)) {
          const types = type.types.map((e) => typeParenthesis(e, propertyTypeToString(e, mode)));
          return (0, types_util_1.distinctAndSorted)(types).join(" | ");
        } else if (isValueType(type)) {
          return type.value.name;
        } else if (isPrimitiveType(type)) {
          return type.primitive;
        } else if (isStringType(type)) {
          const delimiter2 = mode === "AstType" ? "'" : '"';
          return `${delimiter2}${type.string}${delimiter2}`;
        }
        throw new Error("Invalid type");
      }
      exports2.propertyTypeToString = propertyTypeToString;
      function typeParenthesis(type, name) {
        const needsParenthesis = isPropertyUnion(type);
        if (needsParenthesis) {
          name = `(${name})`;
        }
        return name;
      }
      function pushProperties(node, properties, mode, reserved = /* @__PURE__ */ new Set()) {
        function propertyToString(property) {
          const name = mode === "AstType" ? property.name : escapeReservedWords(property.name, reserved);
          const optional = property.optional && !isMandatoryPropertyType(property.type);
          const propType = propertyTypeToString(property.type, mode);
          return `${name}${optional ? "?" : ""}: ${propType}`;
        }
        (0, types_util_1.distinctAndSorted)(properties, (a, b) => a.name.localeCompare(b.name)).forEach((property) => node.append(propertyToString(property), generator_node_1.NL));
      }
      function isMandatoryPropertyType(propertyType) {
        if (isArrayType(propertyType)) {
          return true;
        } else if (isReferenceType(propertyType)) {
          return false;
        } else if (isPropertyUnion(propertyType)) {
          return propertyType.types.every((e) => isMandatoryPropertyType(e));
        } else if (isPrimitiveType(propertyType)) {
          const value = propertyType.primitive;
          return value === "boolean";
        } else {
          return false;
        }
      }
      exports2.isMandatoryPropertyType = isMandatoryPropertyType;
      function pushReflectionInfo(node, name) {
        node.append(`export const ${name} = '${name}';`, generator_node_1.NL);
        node.append(generator_node_1.NL);
        node.append(`export function is${name}(item: unknown): item is ${name} {`, generator_node_1.NL);
        node.indent((body) => body.append(`return reflection.isInstance(item, ${name});`, generator_node_1.NL));
        node.append("}", generator_node_1.NL);
      }
      function pushDataTypeReflectionInfo(node, union) {
        switch (union.dataType) {
          case "string":
            if (containsOnlyStringTypes(union.type)) {
              const subTypes = Array.from(union.subTypes).map((e) => e.name);
              const strings = collectStringValuesFromDataType(union.type);
              const regexes = collectRegexesFromDataType(union.type);
              if (subTypes.length === 0 && strings.length === 0 && regexes.length === 0) {
                generateIsDataTypeFunction(node, union.name, `typeof item === '${union.dataType}'`);
              } else {
                const returnString = createDataTypeCheckerFunctionReturnString(subTypes, strings, regexes);
                generateIsDataTypeFunction(node, union.name, returnString);
              }
            }
            break;
          case "number":
          case "boolean":
          case "bigint":
            generateIsDataTypeFunction(node, union.name, `typeof item === '${union.dataType}'`);
            break;
          case "Date":
            generateIsDataTypeFunction(node, union.name, "item instanceof Date");
            break;
          default:
            return;
        }
      }
      function containsOnlyStringTypes(propertyType) {
        let result = true;
        if (isPrimitiveType(propertyType)) {
          if (propertyType.primitive === "string") {
            return true;
          } else {
            return false;
          }
        } else if (isStringType(propertyType)) {
          return true;
        } else if (!isPropertyUnion(propertyType)) {
          return false;
        } else {
          for (const type of propertyType.types) {
            if (isValueType(type)) {
              if (isUnionType(type.value)) {
                if (!containsOnlyStringTypes(type.value.type)) {
                  return false;
                }
              } else {
                return false;
              }
            } else if (isPrimitiveType(type)) {
              if (type.primitive !== "string" || !type.regex) {
                return false;
              }
            } else if (isPropertyUnion(type)) {
              result = containsOnlyStringTypes(type);
            } else if (!isStringType(type)) {
              return false;
            }
          }
        }
        return result;
      }
      function createDataTypeCheckerFunctionReturnString(subTypes, strings, regexes) {
        const allArray = [
          ...subTypes.map((e) => `is${e}(item)`),
          ...strings.map((e) => `item === '${e}'`)
        ];
        if (regexes.length > 0) {
          const joinedRegexes = regexes.map((e) => `/${e}/.test(item)`).join(" || ");
          allArray.push(`(typeof item === 'string' && (${joinedRegexes}))`);
        }
        return allArray.join(" || ");
      }
      function escapeReservedWords(name, reserved) {
        return reserved.has(name) ? `^${name}` : name;
      }
      function collectStringValuesFromDataType(propertyType) {
        const values = [];
        if (isStringType(propertyType)) {
          return [propertyType.string];
        }
        if (isPropertyUnion(propertyType)) {
          for (const type of propertyType.types) {
            if (isStringType(type)) {
              values.push(type.string);
            } else if (isPropertyUnion(type)) {
              values.push(...collectStringValuesFromDataType(type));
            }
          }
        }
        return values;
      }
      function collectRegexesFromDataType(propertyType) {
        const regexes = [];
        if (isPrimitiveType(propertyType) && propertyType.primitive === "string" && propertyType.regex) {
          regexes.push(propertyType.regex);
        }
        if (isPropertyUnion(propertyType)) {
          for (const type of propertyType.types) {
            if (isPrimitiveType(type) && type.primitive === "string" && type.regex) {
              regexes.push(type.regex);
            } else if (isPropertyUnion(type)) {
              regexes.push(...collectRegexesFromDataType(type));
            }
          }
        }
        return regexes;
      }
      function generateIsDataTypeFunction(node, unionName, returnString) {
        node.append(generator_node_1.NL, `export function is${unionName}(item: unknown): item is ${unionName} {`, generator_node_1.NL);
        node.indent((body) => body.append(`return ${returnString};`, generator_node_1.NL));
        node.append("}", generator_node_1.NL);
      }
    }
  });

  // node_modules/langium/lib/grammar/type-system/types-util.js
  var require_types_util = __commonJS({
    "node_modules/langium/lib/grammar/type-system/types-util.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.isAstType = exports2.findReferenceTypes = exports2.hasBooleanType = exports2.hasArrayType = exports2.sortInterfacesTopologically = exports2.mergeTypesAndInterfaces = exports2.mergeInterfaces = exports2.collectSuperTypes = exports2.collectTypeHierarchy = exports2.collectChildrenTypes = exports2.distinctAndSorted = exports2.collectAllPlainProperties = void 0;
      var collections_1 = require_collections();
      var ast_1 = require_ast();
      var types_1 = require_types();
      function collectAllPlainProperties(interfaces) {
        const map = new collections_1.MultiMap();
        for (const interfaceType of interfaces) {
          map.addAll(interfaceType.name, interfaceType.properties);
        }
        for (const interfaceType of interfaces) {
          for (const superType of interfaceType.superTypes) {
            const superTypeProperties = map.get(superType);
            if (superTypeProperties) {
              map.addAll(interfaceType.name, superTypeProperties);
            }
          }
        }
        return map;
      }
      exports2.collectAllPlainProperties = collectAllPlainProperties;
      function distinctAndSorted(list, compareFn) {
        return Array.from(new Set(list)).sort(compareFn);
      }
      exports2.distinctAndSorted = distinctAndSorted;
      function collectChildrenTypes(interfaceNode, references, langiumDocuments, nodeLocator) {
        const childrenTypes = /* @__PURE__ */ new Set();
        childrenTypes.add(interfaceNode);
        const refs = references.findReferences(interfaceNode, {});
        refs.forEach((ref) => {
          const doc = langiumDocuments.getOrCreateDocument(ref.sourceUri);
          const astNode = nodeLocator.getAstNode(doc.parseResult.value, ref.sourcePath);
          if ((0, ast_1.isInterface)(astNode)) {
            childrenTypes.add(astNode);
            const childrenOfInterface = collectChildrenTypes(astNode, references, langiumDocuments, nodeLocator);
            childrenOfInterface.forEach((child) => childrenTypes.add(child));
          } else if (astNode && (0, ast_1.isType)(astNode.$container)) {
            childrenTypes.add(astNode.$container);
          }
        });
        return childrenTypes;
      }
      exports2.collectChildrenTypes = collectChildrenTypes;
      function collectTypeHierarchy(types) {
        const allTypes = new Set(types);
        const duplicateSuperTypes = new collections_1.MultiMap();
        const duplicateSubTypes = new collections_1.MultiMap();
        for (const type of allTypes) {
          for (const superType of type.superTypes) {
            if (allTypes.has(superType)) {
              duplicateSuperTypes.add(type.name, superType.name);
              duplicateSubTypes.add(superType.name, type.name);
            }
          }
          for (const subType of type.subTypes) {
            if (allTypes.has(subType)) {
              duplicateSuperTypes.add(subType.name, type.name);
              duplicateSubTypes.add(type.name, subType.name);
            }
          }
        }
        const superTypes = new collections_1.MultiMap();
        const subTypes = new collections_1.MultiMap();
        for (const [name, superTypeList] of Array.from(duplicateSuperTypes.entriesGroupedByKey()).sort(([aName], [bName]) => aName.localeCompare(bName))) {
          superTypes.addAll(name, Array.from(new Set(superTypeList)));
        }
        for (const [name, subTypeList] of Array.from(duplicateSubTypes.entriesGroupedByKey()).sort(([aName], [bName]) => aName.localeCompare(bName))) {
          subTypes.addAll(name, Array.from(new Set(subTypeList)));
        }
        return {
          superTypes,
          subTypes
        };
      }
      exports2.collectTypeHierarchy = collectTypeHierarchy;
      function collectSuperTypes(ruleNode) {
        const superTypes = /* @__PURE__ */ new Set();
        if ((0, ast_1.isInterface)(ruleNode)) {
          superTypes.add(ruleNode);
          ruleNode.superTypes.forEach((superType) => {
            if ((0, ast_1.isInterface)(superType.ref)) {
              superTypes.add(superType.ref);
              const collectedSuperTypes = collectSuperTypes(superType.ref);
              for (const superType2 of collectedSuperTypes) {
                superTypes.add(superType2);
              }
            }
          });
        } else if ((0, ast_1.isType)(ruleNode)) {
          const usedTypes = collectUsedTypes(ruleNode.type);
          for (const usedType of usedTypes) {
            const collectedSuperTypes = collectSuperTypes(usedType);
            for (const superType of collectedSuperTypes) {
              superTypes.add(superType);
            }
          }
        }
        return superTypes;
      }
      exports2.collectSuperTypes = collectSuperTypes;
      function collectUsedTypes(typeDefinition) {
        var _a4;
        if ((0, ast_1.isUnionType)(typeDefinition)) {
          return typeDefinition.types.flatMap((e) => collectUsedTypes(e));
        } else if ((0, ast_1.isSimpleType)(typeDefinition)) {
          const value = (_a4 = typeDefinition.typeRef) === null || _a4 === void 0 ? void 0 : _a4.ref;
          if ((0, ast_1.isType)(value) || (0, ast_1.isInterface)(value)) {
            return [value];
          }
        }
        return [];
      }
      function mergeInterfaces(inferred, declared) {
        return inferred.interfaces.concat(declared.interfaces);
      }
      exports2.mergeInterfaces = mergeInterfaces;
      function mergeTypesAndInterfaces(astTypes) {
        return astTypes.interfaces.concat(astTypes.unions);
      }
      exports2.mergeTypesAndInterfaces = mergeTypesAndInterfaces;
      function sortInterfacesTopologically(interfaces) {
        const nodes = interfaces.sort((a, b) => a.name.localeCompare(b.name)).map((e) => ({ value: e, nodes: [] }));
        for (const node of nodes) {
          node.nodes = nodes.filter((e) => node.value.superTypes.has(e.value.name));
        }
        const l = [];
        const s = nodes.filter((e) => e.nodes.length === 0);
        while (s.length > 0) {
          const n = s.shift();
          if (!l.includes(n)) {
            l.push(n);
            nodes.filter((e) => e.nodes.includes(n)).forEach((m) => s.push(m));
          }
        }
        return l.map((e) => e.value);
      }
      exports2.sortInterfacesTopologically = sortInterfacesTopologically;
      function hasArrayType(type) {
        if ((0, types_1.isPropertyUnion)(type)) {
          return type.types.some((e) => hasArrayType(e));
        } else if ((0, types_1.isArrayType)(type)) {
          return true;
        } else {
          return false;
        }
      }
      exports2.hasArrayType = hasArrayType;
      function hasBooleanType(type) {
        if ((0, types_1.isPropertyUnion)(type)) {
          return type.types.some((e) => hasBooleanType(e));
        } else if ((0, types_1.isPrimitiveType)(type)) {
          return type.primitive === "boolean";
        } else {
          return false;
        }
      }
      exports2.hasBooleanType = hasBooleanType;
      function findReferenceTypes(type) {
        if ((0, types_1.isPropertyUnion)(type)) {
          return type.types.flatMap((e) => findReferenceTypes(e));
        } else if ((0, types_1.isReferenceType)(type)) {
          const refType = type.referenceType;
          if ((0, types_1.isValueType)(refType)) {
            return [refType.value.name];
          }
        } else if ((0, types_1.isArrayType)(type)) {
          return findReferenceTypes(type.elementType);
        }
        return [];
      }
      exports2.findReferenceTypes = findReferenceTypes;
      function isAstType(type) {
        if ((0, types_1.isPropertyUnion)(type)) {
          return type.types.every(isAstType);
        } else if ((0, types_1.isValueType)(type)) {
          const value = type.value;
          if ("type" in value) {
            return isAstType(value.type);
          } else {
            return true;
          }
        }
        return false;
      }
      exports2.isAstType = isAstType;
    }
  });

  // node_modules/langium/lib/references/name-provider.js
  var require_name_provider = __commonJS({
    "node_modules/langium/lib/references/name-provider.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DefaultNameProvider = exports2.isNamed = void 0;
      var grammar_util_1 = require_grammar_util();
      function isNamed(node) {
        return typeof node.name === "string";
      }
      exports2.isNamed = isNamed;
      var DefaultNameProvider = class {
        getName(node) {
          if (isNamed(node)) {
            return node.name;
          }
          return void 0;
        }
        getNameNode(node) {
          return (0, grammar_util_1.findNodeForProperty)(node.$cstNode, "name");
        }
      };
      exports2.DefaultNameProvider = DefaultNameProvider;
    }
  });

  // node_modules/regexp-to-ast/lib/regexp-to-ast.js
  var require_regexp_to_ast = __commonJS({
    "node_modules/regexp-to-ast/lib/regexp-to-ast.js"(exports2, module2) {
      (function(root, factory) {
        if (typeof define === "function" && define.amd) {
          define([], factory);
        } else if (typeof module2 === "object" && module2.exports) {
          module2.exports = factory();
        } else {
          root.regexpToAst = factory();
        }
      })(
        typeof self !== "undefined" ? (
          // istanbul ignore next
          self
        ) : exports2,
        function() {
          function RegExpParser() {
          }
          RegExpParser.prototype.saveState = function() {
            return {
              idx: this.idx,
              input: this.input,
              groupIdx: this.groupIdx
            };
          };
          RegExpParser.prototype.restoreState = function(newState) {
            this.idx = newState.idx;
            this.input = newState.input;
            this.groupIdx = newState.groupIdx;
          };
          RegExpParser.prototype.pattern = function(input) {
            this.idx = 0;
            this.input = input;
            this.groupIdx = 0;
            this.consumeChar("/");
            var value = this.disjunction();
            this.consumeChar("/");
            var flags = {
              type: "Flags",
              loc: { begin: this.idx, end: input.length },
              global: false,
              ignoreCase: false,
              multiLine: false,
              unicode: false,
              sticky: false
            };
            while (this.isRegExpFlag()) {
              switch (this.popChar()) {
                case "g":
                  addFlag(flags, "global");
                  break;
                case "i":
                  addFlag(flags, "ignoreCase");
                  break;
                case "m":
                  addFlag(flags, "multiLine");
                  break;
                case "u":
                  addFlag(flags, "unicode");
                  break;
                case "y":
                  addFlag(flags, "sticky");
                  break;
              }
            }
            if (this.idx !== this.input.length) {
              throw Error(
                "Redundant input: " + this.input.substring(this.idx)
              );
            }
            return {
              type: "Pattern",
              flags,
              value,
              loc: this.loc(0)
            };
          };
          RegExpParser.prototype.disjunction = function() {
            var alts = [];
            var begin = this.idx;
            alts.push(this.alternative());
            while (this.peekChar() === "|") {
              this.consumeChar("|");
              alts.push(this.alternative());
            }
            return { type: "Disjunction", value: alts, loc: this.loc(begin) };
          };
          RegExpParser.prototype.alternative = function() {
            var terms = [];
            var begin = this.idx;
            while (this.isTerm()) {
              terms.push(this.term());
            }
            return { type: "Alternative", value: terms, loc: this.loc(begin) };
          };
          RegExpParser.prototype.term = function() {
            if (this.isAssertion()) {
              return this.assertion();
            } else {
              return this.atom();
            }
          };
          RegExpParser.prototype.assertion = function() {
            var begin = this.idx;
            switch (this.popChar()) {
              case "^":
                return {
                  type: "StartAnchor",
                  loc: this.loc(begin)
                };
              case "$":
                return { type: "EndAnchor", loc: this.loc(begin) };
              case "\\":
                switch (this.popChar()) {
                  case "b":
                    return {
                      type: "WordBoundary",
                      loc: this.loc(begin)
                    };
                  case "B":
                    return {
                      type: "NonWordBoundary",
                      loc: this.loc(begin)
                    };
                }
                throw Error("Invalid Assertion Escape");
              case "(":
                this.consumeChar("?");
                var type;
                switch (this.popChar()) {
                  case "=":
                    type = "Lookahead";
                    break;
                  case "!":
                    type = "NegativeLookahead";
                    break;
                }
                ASSERT_EXISTS(type);
                var disjunction = this.disjunction();
                this.consumeChar(")");
                return {
                  type,
                  value: disjunction,
                  loc: this.loc(begin)
                };
            }
            ASSERT_NEVER_REACH_HERE();
          };
          RegExpParser.prototype.quantifier = function(isBacktracking) {
            var range;
            var begin = this.idx;
            switch (this.popChar()) {
              case "*":
                range = {
                  atLeast: 0,
                  atMost: Infinity
                };
                break;
              case "+":
                range = {
                  atLeast: 1,
                  atMost: Infinity
                };
                break;
              case "?":
                range = {
                  atLeast: 0,
                  atMost: 1
                };
                break;
              case "{":
                var atLeast = this.integerIncludingZero();
                switch (this.popChar()) {
                  case "}":
                    range = {
                      atLeast,
                      atMost: atLeast
                    };
                    break;
                  case ",":
                    var atMost;
                    if (this.isDigit()) {
                      atMost = this.integerIncludingZero();
                      range = {
                        atLeast,
                        atMost
                      };
                    } else {
                      range = {
                        atLeast,
                        atMost: Infinity
                      };
                    }
                    this.consumeChar("}");
                    break;
                }
                if (isBacktracking === true && range === void 0) {
                  return void 0;
                }
                ASSERT_EXISTS(range);
                break;
            }
            if (isBacktracking === true && range === void 0) {
              return void 0;
            }
            ASSERT_EXISTS(range);
            if (this.peekChar(0) === "?") {
              this.consumeChar("?");
              range.greedy = false;
            } else {
              range.greedy = true;
            }
            range.type = "Quantifier";
            range.loc = this.loc(begin);
            return range;
          };
          RegExpParser.prototype.atom = function() {
            var atom;
            var begin = this.idx;
            switch (this.peekChar()) {
              case ".":
                atom = this.dotAll();
                break;
              case "\\":
                atom = this.atomEscape();
                break;
              case "[":
                atom = this.characterClass();
                break;
              case "(":
                atom = this.group();
                break;
            }
            if (atom === void 0 && this.isPatternCharacter()) {
              atom = this.patternCharacter();
            }
            ASSERT_EXISTS(atom);
            atom.loc = this.loc(begin);
            if (this.isQuantifier()) {
              atom.quantifier = this.quantifier();
            }
            return atom;
          };
          RegExpParser.prototype.dotAll = function() {
            this.consumeChar(".");
            return {
              type: "Set",
              complement: true,
              value: [cc("\n"), cc("\r"), cc("\u2028"), cc("\u2029")]
            };
          };
          RegExpParser.prototype.atomEscape = function() {
            this.consumeChar("\\");
            switch (this.peekChar()) {
              case "1":
              case "2":
              case "3":
              case "4":
              case "5":
              case "6":
              case "7":
              case "8":
              case "9":
                return this.decimalEscapeAtom();
              case "d":
              case "D":
              case "s":
              case "S":
              case "w":
              case "W":
                return this.characterClassEscape();
              case "f":
              case "n":
              case "r":
              case "t":
              case "v":
                return this.controlEscapeAtom();
              case "c":
                return this.controlLetterEscapeAtom();
              case "0":
                return this.nulCharacterAtom();
              case "x":
                return this.hexEscapeSequenceAtom();
              case "u":
                return this.regExpUnicodeEscapeSequenceAtom();
              default:
                return this.identityEscapeAtom();
            }
          };
          RegExpParser.prototype.decimalEscapeAtom = function() {
            var value = this.positiveInteger();
            return { type: "GroupBackReference", value };
          };
          RegExpParser.prototype.characterClassEscape = function() {
            var set;
            var complement = false;
            switch (this.popChar()) {
              case "d":
                set = digitsCharCodes;
                break;
              case "D":
                set = digitsCharCodes;
                complement = true;
                break;
              case "s":
                set = whitespaceCodes;
                break;
              case "S":
                set = whitespaceCodes;
                complement = true;
                break;
              case "w":
                set = wordCharCodes;
                break;
              case "W":
                set = wordCharCodes;
                complement = true;
                break;
            }
            ASSERT_EXISTS(set);
            return { type: "Set", value: set, complement };
          };
          RegExpParser.prototype.controlEscapeAtom = function() {
            var escapeCode;
            switch (this.popChar()) {
              case "f":
                escapeCode = cc("\f");
                break;
              case "n":
                escapeCode = cc("\n");
                break;
              case "r":
                escapeCode = cc("\r");
                break;
              case "t":
                escapeCode = cc("	");
                break;
              case "v":
                escapeCode = cc("\v");
                break;
            }
            ASSERT_EXISTS(escapeCode);
            return { type: "Character", value: escapeCode };
          };
          RegExpParser.prototype.controlLetterEscapeAtom = function() {
            this.consumeChar("c");
            var letter = this.popChar();
            if (/[a-zA-Z]/.test(letter) === false) {
              throw Error("Invalid ");
            }
            var letterCode = letter.toUpperCase().charCodeAt(0) - 64;
            return { type: "Character", value: letterCode };
          };
          RegExpParser.prototype.nulCharacterAtom = function() {
            this.consumeChar("0");
            return { type: "Character", value: cc("\0") };
          };
          RegExpParser.prototype.hexEscapeSequenceAtom = function() {
            this.consumeChar("x");
            return this.parseHexDigits(2);
          };
          RegExpParser.prototype.regExpUnicodeEscapeSequenceAtom = function() {
            this.consumeChar("u");
            return this.parseHexDigits(4);
          };
          RegExpParser.prototype.identityEscapeAtom = function() {
            var escapedChar = this.popChar();
            return { type: "Character", value: cc(escapedChar) };
          };
          RegExpParser.prototype.classPatternCharacterAtom = function() {
            switch (this.peekChar()) {
              case "\n":
              case "\r":
              case "\u2028":
              case "\u2029":
              case "\\":
              case "]":
                throw Error("TBD");
              default:
                var nextChar = this.popChar();
                return { type: "Character", value: cc(nextChar) };
            }
          };
          RegExpParser.prototype.characterClass = function() {
            var set = [];
            var complement = false;
            this.consumeChar("[");
            if (this.peekChar(0) === "^") {
              this.consumeChar("^");
              complement = true;
            }
            while (this.isClassAtom()) {
              var from = this.classAtom();
              var isFromSingleChar = from.type === "Character";
              if (isFromSingleChar && this.isRangeDash()) {
                this.consumeChar("-");
                var to = this.classAtom();
                var isToSingleChar = to.type === "Character";
                if (isToSingleChar) {
                  if (to.value < from.value) {
                    throw Error("Range out of order in character class");
                  }
                  set.push({ from: from.value, to: to.value });
                } else {
                  insertToSet(from.value, set);
                  set.push(cc("-"));
                  insertToSet(to.value, set);
                }
              } else {
                insertToSet(from.value, set);
              }
            }
            this.consumeChar("]");
            return { type: "Set", complement, value: set };
          };
          RegExpParser.prototype.classAtom = function() {
            switch (this.peekChar()) {
              case "]":
              case "\n":
              case "\r":
              case "\u2028":
              case "\u2029":
                throw Error("TBD");
              case "\\":
                return this.classEscape();
              default:
                return this.classPatternCharacterAtom();
            }
          };
          RegExpParser.prototype.classEscape = function() {
            this.consumeChar("\\");
            switch (this.peekChar()) {
              case "b":
                this.consumeChar("b");
                return { type: "Character", value: cc("\b") };
              case "d":
              case "D":
              case "s":
              case "S":
              case "w":
              case "W":
                return this.characterClassEscape();
              case "f":
              case "n":
              case "r":
              case "t":
              case "v":
                return this.controlEscapeAtom();
              case "c":
                return this.controlLetterEscapeAtom();
              case "0":
                return this.nulCharacterAtom();
              case "x":
                return this.hexEscapeSequenceAtom();
              case "u":
                return this.regExpUnicodeEscapeSequenceAtom();
              default:
                return this.identityEscapeAtom();
            }
          };
          RegExpParser.prototype.group = function() {
            var capturing = true;
            this.consumeChar("(");
            switch (this.peekChar(0)) {
              case "?":
                this.consumeChar("?");
                this.consumeChar(":");
                capturing = false;
                break;
              default:
                this.groupIdx++;
                break;
            }
            var value = this.disjunction();
            this.consumeChar(")");
            var groupAst = {
              type: "Group",
              capturing,
              value
            };
            if (capturing) {
              groupAst.idx = this.groupIdx;
            }
            return groupAst;
          };
          RegExpParser.prototype.positiveInteger = function() {
            var number = this.popChar();
            if (decimalPatternNoZero.test(number) === false) {
              throw Error("Expecting a positive integer");
            }
            while (decimalPattern.test(this.peekChar(0))) {
              number += this.popChar();
            }
            return parseInt(number, 10);
          };
          RegExpParser.prototype.integerIncludingZero = function() {
            var number = this.popChar();
            if (decimalPattern.test(number) === false) {
              throw Error("Expecting an integer");
            }
            while (decimalPattern.test(this.peekChar(0))) {
              number += this.popChar();
            }
            return parseInt(number, 10);
          };
          RegExpParser.prototype.patternCharacter = function() {
            var nextChar = this.popChar();
            switch (nextChar) {
              case "\n":
              case "\r":
              case "\u2028":
              case "\u2029":
              case "^":
              case "$":
              case "\\":
              case ".":
              case "*":
              case "+":
              case "?":
              case "(":
              case ")":
              case "[":
              case "|":
                throw Error("TBD");
              default:
                return { type: "Character", value: cc(nextChar) };
            }
          };
          RegExpParser.prototype.isRegExpFlag = function() {
            switch (this.peekChar(0)) {
              case "g":
              case "i":
              case "m":
              case "u":
              case "y":
                return true;
              default:
                return false;
            }
          };
          RegExpParser.prototype.isRangeDash = function() {
            return this.peekChar() === "-" && this.isClassAtom(1);
          };
          RegExpParser.prototype.isDigit = function() {
            return decimalPattern.test(this.peekChar(0));
          };
          RegExpParser.prototype.isClassAtom = function(howMuch) {
            if (howMuch === void 0) {
              howMuch = 0;
            }
            switch (this.peekChar(howMuch)) {
              case "]":
              case "\n":
              case "\r":
              case "\u2028":
              case "\u2029":
                return false;
              default:
                return true;
            }
          };
          RegExpParser.prototype.isTerm = function() {
            return this.isAtom() || this.isAssertion();
          };
          RegExpParser.prototype.isAtom = function() {
            if (this.isPatternCharacter()) {
              return true;
            }
            switch (this.peekChar(0)) {
              case ".":
              case "\\":
              case "[":
              case "(":
                return true;
              default:
                return false;
            }
          };
          RegExpParser.prototype.isAssertion = function() {
            switch (this.peekChar(0)) {
              case "^":
              case "$":
                return true;
              case "\\":
                switch (this.peekChar(1)) {
                  case "b":
                  case "B":
                    return true;
                  default:
                    return false;
                }
              case "(":
                return this.peekChar(1) === "?" && (this.peekChar(2) === "=" || this.peekChar(2) === "!");
              default:
                return false;
            }
          };
          RegExpParser.prototype.isQuantifier = function() {
            var prevState = this.saveState();
            try {
              return this.quantifier(true) !== void 0;
            } catch (e) {
              return false;
            } finally {
              this.restoreState(prevState);
            }
          };
          RegExpParser.prototype.isPatternCharacter = function() {
            switch (this.peekChar()) {
              case "^":
              case "$":
              case "\\":
              case ".":
              case "*":
              case "+":
              case "?":
              case "(":
              case ")":
              case "[":
              case "|":
              case "/":
              case "\n":
              case "\r":
              case "\u2028":
              case "\u2029":
                return false;
              default:
                return true;
            }
          };
          RegExpParser.prototype.parseHexDigits = function(howMany) {
            var hexString = "";
            for (var i2 = 0; i2 < howMany; i2++) {
              var hexChar = this.popChar();
              if (hexDigitPattern.test(hexChar) === false) {
                throw Error("Expecting a HexDecimal digits");
              }
              hexString += hexChar;
            }
            var charCode = parseInt(hexString, 16);
            return { type: "Character", value: charCode };
          };
          RegExpParser.prototype.peekChar = function(howMuch) {
            if (howMuch === void 0) {
              howMuch = 0;
            }
            return this.input[this.idx + howMuch];
          };
          RegExpParser.prototype.popChar = function() {
            var nextChar = this.peekChar(0);
            this.consumeChar();
            return nextChar;
          };
          RegExpParser.prototype.consumeChar = function(char) {
            if (char !== void 0 && this.input[this.idx] !== char) {
              throw Error(
                "Expected: '" + char + "' but found: '" + this.input[this.idx] + "' at offset: " + this.idx
              );
            }
            if (this.idx >= this.input.length) {
              throw Error("Unexpected end of input");
            }
            this.idx++;
          };
          RegExpParser.prototype.loc = function(begin) {
            return { begin, end: this.idx };
          };
          var hexDigitPattern = /[0-9a-fA-F]/;
          var decimalPattern = /[0-9]/;
          var decimalPatternNoZero = /[1-9]/;
          function cc(char) {
            return char.charCodeAt(0);
          }
          function insertToSet(item, set) {
            if (item.length !== void 0) {
              item.forEach(function(subItem) {
                set.push(subItem);
              });
            } else {
              set.push(item);
            }
          }
          function addFlag(flagObj, flagKey) {
            if (flagObj[flagKey] === true) {
              throw "duplicate flag " + flagKey;
            }
            flagObj[flagKey] = true;
          }
          function ASSERT_EXISTS(obj) {
            if (obj === void 0) {
              throw Error("Internal Error - Should never get here!");
            }
          }
          function ASSERT_NEVER_REACH_HERE() {
            throw Error("Internal Error - Should never get here!");
          }
          var i;
          var digitsCharCodes = [];
          for (i = cc("0"); i <= cc("9"); i++) {
            digitsCharCodes.push(i);
          }
          var wordCharCodes = [cc("_")].concat(digitsCharCodes);
          for (i = cc("a"); i <= cc("z"); i++) {
            wordCharCodes.push(i);
          }
          for (i = cc("A"); i <= cc("Z"); i++) {
            wordCharCodes.push(i);
          }
          var whitespaceCodes = [
            cc(" "),
            cc("\f"),
            cc("\n"),
            cc("\r"),
            cc("	"),
            cc("\v"),
            cc("	"),
            cc("\xA0"),
            cc("\u1680"),
            cc("\u2000"),
            cc("\u2001"),
            cc("\u2002"),
            cc("\u2003"),
            cc("\u2004"),
            cc("\u2005"),
            cc("\u2006"),
            cc("\u2007"),
            cc("\u2008"),
            cc("\u2009"),
            cc("\u200A"),
            cc("\u2028"),
            cc("\u2029"),
            cc("\u202F"),
            cc("\u205F"),
            cc("\u3000"),
            cc("\uFEFF")
          ];
          function BaseRegExpVisitor() {
          }
          BaseRegExpVisitor.prototype.visitChildren = function(node) {
            for (var key in node) {
              var child = node[key];
              if (node.hasOwnProperty(key)) {
                if (child.type !== void 0) {
                  this.visit(child);
                } else if (Array.isArray(child)) {
                  child.forEach(function(subChild) {
                    this.visit(subChild);
                  }, this);
                }
              }
            }
          };
          BaseRegExpVisitor.prototype.visit = function(node) {
            switch (node.type) {
              case "Pattern":
                this.visitPattern(node);
                break;
              case "Flags":
                this.visitFlags(node);
                break;
              case "Disjunction":
                this.visitDisjunction(node);
                break;
              case "Alternative":
                this.visitAlternative(node);
                break;
              case "StartAnchor":
                this.visitStartAnchor(node);
                break;
              case "EndAnchor":
                this.visitEndAnchor(node);
                break;
              case "WordBoundary":
                this.visitWordBoundary(node);
                break;
              case "NonWordBoundary":
                this.visitNonWordBoundary(node);
                break;
              case "Lookahead":
                this.visitLookahead(node);
                break;
              case "NegativeLookahead":
                this.visitNegativeLookahead(node);
                break;
              case "Character":
                this.visitCharacter(node);
                break;
              case "Set":
                this.visitSet(node);
                break;
              case "Group":
                this.visitGroup(node);
                break;
              case "GroupBackReference":
                this.visitGroupBackReference(node);
                break;
              case "Quantifier":
                this.visitQuantifier(node);
                break;
            }
            this.visitChildren(node);
          };
          BaseRegExpVisitor.prototype.visitPattern = function(node) {
          };
          BaseRegExpVisitor.prototype.visitFlags = function(node) {
          };
          BaseRegExpVisitor.prototype.visitDisjunction = function(node) {
          };
          BaseRegExpVisitor.prototype.visitAlternative = function(node) {
          };
          BaseRegExpVisitor.prototype.visitStartAnchor = function(node) {
          };
          BaseRegExpVisitor.prototype.visitEndAnchor = function(node) {
          };
          BaseRegExpVisitor.prototype.visitWordBoundary = function(node) {
          };
          BaseRegExpVisitor.prototype.visitNonWordBoundary = function(node) {
          };
          BaseRegExpVisitor.prototype.visitLookahead = function(node) {
          };
          BaseRegExpVisitor.prototype.visitNegativeLookahead = function(node) {
          };
          BaseRegExpVisitor.prototype.visitCharacter = function(node) {
          };
          BaseRegExpVisitor.prototype.visitSet = function(node) {
          };
          BaseRegExpVisitor.prototype.visitGroup = function(node) {
          };
          BaseRegExpVisitor.prototype.visitGroupBackReference = function(node) {
          };
          BaseRegExpVisitor.prototype.visitQuantifier = function(node) {
          };
          return {
            RegExpParser,
            BaseRegExpVisitor,
            VERSION: "0.5.0"
          };
        }
      );
    }
  });

  // node_modules/langium/lib/utils/regex-util.js
  var require_regex_util = __commonJS({
    "node_modules/langium/lib/utils/regex-util.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.partialRegex = exports2.partialMatches = exports2.getCaseInsensitivePattern = exports2.escapeRegExp = exports2.isWhitespaceRegExp = exports2.isMultilineComment = exports2.getTerminalParts = void 0;
      var regexp_to_ast_1 = require_regexp_to_ast();
      var regexParser = new regexp_to_ast_1.RegExpParser();
      var TerminalRegexVisitor = class extends regexp_to_ast_1.BaseRegExpVisitor {
        constructor() {
          super(...arguments);
          this.isStarting = true;
          this.endRegexStack = [];
          this.multiline = false;
        }
        get endRegex() {
          return this.endRegexStack.join("");
        }
        reset(regex) {
          this.multiline = false;
          this.regex = regex;
          this.startRegex = "";
          this.isStarting = true;
          this.endRegexStack = [];
        }
        visitGroup(node) {
          if (node.quantifier) {
            this.isStarting = false;
            this.endRegexStack = [];
          }
        }
        visitCharacter(node) {
          const char = String.fromCharCode(node.value);
          if (!this.multiline && char === "\n") {
            this.multiline = true;
          }
          if (node.quantifier) {
            this.isStarting = false;
            this.endRegexStack = [];
          } else {
            const escapedChar = escapeRegExp(char);
            this.endRegexStack.push(escapedChar);
            if (this.isStarting) {
              this.startRegex += escapedChar;
            }
          }
        }
        visitSet(node) {
          if (!this.multiline) {
            const set = this.regex.substring(node.loc.begin, node.loc.end);
            const regex = new RegExp(set);
            this.multiline = Boolean("\n".match(regex));
          }
          if (node.quantifier) {
            this.isStarting = false;
            this.endRegexStack = [];
          } else {
            const set = this.regex.substring(node.loc.begin, node.loc.end);
            this.endRegexStack.push(set);
            if (this.isStarting) {
              this.startRegex += set;
            }
          }
        }
        visitChildren(node) {
          if (node.type === "Group") {
            const group = node;
            if (group.quantifier) {
              return;
            }
          }
          super.visitChildren(node);
        }
      };
      var visitor = new TerminalRegexVisitor();
      function getTerminalParts(regex) {
        try {
          if (typeof regex !== "string") {
            regex = regex.source;
          }
          regex = `/${regex}/`;
          const pattern = regexParser.pattern(regex);
          const parts = [];
          for (const alternative of pattern.value.value) {
            visitor.reset(regex);
            visitor.visit(alternative);
            parts.push({
              start: visitor.startRegex,
              end: visitor.endRegex
            });
          }
          return parts;
        } catch (_a4) {
          return [];
        }
      }
      exports2.getTerminalParts = getTerminalParts;
      function isMultilineComment(regex) {
        try {
          if (typeof regex !== "string") {
            regex = regex.source;
          }
          regex = `/${regex}/`;
          visitor.reset(regex);
          visitor.visit(regexParser.pattern(regex));
          return visitor.multiline;
        } catch (_a4) {
          return false;
        }
      }
      exports2.isMultilineComment = isMultilineComment;
      function isWhitespaceRegExp(value) {
        const regexp = typeof value === "string" ? new RegExp(value) : value;
        return regexp.test(" ");
      }
      exports2.isWhitespaceRegExp = isWhitespaceRegExp;
      function escapeRegExp(value) {
        return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      exports2.escapeRegExp = escapeRegExp;
      function getCaseInsensitivePattern(keyword) {
        return Array.prototype.map.call(keyword, (letter) => /\w/.test(letter) ? `[${letter.toLowerCase()}${letter.toUpperCase()}]` : escapeRegExp(letter)).join("");
      }
      exports2.getCaseInsensitivePattern = getCaseInsensitivePattern;
      function partialMatches(regex, input) {
        const partial = partialRegex(regex);
        const match = input.match(partial);
        return !!match && match[0].length > 0;
      }
      exports2.partialMatches = partialMatches;
      function partialRegex(regex) {
        if (typeof regex === "string") {
          regex = new RegExp(regex);
        }
        const re = regex, source = regex.source;
        let i = 0;
        function process2() {
          let result = "", tmp;
          function appendRaw(nbChars) {
            result += source.substr(i, nbChars);
            i += nbChars;
          }
          function appendOptional(nbChars) {
            result += "(?:" + source.substr(i, nbChars) + "|$)";
            i += nbChars;
          }
          while (i < source.length) {
            switch (source[i]) {
              case "\\":
                switch (source[i + 1]) {
                  case "c":
                    appendOptional(3);
                    break;
                  case "x":
                    appendOptional(4);
                    break;
                  case "u":
                    if (re.unicode) {
                      if (source[i + 2] === "{") {
                        appendOptional(source.indexOf("}", i) - i + 1);
                      } else {
                        appendOptional(6);
                      }
                    } else {
                      appendOptional(2);
                    }
                    break;
                  case "p":
                  case "P":
                    if (re.unicode) {
                      appendOptional(source.indexOf("}", i) - i + 1);
                    } else {
                      appendOptional(2);
                    }
                    break;
                  case "k":
                    appendOptional(source.indexOf(">", i) - i + 1);
                    break;
                  default:
                    appendOptional(2);
                    break;
                }
                break;
              case "[":
                tmp = /\[(?:\\.|.)*?\]/g;
                tmp.lastIndex = i;
                tmp = tmp.exec(source) || [];
                appendOptional(tmp[0].length);
                break;
              case "|":
              case "^":
              case "$":
              case "*":
              case "+":
              case "?":
                appendRaw(1);
                break;
              case "{":
                tmp = /\{\d+,?\d*\}/g;
                tmp.lastIndex = i;
                tmp = tmp.exec(source);
                if (tmp) {
                  appendRaw(tmp[0].length);
                } else {
                  appendOptional(1);
                }
                break;
              case "(":
                if (source[i + 1] === "?") {
                  switch (source[i + 2]) {
                    case ":":
                      result += "(?:";
                      i += 3;
                      result += process2() + "|$)";
                      break;
                    case "=":
                      result += "(?=";
                      i += 3;
                      result += process2() + ")";
                      break;
                    case "!":
                      tmp = i;
                      i += 3;
                      process2();
                      result += source.substr(tmp, i - tmp);
                      break;
                    case "<":
                      switch (source[i + 3]) {
                        case "=":
                        case "!":
                          tmp = i;
                          i += 4;
                          process2();
                          result += source.substr(tmp, i - tmp);
                          break;
                        default:
                          appendRaw(source.indexOf(">", i) - i + 1);
                          result += process2() + "|$)";
                          break;
                      }
                      break;
                  }
                } else {
                  appendRaw(1);
                  result += process2() + "|$)";
                }
                break;
              case ")":
                ++i;
                return result;
              default:
                appendOptional(1);
                break;
            }
          }
          return result;
        }
        return new RegExp(process2(), regex.flags);
      }
      exports2.partialRegex = partialRegex;
    }
  });

  // node_modules/langium/lib/grammar/internal-grammar-util.js
  var require_internal_grammar_util = __commonJS({
    "node_modules/langium/lib/grammar/internal-grammar-util.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.isPrimitiveType = exports2.extractAssignments = exports2.resolveTransitiveImports = exports2.resolveImport = exports2.resolveImportUri = exports2.terminalRegex = exports2.getRuleType = exports2.getActionType = exports2.getExplicitRuleType = exports2.getTypeNameWithoutError = exports2.getTypeName = exports2.getActionAtElement = exports2.isDataType = exports2.hasDataTypeReturn = exports2.isDataTypeRule = exports2.isArrayOperator = exports2.isArrayCardinality = exports2.isOptionalCardinality = void 0;
      var ast = __importStar(require_ast());
      var vscode_uri_1 = require_umd();
      var ast_util_1 = require_ast_util();
      var types_1 = require_types();
      var regex_util_1 = require_regex_util();
      function isOptionalCardinality(cardinality) {
        return cardinality === "?" || cardinality === "*";
      }
      exports2.isOptionalCardinality = isOptionalCardinality;
      function isArrayCardinality(cardinality) {
        return cardinality === "*" || cardinality === "+";
      }
      exports2.isArrayCardinality = isArrayCardinality;
      function isArrayOperator(operator) {
        return operator === "+=";
      }
      exports2.isArrayOperator = isArrayOperator;
      function isDataTypeRule(rule) {
        return isDataTypeRuleInternal(rule, /* @__PURE__ */ new Set());
      }
      exports2.isDataTypeRule = isDataTypeRule;
      function isDataTypeRuleInternal(rule, visited) {
        if (visited.has(rule)) {
          return true;
        } else {
          visited.add(rule);
        }
        for (const node of (0, ast_util_1.streamAllContents)(rule)) {
          if (ast.isRuleCall(node)) {
            if (!node.rule.ref) {
              return false;
            }
            if (ast.isParserRule(node.rule.ref) && !isDataTypeRuleInternal(node.rule.ref, visited)) {
              return false;
            }
          } else if (ast.isAssignment(node)) {
            return false;
          } else if (ast.isAction(node)) {
            return false;
          }
        }
        return Boolean(rule.definition);
      }
      function hasDataTypeReturn(rule) {
        var _a4;
        const returnType = (_a4 = rule.returnType) === null || _a4 === void 0 ? void 0 : _a4.ref;
        return rule.dataType !== void 0 || ast.isType(returnType) && isDataType(returnType);
      }
      exports2.hasDataTypeReturn = hasDataTypeReturn;
      function isDataType(type) {
        return isDataTypeInternal(type.type, /* @__PURE__ */ new Set());
      }
      exports2.isDataType = isDataType;
      function isDataTypeInternal(type, visited) {
        if (visited.has(type)) {
          return true;
        } else {
          visited.add(type);
        }
        if (ast.isArrayType(type)) {
          return false;
        } else if (ast.isReferenceType(type)) {
          return false;
        } else if (ast.isUnionType(type)) {
          return type.types.every((e) => isDataTypeInternal(e, visited));
        } else if (ast.isSimpleType(type)) {
          if (type.primitiveType !== void 0) {
            return true;
          } else if (type.stringType !== void 0) {
            return true;
          } else if (type.typeRef !== void 0) {
            const ref = type.typeRef.ref;
            if (ast.isType(ref)) {
              return isDataTypeInternal(ref.type, visited);
            } else {
              return false;
            }
          } else {
            return false;
          }
        } else {
          return false;
        }
      }
      function getActionAtElement(element) {
        const parent = element.$container;
        if (ast.isGroup(parent)) {
          const elements = parent.elements;
          const index = elements.indexOf(element);
          for (let i = index - 1; i >= 0; i--) {
            const item = elements[i];
            if (ast.isAction(item)) {
              return item;
            } else {
              const action = (0, ast_util_1.streamAllContents)(elements[i]).find(ast.isAction);
              if (action) {
                return action;
              }
            }
          }
        }
        if (ast.isAbstractElement(parent)) {
          return getActionAtElement(parent);
        } else {
          return void 0;
        }
      }
      exports2.getActionAtElement = getActionAtElement;
      function getTypeName(type) {
        var _a4;
        if (ast.isParserRule(type)) {
          return isDataTypeRule(type) ? type.name : (_a4 = getExplicitRuleType(type)) !== null && _a4 !== void 0 ? _a4 : type.name;
        } else if (ast.isInterface(type) || ast.isType(type) || ast.isReturnType(type)) {
          return type.name;
        } else if (ast.isAction(type)) {
          const actionType = getActionType(type);
          if (actionType) {
            return actionType;
          }
        } else if (ast.isInferredType(type)) {
          return type.name;
        }
        throw new types_1.TypeResolutionError("Cannot get name of Unknown Type", type.$cstNode);
      }
      exports2.getTypeName = getTypeName;
      function getTypeNameWithoutError(type) {
        if (!type) {
          return void 0;
        }
        try {
          return getTypeName(type);
        } catch (_a4) {
          return void 0;
        }
      }
      exports2.getTypeNameWithoutError = getTypeNameWithoutError;
      function getExplicitRuleType(rule) {
        if (rule.inferredType) {
          return rule.inferredType.name;
        } else if (rule.dataType) {
          return rule.dataType;
        } else if (rule.returnType) {
          const refType = rule.returnType.ref;
          if (refType) {
            if (ast.isParserRule(refType)) {
              return refType.name;
            } else if (ast.isInterface(refType) || ast.isType(refType)) {
              return refType.name;
            }
          }
        }
        return void 0;
      }
      exports2.getExplicitRuleType = getExplicitRuleType;
      function getActionType(action) {
        var _a4;
        if (action.inferredType) {
          return action.inferredType.name;
        } else if ((_a4 = action.type) === null || _a4 === void 0 ? void 0 : _a4.ref) {
          return getTypeName(action.type.ref);
        }
        return void 0;
      }
      exports2.getActionType = getActionType;
      function getRuleType(rule) {
        var _a4, _b2, _c2;
        if (ast.isTerminalRule(rule)) {
          return (_b2 = (_a4 = rule.type) === null || _a4 === void 0 ? void 0 : _a4.name) !== null && _b2 !== void 0 ? _b2 : "string";
        } else {
          return isDataTypeRule(rule) ? rule.name : (_c2 = getExplicitRuleType(rule)) !== null && _c2 !== void 0 ? _c2 : rule.name;
        }
      }
      exports2.getRuleType = getRuleType;
      function terminalRegex(terminalRule) {
        return abstractElementToRegex(terminalRule.definition);
      }
      exports2.terminalRegex = terminalRegex;
      var WILDCARD = /[\s\S]/.source;
      function abstractElementToRegex(element) {
        if (ast.isTerminalAlternatives(element)) {
          return terminalAlternativesToRegex(element);
        } else if (ast.isTerminalGroup(element)) {
          return terminalGroupToRegex(element);
        } else if (ast.isCharacterRange(element)) {
          return characterRangeToRegex(element);
        } else if (ast.isTerminalRuleCall(element)) {
          const rule = element.rule.ref;
          if (!rule) {
            throw new Error("Missing rule reference.");
          }
          return withCardinality(terminalRegex(rule), {
            cardinality: element.cardinality,
            lookahead: element.lookahead
          });
        } else if (ast.isNegatedToken(element)) {
          return negateTokenToRegex(element);
        } else if (ast.isUntilToken(element)) {
          return untilTokenToRegex(element);
        } else if (ast.isRegexToken(element)) {
          return withCardinality(element.regex, {
            cardinality: element.cardinality,
            lookahead: element.lookahead,
            wrap: false
          });
        } else if (ast.isWildcard(element)) {
          return withCardinality(WILDCARD, {
            cardinality: element.cardinality,
            lookahead: element.lookahead
          });
        } else {
          throw new Error(`Invalid terminal element: ${element === null || element === void 0 ? void 0 : element.$type}`);
        }
      }
      function terminalAlternativesToRegex(alternatives) {
        return withCardinality(alternatives.elements.map(abstractElementToRegex).join("|"), {
          cardinality: alternatives.cardinality,
          lookahead: alternatives.lookahead
        });
      }
      function terminalGroupToRegex(group) {
        return withCardinality(group.elements.map(abstractElementToRegex).join(""), {
          cardinality: group.cardinality,
          lookahead: group.lookahead
        });
      }
      function untilTokenToRegex(until) {
        return withCardinality(`${WILDCARD}*?${abstractElementToRegex(until.terminal)}`, {
          cardinality: until.cardinality,
          lookahead: until.lookahead
        });
      }
      function negateTokenToRegex(negate) {
        return withCardinality(`(?!${abstractElementToRegex(negate.terminal)})${WILDCARD}*?`, {
          cardinality: negate.cardinality,
          lookahead: negate.lookahead
        });
      }
      function characterRangeToRegex(range) {
        if (range.right) {
          return withCardinality(`[${keywordToRegex(range.left)}-${keywordToRegex(range.right)}]`, {
            cardinality: range.cardinality,
            lookahead: range.lookahead,
            wrap: false
          });
        }
        return withCardinality(keywordToRegex(range.left), {
          cardinality: range.cardinality,
          lookahead: range.lookahead,
          wrap: false
        });
      }
      function keywordToRegex(keyword) {
        return (0, regex_util_1.escapeRegExp)(keyword.value);
      }
      function withCardinality(regex, options) {
        var _a4;
        if (options.wrap !== false || options.lookahead) {
          regex = `(${(_a4 = options.lookahead) !== null && _a4 !== void 0 ? _a4 : ""}${regex})`;
        }
        if (options.cardinality) {
          return `${regex}${options.cardinality}`;
        }
        return regex;
      }
      function resolveImportUri(imp) {
        if (imp.path === void 0 || imp.path.length === 0) {
          return void 0;
        }
        const dirUri = vscode_uri_1.Utils.dirname((0, ast_util_1.getDocument)(imp).uri);
        let grammarPath = imp.path;
        if (!grammarPath.endsWith(".langium")) {
          grammarPath += ".langium";
        }
        return vscode_uri_1.Utils.resolvePath(dirUri, grammarPath);
      }
      exports2.resolveImportUri = resolveImportUri;
      function resolveImport(documents, imp) {
        const resolvedUri = resolveImportUri(imp);
        try {
          if (resolvedUri) {
            const resolvedDocument = documents.getOrCreateDocument(resolvedUri);
            const node = resolvedDocument.parseResult.value;
            if (ast.isGrammar(node)) {
              return node;
            }
          }
        } catch (_a4) {
        }
        return void 0;
      }
      exports2.resolveImport = resolveImport;
      function resolveTransitiveImports(documents, grammarOrImport) {
        if (ast.isGrammarImport(grammarOrImport)) {
          const resolvedGrammar = resolveImport(documents, grammarOrImport);
          if (resolvedGrammar) {
            const transitiveGrammars = resolveTransitiveImportsInternal(documents, resolvedGrammar);
            transitiveGrammars.push(resolvedGrammar);
            return transitiveGrammars;
          }
          return [];
        } else {
          return resolveTransitiveImportsInternal(documents, grammarOrImport);
        }
      }
      exports2.resolveTransitiveImports = resolveTransitiveImports;
      function resolveTransitiveImportsInternal(documents, grammar, initialGrammar = grammar, visited = /* @__PURE__ */ new Set(), grammars = /* @__PURE__ */ new Set()) {
        const doc = (0, ast_util_1.getDocument)(grammar);
        if (initialGrammar !== grammar) {
          grammars.add(grammar);
        }
        if (!visited.has(doc.uri)) {
          visited.add(doc.uri);
          for (const imp of grammar.imports) {
            const importedGrammar = resolveImport(documents, imp);
            if (importedGrammar) {
              resolveTransitiveImportsInternal(documents, importedGrammar, initialGrammar, visited, grammars);
            }
          }
        }
        return Array.from(grammars);
      }
      function extractAssignments(element) {
        if (ast.isAssignment(element)) {
          return [element];
        } else if (ast.isAlternatives(element) || ast.isGroup(element) || ast.isUnorderedGroup(element)) {
          return element.elements.flatMap((e) => extractAssignments(e));
        } else if (ast.isRuleCall(element) && element.rule.ref) {
          return extractAssignments(element.rule.ref.definition);
        }
        return [];
      }
      exports2.extractAssignments = extractAssignments;
      var primitiveTypes = ["string", "number", "boolean", "Date", "bigint"];
      function isPrimitiveType(type) {
        return primitiveTypes.includes(type);
      }
      exports2.isPrimitiveType = isPrimitiveType;
    }
  });

  // node_modules/langium/lib/grammar/type-system/type-collector/plain-types.js
  var require_plain_types = __commonJS({
    "node_modules/langium/lib/grammar/type-system/type-collector/plain-types.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.flattenPlainType = exports2.mergePropertyTypes = exports2.plainToTypes = exports2.isPlainStringType = exports2.isPlainPrimitiveType = exports2.isPlainValueType = exports2.isPlainPropertyUnion = exports2.isPlainArrayType = exports2.isPlainReferenceType = exports2.isPlainUnion = exports2.isPlainInterface = void 0;
      var types_1 = require_types();
      function isPlainInterface(type) {
        return !isPlainUnion(type);
      }
      exports2.isPlainInterface = isPlainInterface;
      function isPlainUnion(type) {
        return "type" in type;
      }
      exports2.isPlainUnion = isPlainUnion;
      function isPlainReferenceType(propertyType) {
        return "referenceType" in propertyType;
      }
      exports2.isPlainReferenceType = isPlainReferenceType;
      function isPlainArrayType(propertyType) {
        return "elementType" in propertyType;
      }
      exports2.isPlainArrayType = isPlainArrayType;
      function isPlainPropertyUnion(propertyType) {
        return "types" in propertyType;
      }
      exports2.isPlainPropertyUnion = isPlainPropertyUnion;
      function isPlainValueType(propertyType) {
        return "value" in propertyType;
      }
      exports2.isPlainValueType = isPlainValueType;
      function isPlainPrimitiveType(propertyType) {
        return "primitive" in propertyType;
      }
      exports2.isPlainPrimitiveType = isPlainPrimitiveType;
      function isPlainStringType(propertyType) {
        return "string" in propertyType;
      }
      exports2.isPlainStringType = isPlainStringType;
      function plainToTypes(plain) {
        const interfaceTypes = /* @__PURE__ */ new Map();
        const unionTypes = /* @__PURE__ */ new Map();
        for (const interfaceValue of plain.interfaces) {
          const type = new types_1.InterfaceType(interfaceValue.name, interfaceValue.declared, interfaceValue.abstract);
          interfaceTypes.set(interfaceValue.name, type);
        }
        for (const unionValue of plain.unions) {
          const type = new types_1.UnionType(unionValue.name, {
            declared: unionValue.declared,
            dataType: unionValue.dataType
          });
          unionTypes.set(unionValue.name, type);
        }
        for (const interfaceValue of plain.interfaces) {
          const type = interfaceTypes.get(interfaceValue.name);
          for (const superTypeName of interfaceValue.superTypes) {
            const superType = interfaceTypes.get(superTypeName) || unionTypes.get(superTypeName);
            if (superType) {
              type.superTypes.add(superType);
            }
          }
          for (const subTypeName of interfaceValue.subTypes) {
            const subType = interfaceTypes.get(subTypeName) || unionTypes.get(subTypeName);
            if (subType) {
              type.subTypes.add(subType);
            }
          }
          for (const property of interfaceValue.properties) {
            const prop = plainToProperty(property, interfaceTypes, unionTypes);
            type.properties.push(prop);
          }
        }
        for (const unionValue of plain.unions) {
          const type = unionTypes.get(unionValue.name);
          type.type = plainToPropertyType(unionValue.type, type, interfaceTypes, unionTypes);
        }
        return {
          interfaces: Array.from(interfaceTypes.values()),
          unions: Array.from(unionTypes.values())
        };
      }
      exports2.plainToTypes = plainToTypes;
      function plainToProperty(property, interfaces, unions) {
        return {
          name: property.name,
          optional: property.optional,
          astNodes: property.astNodes,
          type: plainToPropertyType(property.type, void 0, interfaces, unions)
        };
      }
      function plainToPropertyType(type, union, interfaces, unions) {
        if (isPlainArrayType(type)) {
          return {
            elementType: plainToPropertyType(type.elementType, union, interfaces, unions)
          };
        } else if (isPlainReferenceType(type)) {
          return {
            referenceType: plainToPropertyType(type.referenceType, void 0, interfaces, unions)
          };
        } else if (isPlainPropertyUnion(type)) {
          return {
            types: type.types.map((e) => plainToPropertyType(e, union, interfaces, unions))
          };
        } else if (isPlainStringType(type)) {
          return {
            string: type.string
          };
        } else if (isPlainPrimitiveType(type)) {
          return {
            primitive: type.primitive,
            regex: type.regex
          };
        } else if (isPlainValueType(type)) {
          const value = interfaces.get(type.value) || unions.get(type.value);
          if (!value) {
            return {
              primitive: "unknown"
            };
          }
          if (union) {
            union.subTypes.add(value);
          }
          return {
            value
          };
        } else {
          throw new Error("Invalid property type");
        }
      }
      function mergePropertyTypes(first, second) {
        const flattenedFirst = flattenPlainType(first);
        const flattenedSecond = flattenPlainType(second);
        for (const second2 of flattenedSecond) {
          if (!includesType(flattenedFirst, second2)) {
            flattenedFirst.push(second2);
          }
        }
        if (flattenedFirst.length === 1) {
          return flattenedFirst[0];
        } else {
          return {
            types: flattenedFirst
          };
        }
      }
      exports2.mergePropertyTypes = mergePropertyTypes;
      function includesType(list, value) {
        return list.some((e) => typeEquals(e, value));
      }
      function typeEquals(first, second) {
        if (isPlainArrayType(first) && isPlainArrayType(second)) {
          return typeEquals(first.elementType, second.elementType);
        } else if (isPlainReferenceType(first) && isPlainReferenceType(second)) {
          return typeEquals(first.referenceType, second.referenceType);
        } else if (isPlainValueType(first) && isPlainValueType(second)) {
          return first.value === second.value;
        } else {
          return false;
        }
      }
      function flattenPlainType(type) {
        if (isPlainPropertyUnion(type)) {
          return type.types.flatMap((e) => flattenPlainType(e));
        } else {
          return [type];
        }
      }
      exports2.flattenPlainType = flattenPlainType;
    }
  });

  // node_modules/langium/lib/grammar/type-system/type-collector/inferred-types.js
  var require_inferred_types = __commonJS({
    "node_modules/langium/lib/grammar/type-system/type-collector/inferred-types.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.collectInferredTypes = void 0;
      var name_provider_1 = require_name_provider();
      var collections_1 = require_collections();
      var ast_1 = require_ast();
      var internal_grammar_util_1 = require_internal_grammar_util();
      var plain_types_1 = require_plain_types();
      var TypeGraph = class {
        constructor(context, root) {
          this.context = context;
          this.root = root;
        }
        getTypes() {
          const rootType = {
            name: this.root.name,
            properties: this.root.properties,
            ruleCalls: this.root.ruleCalls,
            super: []
          };
          if (this.root.children.length === 0) {
            return [{ alt: rootType, next: [] }];
          } else {
            return this.applyNext(this.root, {
              alt: rootType,
              next: this.root.children
            });
          }
        }
        applyNext(root, nextPath) {
          const splits = this.splitType(nextPath.alt, nextPath.next.length);
          const paths = [];
          for (let i = 0; i < nextPath.next.length; i++) {
            const split = splits[i];
            const part = nextPath.next[i];
            if (part.actionWithAssignment) {
              paths.push({
                alt: copyTypeAlternative(split),
                next: []
              });
            }
            if (part.name !== void 0 && part.name !== split.name) {
              if (part.actionWithAssignment) {
                split.properties = [];
                split.ruleCalls = [];
                split.super = [root.name];
                split.name = part.name;
              } else {
                split.super = [split.name, ...split.ruleCalls];
                split.properties = [];
                split.ruleCalls = [];
                split.name = part.name;
              }
            }
            split.properties.push(...part.properties);
            split.ruleCalls.push(...part.ruleCalls);
            const path = {
              alt: split,
              next: part.children
            };
            if (path.next.length === 0) {
              path.alt.super = path.alt.super.filter((e) => e !== path.alt.name);
              paths.push(path);
            } else {
              paths.push(...this.applyNext(root, path));
            }
          }
          return flattenTypes(paths);
        }
        splitType(type, count) {
          const alternatives = [];
          for (let i = 0; i < count; i++) {
            alternatives.push(copyTypeAlternative(type));
          }
          return alternatives;
        }
        getSuperTypes(node) {
          const set = /* @__PURE__ */ new Set();
          this.collectSuperTypes(node, node, set);
          return Array.from(set);
        }
        collectSuperTypes(original, part, set) {
          if (part.ruleCalls.length > 0) {
            for (const ruleCall of part.ruleCalls) {
              set.add(ruleCall);
            }
            return;
          }
          for (const parent of part.parents) {
            if (original.name === void 0) {
              this.collectSuperTypes(parent, parent, set);
            } else if (parent.name !== void 0 && parent.name !== original.name) {
              set.add(parent.name);
            } else {
              this.collectSuperTypes(original, parent, set);
            }
          }
          if (part.parents.length === 0 && part.name) {
            set.add(part.name);
          }
        }
        connect(parent, children) {
          children.parents.push(parent);
          parent.children.push(children);
          return children;
        }
        merge(...parts) {
          if (parts.length === 1) {
            return parts[0];
          } else if (parts.length === 0) {
            throw new Error("No parts to merge");
          }
          const node = newTypePart();
          node.parents = parts;
          for (const parent of parts) {
            parent.children.push(node);
          }
          return node;
        }
        hasLeafNode(part) {
          return this.partHasLeafNode(part);
        }
        partHasLeafNode(part, ignore) {
          if (part.children.some((e) => e !== ignore)) {
            return true;
          } else if (part.name) {
            return false;
          } else {
            return part.parents.some((e) => this.partHasLeafNode(e, part));
          }
        }
      };
      function copyTypePart(value) {
        return {
          name: value.name,
          children: [],
          parents: [],
          actionWithAssignment: value.actionWithAssignment,
          ruleCalls: [...value.ruleCalls],
          properties: value.properties.map(copyProperty)
        };
      }
      function copyTypeAlternative(value) {
        return {
          name: value.name,
          super: value.super,
          ruleCalls: value.ruleCalls,
          properties: value.properties.map((e) => copyProperty(e))
        };
      }
      function copyProperty(value) {
        return {
          name: value.name,
          optional: value.optional,
          type: value.type,
          astNodes: value.astNodes
        };
      }
      function collectInferredTypes(parserRules, datatypeRules, declared) {
        const allTypes = [];
        const context = {
          fragments: /* @__PURE__ */ new Map()
        };
        for (const rule of parserRules) {
          allTypes.push(...getRuleTypes(context, rule));
        }
        const interfaces = calculateInterfaces(allTypes);
        const unions = buildSuperUnions(interfaces);
        const astTypes = extractUnions(interfaces, unions, declared);
        for (const rule of datatypeRules) {
          const type = getDataRuleType(rule);
          astTypes.unions.push({
            name: rule.name,
            declared: false,
            type,
            subTypes: /* @__PURE__ */ new Set(),
            superTypes: /* @__PURE__ */ new Set(),
            dataType: rule.dataType
          });
        }
        return astTypes;
      }
      exports2.collectInferredTypes = collectInferredTypes;
      function getDataRuleType(rule) {
        if (rule.dataType && rule.dataType !== "string") {
          return {
            primitive: rule.dataType
          };
        }
        let cancelled = false;
        const cancel = () => {
          cancelled = true;
          return {
            primitive: "unknown"
          };
        };
        const type = buildDataRuleType(rule.definition, cancel);
        if (cancelled) {
          return {
            primitive: "string"
          };
        } else {
          return type;
        }
      }
      function buildDataRuleType(element, cancel) {
        var _a4, _b2, _c2;
        if (element.cardinality) {
          return cancel();
        }
        if ((0, ast_1.isAlternatives)(element)) {
          return {
            types: element.elements.map((e) => buildDataRuleType(e, cancel))
          };
        } else if ((0, ast_1.isGroup)(element) || (0, ast_1.isUnorderedGroup)(element)) {
          if (element.elements.length !== 1) {
            return cancel();
          } else {
            return buildDataRuleType(element.elements[0], cancel);
          }
        } else if ((0, ast_1.isRuleCall)(element)) {
          const ref = (_a4 = element.rule) === null || _a4 === void 0 ? void 0 : _a4.ref;
          if (ref) {
            if ((0, ast_1.isTerminalRule)(ref)) {
              return {
                primitive: (_c2 = (_b2 = ref.type) === null || _b2 === void 0 ? void 0 : _b2.name) !== null && _c2 !== void 0 ? _c2 : "string",
                regex: (0, internal_grammar_util_1.terminalRegex)(ref)
              };
            } else {
              return {
                value: ref.name
              };
            }
          } else {
            return cancel();
          }
        } else if ((0, ast_1.isKeyword)(element)) {
          return {
            string: element.value
          };
        }
        return cancel();
      }
      function getRuleTypes(context, rule) {
        const type = newTypePart(rule);
        const graph = new TypeGraph(context, type);
        if (rule.definition) {
          collectElement(graph, graph.root, rule.definition);
        }
        return graph.getTypes();
      }
      function newTypePart(element) {
        return {
          name: (0, ast_1.isParserRule)(element) || (0, ast_1.isAction)(element) ? (0, internal_grammar_util_1.getTypeNameWithoutError)(element) : element,
          properties: [],
          ruleCalls: [],
          children: [],
          parents: [],
          actionWithAssignment: false
        };
      }
      function collectElement(graph, current, element) {
        const optional = (0, internal_grammar_util_1.isOptionalCardinality)(element.cardinality);
        if ((0, ast_1.isAlternatives)(element)) {
          const children = [];
          if (optional) {
            children.push(graph.connect(current, newTypePart()));
          }
          for (const alt of element.elements) {
            const altType = graph.connect(current, newTypePart());
            children.push(collectElement(graph, altType, alt));
          }
          return graph.merge(...children);
        } else if ((0, ast_1.isGroup)(element) || (0, ast_1.isUnorderedGroup)(element)) {
          let groupNode = graph.connect(current, newTypePart());
          let skipNode;
          if (optional) {
            skipNode = graph.connect(current, newTypePart());
          }
          for (const item of element.elements) {
            groupNode = collectElement(graph, groupNode, item);
          }
          if (skipNode) {
            return graph.merge(skipNode, groupNode);
          } else {
            return groupNode;
          }
        } else if ((0, ast_1.isAction)(element)) {
          return addAction(graph, current, element);
        } else if ((0, ast_1.isAssignment)(element)) {
          addAssignment(current, element);
        } else if ((0, ast_1.isRuleCall)(element)) {
          addRuleCall(graph, current, element);
        }
        return current;
      }
      function addAction(graph, parent, action) {
        var _a4;
        if (!graph.hasLeafNode(parent)) {
          const copy = copyTypePart(parent);
          graph.connect(parent, copy);
        }
        const typeNode = graph.connect(parent, newTypePart(action));
        if (action.type) {
          const type = (_a4 = action.type) === null || _a4 === void 0 ? void 0 : _a4.ref;
          if (type && (0, name_provider_1.isNamed)(type))
            typeNode.name = type.name;
        }
        if (action.feature && action.operator) {
          typeNode.actionWithAssignment = true;
          typeNode.properties.push({
            name: action.feature,
            optional: false,
            type: toPropertyType(action.operator === "+=", false, graph.root.ruleCalls.length !== 0 ? graph.root.ruleCalls : graph.getSuperTypes(typeNode)),
            astNodes: /* @__PURE__ */ new Set([action])
          });
        }
        return typeNode;
      }
      function addAssignment(current, assignment) {
        const typeItems = { types: /* @__PURE__ */ new Set(), reference: false };
        findTypes(assignment.terminal, typeItems);
        const type = toPropertyType(assignment.operator === "+=", typeItems.reference, assignment.operator === "?=" ? ["boolean"] : Array.from(typeItems.types));
        current.properties.push({
          name: assignment.feature,
          optional: (0, internal_grammar_util_1.isOptionalCardinality)(assignment.cardinality),
          type,
          astNodes: /* @__PURE__ */ new Set([assignment])
        });
      }
      function findTypes(terminal, types) {
        if ((0, ast_1.isAlternatives)(terminal) || (0, ast_1.isUnorderedGroup)(terminal) || (0, ast_1.isGroup)(terminal)) {
          for (const element of terminal.elements) {
            findTypes(element, types);
          }
        } else if ((0, ast_1.isKeyword)(terminal)) {
          types.types.add(`'${terminal.value}'`);
        } else if ((0, ast_1.isRuleCall)(terminal) && terminal.rule.ref) {
          types.types.add((0, internal_grammar_util_1.getRuleType)(terminal.rule.ref));
        } else if ((0, ast_1.isCrossReference)(terminal) && terminal.type.ref) {
          const refTypeName = (0, internal_grammar_util_1.getTypeNameWithoutError)(terminal.type.ref);
          if (refTypeName) {
            types.types.add(refTypeName);
          }
          types.reference = true;
        }
      }
      function addRuleCall(graph, current, ruleCall) {
        const rule = ruleCall.rule.ref;
        if ((0, ast_1.isParserRule)(rule) && rule.fragment) {
          const properties = getFragmentProperties(rule, graph.context);
          if ((0, internal_grammar_util_1.isOptionalCardinality)(ruleCall.cardinality)) {
            current.properties.push(...properties.map((e) => Object.assign(Object.assign({}, e), { optional: true })));
          } else {
            current.properties.push(...properties);
          }
        } else if ((0, ast_1.isParserRule)(rule)) {
          current.ruleCalls.push((0, internal_grammar_util_1.getRuleType)(rule));
        }
      }
      function getFragmentProperties(fragment, context) {
        const existing = context.fragments.get(fragment);
        if (existing) {
          return existing;
        }
        const properties = [];
        context.fragments.set(fragment, properties);
        const fragmentName = (0, internal_grammar_util_1.getTypeNameWithoutError)(fragment);
        const typeAlternatives = getRuleTypes(context, fragment).filter((e) => e.alt.name === fragmentName);
        properties.push(...typeAlternatives.flatMap((e) => e.alt.properties));
        return properties;
      }
      function calculateInterfaces(alternatives) {
        const interfaces = /* @__PURE__ */ new Map();
        const ruleCallAlternatives = [];
        const flattened = flattenTypes(alternatives).map((e) => e.alt);
        for (const flat of flattened) {
          const interfaceType = {
            name: flat.name,
            properties: flat.properties,
            superTypes: new Set(flat.super),
            subTypes: /* @__PURE__ */ new Set(),
            declared: false,
            abstract: false
          };
          interfaces.set(interfaceType.name, interfaceType);
          if (flat.ruleCalls.length > 0) {
            ruleCallAlternatives.push(flat);
            flat.ruleCalls.forEach((e) => {
              if (e !== interfaceType.name) {
                interfaceType.subTypes.add(e);
              }
            });
          }
        }
        for (const ruleCallType of ruleCallAlternatives) {
          for (const ruleCall of ruleCallType.ruleCalls) {
            const calledInterface = interfaces.get(ruleCall);
            if (calledInterface) {
              if (calledInterface.name !== ruleCallType.name) {
                calledInterface.superTypes.add(ruleCallType.name);
              }
            }
          }
        }
        return Array.from(interfaces.values());
      }
      function flattenTypes(alternatives) {
        const nameToAlternatives = alternatives.reduce((acc, e) => acc.add(e.alt.name, e), new collections_1.MultiMap());
        const types = [];
        for (const [name, namedAlternatives] of nameToAlternatives.entriesGroupedByKey()) {
          const properties = [];
          const ruleCalls = /* @__PURE__ */ new Set();
          const type = { alt: { name, properties, ruleCalls: [], super: [] }, next: [] };
          for (const path of namedAlternatives) {
            const alt = path.alt;
            type.alt.super.push(...alt.super);
            type.next.push(...path.next);
            const altProperties = alt.properties;
            for (const altProperty of altProperties) {
              const existingProperty = properties.find((e) => e.name === altProperty.name);
              if (existingProperty) {
                existingProperty.type = (0, plain_types_1.mergePropertyTypes)(existingProperty.type, altProperty.type);
                altProperty.astNodes.forEach((e) => existingProperty.astNodes.add(e));
              } else {
                properties.push(Object.assign({}, altProperty));
              }
            }
            alt.ruleCalls.forEach((ruleCall) => ruleCalls.add(ruleCall));
          }
          for (const path of namedAlternatives) {
            const alt = path.alt;
            if (alt.ruleCalls.length === 0) {
              for (const property of properties) {
                if (!alt.properties.find((e) => e.name === property.name)) {
                  property.optional = true;
                }
              }
            }
          }
          type.alt.ruleCalls = Array.from(ruleCalls);
          types.push(type);
        }
        return types;
      }
      function buildSuperUnions(interfaces) {
        const interfaceMap = new Map(interfaces.map((e) => [e.name, e]));
        const unions = [];
        const allSupertypes = new collections_1.MultiMap();
        for (const interfaceType of interfaces) {
          for (const superType of interfaceType.superTypes) {
            allSupertypes.add(superType, interfaceType.name);
          }
        }
        for (const [superType, types] of allSupertypes.entriesGroupedByKey()) {
          if (!interfaceMap.has(superType)) {
            const union = {
              declared: false,
              name: superType,
              subTypes: /* @__PURE__ */ new Set(),
              superTypes: /* @__PURE__ */ new Set(),
              type: toPropertyType(false, false, types)
            };
            unions.push(union);
          }
        }
        return unions;
      }
      function extractUnions(interfaces, unions, declared) {
        const subTypes = new collections_1.MultiMap();
        for (const interfaceType of interfaces) {
          for (const superTypeName of interfaceType.superTypes) {
            subTypes.add(superTypeName, interfaceType.name);
          }
        }
        const declaredInterfaces = new Set(declared.interfaces.map((e) => e.name));
        const astTypes = { interfaces: [], unions };
        const unionTypes = new Map(unions.map((e) => [e.name, e]));
        for (const interfaceType of interfaces) {
          const interfaceSubTypes = new Set(subTypes.get(interfaceType.name));
          if (interfaceType.properties.length === 0 && interfaceSubTypes.size > 0) {
            if (declaredInterfaces.has(interfaceType.name)) {
              interfaceType.abstract = true;
              astTypes.interfaces.push(interfaceType);
            } else {
              const interfaceTypeValue = toPropertyType(false, false, Array.from(interfaceSubTypes));
              const existingUnion = unionTypes.get(interfaceType.name);
              if (existingUnion) {
                existingUnion.type = (0, plain_types_1.mergePropertyTypes)(existingUnion.type, interfaceTypeValue);
              } else {
                const unionType = {
                  name: interfaceType.name,
                  declared: false,
                  subTypes: interfaceSubTypes,
                  superTypes: interfaceType.superTypes,
                  type: interfaceTypeValue
                };
                astTypes.unions.push(unionType);
                unionTypes.set(interfaceType.name, unionType);
              }
            }
          } else {
            astTypes.interfaces.push(interfaceType);
          }
        }
        for (const interfaceType of astTypes.interfaces) {
          interfaceType.superTypes = new Set([...interfaceType.superTypes].filter((superType) => !unionTypes.has(superType)));
        }
        return astTypes;
      }
      function toPropertyType(array, reference, types) {
        if (array) {
          return {
            elementType: toPropertyType(false, reference, types)
          };
        } else if (reference) {
          return {
            referenceType: toPropertyType(false, false, types)
          };
        } else if (types.length === 1) {
          const type = types[0];
          if (type.startsWith("'")) {
            return {
              string: type.substring(1, type.length - 1)
            };
          }
          if ((0, internal_grammar_util_1.isPrimitiveType)(type)) {
            return {
              primitive: type
            };
          } else {
            return {
              value: type
            };
          }
        } else {
          return {
            types: types.map((e) => toPropertyType(false, false, [e]))
          };
        }
      }
    }
  });

  // node_modules/langium/lib/grammar/type-system/type-collector/declared-types.js
  var require_declared_types = __commonJS({
    "node_modules/langium/lib/grammar/type-system/type-collector/declared-types.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.typeDefinitionToPropertyType = exports2.collectDeclaredTypes = void 0;
      var ast_1 = require_ast();
      var internal_grammar_util_1 = require_internal_grammar_util();
      function collectDeclaredTypes(interfaces, unions) {
        const declaredTypes = { unions: [], interfaces: [] };
        for (const type of interfaces) {
          const properties = [];
          for (const attribute of type.attributes) {
            properties.push({
              name: attribute.name,
              optional: attribute.isOptional,
              astNodes: /* @__PURE__ */ new Set([attribute]),
              type: typeDefinitionToPropertyType(attribute.type)
            });
          }
          const superTypes = /* @__PURE__ */ new Set();
          for (const superType of type.superTypes) {
            if (superType.ref) {
              superTypes.add((0, internal_grammar_util_1.getTypeName)(superType.ref));
            }
          }
          const interfaceType = {
            name: type.name,
            declared: true,
            abstract: false,
            properties,
            superTypes,
            subTypes: /* @__PURE__ */ new Set()
          };
          declaredTypes.interfaces.push(interfaceType);
        }
        for (const union of unions) {
          const unionType = {
            name: union.name,
            declared: true,
            type: typeDefinitionToPropertyType(union.type),
            superTypes: /* @__PURE__ */ new Set(),
            subTypes: /* @__PURE__ */ new Set()
          };
          declaredTypes.unions.push(unionType);
        }
        return declaredTypes;
      }
      exports2.collectDeclaredTypes = collectDeclaredTypes;
      function typeDefinitionToPropertyType(type) {
        if ((0, ast_1.isArrayType)(type)) {
          return {
            elementType: typeDefinitionToPropertyType(type.elementType)
          };
        } else if ((0, ast_1.isReferenceType)(type)) {
          return {
            referenceType: typeDefinitionToPropertyType(type.referenceType)
          };
        } else if ((0, ast_1.isUnionType)(type)) {
          return {
            types: type.types.map(typeDefinitionToPropertyType)
          };
        } else if ((0, ast_1.isSimpleType)(type)) {
          let value;
          if (type.primitiveType) {
            value = type.primitiveType;
            return {
              primitive: value
            };
          } else if (type.stringType) {
            value = type.stringType;
            return {
              string: value
            };
          } else if (type.typeRef) {
            const ref = type.typeRef.ref;
            const value2 = (0, internal_grammar_util_1.getTypeNameWithoutError)(ref);
            if (value2) {
              if ((0, internal_grammar_util_1.isPrimitiveType)(value2)) {
                return {
                  primitive: value2
                };
              } else {
                return {
                  value: value2
                };
              }
            }
          }
        }
        return {
          primitive: "unknown"
        };
      }
      exports2.typeDefinitionToPropertyType = typeDefinitionToPropertyType;
    }
  });

  // node_modules/langium/lib/grammar/type-system/type-collector/all-types.js
  var require_all_types = __commonJS({
    "node_modules/langium/lib/grammar/type-system/type-collector/all-types.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.collectAllAstResources = exports2.collectTypeResources = void 0;
      var inferred_types_1 = require_inferred_types();
      var declared_types_1 = require_declared_types();
      var ast_util_1 = require_ast_util();
      var ast_1 = require_ast();
      var internal_grammar_util_1 = require_internal_grammar_util();
      function collectTypeResources(grammars, documents) {
        const astResources = collectAllAstResources(grammars, documents);
        const declared = (0, declared_types_1.collectDeclaredTypes)(astResources.interfaces, astResources.types);
        const inferred = (0, inferred_types_1.collectInferredTypes)(astResources.parserRules, astResources.datatypeRules, declared);
        return {
          astResources,
          inferred,
          declared
        };
      }
      exports2.collectTypeResources = collectTypeResources;
      function collectAllAstResources(grammars, documents, visited = /* @__PURE__ */ new Set(), astResources = { parserRules: [], datatypeRules: [], interfaces: [], types: [] }) {
        if (!Array.isArray(grammars))
          grammars = [grammars];
        for (const grammar of grammars) {
          const doc = (0, ast_util_1.getDocument)(grammar);
          if (visited.has(doc.uri)) {
            continue;
          }
          visited.add(doc.uri);
          for (const rule of grammar.rules) {
            if ((0, ast_1.isParserRule)(rule) && !rule.fragment) {
              if ((0, internal_grammar_util_1.isDataTypeRule)(rule)) {
                astResources.datatypeRules.push(rule);
              } else {
                astResources.parserRules.push(rule);
              }
            }
          }
          grammar.interfaces.forEach((e) => astResources.interfaces.push(e));
          grammar.types.forEach((e) => astResources.types.push(e));
          if (documents) {
            const importedGrammars = grammar.imports.map((e) => (0, internal_grammar_util_1.resolveImport)(documents, e)).filter((e) => e !== void 0);
            collectAllAstResources(importedGrammars, documents, visited, astResources);
          }
        }
        return astResources;
      }
      exports2.collectAllAstResources = collectAllAstResources;
    }
  });

  // node_modules/langium/lib/grammar/type-system/ast-collector.js
  var require_ast_collector = __commonJS({
    "node_modules/langium/lib/grammar/type-system/ast-collector.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.specifyAstNodeProperties = exports2.createAstTypes = exports2.collectValidationAst = exports2.collectAst = void 0;
      var types_util_1 = require_types_util();
      var types_1 = require_types();
      var all_types_1 = require_all_types();
      var plain_types_1 = require_plain_types();
      function collectAst(grammars, documents) {
        const { inferred, declared } = (0, all_types_1.collectTypeResources)(grammars, documents);
        return createAstTypes(inferred, declared);
      }
      exports2.collectAst = collectAst;
      function collectValidationAst(grammars, documents) {
        const { inferred, declared, astResources } = (0, all_types_1.collectTypeResources)(grammars, documents);
        return {
          astResources,
          inferred: createAstTypes(declared, inferred),
          declared: createAstTypes(inferred, declared)
        };
      }
      exports2.collectValidationAst = collectValidationAst;
      function createAstTypes(first, second) {
        var _a4, _b2;
        const astTypes = {
          interfaces: (0, types_util_1.sortInterfacesTopologically)(mergeAndRemoveDuplicates(...first.interfaces, ...(_a4 = second === null || second === void 0 ? void 0 : second.interfaces) !== null && _a4 !== void 0 ? _a4 : [])),
          unions: mergeAndRemoveDuplicates(...first.unions, ...(_b2 = second === null || second === void 0 ? void 0 : second.unions) !== null && _b2 !== void 0 ? _b2 : [])
        };
        const finalTypes = (0, plain_types_1.plainToTypes)(astTypes);
        specifyAstNodeProperties(finalTypes);
        return finalTypes;
      }
      exports2.createAstTypes = createAstTypes;
      function mergeAndRemoveDuplicates(...elements) {
        return Array.from(elements.reduce((acc, type) => {
          acc.set(type.name, type);
          return acc;
        }, /* @__PURE__ */ new Map()).values()).sort((a, b) => a.name.localeCompare(b.name));
      }
      function specifyAstNodeProperties(astTypes) {
        const nameToType = filterInterfaceLikeTypes(astTypes);
        const array = Array.from(nameToType.values());
        addSubTypes(array);
        buildContainerTypes(array);
        buildTypeNames(array);
      }
      exports2.specifyAstNodeProperties = specifyAstNodeProperties;
      function buildTypeNames(types) {
        const visited = /* @__PURE__ */ new Set();
        const collect = (type) => {
          if (visited.has(type))
            return;
          visited.add(type);
          type.typeNames.add(type.name);
          for (const subtype of type.subTypes) {
            collect(subtype);
            subtype.typeNames.forEach((n) => type.typeNames.add(n));
          }
        };
        types.forEach(collect);
      }
      function filterInterfaceLikeTypes({ interfaces, unions }) {
        const nameToType = interfaces.concat(unions).reduce((acc, e) => {
          acc.set(e.name, e);
          return acc;
        }, /* @__PURE__ */ new Map());
        const cache = /* @__PURE__ */ new Map();
        for (const union of unions) {
          cache.set(union, isDataType(union.type, /* @__PURE__ */ new Set()));
        }
        for (const [union, isDataType2] of cache) {
          if (isDataType2) {
            nameToType.delete(union.name);
          }
        }
        return nameToType;
      }
      function isDataType(property, visited) {
        if (visited.has(property)) {
          return true;
        }
        visited.add(property);
        if ((0, types_1.isPropertyUnion)(property)) {
          return property.types.every((e) => isDataType(e, visited));
        } else if ((0, types_1.isValueType)(property)) {
          const value = property.value;
          if ((0, types_1.isUnionType)(value)) {
            return isDataType(value.type, visited);
          } else {
            return false;
          }
        } else {
          return (0, types_1.isPrimitiveType)(property) || (0, types_1.isStringType)(property);
        }
      }
      function addSubTypes(types) {
        for (const interfaceType of types) {
          for (const superTypeName of interfaceType.superTypes) {
            superTypeName.subTypes.add(interfaceType);
          }
        }
      }
      function buildContainerTypes(types) {
        const interfaces = types.filter(types_1.isInterfaceType);
        for (const interfaceType of interfaces) {
          const refTypes = interfaceType.properties.flatMap((property) => findChildTypes(property.type, /* @__PURE__ */ new Set()));
          for (const refType of refTypes) {
            refType.containerTypes.add(interfaceType);
          }
        }
        const connectedComponents = calculateConnectedComponents(types);
        shareContainerTypes(connectedComponents);
      }
      function findChildTypes(type, set) {
        if ((0, types_1.isPropertyUnion)(type)) {
          return type.types.flatMap((e) => findChildTypes(e, set));
        } else if ((0, types_1.isValueType)(type)) {
          if (set.has(type.value)) {
            return [];
          } else {
            set.add(type.value);
          }
          return [type.value];
        } else if ((0, types_1.isArrayType)(type)) {
          return findChildTypes(type.elementType, set);
        } else {
          return [];
        }
      }
      function calculateConnectedComponents(interfaces) {
        function dfs(typeInterface) {
          const component = [typeInterface];
          visited.add(typeInterface);
          const allTypes = [
            ...hierarchy.subTypes.get(typeInterface.name),
            ...hierarchy.superTypes.get(typeInterface.name)
          ];
          for (const nextTypeInterface of allTypes) {
            const nextType = map.get(nextTypeInterface);
            if (nextType && !visited.has(nextType)) {
              component.push(...dfs(nextType));
            }
          }
          return component;
        }
        const map = new Map(interfaces.map((e) => [e.name, e]));
        const connectedComponents = [];
        const hierarchy = (0, types_util_1.collectTypeHierarchy)(interfaces);
        const visited = /* @__PURE__ */ new Set();
        for (const typeInterface of interfaces) {
          if (!visited.has(typeInterface)) {
            connectedComponents.push(dfs(typeInterface));
          }
        }
        return connectedComponents;
      }
      function shareContainerTypes(connectedComponents) {
        for (const component of connectedComponents) {
          const superSet = /* @__PURE__ */ new Set();
          component.forEach((type) => type.containerTypes.forEach((e) => superSet.add(e)));
          component.forEach((type) => type.containerTypes = superSet);
        }
      }
    }
  });

  // node_modules/langium/lib/grammar/ast-reflection-interpreter.js
  var require_ast_reflection_interpreter = __commonJS({
    "node_modules/langium/lib/grammar/ast-reflection-interpreter.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.interpretAstReflection = void 0;
      var syntax_tree_1 = require_syntax_tree();
      var collections_1 = require_collections();
      var ast_1 = require_ast();
      var ast_collector_1 = require_ast_collector();
      var types_util_1 = require_types_util();
      function interpretAstReflection(grammarOrTypes, documents) {
        let collectedTypes;
        if ((0, ast_1.isGrammar)(grammarOrTypes)) {
          collectedTypes = (0, ast_collector_1.collectAst)(grammarOrTypes, documents);
        } else {
          collectedTypes = grammarOrTypes;
        }
        const allTypes = collectedTypes.interfaces.map((e) => e.name).concat(collectedTypes.unions.filter((e) => (0, types_util_1.isAstType)(e.type)).map((e) => e.name));
        const references = buildReferenceTypes(collectedTypes);
        const metaData = buildTypeMetaData(collectedTypes);
        const superTypes = (0, types_util_1.collectTypeHierarchy)((0, types_util_1.mergeTypesAndInterfaces)(collectedTypes)).superTypes;
        return new InterpretedAstReflection({
          allTypes,
          references,
          metaData,
          superTypes
        });
      }
      exports2.interpretAstReflection = interpretAstReflection;
      var InterpretedAstReflection = class extends syntax_tree_1.AbstractAstReflection {
        constructor(options) {
          super();
          this.allTypes = options.allTypes;
          this.references = options.references;
          this.metaData = options.metaData;
          this.superTypes = options.superTypes;
        }
        getAllTypes() {
          return this.allTypes;
        }
        getReferenceType(refInfo) {
          const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
          const referenceType = this.references.get(referenceId);
          if (referenceType) {
            return referenceType;
          }
          throw new Error("Could not find reference type for " + referenceId);
        }
        getTypeMetaData(type) {
          var _a4;
          return (_a4 = this.metaData.get(type)) !== null && _a4 !== void 0 ? _a4 : {
            name: type,
            mandatory: []
          };
        }
        computeIsSubtype(subtype, originalSuperType) {
          const superTypes = this.superTypes.get(subtype);
          for (const superType of superTypes) {
            if (this.isSubtype(superType, originalSuperType)) {
              return true;
            }
          }
          return false;
        }
      };
      function buildReferenceTypes(astTypes) {
        const references = new collections_1.MultiMap();
        for (const interfaceType of astTypes.interfaces) {
          for (const property of interfaceType.properties) {
            for (const referenceType of (0, types_util_1.findReferenceTypes)(property.type)) {
              references.add(interfaceType.name, [property.name, referenceType]);
            }
          }
          for (const superType of interfaceType.interfaceSuperTypes) {
            const superTypeReferences = references.get(superType.name);
            references.addAll(interfaceType.name, superTypeReferences);
          }
        }
        const map = /* @__PURE__ */ new Map();
        for (const [type, [property, target]] of references) {
          map.set(`${type}:${property}`, target);
        }
        return map;
      }
      function buildTypeMetaData(astTypes) {
        const map = /* @__PURE__ */ new Map();
        for (const interfaceType of astTypes.interfaces) {
          const props = interfaceType.superProperties;
          const arrayProps = props.filter((e) => (0, types_util_1.hasArrayType)(e.type));
          const booleanProps = props.filter((e) => !(0, types_util_1.hasArrayType)(e.type) && (0, types_util_1.hasBooleanType)(e.type));
          if (arrayProps.length > 0 || booleanProps.length > 0) {
            map.set(interfaceType.name, {
              name: interfaceType.name,
              mandatory: buildMandatoryMetaData(arrayProps, booleanProps)
            });
          }
        }
        return map;
      }
      function buildMandatoryMetaData(arrayProps, booleanProps) {
        const array = [];
        const all = arrayProps.concat(booleanProps).sort((a, b) => a.name.localeCompare(b.name));
        for (const property of all) {
          const type = arrayProps.includes(property) ? "array" : "boolean";
          array.push({
            name: property.name,
            type
          });
        }
        return array;
      }
    }
  });

  // node_modules/langium/lib/grammar/generated/grammar.js
  var require_grammar = __commonJS({
    "node_modules/langium/lib/grammar/generated/grammar.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LangiumGrammarGrammar = void 0;
      var grammar_util_1 = require_grammar_util();
      var loadedLangiumGrammarGrammar;
      var LangiumGrammarGrammar = () => loadedLangiumGrammarGrammar !== null && loadedLangiumGrammarGrammar !== void 0 ? loadedLangiumGrammarGrammar : loadedLangiumGrammarGrammar = (0, grammar_util_1.loadGrammarFromJson)(`{
  "$type": "Grammar",
  "isDeclared": true,
  "name": "LangiumGrammar",
  "rules": [
    {
      "$type": "ParserRule",
      "name": "Grammar",
      "entry": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "isDeclared",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "grammar"
                }
              },
              {
                "$type": "Assignment",
                "feature": "name",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@59"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "with"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "usedGrammars",
                    "operator": "+=",
                    "terminal": {
                      "$type": "CrossReference",
                      "type": {
                        "$ref": "#/rules@0"
                      },
                      "terminal": {
                        "$type": "RuleCall",
                        "rule": {
                          "$ref": "#/rules@59"
                        },
                        "arguments": []
                      },
                      "deprecatedSyntax": false
                    }
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": ","
                      },
                      {
                        "$type": "Assignment",
                        "feature": "usedGrammars",
                        "operator": "+=",
                        "terminal": {
                          "$type": "CrossReference",
                          "type": {
                            "$ref": "#/rules@0"
                          },
                          "terminal": {
                            "$type": "RuleCall",
                            "rule": {
                              "$ref": "#/rules@59"
                            },
                            "arguments": []
                          },
                          "deprecatedSyntax": false
                        }
                      }
                    ],
                    "cardinality": "*"
                  }
                ],
                "cardinality": "?"
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "definesHiddenTokens",
                    "operator": "?=",
                    "terminal": {
                      "$type": "Keyword",
                      "value": "hidden"
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": "("
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Assignment",
                        "feature": "hiddenTokens",
                        "operator": "+=",
                        "terminal": {
                          "$type": "CrossReference",
                          "type": {
                            "$ref": "#/rules@11"
                          },
                          "terminal": {
                            "$type": "RuleCall",
                            "rule": {
                              "$ref": "#/rules@59"
                            },
                            "arguments": []
                          },
                          "deprecatedSyntax": false
                        }
                      },
                      {
                        "$type": "Group",
                        "elements": [
                          {
                            "$type": "Keyword",
                            "value": ","
                          },
                          {
                            "$type": "Assignment",
                            "feature": "hiddenTokens",
                            "operator": "+=",
                            "terminal": {
                              "$type": "CrossReference",
                              "type": {
                                "$ref": "#/rules@11"
                              },
                              "terminal": {
                                "$type": "RuleCall",
                                "rule": {
                                  "$ref": "#/rules@59"
                                },
                                "arguments": []
                              },
                              "deprecatedSyntax": false
                            }
                          }
                        ],
                        "cardinality": "*"
                      }
                    ],
                    "cardinality": "?"
                  },
                  {
                    "$type": "Keyword",
                    "value": ")"
                  }
                ],
                "cardinality": "?"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "imports",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@12"
              },
              "arguments": []
            },
            "cardinality": "*"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "rules",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@11"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "interfaces",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@1"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "types",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@10"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "+"
          }
        ]
      },
      "definesHiddenTokens": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Interface",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "interface"
          },
          {
            "$type": "Assignment",
            "feature": "name",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@59"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "extends"
              },
              {
                "$type": "Assignment",
                "feature": "superTypes",
                "operator": "+=",
                "terminal": {
                  "$type": "CrossReference",
                  "type": {
                    "$ref": "#/types@0"
                  },
                  "terminal": {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@59"
                    },
                    "arguments": []
                  },
                  "deprecatedSyntax": false
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": ","
                  },
                  {
                    "$type": "Assignment",
                    "feature": "superTypes",
                    "operator": "+=",
                    "terminal": {
                      "$type": "CrossReference",
                      "type": {
                        "$ref": "#/types@0"
                      },
                      "terminal": {
                        "$type": "RuleCall",
                        "rule": {
                          "$ref": "#/rules@59"
                        },
                        "arguments": []
                      },
                      "deprecatedSyntax": false
                    }
                  }
                ],
                "cardinality": "*"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@2"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SchemaType",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "{"
          },
          {
            "$type": "Assignment",
            "feature": "attributes",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@3"
              },
              "arguments": []
            },
            "cardinality": "*"
          },
          {
            "$type": "Keyword",
            "value": "}"
          },
          {
            "$type": "Keyword",
            "value": ";",
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TypeAttribute",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "name",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@58"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "isOptional",
            "operator": "?=",
            "terminal": {
              "$type": "Keyword",
              "value": "?"
            },
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": ":"
          },
          {
            "$type": "Assignment",
            "feature": "type",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@4"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ";",
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TypeDefinition",
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@5"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "UnionType",
      "inferredType": {
        "$type": "InferredType",
        "name": "TypeDefinition"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@6"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "UnionType"
                },
                "feature": "types",
                "operator": "+="
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "|"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "types",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@6"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "+"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ArrayType",
      "inferredType": {
        "$type": "InferredType",
        "name": "TypeDefinition"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@7"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "ArrayType"
                },
                "feature": "elementType",
                "operator": "="
              },
              {
                "$type": "Keyword",
                "value": "["
              },
              {
                "$type": "Keyword",
                "value": "]"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ReferenceType",
      "inferredType": {
        "$type": "InferredType",
        "name": "TypeDefinition"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@8"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "ReferenceType"
                }
              },
              {
                "$type": "Keyword",
                "value": "@"
              },
              {
                "$type": "Assignment",
                "feature": "referenceType",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@8"
                  },
                  "arguments": []
                }
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SimpleType",
      "inferredType": {
        "$type": "InferredType",
        "name": "TypeDefinition"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@4"
                },
                "arguments": []
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "SimpleType"
                }
              },
              {
                "$type": "Alternatives",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "typeRef",
                    "operator": "=",
                    "terminal": {
                      "$type": "CrossReference",
                      "type": {
                        "$ref": "#/types@0"
                      },
                      "terminal": {
                        "$type": "RuleCall",
                        "rule": {
                          "$ref": "#/rules@59"
                        },
                        "arguments": []
                      },
                      "deprecatedSyntax": false
                    }
                  },
                  {
                    "$type": "Assignment",
                    "feature": "primitiveType",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@9"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Assignment",
                    "feature": "stringType",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@60"
                      },
                      "arguments": []
                    }
                  }
                ]
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PrimitiveType",
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": "string"
          },
          {
            "$type": "Keyword",
            "value": "number"
          },
          {
            "$type": "Keyword",
            "value": "boolean"
          },
          {
            "$type": "Keyword",
            "value": "Date"
          },
          {
            "$type": "Keyword",
            "value": "bigint"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Type",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "type"
          },
          {
            "$type": "Assignment",
            "feature": "name",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@59"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": "="
          },
          {
            "$type": "Assignment",
            "feature": "type",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@4"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ";",
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AbstractRule",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@13"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@46"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "GrammarImport",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "import"
          },
          {
            "$type": "Assignment",
            "feature": "path",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@60"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ";",
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ParserRule",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "entry",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "entry"
                }
              },
              {
                "$type": "Assignment",
                "feature": "fragment",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "fragment"
                }
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@15"
            },
            "arguments": []
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "wildcard",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "*"
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "returns"
                  },
                  {
                    "$type": "Alternatives",
                    "elements": [
                      {
                        "$type": "Assignment",
                        "feature": "returnType",
                        "operator": "=",
                        "terminal": {
                          "$type": "CrossReference",
                          "type": {
                            "$ref": "#/types@0"
                          },
                          "terminal": {
                            "$type": "RuleCall",
                            "rule": {
                              "$ref": "#/rules@59"
                            },
                            "arguments": []
                          },
                          "deprecatedSyntax": false
                        }
                      },
                      {
                        "$type": "Assignment",
                        "feature": "dataType",
                        "operator": "=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@9"
                          },
                          "arguments": []
                        }
                      }
                    ]
                  }
                ]
              },
              {
                "$type": "Assignment",
                "feature": "inferredType",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@14"
                  },
                  "arguments": [
                    {
                      "$type": "NamedArgument",
                      "value": {
                        "$type": "LiteralCondition",
                        "true": false
                      },
                      "calledByName": false
                    }
                  ]
                }
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "definesHiddenTokens",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "hidden"
                }
              },
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "hiddenTokens",
                    "operator": "+=",
                    "terminal": {
                      "$type": "CrossReference",
                      "type": {
                        "$ref": "#/rules@11"
                      },
                      "terminal": {
                        "$type": "RuleCall",
                        "rule": {
                          "$ref": "#/rules@59"
                        },
                        "arguments": []
                      },
                      "deprecatedSyntax": false
                    }
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": ","
                      },
                      {
                        "$type": "Assignment",
                        "feature": "hiddenTokens",
                        "operator": "+=",
                        "terminal": {
                          "$type": "CrossReference",
                          "type": {
                            "$ref": "#/rules@11"
                          },
                          "terminal": {
                            "$type": "RuleCall",
                            "rule": {
                              "$ref": "#/rules@59"
                            },
                            "arguments": []
                          },
                          "deprecatedSyntax": false
                        }
                      }
                    ],
                    "cardinality": "*"
                  }
                ],
                "cardinality": "?"
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": ":"
          },
          {
            "$type": "Assignment",
            "feature": "definition",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@17"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "InferredType",
      "parameters": [
        {
          "$type": "Parameter",
          "name": "imperative"
        }
      ],
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Group",
                "guardCondition": {
                  "$type": "ParameterReference",
                  "parameter": {
                    "$ref": "#/rules@14/parameters@0"
                  }
                },
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "infer"
                  }
                ]
              },
              {
                "$type": "Group",
                "guardCondition": {
                  "$type": "Negation",
                  "value": {
                    "$type": "ParameterReference",
                    "parameter": {
                      "$ref": "#/rules@14/parameters@0"
                    }
                  }
                },
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "infers"
                  }
                ]
              }
            ]
          },
          {
            "$type": "Assignment",
            "feature": "name",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@59"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RuleNameAndParams",
      "fragment": true,
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "name",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@59"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "<"
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "parameters",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@16"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": ","
                      },
                      {
                        "$type": "Assignment",
                        "feature": "parameters",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@16"
                          },
                          "arguments": []
                        }
                      }
                    ],
                    "cardinality": "*"
                  }
                ],
                "cardinality": "?"
              },
              {
                "$type": "Keyword",
                "value": ">"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Parameter",
      "definition": {
        "$type": "Assignment",
        "feature": "name",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@59"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Alternatives",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@18"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "Alternatives"
                },
                "feature": "elements",
                "operator": "+="
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "|"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "elements",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@18"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "+"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ConditionalBranch",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@19"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "Group"
                }
              },
              {
                "$type": "Keyword",
                "value": "<"
              },
              {
                "$type": "Assignment",
                "feature": "guardCondition",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@29"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ">"
              },
              {
                "$type": "Assignment",
                "feature": "elements",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@21"
                  },
                  "arguments": []
                },
                "cardinality": "+"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "UnorderedGroup",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@20"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "UnorderedGroup"
                },
                "feature": "elements",
                "operator": "+="
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "&"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "elements",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@20"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "+"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Group",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@21"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "Group"
                },
                "feature": "elements",
                "operator": "+="
              },
              {
                "$type": "Assignment",
                "feature": "elements",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@21"
                  },
                  "arguments": []
                },
                "cardinality": "+"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AbstractToken",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@22"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@23"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AbstractTokenWithCardinality",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@37"
                },
                "arguments": []
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@24"
                },
                "arguments": []
              }
            ]
          },
          {
            "$type": "Assignment",
            "feature": "cardinality",
            "operator": "=",
            "terminal": {
              "$type": "Alternatives",
              "elements": [
                {
                  "$type": "Keyword",
                  "value": "?"
                },
                {
                  "$type": "Keyword",
                  "value": "*"
                },
                {
                  "$type": "Keyword",
                  "value": "+"
                }
              ]
            },
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Action",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "Action"
            }
          },
          {
            "$type": "Keyword",
            "value": "{"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "type",
                "operator": "=",
                "terminal": {
                  "$type": "CrossReference",
                  "type": {
                    "$ref": "#/types@0"
                  },
                  "terminal": {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@59"
                    },
                    "arguments": []
                  },
                  "deprecatedSyntax": false
                }
              },
              {
                "$type": "Assignment",
                "feature": "inferredType",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@14"
                  },
                  "arguments": [
                    {
                      "$type": "NamedArgument",
                      "value": {
                        "$type": "LiteralCondition",
                        "true": true
                      },
                      "calledByName": false
                    }
                  ]
                }
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "."
              },
              {
                "$type": "Assignment",
                "feature": "feature",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@58"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "operator",
                "operator": "=",
                "terminal": {
                  "$type": "Alternatives",
                  "elements": [
                    {
                      "$type": "Keyword",
                      "value": "="
                    },
                    {
                      "$type": "Keyword",
                      "value": "+="
                    }
                  ]
                }
              },
              {
                "$type": "Keyword",
                "value": "current"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "}"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AbstractTerminal",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@25"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@26"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@43"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@35"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@36"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@44"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Keyword",
      "definition": {
        "$type": "Assignment",
        "feature": "value",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@60"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RuleCall",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "rule",
            "operator": "=",
            "terminal": {
              "$type": "CrossReference",
              "type": {
                "$ref": "#/rules@11"
              },
              "terminal": {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@59"
                },
                "arguments": []
              },
              "deprecatedSyntax": false
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "<"
              },
              {
                "$type": "Assignment",
                "feature": "arguments",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@27"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": ","
                  },
                  {
                    "$type": "Assignment",
                    "feature": "arguments",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@27"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "*"
              },
              {
                "$type": "Keyword",
                "value": ">"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NamedArgument",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "parameter",
                "operator": "=",
                "terminal": {
                  "$type": "CrossReference",
                  "type": {
                    "$ref": "#/rules@16"
                  },
                  "terminal": {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@59"
                    },
                    "arguments": []
                  },
                  "deprecatedSyntax": false
                }
              },
              {
                "$type": "Assignment",
                "feature": "calledByName",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "="
                }
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "value",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@29"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "LiteralCondition",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "true",
            "operator": "?=",
            "terminal": {
              "$type": "Keyword",
              "value": "true"
            }
          },
          {
            "$type": "Keyword",
            "value": "false"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Disjunction",
      "inferredType": {
        "$type": "InferredType",
        "name": "Condition"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@30"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "Disjunction"
                },
                "feature": "left",
                "operator": "="
              },
              {
                "$type": "Keyword",
                "value": "|"
              },
              {
                "$type": "Assignment",
                "feature": "right",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@30"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Conjunction",
      "inferredType": {
        "$type": "InferredType",
        "name": "Condition"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@31"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "Conjunction"
                },
                "feature": "left",
                "operator": "="
              },
              {
                "$type": "Keyword",
                "value": "&"
              },
              {
                "$type": "Assignment",
                "feature": "right",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@31"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Negation",
      "inferredType": {
        "$type": "InferredType",
        "name": "Condition"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@32"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "Negation"
                }
              },
              {
                "$type": "Keyword",
                "value": "!"
              },
              {
                "$type": "Assignment",
                "feature": "value",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@31"
                  },
                  "arguments": []
                }
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Atom",
      "inferredType": {
        "$type": "InferredType",
        "name": "Condition"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@34"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@33"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@28"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ParenthesizedCondition",
      "inferredType": {
        "$type": "InferredType",
        "name": "Condition"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@29"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ParameterReference",
      "definition": {
        "$type": "Assignment",
        "feature": "parameter",
        "operator": "=",
        "terminal": {
          "$type": "CrossReference",
          "type": {
            "$ref": "#/rules@16"
          },
          "terminal": {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@59"
            },
            "arguments": []
          },
          "deprecatedSyntax": false
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PredicatedKeyword",
      "inferredType": {
        "$type": "InferredType",
        "name": "Keyword"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "=>"
              },
              {
                "$type": "Keyword",
                "value": "->"
              }
            ]
          },
          {
            "$type": "Assignment",
            "feature": "value",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@60"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PredicatedRuleCall",
      "inferredType": {
        "$type": "InferredType",
        "name": "RuleCall"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "=>"
              },
              {
                "$type": "Keyword",
                "value": "->"
              }
            ]
          },
          {
            "$type": "Assignment",
            "feature": "rule",
            "operator": "=",
            "terminal": {
              "$type": "CrossReference",
              "type": {
                "$ref": "#/rules@11"
              },
              "terminal": {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@59"
                },
                "arguments": []
              },
              "deprecatedSyntax": false
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "<"
              },
              {
                "$type": "Assignment",
                "feature": "arguments",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@27"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": ","
                  },
                  {
                    "$type": "Assignment",
                    "feature": "arguments",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@27"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "*"
              },
              {
                "$type": "Keyword",
                "value": ">"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Assignment",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "Assignment"
            }
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "=>"
              },
              {
                "$type": "Keyword",
                "value": "->"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "feature",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@58"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "operator",
            "operator": "=",
            "terminal": {
              "$type": "Alternatives",
              "elements": [
                {
                  "$type": "Keyword",
                  "value": "+="
                },
                {
                  "$type": "Keyword",
                  "value": "="
                },
                {
                  "$type": "Keyword",
                  "value": "?="
                }
              ]
            }
          },
          {
            "$type": "Assignment",
            "feature": "terminal",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@38"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AssignableTerminal",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@25"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@26"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@39"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@41"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ParenthesizedAssignableElement",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@40"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AssignableAlternatives",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@38"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "Alternatives"
                },
                "feature": "elements",
                "operator": "+="
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "|"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "elements",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@38"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "+"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "CrossReference",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "CrossReference"
            }
          },
          {
            "$type": "Keyword",
            "value": "["
          },
          {
            "$type": "Assignment",
            "feature": "type",
            "operator": "=",
            "terminal": {
              "$type": "CrossReference",
              "type": {
                "$ref": "#/types@0"
              },
              "deprecatedSyntax": false
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Alternatives",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "deprecatedSyntax",
                    "operator": "?=",
                    "terminal": {
                      "$type": "Keyword",
                      "value": "|"
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": ":"
                  }
                ]
              },
              {
                "$type": "Assignment",
                "feature": "terminal",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@42"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "]"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "CrossReferenceableTerminal",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@25"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@26"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ParenthesizedElement",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@17"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PredicatedGroup",
      "inferredType": {
        "$type": "InferredType",
        "name": "Group"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "=>"
              },
              {
                "$type": "Keyword",
                "value": "->"
              }
            ]
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "elements",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@17"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ReturnType",
      "definition": {
        "$type": "Assignment",
        "feature": "name",
        "operator": "=",
        "terminal": {
          "$type": "Alternatives",
          "elements": [
            {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@9"
              },
              "arguments": []
            },
            {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@59"
              },
              "arguments": []
            }
          ]
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TerminalRule",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "hidden",
            "operator": "?=",
            "terminal": {
              "$type": "Keyword",
              "value": "hidden"
            },
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": "terminal"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "fragment",
                    "operator": "?=",
                    "terminal": {
                      "$type": "Keyword",
                      "value": "fragment"
                    }
                  },
                  {
                    "$type": "Assignment",
                    "feature": "name",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@59"
                      },
                      "arguments": []
                    }
                  }
                ]
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "name",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@59"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": "returns"
                      },
                      {
                        "$type": "Assignment",
                        "feature": "type",
                        "operator": "=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@45"
                          },
                          "arguments": []
                        }
                      }
                    ],
                    "cardinality": "?"
                  }
                ]
              }
            ]
          },
          {
            "$type": "Keyword",
            "value": ":"
          },
          {
            "$type": "Assignment",
            "feature": "definition",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@47"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TerminalAlternatives",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@48"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "TerminalAlternatives"
                },
                "feature": "elements",
                "operator": "+="
              },
              {
                "$type": "Keyword",
                "value": "|"
              },
              {
                "$type": "Assignment",
                "feature": "elements",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@48"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TerminalGroup",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@49"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "TerminalGroup"
                },
                "feature": "elements",
                "operator": "+="
              },
              {
                "$type": "Assignment",
                "feature": "elements",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@49"
                  },
                  "arguments": []
                },
                "cardinality": "+"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TerminalToken",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@50"
            },
            "arguments": []
          },
          {
            "$type": "Assignment",
            "feature": "cardinality",
            "operator": "=",
            "terminal": {
              "$type": "Alternatives",
              "elements": [
                {
                  "$type": "Keyword",
                  "value": "?"
                },
                {
                  "$type": "Keyword",
                  "value": "*"
                },
                {
                  "$type": "Keyword",
                  "value": "+"
                }
              ]
            },
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TerminalTokenElement",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@57"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@52"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@51"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@53"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@54"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@55"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@56"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ParenthesizedTerminalElement",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "lookahead",
            "operator": "=",
            "terminal": {
              "$type": "Alternatives",
              "elements": [
                {
                  "$type": "Keyword",
                  "value": "?="
                },
                {
                  "$type": "Keyword",
                  "value": "?!"
                }
              ]
            },
            "cardinality": "?"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@47"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TerminalRuleCall",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "TerminalRuleCall"
            }
          },
          {
            "$type": "Assignment",
            "feature": "rule",
            "operator": "=",
            "terminal": {
              "$type": "CrossReference",
              "type": {
                "$ref": "#/rules@46"
              },
              "terminal": {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@59"
                },
                "arguments": []
              },
              "deprecatedSyntax": false
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NegatedToken",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "NegatedToken"
            }
          },
          {
            "$type": "Keyword",
            "value": "!"
          },
          {
            "$type": "Assignment",
            "feature": "terminal",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@50"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "UntilToken",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "UntilToken"
            }
          },
          {
            "$type": "Keyword",
            "value": "->"
          },
          {
            "$type": "Assignment",
            "feature": "terminal",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@50"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RegexToken",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "RegexToken"
            }
          },
          {
            "$type": "Assignment",
            "feature": "regex",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@61"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Wildcard",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "Wildcard"
            }
          },
          {
            "$type": "Keyword",
            "value": "."
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "CharacterRange",
      "inferredType": {
        "$type": "InferredType",
        "name": "AbstractElement"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "CharacterRange"
            }
          },
          {
            "$type": "Assignment",
            "feature": "left",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@25"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ".."
              },
              {
                "$type": "Assignment",
                "feature": "right",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@25"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeatureName",
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": "current"
          },
          {
            "$type": "Keyword",
            "value": "entry"
          },
          {
            "$type": "Keyword",
            "value": "extends"
          },
          {
            "$type": "Keyword",
            "value": "false"
          },
          {
            "$type": "Keyword",
            "value": "fragment"
          },
          {
            "$type": "Keyword",
            "value": "grammar"
          },
          {
            "$type": "Keyword",
            "value": "hidden"
          },
          {
            "$type": "Keyword",
            "value": "import"
          },
          {
            "$type": "Keyword",
            "value": "interface"
          },
          {
            "$type": "Keyword",
            "value": "returns"
          },
          {
            "$type": "Keyword",
            "value": "terminal"
          },
          {
            "$type": "Keyword",
            "value": "true"
          },
          {
            "$type": "Keyword",
            "value": "type"
          },
          {
            "$type": "Keyword",
            "value": "infer"
          },
          {
            "$type": "Keyword",
            "value": "infers"
          },
          {
            "$type": "Keyword",
            "value": "with"
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@9"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@59"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "TerminalRule",
      "name": "ID",
      "definition": {
        "$type": "RegexToken",
        "regex": "\\\\^?[_a-zA-Z][\\\\w_]*"
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "name": "STRING",
      "definition": {
        "$type": "RegexToken",
        "regex": "\\"(\\\\\\\\.|[^\\"\\\\\\\\])*\\"|'(\\\\\\\\.|[^'\\\\\\\\])*'"
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "name": "RegexLiteral",
      "type": {
        "$type": "ReturnType",
        "name": "string"
      },
      "definition": {
        "$type": "RegexToken",
        "regex": "\\\\/(?![*+?])(?:[^\\\\r\\\\n\\\\[/\\\\\\\\]|\\\\\\\\.|\\\\[(?:[^\\\\r\\\\n\\\\]\\\\\\\\]|\\\\\\\\.)*\\\\])+\\\\/"
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "hidden": true,
      "name": "WS",
      "definition": {
        "$type": "RegexToken",
        "regex": "\\\\s+"
      },
      "fragment": false
    },
    {
      "$type": "TerminalRule",
      "hidden": true,
      "name": "ML_COMMENT",
      "definition": {
        "$type": "RegexToken",
        "regex": "\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/"
      },
      "fragment": false
    },
    {
      "$type": "TerminalRule",
      "hidden": true,
      "name": "SL_COMMENT",
      "definition": {
        "$type": "RegexToken",
        "regex": "\\\\/\\\\/[^\\\\n\\\\r]*"
      },
      "fragment": false
    }
  ],
  "types": [
    {
      "$type": "Type",
      "name": "AbstractType",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/rules@1"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/rules@10"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/rules@23/definition/elements@0"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/rules@13"
            }
          }
        ]
      }
    }
  ],
  "definesHiddenTokens": false,
  "hiddenTokens": [],
  "imports": [],
  "interfaces": [],
  "usedGrammars": []
}`);
      exports2.LangiumGrammarGrammar = LangiumGrammarGrammar;
    }
  });

  // node_modules/langium/lib/grammar/generated/module.js
  var require_module = __commonJS({
    "node_modules/langium/lib/grammar/generated/module.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LangiumGrammarGeneratedModule = exports2.LangiumGrammarGeneratedSharedModule = exports2.LangiumGrammarParserConfig = exports2.LangiumGrammarLanguageMetaData = void 0;
      var ast_1 = require_ast();
      var grammar_1 = require_grammar();
      exports2.LangiumGrammarLanguageMetaData = {
        languageId: "langium",
        fileExtensions: [".langium"],
        caseInsensitive: false
      };
      exports2.LangiumGrammarParserConfig = {
        maxLookahead: 3
      };
      exports2.LangiumGrammarGeneratedSharedModule = {
        AstReflection: () => new ast_1.LangiumGrammarAstReflection()
      };
      exports2.LangiumGrammarGeneratedModule = {
        Grammar: () => (0, grammar_1.LangiumGrammarGrammar)(),
        LanguageMetaData: () => exports2.LangiumGrammarLanguageMetaData,
        parser: {
          ParserConfig: () => exports2.LangiumGrammarParserConfig
        }
      };
    }
  });

  // node_modules/langium/lib/utils/promise-util.js
  var require_promise_util = __commonJS({
    "node_modules/langium/lib/utils/promise-util.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Deferred = exports2.MutexLock = exports2.interruptAndCheck = exports2.isOperationCancelled = exports2.OperationCancelled = exports2.setInterruptionPeriod = exports2.startCancelableOperation = exports2.delayNextTick = void 0;
      var vscode_jsonrpc_1 = require_main();
      function delayNextTick() {
        return new Promise((resolve2) => {
          if (typeof setImmediate === "undefined") {
            setTimeout(resolve2, 0);
          } else {
            setImmediate(resolve2);
          }
        });
      }
      exports2.delayNextTick = delayNextTick;
      var lastTick = 0;
      var globalInterruptionPeriod = 10;
      function startCancelableOperation() {
        lastTick = Date.now();
        return new vscode_jsonrpc_1.CancellationTokenSource();
      }
      exports2.startCancelableOperation = startCancelableOperation;
      function setInterruptionPeriod(period) {
        globalInterruptionPeriod = period;
      }
      exports2.setInterruptionPeriod = setInterruptionPeriod;
      exports2.OperationCancelled = Symbol("OperationCancelled");
      function isOperationCancelled(err) {
        return err === exports2.OperationCancelled;
      }
      exports2.isOperationCancelled = isOperationCancelled;
      async function interruptAndCheck(token) {
        if (token === vscode_jsonrpc_1.CancellationToken.None) {
          return;
        }
        const current = Date.now();
        if (current - lastTick >= globalInterruptionPeriod) {
          lastTick = current;
          await delayNextTick();
        }
        if (token.isCancellationRequested) {
          throw exports2.OperationCancelled;
        }
      }
      exports2.interruptAndCheck = interruptAndCheck;
      var MutexLock = class {
        constructor() {
          this.previousAction = Promise.resolve();
          this.previousTokenSource = new vscode_jsonrpc_1.CancellationTokenSource();
        }
        /**
         * Performs a single async action, like initializing the workspace or processing document changes.
         * Only one action will be executed at a time.
         *
         * When another action is queued up, the token provided for the action will be cancelled.
         * Assuming the action makes use of this token, the next action only has to wait for the current action to finish cancellation.
         */
        lock(action) {
          this.cancel();
          const tokenSource = new vscode_jsonrpc_1.CancellationTokenSource();
          this.previousTokenSource = tokenSource;
          return this.previousAction = this.previousAction.then(() => action(tokenSource.token).catch((err) => {
            if (!isOperationCancelled(err)) {
              console.error("Error: ", err);
            }
          }));
        }
        /**
         * Cancels the currently executed action
         */
        cancel() {
          this.previousTokenSource.cancel();
        }
      };
      exports2.MutexLock = MutexLock;
      var Deferred = class {
        constructor() {
          this.promise = new Promise((resolve2, reject) => {
            this.resolve = (arg) => (resolve2(arg), this);
            this.reject = (err) => (reject(err), this);
          });
        }
      };
      exports2.Deferred = Deferred;
    }
  });

  // node_modules/langium/lib/references/scope-computation.js
  var require_scope_computation = __commonJS({
    "node_modules/langium/lib/references/scope-computation.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DefaultScopeComputation = void 0;
      var vscode_jsonrpc_1 = require_main();
      var ast_util_1 = require_ast_util();
      var collections_1 = require_collections();
      var promise_util_1 = require_promise_util();
      var DefaultScopeComputation = class {
        constructor(services) {
          this.nameProvider = services.references.NameProvider;
          this.descriptions = services.workspace.AstNodeDescriptionProvider;
        }
        async computeExports(document2, cancelToken = vscode_jsonrpc_1.CancellationToken.None) {
          return this.computeExportsForNode(document2.parseResult.value, document2, void 0, cancelToken);
        }
        /**
         * Creates {@link AstNodeDescription AstNodeDescriptions} for the given {@link AstNode parentNode} and its children.
         * The list of children to be considered is determined by the function parameter {@link children}.
         * By default only the direct children of {@link parentNode} are visited, nested nodes are not exported.
         *
         * @param parentNode AST node to be exported, i.e., of which an {@link AstNodeDescription} shall be added to the returned list.
         * @param document The document containing the AST node to be exported.
         * @param children A function called with {@link parentNode} as single argument and returning an {@link Iterable} supplying the children to be visited, which must be directly or transitively contained in {@link parentNode}.
         * @param cancelToken Indicates when to cancel the current operation.
         * @throws `OperationCanceled` if a user action occurs during execution.
         * @returns A list of {@link AstNodeDescription AstNodeDescriptions} to be published to index.
         */
        async computeExportsForNode(parentNode, document2, children = ast_util_1.streamContents, cancelToken = vscode_jsonrpc_1.CancellationToken.None) {
          const exports3 = [];
          this.exportNode(parentNode, exports3, document2);
          for (const node of children(parentNode)) {
            await (0, promise_util_1.interruptAndCheck)(cancelToken);
            this.exportNode(node, exports3, document2);
          }
          return exports3;
        }
        /**
         * Add a single node to the list of exports if it has a name. Override this method to change how
         * symbols are exported, e.g. by modifying their exported name.
         */
        exportNode(node, exports3, document2) {
          const name = this.nameProvider.getName(node);
          if (name) {
            exports3.push(this.descriptions.createDescription(node, name, document2));
          }
        }
        async computeLocalScopes(document2, cancelToken = vscode_jsonrpc_1.CancellationToken.None) {
          const rootNode = document2.parseResult.value;
          const scopes = new collections_1.MultiMap();
          for (const node of (0, ast_util_1.streamAllContents)(rootNode)) {
            await (0, promise_util_1.interruptAndCheck)(cancelToken);
            this.processNode(node, document2, scopes);
          }
          return scopes;
        }
        /**
         * Process a single node during scopes computation. The default implementation makes the node visible
         * in the subtree of its container (if the node has a name). Override this method to change this,
         * e.g. by increasing the visibility to a higher level in the AST.
         */
        processNode(node, document2, scopes) {
          const container = node.$container;
          if (container) {
            const name = this.nameProvider.getName(node);
            if (name) {
              scopes.add(container, this.descriptions.createDescription(node, name, document2));
            }
          }
        }
      };
      exports2.DefaultScopeComputation = DefaultScopeComputation;
    }
  });

  // node_modules/langium/lib/references/scope-provider.js
  var require_scope_provider = __commonJS({
    "node_modules/langium/lib/references/scope-provider.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DefaultScopeProvider = exports2.EMPTY_SCOPE = exports2.StreamScope = void 0;
      var ast_util_1 = require_ast_util();
      var stream_1 = require_stream();
      var StreamScope = class {
        constructor(elements, outerScope, options) {
          this.elements = elements;
          this.outerScope = outerScope;
          this.caseInsensitive = options === null || options === void 0 ? void 0 : options.caseInsensitive;
        }
        getAllElements() {
          if (this.outerScope) {
            return this.elements.concat(this.outerScope.getAllElements());
          } else {
            return this.elements;
          }
        }
        getElement(name) {
          const local = this.caseInsensitive ? this.elements.find((e) => e.name.toLowerCase() === name.toLowerCase()) : this.elements.find((e) => e.name === name);
          if (local) {
            return local;
          }
          if (this.outerScope) {
            return this.outerScope.getElement(name);
          }
          return void 0;
        }
      };
      exports2.StreamScope = StreamScope;
      exports2.EMPTY_SCOPE = {
        getElement() {
          return void 0;
        },
        getAllElements() {
          return stream_1.EMPTY_STREAM;
        }
      };
      var DefaultScopeProvider = class {
        constructor(services) {
          this.reflection = services.shared.AstReflection;
          this.nameProvider = services.references.NameProvider;
          this.descriptions = services.workspace.AstNodeDescriptionProvider;
          this.indexManager = services.shared.workspace.IndexManager;
        }
        getScope(context) {
          const scopes = [];
          const referenceType = this.reflection.getReferenceType(context);
          const precomputed = (0, ast_util_1.getDocument)(context.container).precomputedScopes;
          if (precomputed) {
            let currentNode = context.container;
            do {
              const allDescriptions = precomputed.get(currentNode);
              if (allDescriptions.length > 0) {
                scopes.push((0, stream_1.stream)(allDescriptions).filter((desc) => this.reflection.isSubtype(desc.type, referenceType)));
              }
              currentNode = currentNode.$container;
            } while (currentNode);
          }
          let result = this.getGlobalScope(referenceType, context);
          for (let i = scopes.length - 1; i >= 0; i--) {
            result = this.createScope(scopes[i], result);
          }
          return result;
        }
        /**
         * Create a scope for the given collection of AST node descriptions.
         */
        createScope(elements, outerScope, options) {
          return new StreamScope((0, stream_1.stream)(elements), outerScope, options);
        }
        /**
         * Create a scope for the given collection of AST nodes, which need to be transformed into respective
         * descriptions first. This is done using the `NameProvider` and `AstNodeDescriptionProvider` services.
         */
        createScopeForNodes(elements, outerScope, options) {
          const s = (0, stream_1.stream)(elements).map((e) => {
            const name = this.nameProvider.getName(e);
            if (name) {
              return this.descriptions.createDescription(e, name);
            }
            return void 0;
          }).nonNullable();
          return new StreamScope(s, outerScope, options);
        }
        /**
         * Create a global scope filtered for the given reference type.
         */
        getGlobalScope(referenceType, _context) {
          return new StreamScope(this.indexManager.allElements(referenceType));
        }
      };
      exports2.DefaultScopeProvider = DefaultScopeProvider;
    }
  });

  // node_modules/langium/lib/utils/uri-util.js
  var require_uri_util = __commonJS({
    "node_modules/langium/lib/utils/uri-util.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.relativeURI = exports2.equalURI = void 0;
      function equalURI(a, b) {
        return (a === null || a === void 0 ? void 0 : a.toString()) === (b === null || b === void 0 ? void 0 : b.toString());
      }
      exports2.equalURI = equalURI;
      function relativeURI(from, to) {
        const fromPath = from.path;
        const toPath = to.path;
        const fromParts = fromPath.split("/").filter((e) => e.length > 0);
        const toParts = toPath.split("/").filter((e) => e.length > 0);
        let i = 0;
        for (; i < fromParts.length; i++) {
          if (fromParts[i] !== toParts[i]) {
            break;
          }
        }
        const backPart = "../".repeat(fromParts.length - i);
        const toPart = toParts.slice(i).join("/");
        return backPart + toPart;
      }
      exports2.relativeURI = relativeURI;
    }
  });

  // node_modules/langium/lib/grammar/references/grammar-scope.js
  var require_grammar_scope = __commonJS({
    "node_modules/langium/lib/grammar/references/grammar-scope.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LangiumGrammarScopeComputation = exports2.LangiumGrammarScopeProvider = void 0;
      var scope_computation_1 = require_scope_computation();
      var scope_provider_1 = require_scope_provider();
      var ast_util_1 = require_ast_util();
      var cst_util_1 = require_cst_util();
      var stream_1 = require_stream();
      var uri_util_1 = require_uri_util();
      var ast_1 = require_ast();
      var internal_grammar_util_1 = require_internal_grammar_util();
      var LangiumGrammarScopeProvider = class extends scope_provider_1.DefaultScopeProvider {
        constructor(services) {
          super(services);
        }
        getScope(context) {
          const referenceType = this.reflection.getReferenceType(context);
          if (referenceType === ast_1.AbstractType) {
            return this.getTypeScope(referenceType, context);
          } else {
            return super.getScope(context);
          }
        }
        getTypeScope(referenceType, context) {
          let localScope;
          const precomputed = (0, ast_util_1.getDocument)(context.container).precomputedScopes;
          const rootNode = (0, ast_util_1.findRootNode)(context.container);
          if (precomputed && rootNode) {
            const allDescriptions = precomputed.get(rootNode);
            if (allDescriptions.length > 0) {
              localScope = (0, stream_1.stream)(allDescriptions).filter((des) => des.type === ast_1.Interface || des.type === ast_1.Type);
            }
          }
          const globalScope = this.getGlobalScope(referenceType, context);
          if (localScope) {
            return this.createScope(localScope, globalScope);
          } else {
            return globalScope;
          }
        }
        getGlobalScope(referenceType, context) {
          const grammar = (0, ast_util_1.getContainerOfType)(context.container, ast_1.isGrammar);
          if (!grammar) {
            return scope_provider_1.EMPTY_SCOPE;
          }
          const importedUris = (0, stream_1.stream)(grammar.imports).map(internal_grammar_util_1.resolveImportUri).nonNullable();
          let importedElements = this.indexManager.allElements(referenceType).filter((des) => importedUris.some((importedUri) => (0, uri_util_1.equalURI)(des.documentUri, importedUri)));
          if (referenceType === ast_1.AbstractType) {
            importedElements = importedElements.filter((des) => des.type === ast_1.Interface || des.type === ast_1.Type);
          }
          return new scope_provider_1.StreamScope(importedElements);
        }
      };
      exports2.LangiumGrammarScopeProvider = LangiumGrammarScopeProvider;
      var LangiumGrammarScopeComputation = class extends scope_computation_1.DefaultScopeComputation {
        constructor(services) {
          super(services);
          this.astNodeLocator = services.workspace.AstNodeLocator;
        }
        exportNode(node, exports3, document2) {
          var _a4;
          super.exportNode(node, exports3, document2);
          if ((0, ast_1.isParserRule)(node)) {
            if (!node.returnType && !node.dataType) {
              const typeNode = (_a4 = node.inferredType) !== null && _a4 !== void 0 ? _a4 : node;
              exports3.push(this.createInterfaceDescription(typeNode, typeNode.name, document2));
            }
            (0, ast_util_1.streamAllContents)(node).forEach((childNode) => {
              if ((0, ast_1.isAction)(childNode) && childNode.inferredType) {
                const typeName = (0, internal_grammar_util_1.getActionType)(childNode);
                if (typeName) {
                  exports3.push(this.createInterfaceDescription(childNode, typeName, document2));
                }
              }
            });
          }
        }
        processNode(node, document2, scopes) {
          if ((0, ast_1.isReturnType)(node))
            return;
          this.processTypeNode(node, document2, scopes);
          this.processActionNode(node, document2, scopes);
          super.processNode(node, document2, scopes);
        }
        /**
         * Add synthetic Interface in case of explicitly or implicitly inferred type:<br>
         * cases: `ParserRule: ...;` or `ParserRule infers Type: ...;`
         */
        processTypeNode(node, document2, scopes) {
          var _a4;
          const container = node.$container;
          if (container && (0, ast_1.isParserRule)(node) && !node.returnType && !node.dataType) {
            const typeNode = (_a4 = node.inferredType) !== null && _a4 !== void 0 ? _a4 : node;
            scopes.add(container, this.createInterfaceDescription(typeNode, typeNode.name, document2));
          }
        }
        /**
         * Add synthetic Interface in case of explicitly inferred type:
         *
         * case: `{infer Action}`
         */
        processActionNode(node, document2, scopes) {
          const container = (0, ast_util_1.findRootNode)(node);
          if (container && (0, ast_1.isAction)(node) && node.inferredType) {
            const typeName = (0, internal_grammar_util_1.getActionType)(node);
            if (typeName) {
              scopes.add(container, this.createInterfaceDescription(node, typeName, document2));
            }
          }
        }
        createInterfaceDescription(node, name, document2 = (0, ast_util_1.getDocument)(node)) {
          var _a4;
          const nameNode = (_a4 = this.nameProvider.getNameNode(node)) !== null && _a4 !== void 0 ? _a4 : node.$cstNode;
          return {
            node,
            name,
            nameSegment: (0, cst_util_1.toDocumentSegment)(nameNode),
            selectionSegment: (0, cst_util_1.toDocumentSegment)(node.$cstNode),
            type: "Interface",
            documentUri: document2.uri,
            path: this.astNodeLocator.getAstNodePath(node)
          };
        }
      };
      exports2.LangiumGrammarScopeComputation = LangiumGrammarScopeComputation;
    }
  });

  // node_modules/langium/lib/grammar/validation/validator.js
  var require_validator = __commonJS({
    "node_modules/langium/lib/grammar/validation/validator.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LangiumGrammarValidator = exports2.IssueCodes = exports2.registerValidationChecks = void 0;
      var vscode_languageserver_types_1 = require_main2();
      var ast_util_1 = require_ast_util();
      var collections_1 = require_collections();
      var cst_util_1 = require_cst_util();
      var grammar_util_1 = require_grammar_util();
      var stream_1 = require_stream();
      var ast = __importStar(require_ast());
      var ast_1 = require_ast();
      var internal_grammar_util_1 = require_internal_grammar_util();
      var declared_types_1 = require_declared_types();
      var plain_types_1 = require_plain_types();
      function registerValidationChecks(services) {
        const registry = services.validation.ValidationRegistry;
        const validator = services.validation.LangiumGrammarValidator;
        const checks = {
          Action: [
            validator.checkAssignmentReservedName
          ],
          AbstractRule: validator.checkRuleName,
          Assignment: [
            validator.checkAssignmentWithFeatureName,
            validator.checkAssignmentToFragmentRule,
            validator.checkAssignmentTypes,
            validator.checkAssignmentReservedName
          ],
          ParserRule: [
            validator.checkParserRuleDataType,
            validator.checkRuleParametersUsed,
            validator.checkParserRuleReservedName
          ],
          TerminalRule: [
            validator.checkTerminalRuleReturnType,
            validator.checkHiddenTerminalRule,
            validator.checkEmptyTerminalRule
          ],
          InferredType: validator.checkTypeReservedName,
          Keyword: validator.checkKeyword,
          UnorderedGroup: validator.checkUnorderedGroup,
          Grammar: [
            validator.checkGrammarName,
            validator.checkEntryGrammarRule,
            validator.checkUniqueRuleName,
            validator.checkUniqueTypeName,
            validator.checkUniqueImportedRules,
            validator.checkDuplicateImportedGrammar,
            validator.checkGrammarHiddenTokens,
            validator.checkGrammarForUnusedRules,
            validator.checkGrammarTypeInfer,
            validator.checkClashingTerminalNames
          ],
          GrammarImport: validator.checkPackageImport,
          CharacterRange: validator.checkInvalidCharacterRange,
          Interface: [
            validator.checkTypeReservedName,
            validator.checkInterfacePropertyTypes
          ],
          Type: [
            validator.checkTypeReservedName
          ],
          TypeAttribute: validator.checkTypeReservedName,
          RuleCall: [
            validator.checkUsedHiddenTerminalRule,
            validator.checkUsedFragmentTerminalRule,
            validator.checkRuleCallParameters
          ],
          TerminalRuleCall: validator.checkUsedHiddenTerminalRule,
          CrossReference: [
            validator.checkCrossReferenceSyntax,
            validator.checkCrossRefNameAssignment,
            validator.checkCrossRefTerminalType,
            validator.checkCrossRefType,
            validator.checkCrossReferenceToTypeUnion
          ],
          SimpleType: validator.checkFragmentsInTypes,
          ReferenceType: validator.checkReferenceTypeUnion
        };
        registry.register(checks, validator);
      }
      exports2.registerValidationChecks = registerValidationChecks;
      var IssueCodes;
      (function(IssueCodes2) {
        IssueCodes2.GrammarNameUppercase = "grammar-name-uppercase";
        IssueCodes2.RuleNameUppercase = "rule-name-uppercase";
        IssueCodes2.HiddenGrammarTokens = "hidden-grammar-tokens";
        IssueCodes2.UseRegexTokens = "use-regex-tokens";
        IssueCodes2.EntryRuleTokenSyntax = "entry-rule-token-syntax";
        IssueCodes2.CrossRefTokenSyntax = "cross-ref-token-syntax";
        IssueCodes2.UnnecessaryFileExtension = "unnecessary-file-extension";
        IssueCodes2.InvalidReturns = "invalid-returns";
        IssueCodes2.InvalidInfers = "invalid-infers";
        IssueCodes2.MissingInfer = "missing-infer";
        IssueCodes2.MissingReturns = "missing-returns";
        IssueCodes2.SuperfluousInfer = "superfluous-infer";
        IssueCodes2.OptionalUnorderedGroup = "optional-unordered-group";
      })(IssueCodes = exports2.IssueCodes || (exports2.IssueCodes = {}));
      var LangiumGrammarValidator = class {
        constructor(services) {
          this.references = services.references.References;
          this.documents = services.shared.workspace.LangiumDocuments;
        }
        checkGrammarName(grammar, accept) {
          if (grammar.name) {
            const firstChar = grammar.name.substring(0, 1);
            if (firstChar.toUpperCase() !== firstChar) {
              accept("warning", "Grammar name should start with an upper case letter.", { node: grammar, property: "name", code: IssueCodes.GrammarNameUppercase });
            }
          }
        }
        checkEntryGrammarRule(grammar, accept) {
          if (grammar.isDeclared && !grammar.name) {
            return;
          }
          const entryRules = grammar.rules.filter((e) => ast.isParserRule(e) && e.entry);
          if (grammar.isDeclared && entryRules.length === 0) {
            const possibleEntryRule = grammar.rules.find((e) => ast.isParserRule(e) && !(0, internal_grammar_util_1.isDataTypeRule)(e));
            if (possibleEntryRule) {
              accept("error", "The grammar is missing an entry parser rule. This rule can be an entry one.", { node: possibleEntryRule, property: "name", code: IssueCodes.EntryRuleTokenSyntax });
            } else {
              accept("error", "This grammar is missing an entry parser rule.", { node: grammar, property: "name" });
            }
          } else if (!grammar.isDeclared && entryRules.length >= 1) {
            entryRules.forEach((rule) => accept("error", "Cannot declare entry rules for unnamed grammars.", { node: rule, property: "name" }));
          } else if (entryRules.length > 1) {
            entryRules.forEach((rule) => accept("error", "The entry rule has to be unique.", { node: rule, property: "name" }));
          } else if (entryRules.length === 1 && (0, internal_grammar_util_1.isDataTypeRule)(entryRules[0])) {
            accept("error", "The entry rule cannot be a data type rule.", { node: entryRules[0], property: "name" });
          }
        }
        /**
         * Check whether any rule defined in this grammar is a duplicate of an already defined rule or an imported rule
         */
        checkUniqueRuleName(grammar, accept) {
          const extractor = (grammar2) => (0, stream_1.stream)(grammar2.rules).filter((rule) => !isEmptyRule(rule));
          this.checkUniqueName(grammar, accept, extractor, "rule");
        }
        /**
         * Check whether any type defined in this grammar is a duplicate of an already defined type or an imported type
         */
        checkUniqueTypeName(grammar, accept) {
          const extractor = (grammar2) => (0, stream_1.stream)(grammar2.types).concat(grammar2.interfaces);
          this.checkUniqueName(grammar, accept, extractor, "type");
        }
        checkUniqueName(grammar, accept, extractor, uniqueObjName) {
          const map = new collections_1.MultiMap();
          extractor(grammar).forEach((e) => map.add(e.name, e));
          for (const [, types] of map.entriesGroupedByKey()) {
            if (types.length > 1) {
              types.forEach((e) => {
                accept("error", `A ${uniqueObjName}'s name has to be unique.`, { node: e, property: "name" });
              });
            }
          }
          const imported = /* @__PURE__ */ new Set();
          const resolvedGrammars = (0, internal_grammar_util_1.resolveTransitiveImports)(this.documents, grammar);
          for (const resolvedGrammar of resolvedGrammars) {
            extractor(resolvedGrammar).forEach((e) => imported.add(e.name));
          }
          for (const name of map.keys()) {
            if (imported.has(name)) {
              const types = map.get(name);
              types.forEach((e) => {
                accept("error", `A ${uniqueObjName} with the name '${e.name}' already exists in an imported grammar.`, { node: e, property: "name" });
              });
            }
          }
        }
        checkDuplicateImportedGrammar(grammar, accept) {
          const importMap = new collections_1.MultiMap();
          for (const imp of grammar.imports) {
            const resolvedGrammar = (0, internal_grammar_util_1.resolveImport)(this.documents, imp);
            if (resolvedGrammar) {
              importMap.add(resolvedGrammar, imp);
            }
          }
          for (const [, imports] of importMap.entriesGroupedByKey()) {
            if (imports.length > 1) {
              imports.forEach((imp, i) => {
                if (i > 0) {
                  accept("warning", "The grammar is already being directly imported.", { node: imp, tags: [vscode_languageserver_types_1.DiagnosticTag.Unnecessary] });
                }
              });
            }
          }
        }
        /**
         * Compared to the validation above, this validation only checks whether two imported grammars export the same grammar rule.
         */
        checkUniqueImportedRules(grammar, accept) {
          const imports = /* @__PURE__ */ new Map();
          for (const imp of grammar.imports) {
            const importedGrammars = (0, internal_grammar_util_1.resolveTransitiveImports)(this.documents, imp);
            imports.set(imp, importedGrammars);
          }
          const allDuplicates = new collections_1.MultiMap();
          for (const outerImport of grammar.imports) {
            const outerGrammars = imports.get(outerImport);
            for (const innerImport of grammar.imports) {
              if (outerImport === innerImport) {
                continue;
              }
              const innerGrammars = imports.get(innerImport);
              const duplicates = this.getDuplicateExportedRules(outerGrammars, innerGrammars);
              for (const duplicate of duplicates) {
                allDuplicates.add(outerImport, duplicate);
              }
            }
          }
          for (const imp of grammar.imports) {
            const duplicates = allDuplicates.get(imp);
            if (duplicates.length > 0) {
              accept("error", "Some rules exported by this grammar are also included in other imports: " + (0, stream_1.stream)(duplicates).distinct().join(", "), { node: imp, property: "path" });
            }
          }
        }
        getDuplicateExportedRules(outer, inner) {
          const exclusiveOuter = outer.filter((g) => !inner.includes(g));
          const outerRules = exclusiveOuter.flatMap((e) => e.rules);
          const innerRules = inner.flatMap((e) => e.rules);
          const duplicates = /* @__PURE__ */ new Set();
          for (const outerRule of outerRules) {
            const outerName = outerRule.name;
            for (const innerRule of innerRules) {
              const innerName = innerRule.name;
              if (outerName === innerName) {
                duplicates.add(innerRule.name);
              }
            }
          }
          return duplicates;
        }
        checkGrammarTypeInfer(grammar, accept) {
          var _a4, _b2, _c2;
          const types = /* @__PURE__ */ new Set();
          for (const type of grammar.types) {
            types.add(type.name);
          }
          for (const interfaceType of grammar.interfaces) {
            types.add(interfaceType.name);
          }
          (0, internal_grammar_util_1.resolveTransitiveImports)(this.documents, grammar).forEach((grammar2) => {
            grammar2.types.forEach((type) => types.add(type.name));
            grammar2.interfaces.forEach((iface) => types.add(iface.name));
          });
          for (const rule of grammar.rules.filter(ast.isParserRule)) {
            if (isEmptyRule(rule)) {
              continue;
            }
            const isDataType = (0, internal_grammar_util_1.isDataTypeRule)(rule);
            const isInfers = !rule.returnType && !rule.dataType;
            const ruleTypeName = (0, internal_grammar_util_1.getTypeNameWithoutError)(rule);
            if (!isDataType && ruleTypeName && types.has(ruleTypeName) === isInfers) {
              if ((isInfers || ((_a4 = rule.returnType) === null || _a4 === void 0 ? void 0 : _a4.ref) !== void 0) && rule.inferredType === void 0) {
                accept("error", getMessage(ruleTypeName, isInfers), {
                  node: rule,
                  property: "name",
                  code: IssueCodes.MissingReturns
                });
              } else if (isInfers || ((_b2 = rule.returnType) === null || _b2 === void 0 ? void 0 : _b2.ref) !== void 0) {
                const infersNode = (0, grammar_util_1.findNodeForKeyword)(rule.inferredType.$cstNode, "infers");
                accept("error", getMessage(ruleTypeName, isInfers), {
                  node: rule.inferredType,
                  property: "name",
                  code: IssueCodes.InvalidInfers,
                  data: (0, cst_util_1.toDocumentSegment)(infersNode)
                });
              }
            } else if (isDataType && isInfers) {
              const inferNode = (0, grammar_util_1.findNodeForKeyword)(rule.$cstNode, "infer");
              accept("error", "Data type rules cannot infer a type.", {
                node: rule,
                property: "inferredType",
                code: IssueCodes.InvalidInfers,
                data: (0, cst_util_1.toDocumentSegment)(inferNode)
              });
            }
          }
          for (const action of (0, ast_util_1.streamAllContents)(grammar).filter(ast.isAction)) {
            const actionType = this.getActionType(action);
            if (actionType) {
              const isInfers = Boolean(action.inferredType);
              const typeName = (0, internal_grammar_util_1.getTypeNameWithoutError)(action);
              if (action.type && typeName && types.has(typeName) === isInfers) {
                const keywordNode = isInfers ? (0, grammar_util_1.findNodeForKeyword)(action.$cstNode, "infer") : (0, grammar_util_1.findNodeForKeyword)(action.$cstNode, "{");
                accept("error", getMessage(typeName, isInfers), {
                  node: action,
                  property: "type",
                  code: isInfers ? IssueCodes.SuperfluousInfer : IssueCodes.MissingInfer,
                  data: (0, cst_util_1.toDocumentSegment)(keywordNode)
                });
              } else if (actionType && typeName && types.has(typeName) && isInfers) {
                if (action.$cstNode) {
                  const inferredTypeNode = (0, grammar_util_1.findNodeForProperty)((_c2 = action.inferredType) === null || _c2 === void 0 ? void 0 : _c2.$cstNode, "name");
                  const keywordNode = (0, grammar_util_1.findNodeForKeyword)(action.$cstNode, "{");
                  if (inferredTypeNode && keywordNode) {
                    accept("error", `${typeName} is a declared type and cannot be redefined.`, {
                      node: action,
                      property: "type",
                      code: IssueCodes.SuperfluousInfer,
                      data: {
                        start: keywordNode.range.end,
                        end: inferredTypeNode.range.start
                      }
                    });
                  }
                }
              }
            }
          }
          function getMessage(name, infer) {
            if (infer) {
              return `The type '${name}' is already explicitly declared and cannot be inferred.`;
            } else {
              return `The type '${name}' is not explicitly declared and must be inferred.`;
            }
          }
        }
        getActionType(rule) {
          var _a4;
          if (rule.type) {
            return (_a4 = rule.type) === null || _a4 === void 0 ? void 0 : _a4.ref;
          } else if (rule.inferredType) {
            return rule.inferredType;
          }
          return void 0;
        }
        checkGrammarHiddenTokens(grammar, accept) {
          if (grammar.definesHiddenTokens) {
            accept("error", "Hidden terminals are declared at the terminal definition.", { node: grammar, property: "definesHiddenTokens", code: IssueCodes.HiddenGrammarTokens });
          }
        }
        checkHiddenTerminalRule(terminalRule, accept) {
          if (terminalRule.hidden && terminalRule.fragment) {
            accept("error", "Cannot use terminal fragments as hidden tokens.", { node: terminalRule, property: "hidden" });
          }
        }
        checkEmptyTerminalRule(terminalRule, accept) {
          try {
            const regex = (0, internal_grammar_util_1.terminalRegex)(terminalRule);
            if (new RegExp(regex).test("")) {
              accept("error", "This terminal could match an empty string.", { node: terminalRule, property: "name" });
            }
          } catch (_a4) {
          }
        }
        checkUsedHiddenTerminalRule(ruleCall, accept) {
          const parentRule = (0, ast_util_1.getContainerOfType)(ruleCall, (n) => ast.isTerminalRule(n) || ast.isParserRule(n));
          if (parentRule) {
            if ("hidden" in parentRule && parentRule.hidden) {
              return;
            }
            const ref = ruleCall.rule.ref;
            if (ast.isTerminalRule(ref) && ref.hidden) {
              accept("error", "Cannot use hidden terminal in non-hidden rule", { node: ruleCall, property: "rule" });
            }
          }
        }
        checkUsedFragmentTerminalRule(ruleCall, accept) {
          const terminal = ruleCall.rule.ref;
          if (ast.isTerminalRule(terminal) && terminal.fragment) {
            const parentRule = (0, ast_util_1.getContainerOfType)(ruleCall, ast.isParserRule);
            if (parentRule) {
              accept("error", "Cannot use terminal fragments as part of parser rules.", { node: ruleCall, property: "rule" });
            }
          }
        }
        checkCrossReferenceSyntax(crossRef, accept) {
          if (crossRef.deprecatedSyntax) {
            accept("error", "'|' is deprecated. Please, use ':' instead.", { node: crossRef, property: "deprecatedSyntax", code: IssueCodes.CrossRefTokenSyntax });
          }
        }
        checkPackageImport(imp, accept) {
          const resolvedGrammar = (0, internal_grammar_util_1.resolveImport)(this.documents, imp);
          if (resolvedGrammar === void 0) {
            accept("error", "Import cannot be resolved.", { node: imp, property: "path" });
          } else if (imp.path.endsWith(".langium")) {
            accept("warning", "Imports do not need file extensions.", { node: imp, property: "path", code: IssueCodes.UnnecessaryFileExtension });
          }
        }
        checkInvalidCharacterRange(range, accept) {
          if (range.right) {
            const message = "Character ranges cannot use more than one character";
            let invalid = false;
            if (range.left.value.length > 1) {
              invalid = true;
              accept("error", message, { node: range.left, property: "value" });
            }
            if (range.right.value.length > 1) {
              invalid = true;
              accept("error", message, { node: range.right, property: "value" });
            }
            if (!invalid) {
              accept("hint", "Consider using regex instead of character ranges", { node: range, code: IssueCodes.UseRegexTokens });
            }
          }
        }
        checkGrammarForUnusedRules(grammar, accept) {
          const reachableRules = (0, grammar_util_1.getAllReachableRules)(grammar, true);
          for (const rule of grammar.rules) {
            if (ast.isTerminalRule(rule) && rule.hidden || isEmptyRule(rule)) {
              continue;
            }
            if (!reachableRules.has(rule)) {
              accept("hint", "This rule is declared but never referenced.", {
                node: rule,
                property: "name",
                tags: [vscode_languageserver_types_1.DiagnosticTag.Unnecessary]
              });
            }
          }
        }
        checkClashingTerminalNames(grammar, accept) {
          const localTerminals = new collections_1.MultiMap();
          const localKeywords = /* @__PURE__ */ new Set();
          for (const rule of grammar.rules) {
            if (ast.isTerminalRule(rule) && rule.name) {
              localTerminals.add(rule.name, rule);
            }
            if (ast.isParserRule(rule)) {
              const keywords = (0, ast_util_1.streamAllContents)(rule).filter(ast.isKeyword);
              keywords.forEach((e) => localKeywords.add(e.value));
            }
          }
          const importedTerminals = new collections_1.MultiMap();
          const importedKeywords = new collections_1.MultiMap();
          for (const importNode of grammar.imports) {
            const importedGrammars = (0, internal_grammar_util_1.resolveTransitiveImports)(this.documents, importNode);
            for (const importedGrammar of importedGrammars) {
              for (const rule of importedGrammar.rules) {
                if (ast.isTerminalRule(rule) && rule.name) {
                  importedTerminals.add(rule.name, importNode);
                } else if (ast.isParserRule(rule) && rule.name) {
                  const keywords = (0, ast_util_1.streamAllContents)(rule).filter(ast.isKeyword);
                  keywords.forEach((e) => importedKeywords.add(e.value, importNode));
                }
              }
            }
          }
          for (const localTerminal of localTerminals.values()) {
            if (localKeywords.has(localTerminal.name)) {
              accept("error", "Terminal name clashes with existing keyword.", {
                node: localTerminal,
                property: "name"
              });
            } else if (importedKeywords.has(localTerminal.name)) {
              const importNode = importedKeywords.get(localTerminal.name);
              accept("error", `Terminal name clashes with imported keyword from "${importNode[0].path}".`, {
                node: localTerminal,
                property: "name"
              });
            }
          }
          const importTerminalMap = new collections_1.MultiMap();
          for (const localKeyword of localKeywords) {
            for (const importNode of importedTerminals.get(localKeyword)) {
              importTerminalMap.add(importNode, localKeyword);
            }
          }
          for (const [importNode, keywords] of importTerminalMap.entriesGroupedByKey()) {
            if (keywords.length > 0) {
              accept("error", `Imported terminals (${keywords.join(", ")}) clash with locally defined keywords.`, {
                node: importNode,
                property: "path"
              });
            }
          }
          const importKeywordMap = new collections_1.MultiMap();
          for (const [name, imports] of importedTerminals.entriesGroupedByKey()) {
            const keywordImports = importedKeywords.get(name);
            if (keywordImports.length > 0) {
              imports.filter((e) => !keywordImports.includes(e)).forEach((e) => importKeywordMap.add(e, name));
            }
          }
          for (const [importNode, keywords] of importKeywordMap.entriesGroupedByKey()) {
            if (keywords.length > 0) {
              accept("error", `Imported terminals (${keywords.join(", ")}) clash with imported keywords.`, {
                node: importNode,
                property: "path"
              });
            }
          }
        }
        checkRuleName(rule, accept) {
          if (rule.name && !isEmptyRule(rule)) {
            const firstChar = rule.name.substring(0, 1);
            if (firstChar.toUpperCase() !== firstChar) {
              accept("warning", "Rule name should start with an upper case letter.", {
                node: rule,
                property: "name",
                code: IssueCodes.RuleNameUppercase
              });
            }
          }
        }
        checkTypeReservedName(type, accept) {
          this.checkReservedName(type, "name", accept);
        }
        checkAssignmentReservedName(assignment, accept) {
          this.checkReservedName(assignment, "feature", accept);
        }
        checkParserRuleReservedName(rule, accept) {
          if (!rule.inferredType) {
            this.checkReservedName(rule, "name", accept);
          }
        }
        checkReservedName(node, property, accept) {
          const name = node[property];
          if (typeof name === "string" && reservedNames.has(name)) {
            accept("error", `'${name}' is a reserved name of the JavaScript runtime.`, {
              node,
              property
            });
          }
        }
        checkKeyword(keyword, accept) {
          if ((0, ast_util_1.getContainerOfType)(keyword, ast_1.isParserRule)) {
            if (keyword.value.length === 0) {
              accept("error", "Keywords cannot be empty.", { node: keyword });
            } else if (keyword.value.trim().length === 0) {
              accept("error", "Keywords cannot only consist of whitespace characters.", { node: keyword });
            } else if (/\s/g.test(keyword.value)) {
              accept("warning", "Keywords should not contain whitespace characters.", { node: keyword });
            }
          }
        }
        checkUnorderedGroup(unorderedGroup, accept) {
          unorderedGroup.elements.forEach((ele) => {
            if ((0, internal_grammar_util_1.isOptionalCardinality)(ele.cardinality)) {
              accept("error", "Optional elements in Unordered groups are currently not supported", { node: ele, code: IssueCodes.OptionalUnorderedGroup });
            }
          });
        }
        checkRuleParametersUsed(rule, accept) {
          const parameters = rule.parameters;
          if (parameters.length > 0) {
            const allReferences = (0, ast_util_1.streamAllContents)(rule).filter(ast.isParameterReference);
            for (const parameter of parameters) {
              if (!allReferences.some((e) => e.parameter.ref === parameter)) {
                accept("hint", `Parameter '${parameter.name}' is unused.`, {
                  node: parameter,
                  tags: [vscode_languageserver_types_1.DiagnosticTag.Unnecessary]
                });
              }
            }
          }
        }
        checkParserRuleDataType(rule, accept) {
          if (isEmptyRule(rule)) {
            return;
          }
          const hasDatatypeReturnType = (0, internal_grammar_util_1.hasDataTypeReturn)(rule);
          const dataTypeRule = (0, internal_grammar_util_1.isDataTypeRule)(rule);
          if (!hasDatatypeReturnType && dataTypeRule) {
            accept("error", "This parser rule does not create an object. Add a primitive return type or an action to the start of the rule to force object instantiation.", { node: rule, property: "name" });
          } else if (hasDatatypeReturnType && !dataTypeRule) {
            accept("error", "Normal parser rules are not allowed to return a primitive value. Use a datatype rule for that.", { node: rule, property: rule.dataType ? "dataType" : "returnType" });
          }
        }
        checkAssignmentToFragmentRule(assignment, accept) {
          if (!assignment.terminal) {
            return;
          }
          if ((0, ast_1.isRuleCall)(assignment.terminal) && (0, ast_1.isParserRule)(assignment.terminal.rule.ref) && assignment.terminal.rule.ref.fragment) {
            accept("error", `Cannot use fragment rule '${assignment.terminal.rule.ref.name}' for assignment of property '${assignment.feature}'.`, { node: assignment, property: "terminal" });
          }
        }
        checkAssignmentTypes(assignment, accept) {
          if (!assignment.terminal) {
            return;
          }
          let firstType;
          const foundMixed = (0, ast_util_1.streamAllContents)(assignment.terminal).map((node) => ast.isCrossReference(node) ? "ref" : "other").find((type) => {
            if (!firstType) {
              firstType = type;
              return false;
            }
            return type !== firstType;
          });
          if (foundMixed) {
            accept("error", this.createMixedTypeError(assignment.feature), {
              node: assignment,
              property: "terminal"
            });
          }
        }
        checkInterfacePropertyTypes(interfaceDecl, accept) {
          for (const attribute of interfaceDecl.attributes) {
            if (attribute.type) {
              const plainType = (0, declared_types_1.typeDefinitionToPropertyType)(attribute.type);
              const flattened = (0, plain_types_1.flattenPlainType)(plainType);
              let hasRef = false;
              let hasNonRef = false;
              for (const flat of flattened) {
                if ((0, plain_types_1.isPlainReferenceType)(flat)) {
                  hasRef = true;
                } else if (!(0, plain_types_1.isPlainReferenceType)(flat)) {
                  hasNonRef = true;
                }
              }
              if (hasRef && hasNonRef) {
                accept("error", this.createMixedTypeError(attribute.name), {
                  node: attribute,
                  property: "type"
                });
              }
            }
          }
        }
        createMixedTypeError(propName) {
          return `Mixing a cross-reference with other types is not supported. Consider splitting property "${propName}" into two or more different properties.`;
        }
        checkTerminalRuleReturnType(rule, accept) {
          var _a4;
          if (((_a4 = rule.type) === null || _a4 === void 0 ? void 0 : _a4.name) && !(0, internal_grammar_util_1.isPrimitiveType)(rule.type.name)) {
            accept("error", "Terminal rules can only return primitive types like 'string', 'boolean', 'number', 'Date' or 'bigint'.", { node: rule.type, property: "name" });
          }
        }
        checkRuleCallParameters(ruleCall, accept) {
          const rule = ruleCall.rule.ref;
          if (ast.isParserRule(rule)) {
            const expected = rule.parameters.length;
            const given = ruleCall.arguments.length;
            if (expected !== given) {
              accept("error", `Rule '${rule.name}' expects ${expected} arguments, but got ${given}.`, { node: ruleCall });
            }
          } else if (ast.isTerminalRule(rule) && ruleCall.arguments.length > 0) {
            accept("error", "Terminal rules do not accept any arguments", { node: ruleCall });
          }
        }
        checkCrossRefNameAssignment(reference, accept) {
          if (!reference.terminal && reference.type.ref && !(0, grammar_util_1.findNameAssignment)(reference.type.ref)) {
            accept("error", "Cannot infer terminal or data type rule for cross reference.", { node: reference, property: "type" });
          }
        }
        checkCrossRefTerminalType(reference, accept) {
          if (ast.isRuleCall(reference.terminal) && ast.isParserRule(reference.terminal.rule.ref) && !(0, internal_grammar_util_1.isDataTypeRule)(reference.terminal.rule.ref)) {
            accept("error", "Parser rules cannot be used for cross references.", { node: reference.terminal, property: "rule" });
          }
        }
        checkCrossRefType(reference, accept) {
          const issue = this.checkReferenceToRuleButNotType(reference === null || reference === void 0 ? void 0 : reference.type);
          if (issue) {
            accept("error", issue, { node: reference, property: "type" });
          }
        }
        checkCrossReferenceToTypeUnion(reference, accept) {
          if (ast.isType(reference.type.ref) && ast.isUnionType(reference.type.ref.type)) {
            const errors = checkTypeUnionContainsOnlyParseRules(reference.type.ref.type);
            if (errors.length > 0) {
              accept("error", `Cross-reference on type union is only valid if all alternatives are AST nodes. ${errors.join(", ")} ${errors.length > 1 ? "are" : "is"} not ${errors.length > 1 ? "" : "an "}AST node${errors.length > 1 ? "s" : ""}.`, { node: reference, property: "type" });
            }
          }
        }
        checkFragmentsInTypes(type, accept) {
          var _a4, _b2;
          if (ast.isParserRule((_a4 = type.typeRef) === null || _a4 === void 0 ? void 0 : _a4.ref) && ((_b2 = type.typeRef) === null || _b2 === void 0 ? void 0 : _b2.ref.fragment)) {
            accept("error", "Cannot use rule fragments in types.", { node: type, property: "typeRef" });
          }
        }
        checkReferenceTypeUnion(type, accept) {
          if (!ast.isSimpleType(type.referenceType)) {
            accept("error", "Only direct rule references are allowed in reference types.", { node: type, property: "referenceType" });
          }
        }
        checkReferenceToRuleButNotType(type) {
          if (type && ast.isParserRule(type.ref) && !(0, internal_grammar_util_1.isDataTypeRule)(type.ref) && (type.ref.returnType || type.ref.inferredType)) {
            const typeName = (0, internal_grammar_util_1.getTypeNameWithoutError)(type.ref);
            if (typeName) {
              return `Use the rule type '${typeName}' instead of the typed rule name '${type.ref.name}' for cross references.`;
            }
          }
          return void 0;
        }
        checkAssignmentWithFeatureName(assignment, accept) {
          if (assignment.feature === "name" && ast.isCrossReference(assignment.terminal)) {
            accept("warning", 'The "name" property is not recommended for cross-references.', { node: assignment, property: "feature" });
          }
        }
      };
      exports2.LangiumGrammarValidator = LangiumGrammarValidator;
      function isEmptyRule(rule) {
        return !rule.definition || !rule.definition.$cstNode || rule.definition.$cstNode.length === 0;
      }
      var reservedNames = /* @__PURE__ */ new Set([
        // Built-in objects, properties and methods
        // Collections
        "Array",
        "Int8Array",
        "Uint8Array",
        "Uint8ClampedArray",
        "Int16Array",
        "Uint16Array",
        "Int32Array",
        "Uint32Array",
        "Float32Array",
        "Float64Array",
        "BigInt64Array",
        "BigUint64Array",
        // Keyed collections
        "Map",
        "Set",
        "WeakMap",
        "WeakSet",
        // Errors
        "Error",
        "AggregateError",
        "EvalError",
        "InternalError",
        "RangeError",
        "ReferenceError",
        "SyntaxError",
        "TypeError",
        "URIError",
        // Primitives
        "BigInt",
        "RegExp",
        "Number",
        "Object",
        "Function",
        "Symbol",
        "String",
        // Math
        "Math",
        "NaN",
        "Infinity",
        "isFinite",
        "isNaN",
        // Structured data
        "Buffer",
        "ArrayBuffer",
        "SharedArrayBuffer",
        "Atomics",
        "DataView",
        "JSON",
        "globalThis",
        "decodeURIComponent",
        "decodeURI",
        "encodeURIComponent",
        "encodeURI",
        "parseInt",
        "parseFloat",
        // Control abstraction
        "Promise",
        "Generator",
        "GeneratorFunction",
        "AsyncFunction",
        "AsyncGenerator",
        "AsyncGeneratorFunction",
        // Reflection
        "Reflect",
        "Proxy",
        // Others
        "Date",
        "Intl",
        "eval",
        "undefined"
      ]);
      function checkTypeUnionContainsOnlyParseRules(type) {
        const errors = [];
        type.types.forEach((type2) => {
          var _a4;
          if (ast.isSimpleType(type2)) {
            if ((_a4 = type2.typeRef) === null || _a4 === void 0 ? void 0 : _a4.ref) {
              if (ast.isType(type2.typeRef.ref)) {
                if (ast.isUnionType(type2.typeRef.ref.type)) {
                  errors.push(...checkTypeUnionContainsOnlyParseRules(type2.typeRef.ref.type));
                } else {
                  errors.push(type2.typeRef.ref.name);
                }
              }
            } else if (type2.stringType) {
              errors.push(`"${type2.stringType}"`);
            } else if (type2.primitiveType) {
              errors.push(type2.primitiveType);
            }
          }
        });
        return Array.from(new Set(errors));
      }
    }
  });

  // node_modules/langium/lib/validation/document-validator.js
  var require_document_validator = __commonJS({
    "node_modules/langium/lib/validation/document-validator.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DocumentValidator = exports2.toDiagnosticSeverity = exports2.getDiagnosticRange = exports2.DefaultDocumentValidator = void 0;
      var vscode_languageserver_1 = require_main4();
      var grammar_util_1 = require_grammar_util();
      var ast_util_1 = require_ast_util();
      var cst_util_1 = require_cst_util();
      var promise_util_1 = require_promise_util();
      var DefaultDocumentValidator = class {
        constructor(services) {
          this.validationRegistry = services.validation.ValidationRegistry;
          this.metadata = services.LanguageMetaData;
        }
        async validateDocument(document2, cancelToken = vscode_languageserver_1.CancellationToken.None) {
          const parseResult = document2.parseResult;
          const diagnostics = [];
          await (0, promise_util_1.interruptAndCheck)(cancelToken);
          for (const lexerError of parseResult.lexerErrors) {
            const diagnostic = {
              severity: vscode_languageserver_1.DiagnosticSeverity.Error,
              range: {
                start: {
                  line: lexerError.line - 1,
                  character: lexerError.column - 1
                },
                end: {
                  line: lexerError.line - 1,
                  character: lexerError.column + lexerError.length - 1
                }
              },
              message: lexerError.message,
              code: DocumentValidator.LexingError,
              source: this.getSource()
            };
            diagnostics.push(diagnostic);
          }
          for (const parserError of parseResult.parserErrors) {
            let range = void 0;
            if (isNaN(parserError.token.startOffset)) {
              if ("previousToken" in parserError) {
                const token = parserError.previousToken;
                if (!isNaN(token.startOffset)) {
                  const position = vscode_languageserver_1.Position.create(token.endLine - 1, token.endColumn);
                  range = vscode_languageserver_1.Range.create(position, position);
                } else {
                  range = vscode_languageserver_1.Range.create(0, 0, 0, 0);
                }
              }
            } else {
              range = (0, cst_util_1.tokenToRange)(parserError.token);
            }
            if (range) {
              const diagnostic = {
                severity: vscode_languageserver_1.DiagnosticSeverity.Error,
                range,
                message: parserError.message,
                code: DocumentValidator.ParsingError,
                source: this.getSource()
              };
              diagnostics.push(diagnostic);
            }
          }
          for (const reference of document2.references) {
            const linkingError = reference.error;
            if (linkingError) {
              const data = {
                containerType: linkingError.container.$type,
                property: linkingError.property,
                refText: linkingError.reference.$refText
              };
              const info = {
                node: linkingError.container,
                property: linkingError.property,
                index: linkingError.index,
                code: DocumentValidator.LinkingError,
                data
              };
              diagnostics.push(this.toDiagnostic("error", linkingError.message, info));
            }
          }
          try {
            diagnostics.push(...await this.validateAst(parseResult.value, document2, cancelToken));
          } catch (err) {
            if ((0, promise_util_1.isOperationCancelled)(err)) {
              throw err;
            }
            console.error("An error occurred during validation:", err);
          }
          await (0, promise_util_1.interruptAndCheck)(cancelToken);
          return diagnostics;
        }
        async validateAst(rootNode, document2, cancelToken = vscode_languageserver_1.CancellationToken.None) {
          const validationItems = [];
          const acceptor = (severity, message, info) => {
            validationItems.push(this.toDiagnostic(severity, message, info));
          };
          await Promise.all((0, ast_util_1.streamAst)(rootNode).map(async (node) => {
            await (0, promise_util_1.interruptAndCheck)(cancelToken);
            const checks = this.validationRegistry.getChecks(node.$type);
            for (const check of checks) {
              await check(node, acceptor, cancelToken);
            }
          }));
          return validationItems;
        }
        toDiagnostic(severity, message, info) {
          return {
            message,
            range: getDiagnosticRange(info),
            severity: toDiagnosticSeverity(severity),
            code: info.code,
            codeDescription: info.codeDescription,
            tags: info.tags,
            relatedInformation: info.relatedInformation,
            data: info.data,
            source: this.getSource()
          };
        }
        getSource() {
          return this.metadata.languageId;
        }
      };
      exports2.DefaultDocumentValidator = DefaultDocumentValidator;
      function getDiagnosticRange(info) {
        if (vscode_languageserver_1.Range.is(info.range)) {
          return info.range;
        }
        let cstNode;
        if (typeof info.property === "string") {
          cstNode = (0, grammar_util_1.findNodeForProperty)(info.node.$cstNode, info.property, info.index);
        } else if (typeof info.keyword === "string") {
          cstNode = (0, grammar_util_1.findNodeForKeyword)(info.node.$cstNode, info.keyword, info.index);
        }
        cstNode !== null && cstNode !== void 0 ? cstNode : cstNode = info.node.$cstNode;
        if (!cstNode) {
          return {
            start: { line: 0, character: 0 },
            end: { line: 0, character: 0 }
          };
        }
        return cstNode.range;
      }
      exports2.getDiagnosticRange = getDiagnosticRange;
      function toDiagnosticSeverity(severity) {
        switch (severity) {
          case "error":
            return vscode_languageserver_1.DiagnosticSeverity.Error;
          case "warning":
            return vscode_languageserver_1.DiagnosticSeverity.Warning;
          case "info":
            return vscode_languageserver_1.DiagnosticSeverity.Information;
          case "hint":
            return vscode_languageserver_1.DiagnosticSeverity.Hint;
          default:
            throw new Error("Invalid diagnostic severity: " + severity);
        }
      }
      exports2.toDiagnosticSeverity = toDiagnosticSeverity;
      var DocumentValidator;
      (function(DocumentValidator2) {
        DocumentValidator2.LexingError = "lexing-error";
        DocumentValidator2.ParsingError = "parsing-error";
        DocumentValidator2.LinkingError = "linking-error";
      })(DocumentValidator = exports2.DocumentValidator || (exports2.DocumentValidator = {}));
    }
  });

  // node_modules/langium/lib/grammar/lsp/grammar-code-actions.js
  var require_grammar_code_actions = __commonJS({
    "node_modules/langium/lib/grammar/lsp/grammar-code-actions.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LangiumGrammarCodeActionProvider = void 0;
      var vscode_languageserver_1 = require_main4();
      var vscode_uri_1 = require_umd();
      var ast_util_1 = require_ast_util();
      var cst_util_1 = require_cst_util();
      var grammar_util_1 = require_grammar_util();
      var regex_util_1 = require_regex_util();
      var uri_util_1 = require_uri_util();
      var document_validator_1 = require_document_validator();
      var ast = __importStar(require_ast());
      var validator_1 = require_validator();
      var LangiumGrammarCodeActionProvider = class {
        constructor(services) {
          this.reflection = services.shared.AstReflection;
          this.indexManager = services.shared.workspace.IndexManager;
        }
        getCodeActions(document2, params) {
          const result = [];
          const acceptor = (ca) => ca && result.push(ca);
          for (const diagnostic of params.context.diagnostics) {
            this.createCodeActions(diagnostic, document2, acceptor);
          }
          return result;
        }
        createCodeActions(diagnostic, document2, accept) {
          switch (diagnostic.code) {
            case validator_1.IssueCodes.GrammarNameUppercase:
            case validator_1.IssueCodes.RuleNameUppercase:
              accept(this.makeUpperCase(diagnostic, document2));
              break;
            case validator_1.IssueCodes.HiddenGrammarTokens:
              accept(this.fixHiddenTerminals(diagnostic, document2));
              break;
            case validator_1.IssueCodes.UseRegexTokens:
              accept(this.fixRegexTokens(diagnostic, document2));
              break;
            case validator_1.IssueCodes.EntryRuleTokenSyntax:
              accept(this.addEntryKeyword(diagnostic, document2));
              break;
            case validator_1.IssueCodes.CrossRefTokenSyntax:
              accept(this.fixCrossRefSyntax(diagnostic, document2));
              break;
            case validator_1.IssueCodes.UnnecessaryFileExtension:
              accept(this.fixUnnecessaryFileExtension(diagnostic, document2));
              break;
            case validator_1.IssueCodes.MissingReturns:
              accept(this.fixMissingReturns(diagnostic, document2));
              break;
            case validator_1.IssueCodes.InvalidInfers:
            case validator_1.IssueCodes.InvalidReturns:
              accept(this.fixInvalidReturnsInfers(diagnostic, document2));
              break;
            case validator_1.IssueCodes.MissingInfer:
              accept(this.fixMissingInfer(diagnostic, document2));
              break;
            case validator_1.IssueCodes.SuperfluousInfer:
              accept(this.fixSuperfluousInfer(diagnostic, document2));
              break;
            case document_validator_1.DocumentValidator.LinkingError: {
              const data = diagnostic.data;
              if (data && data.containerType === "RuleCall" && data.property === "rule") {
                accept(this.addNewRule(diagnostic, data, document2));
              }
              if (data) {
                this.lookInGlobalScope(diagnostic, data, document2).forEach(accept);
              }
              break;
            }
          }
          return void 0;
        }
        /**
         * Adds missing returns for parser rule
         */
        fixMissingReturns(diagnostic, document2) {
          const text = document2.textDocument.getText(diagnostic.range);
          if (text) {
            return {
              title: `Add explicit return type for parser rule ${text}`,
              kind: vscode_languageserver_1.CodeActionKind.QuickFix,
              diagnostics: [diagnostic],
              edit: {
                changes: {
                  [document2.textDocument.uri]: [{
                    range: diagnostic.range,
                    newText: `${text} returns ${text}`
                    // suggestion adds missing 'return'
                  }]
                }
              }
            };
          }
          return void 0;
        }
        fixInvalidReturnsInfers(diagnostic, document2) {
          const data = diagnostic.data;
          if (data) {
            const text = document2.textDocument.getText(data.range);
            return {
              title: `Correct ${text} usage`,
              kind: vscode_languageserver_1.CodeActionKind.QuickFix,
              diagnostics: [diagnostic],
              edit: {
                changes: {
                  [document2.textDocument.uri]: [{
                    range: data.range,
                    newText: text === "infers" ? "returns" : "infers"
                  }]
                }
              }
            };
          }
          return void 0;
        }
        fixMissingInfer(diagnostic, document2) {
          const data = diagnostic.data;
          if (data) {
            return {
              title: "Correct 'infer' usage",
              kind: vscode_languageserver_1.CodeActionKind.QuickFix,
              diagnostics: [diagnostic],
              edit: {
                changes: {
                  [document2.textDocument.uri]: [{
                    range: {
                      start: data.range.end,
                      end: data.range.end
                    },
                    newText: "infer "
                  }]
                }
              }
            };
          }
          return void 0;
        }
        fixSuperfluousInfer(diagnostic, document2) {
          if (diagnostic.data) {
            return {
              title: "Remove the 'infer' keyword",
              kind: vscode_languageserver_1.CodeActionKind.QuickFix,
              diagnostics: [diagnostic],
              edit: {
                changes: {
                  [document2.textDocument.uri]: [{
                    range: diagnostic.data,
                    newText: ""
                  }]
                }
              }
            };
          }
          return void 0;
        }
        fixUnnecessaryFileExtension(diagnostic, document2) {
          const end = Object.assign({}, diagnostic.range.end);
          end.character -= 1;
          const start = Object.assign({}, end);
          start.character -= ".langium".length;
          return {
            title: "Remove file extension",
            kind: vscode_languageserver_1.CodeActionKind.QuickFix,
            diagnostics: [diagnostic],
            isPreferred: true,
            edit: {
              changes: {
                [document2.textDocument.uri]: [{
                  range: {
                    start,
                    end
                  },
                  newText: ""
                }]
              }
            }
          };
        }
        makeUpperCase(diagnostic, document2) {
          const range = {
            start: diagnostic.range.start,
            end: {
              line: diagnostic.range.start.line,
              character: diagnostic.range.start.character + 1
            }
          };
          return {
            title: "First letter to upper case",
            kind: vscode_languageserver_1.CodeActionKind.QuickFix,
            diagnostics: [diagnostic],
            isPreferred: true,
            edit: {
              changes: {
                [document2.textDocument.uri]: [{
                  range,
                  newText: document2.textDocument.getText(range).toUpperCase()
                }]
              }
            }
          };
        }
        addEntryKeyword(diagnostic, document2) {
          return {
            title: "Add entry keyword",
            kind: vscode_languageserver_1.CodeActionKind.QuickFix,
            diagnostics: [diagnostic],
            isPreferred: true,
            edit: {
              changes: {
                [document2.textDocument.uri]: [{
                  range: { start: diagnostic.range.start, end: diagnostic.range.start },
                  newText: "entry "
                }]
              }
            }
          };
        }
        fixRegexTokens(diagnostic, document2) {
          const offset = document2.textDocument.offsetAt(diagnostic.range.start);
          const rootCst = document2.parseResult.value.$cstNode;
          if (rootCst) {
            const cstNode = (0, cst_util_1.findLeafNodeAtOffset)(rootCst, offset);
            const container = (0, ast_util_1.getContainerOfType)(cstNode === null || cstNode === void 0 ? void 0 : cstNode.element, ast.isCharacterRange);
            if (container && container.right && container.$cstNode) {
              const left = container.left.value;
              const right = container.right.value;
              return {
                title: "Refactor into regular expression",
                kind: vscode_languageserver_1.CodeActionKind.QuickFix,
                diagnostics: [diagnostic],
                isPreferred: true,
                edit: {
                  changes: {
                    [document2.textDocument.uri]: [{
                      range: container.$cstNode.range,
                      newText: `/[${(0, regex_util_1.escapeRegExp)(left)}-${(0, regex_util_1.escapeRegExp)(right)}]/`
                    }]
                  }
                }
              };
            }
          }
          return void 0;
        }
        fixCrossRefSyntax(diagnostic, document2) {
          return {
            title: "Replace '|' with ':'",
            kind: vscode_languageserver_1.CodeActionKind.QuickFix,
            diagnostics: [diagnostic],
            isPreferred: true,
            edit: {
              changes: {
                [document2.textDocument.uri]: [{
                  range: diagnostic.range,
                  newText: ":"
                }]
              }
            }
          };
        }
        fixHiddenTerminals(diagnostic, document2) {
          const grammar = document2.parseResult.value;
          const hiddenTokens = grammar.hiddenTokens;
          const changes = [];
          const hiddenNode = (0, grammar_util_1.findNodeForProperty)(grammar.$cstNode, "definesHiddenTokens");
          if (hiddenNode) {
            const start = hiddenNode.range.start;
            const offset = hiddenNode.offset;
            const end = grammar.$cstNode.text.indexOf(")", offset) + 1;
            changes.push({
              newText: "",
              range: {
                start,
                end: document2.textDocument.positionAt(end)
              }
            });
          }
          for (const terminal of hiddenTokens) {
            const ref = terminal.ref;
            if (ref && ast.isTerminalRule(ref) && !ref.hidden && ref.$cstNode) {
              const start = ref.$cstNode.range.start;
              changes.push({
                newText: "hidden ",
                range: {
                  start,
                  end: start
                }
              });
            }
          }
          return {
            title: "Fix hidden terminals",
            kind: vscode_languageserver_1.CodeActionKind.QuickFix,
            diagnostics: [diagnostic],
            isPreferred: true,
            edit: {
              changes: {
                [document2.textDocument.uri]: changes
              }
            }
          };
        }
        addNewRule(diagnostic, data, document2) {
          const offset = document2.textDocument.offsetAt(diagnostic.range.start);
          const rootCst = document2.parseResult.value.$cstNode;
          if (rootCst) {
            const cstNode = (0, cst_util_1.findLeafNodeAtOffset)(rootCst, offset);
            const container = (0, ast_util_1.getContainerOfType)(cstNode === null || cstNode === void 0 ? void 0 : cstNode.element, ast.isParserRule);
            if (container && container.$cstNode) {
              return {
                title: `Add new rule '${data.refText}'`,
                kind: vscode_languageserver_1.CodeActionKind.QuickFix,
                diagnostics: [diagnostic],
                isPreferred: false,
                edit: {
                  changes: {
                    [document2.textDocument.uri]: [{
                      range: {
                        start: container.$cstNode.range.end,
                        end: container.$cstNode.range.end
                      },
                      newText: "\n\n" + data.refText + ":\n    /* TODO implement rule */ {infer " + data.refText + "};"
                    }]
                  }
                }
              };
            }
          }
          return void 0;
        }
        lookInGlobalScope(diagnostic, data, document2) {
          var _a4, _b2;
          const refInfo = {
            container: {
              $type: data.containerType
            },
            property: data.property,
            reference: {
              $refText: data.refText
            }
          };
          const referenceType = this.reflection.getReferenceType(refInfo);
          const candidates = this.indexManager.allElements(referenceType).filter((e) => e.name === data.refText);
          const result = [];
          let shortestPathIndex = -1;
          let shortestPathLength = -1;
          for (const candidate of candidates) {
            if ((0, uri_util_1.equalURI)(candidate.documentUri, document2.uri)) {
              continue;
            }
            const importPath = getRelativeImport(document2.uri, candidate.documentUri);
            let position;
            let suffix = "";
            const grammar = document2.parseResult.value;
            const nextImport = grammar.imports.find((imp) => imp.path && importPath < imp.path);
            if (nextImport) {
              position = (_a4 = nextImport.$cstNode) === null || _a4 === void 0 ? void 0 : _a4.range.start;
            } else if (grammar.imports.length > 0) {
              const rangeEnd = grammar.imports[grammar.imports.length - 1].$cstNode.range.end;
              if (rangeEnd) {
                position = { line: rangeEnd.line + 1, character: 0 };
              }
            } else if (grammar.rules.length > 0) {
              position = (_b2 = grammar.rules[0].$cstNode) === null || _b2 === void 0 ? void 0 : _b2.range.start;
              suffix = "\n";
            }
            if (position) {
              if (shortestPathIndex < 0 || importPath.length < shortestPathLength) {
                shortestPathIndex = result.length;
                shortestPathLength = importPath.length;
              }
              result.push({
                title: `Add import to '${importPath}'`,
                kind: vscode_languageserver_1.CodeActionKind.QuickFix,
                diagnostics: [diagnostic],
                isPreferred: false,
                edit: {
                  changes: {
                    [document2.textDocument.uri]: [{
                      range: {
                        start: position,
                        end: position
                      },
                      newText: `import '${importPath}'
${suffix}`
                    }]
                  }
                }
              });
            }
          }
          if (shortestPathIndex >= 0) {
            result[shortestPathIndex].isPreferred = true;
          }
          return result;
        }
      };
      exports2.LangiumGrammarCodeActionProvider = LangiumGrammarCodeActionProvider;
      function getRelativeImport(source, target) {
        const sourceDir = vscode_uri_1.Utils.dirname(source);
        let relativePath2 = (0, uri_util_1.relativeURI)(sourceDir, target);
        if (!relativePath2.startsWith("./") && !relativePath2.startsWith("../")) {
          relativePath2 = "./" + relativePath2;
        }
        if (relativePath2.endsWith(".langium")) {
          relativePath2 = relativePath2.substring(0, relativePath2.length - ".langium".length);
        }
        return relativePath2;
      }
    }
  });

  // node_modules/langium/lib/lsp/folding-range-provider.js
  var require_folding_range_provider = __commonJS({
    "node_modules/langium/lib/lsp/folding-range-provider.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DefaultFoldingRangeProvider = void 0;
      var vscode_languageserver_1 = require_main4();
      var ast_util_1 = require_ast_util();
      var cst_util_1 = require_cst_util();
      var DefaultFoldingRangeProvider = class {
        constructor(services) {
          this.commentNames = services.parser.GrammarConfig.multilineCommentRules;
        }
        getFoldingRanges(document2) {
          const foldings = [];
          const acceptor = (foldingRange) => foldings.push(foldingRange);
          this.collectFolding(document2, acceptor);
          return foldings;
        }
        collectFolding(document2, acceptor) {
          var _a4;
          const root = (_a4 = document2.parseResult) === null || _a4 === void 0 ? void 0 : _a4.value;
          if (root) {
            if (this.shouldProcessContent(root)) {
              const treeIterator = (0, ast_util_1.streamAllContents)(root).iterator();
              let result;
              do {
                result = treeIterator.next();
                if (!result.done) {
                  const node = result.value;
                  if (this.shouldProcess(node)) {
                    this.collectObjectFolding(document2, node, acceptor);
                  }
                  if (!this.shouldProcessContent(node)) {
                    treeIterator.prune();
                  }
                }
              } while (!result.done);
            }
            this.collectCommentFolding(document2, root, acceptor);
          }
        }
        /**
         * Template method to determine whether the specified `AstNode` should be handled by the folding range provider.
         * Returns true by default for all nodes. Returning false only ignores the specified node and not its content.
         * To ignore the content of a node use `shouldProcessContent`.
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        shouldProcess(node) {
          return true;
        }
        /**
         * Template method to determine whether the content/children of the specified `AstNode` should be handled by the folding range provider.
         * Returns true by default for all nodes. Returning false ignores _all_ content of this node, even transitive ones.
         * For more precise control over foldings use the `shouldProcess` method.
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        shouldProcessContent(node) {
          return true;
        }
        collectObjectFolding(document2, node, acceptor) {
          const cstNode = node.$cstNode;
          if (cstNode) {
            const foldingRange = this.toFoldingRange(document2, cstNode);
            if (foldingRange) {
              acceptor(foldingRange);
            }
          }
        }
        collectCommentFolding(document2, node, acceptor) {
          const cstNode = node.$cstNode;
          if (cstNode) {
            for (const node2 of (0, cst_util_1.flattenCst)(cstNode)) {
              if (this.commentNames.includes(node2.tokenType.name)) {
                const foldingRange = this.toFoldingRange(document2, node2, vscode_languageserver_1.FoldingRangeKind.Comment);
                if (foldingRange) {
                  acceptor(foldingRange);
                }
              }
            }
          }
        }
        toFoldingRange(document2, node, kind) {
          const range = node.range;
          const start = range.start;
          let end = range.end;
          if (end.line - start.line < 2) {
            return void 0;
          }
          if (!this.includeLastFoldingLine(node, kind)) {
            end = document2.textDocument.positionAt(document2.textDocument.offsetAt({ line: end.line, character: 0 }) - 1);
          }
          return vscode_languageserver_1.FoldingRange.create(start.line, end.line, start.character, end.character, kind);
        }
        /**
         * Template method to determine whether the folding range for this cst node should include its last line.
         * Returns false by default for ast nodes which end in braces and for comments.
         */
        includeLastFoldingLine(node, kind) {
          if (kind === vscode_languageserver_1.FoldingRangeKind.Comment) {
            return false;
          }
          const nodeText = node.text;
          const endChar = nodeText.charAt(nodeText.length - 1);
          if (endChar === "}" || endChar === ")" || endChar === "]") {
            return false;
          }
          return true;
        }
      };
      exports2.DefaultFoldingRangeProvider = DefaultFoldingRangeProvider;
    }
  });

  // node_modules/langium/lib/grammar/lsp/grammar-folding-ranges.js
  var require_grammar_folding_ranges = __commonJS({
    "node_modules/langium/lib/grammar/lsp/grammar-folding-ranges.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LangiumGrammarFoldingRangeProvider = void 0;
      var folding_range_provider_1 = require_folding_range_provider();
      var ast_1 = require_ast();
      var LangiumGrammarFoldingRangeProvider = class extends folding_range_provider_1.DefaultFoldingRangeProvider {
        shouldProcessContent(node) {
          return !(0, ast_1.isParserRule)(node);
        }
      };
      exports2.LangiumGrammarFoldingRangeProvider = LangiumGrammarFoldingRangeProvider;
    }
  });

  // node_modules/langium/lib/lsp/formatter.js
  var require_formatter = __commonJS({
    "node_modules/langium/lib/lsp/formatter.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Formatting = exports2.FormattingRegion = exports2.DefaultNodeFormatter = exports2.AbstractFormatter = void 0;
      var grammar_util_1 = require_grammar_util();
      var syntax_tree_1 = require_syntax_tree();
      var ast_util_1 = require_ast_util();
      var cst_util_1 = require_cst_util();
      var stream_1 = require_stream();
      var AbstractFormatter = class {
        constructor() {
          this.collector = () => {
          };
        }
        /**
         * Creates a formatter scoped to the supplied AST node.
         * Allows to define fine-grained formatting rules for elements.
         *
         * Example usage:
         *
         * ```ts
         * export class CustomFormatter extends AbstractFormatter {
         *   protected override format(node: AstNode): void {
         *     if (isPerson(node)) {
         *       const formatter = this.getNodeFormatter(node);
         *       formatter.property('name').prepend(Formatting.oneSpace());
         *     }
         *   }
         * }
         * ```
         * @param node The specific node the formatter should be scoped to. Every call to properties or keywords will only select those which belong to the supplied AST node.
         */
        getNodeFormatter(node) {
          return new DefaultNodeFormatter(node, this.collector);
        }
        formatDocument(document2, params) {
          const pr = document2.parseResult;
          if (pr.lexerErrors.length === 0 && pr.parserErrors.length === 0) {
            return this.doDocumentFormat(document2, params.options);
          } else {
            return [];
          }
        }
        /**
         * Returns whether a range for a given document is error free, i.e. safe to format
         *
         * @param document Document to inspect for lexer & parser errors that may produce an unsafe range
         * @param range Formatting range to check for safety
         * @returns Whether the given formatting range does not overlap with or follow any regions with an error
         */
        isFormatRangeErrorFree(document2, range) {
          const pr = document2.parseResult;
          if (pr.lexerErrors.length || pr.parserErrors.length) {
            const earliestErrLine = Math.min(...pr.lexerErrors.map((e) => {
              var _a4;
              return (_a4 = e.line) !== null && _a4 !== void 0 ? _a4 : Number.MAX_VALUE;
            }), ...pr.parserErrors.map((e) => {
              var _a4;
              return (_a4 = e.token.startLine) !== null && _a4 !== void 0 ? _a4 : Number.MAX_VALUE;
            }));
            return earliestErrLine > range.end.line;
          } else {
            return true;
          }
        }
        formatDocumentRange(document2, params) {
          if (this.isFormatRangeErrorFree(document2, params.range)) {
            return this.doDocumentFormat(document2, params.options, params.range);
          } else {
            return [];
          }
        }
        formatDocumentOnType(document2, params) {
          const range = {
            start: {
              character: 0,
              line: params.position.line
            },
            end: params.position
          };
          if (this.isFormatRangeErrorFree(document2, range)) {
            return this.doDocumentFormat(document2, params.options, range);
          } else {
            return [];
          }
        }
        get formatOnTypeOptions() {
          return void 0;
        }
        doDocumentFormat(document2, options, range) {
          const map = /* @__PURE__ */ new Map();
          const collector = (node, mode, formatting) => {
            var _a4, _b2;
            const key = this.nodeModeToKey(node, mode);
            const existing = map.get(key);
            const priority = (_a4 = formatting.options.priority) !== null && _a4 !== void 0 ? _a4 : 0;
            const existingPriority = (_b2 = existing === null || existing === void 0 ? void 0 : existing.options.priority) !== null && _b2 !== void 0 ? _b2 : 0;
            if (!existing || existingPriority <= priority) {
              map.set(key, formatting);
            }
          };
          this.collector = collector;
          this.iterateAstFormatting(document2, range);
          const edits = this.iterateCstFormatting(document2, map, options, range);
          return this.avoidOverlappingEdits(document2.textDocument, edits);
        }
        avoidOverlappingEdits(textDocument, textEdits) {
          const edits = [];
          for (const edit of textEdits) {
            const last = edits[edits.length - 1];
            if (last) {
              const currentStart = textDocument.offsetAt(edit.range.start);
              const lastEnd = textDocument.offsetAt(last.range.end);
              if (currentStart < lastEnd) {
                edits.pop();
              }
            }
            edits.push(edit);
          }
          return edits;
        }
        iterateAstFormatting(document2, range) {
          const root = document2.parseResult.value;
          this.format(root);
          const treeIterator = (0, ast_util_1.streamAllContents)(root).iterator();
          let result;
          do {
            result = treeIterator.next();
            if (!result.done) {
              const node = result.value;
              const inside = this.insideRange(node.$cstNode.range, range);
              if (inside) {
                this.format(node);
              } else {
                treeIterator.prune();
              }
            }
          } while (!result.done);
        }
        nodeModeToKey(node, mode) {
          return `${node.offset}:${node.end}:${mode}`;
        }
        insideRange(inside, total) {
          if (!total) {
            return true;
          }
          if (inside.start.line <= total.start.line && inside.end.line >= total.end.line || inside.start.line >= total.start.line && inside.end.line <= total.end.line || inside.start.line <= total.end.line && inside.end.line >= total.end.line) {
            return true;
          }
          return false;
        }
        isNecessary(edit, document2) {
          const existing = document2.getText(edit.range);
          return existing !== edit.newText;
        }
        iterateCstFormatting(document2, formattings, options, range) {
          const context = {
            indentation: 0,
            options,
            document: document2.textDocument
          };
          const edits = [];
          const cstTreeStream = this.iterateCstTree(document2, context);
          const iterator = cstTreeStream.iterator();
          let lastNode;
          let result;
          do {
            result = iterator.next();
            if (!result.done) {
              const node = result.value;
              const isLeaf = (0, syntax_tree_1.isLeafCstNode)(node);
              const prependKey = this.nodeModeToKey(node, "prepend");
              const prependFormatting = formattings.get(prependKey);
              formattings.delete(prependKey);
              if (prependFormatting) {
                const nodeEdits = this.createTextEdit(lastNode, node, prependFormatting, context);
                for (const edit of nodeEdits) {
                  if (edit && this.insideRange(edit.range, range) && this.isNecessary(edit, document2.textDocument)) {
                    edits.push(edit);
                  }
                }
              }
              const appendKey = this.nodeModeToKey(node, "append");
              const appendFormatting = formattings.get(appendKey);
              formattings.delete(appendKey);
              if (appendFormatting) {
                const nextNode = (0, cst_util_1.getNextNode)(node);
                if (nextNode) {
                  const nodeEdits = this.createTextEdit(node, nextNode, appendFormatting, context);
                  for (const edit of nodeEdits) {
                    if (edit && this.insideRange(edit.range, range) && this.isNecessary(edit, document2.textDocument)) {
                      edits.push(edit);
                    }
                  }
                }
              }
              if (!prependFormatting && node.hidden) {
                const hiddenEdits = this.createHiddenTextEdits(lastNode, node, void 0, context);
                for (const edit of hiddenEdits) {
                  if (edit && this.insideRange(edit.range, range) && this.isNecessary(edit, document2.textDocument)) {
                    edits.push(edit);
                  }
                }
              }
              if (isLeaf) {
                lastNode = node;
              }
            }
          } while (!result.done);
          return edits;
        }
        createHiddenTextEdits(previous, hidden, formatting, context) {
          var _a4;
          const startLine = hidden.range.start.line;
          if (previous && previous.range.end.line === startLine) {
            return [];
          }
          const edits = [];
          const startRange = {
            start: {
              character: 0,
              line: startLine
            },
            end: hidden.range.start
          };
          const hiddenStartText = context.document.getText(startRange);
          const move = this.findFittingMove(startRange, (_a4 = formatting === null || formatting === void 0 ? void 0 : formatting.moves) !== null && _a4 !== void 0 ? _a4 : [], context);
          const hiddenStartChar = this.getExistingIndentationCharacterCount(hiddenStartText, context);
          const expectedStartChar = this.getIndentationCharacterCount(context, move);
          const characterIncrease = expectedStartChar - hiddenStartChar;
          if (characterIncrease === 0) {
            return [];
          }
          let newText = "";
          if (characterIncrease > 0) {
            newText = (context.options.insertSpaces ? " " : "	").repeat(characterIncrease);
          }
          const lines = hidden.text.split("\n");
          lines[0] = hiddenStartText + lines[0];
          for (let i = 0; i < lines.length; i++) {
            const currentLine = startLine + i;
            const pos = {
              character: 0,
              line: currentLine
            };
            if (characterIncrease > 0) {
              edits.push({
                newText,
                range: {
                  start: pos,
                  end: pos
                }
              });
            } else {
              const currentText = lines[i];
              let j = 0;
              for (; j < currentText.length; j++) {
                const char = currentText.charAt(j);
                if (char !== " " && char !== "	") {
                  break;
                }
              }
              edits.push({
                newText: "",
                range: {
                  start: pos,
                  end: {
                    line: currentLine,
                    // Remove as much whitespace characters as necessary
                    // In some cases `characterIncrease` is actually larger than the amount of whitespace available
                    // So we simply remove all whitespace characters `j`
                    character: Math.min(j, Math.abs(characterIncrease))
                  }
                }
              });
            }
          }
          return edits;
        }
        getExistingIndentationCharacterCount(text, context) {
          const tabWhitespace = " ".repeat(context.options.tabSize);
          const normalized = context.options.insertSpaces ? text.replaceAll("	", tabWhitespace) : text.replaceAll(tabWhitespace, "	");
          return normalized.length;
        }
        getIndentationCharacterCount(context, formattingMove) {
          let indentation = context.indentation;
          if (formattingMove && formattingMove.tabs) {
            indentation += formattingMove.tabs;
          }
          return (context.options.insertSpaces ? context.options.tabSize : 1) * indentation;
        }
        createTextEdit(a, b, formatting, context) {
          var _a4;
          if (b.hidden) {
            return this.createHiddenTextEdits(a, b, formatting, context);
          }
          const betweenRange = {
            start: (_a4 = a === null || a === void 0 ? void 0 : a.range.end) !== null && _a4 !== void 0 ? _a4 : {
              character: 0,
              line: 0
            },
            end: b.range.start
          };
          const move = this.findFittingMove(betweenRange, formatting.moves, context);
          if (!move) {
            return [];
          }
          const chars = move.characters;
          const lines = move.lines;
          const tabs = move.tabs;
          const existingIndentation = context.indentation;
          context.indentation += tabs !== null && tabs !== void 0 ? tabs : 0;
          const edits = [];
          if (chars !== void 0) {
            edits.push(this.createSpaceTextEdit(betweenRange, chars, formatting.options));
          } else if (lines !== void 0) {
            edits.push(this.createLineTextEdit(betweenRange, lines, context, formatting.options));
          } else if (tabs !== void 0) {
            edits.push(this.createTabTextEdit(betweenRange, Boolean(a), context));
          }
          if ((0, syntax_tree_1.isLeafCstNode)(b)) {
            context.indentation = existingIndentation;
          }
          return edits;
        }
        createSpaceTextEdit(range, spaces, options) {
          if (range.start.line === range.end.line) {
            const existingSpaces = range.end.character - range.start.character;
            spaces = this.fitIntoOptions(spaces, existingSpaces, options);
          }
          const newText = " ".repeat(spaces);
          return {
            newText,
            range
          };
        }
        createLineTextEdit(range, lines, context, options) {
          const existingLines = range.end.line - range.start.line;
          lines = this.fitIntoOptions(lines, existingLines, options);
          const indent = context.options.insertSpaces ? " ".repeat(context.options.tabSize) : "	";
          const nodeIndent = indent.repeat(context.indentation);
          const newText = `${"\n".repeat(lines)}${nodeIndent}`;
          return {
            newText,
            range
          };
        }
        createTabTextEdit(range, hasPrevious, context) {
          const indent = context.options.insertSpaces ? " ".repeat(context.options.tabSize) : "	";
          const nodeIndent = indent.repeat(context.indentation);
          const minimumLines = hasPrevious ? 1 : 0;
          const lines = Math.max(range.end.line - range.start.line, minimumLines);
          const newText = `${"\n".repeat(lines)}${nodeIndent}`;
          return {
            newText,
            range
          };
        }
        fitIntoOptions(value, existing, options) {
          if (options.allowMore) {
            value = Math.max(existing, value);
          } else if (options.allowLess) {
            value = Math.min(existing, value);
          }
          return value;
        }
        findFittingMove(range, moves, _context) {
          if (moves.length === 0) {
            return void 0;
          } else if (moves.length === 1) {
            return moves[0];
          }
          const existingLines = range.end.line - range.start.line;
          for (const move of moves) {
            if (move.lines !== void 0 && existingLines <= move.lines) {
              return move;
            } else if (move.lines === void 0 && existingLines === 0) {
              return move;
            }
          }
          return moves[moves.length - 1];
        }
        iterateCstTree(document2, context) {
          const root = document2.parseResult.value;
          const rootCst = root.$cstNode;
          if (!rootCst) {
            return stream_1.EMPTY_STREAM;
          }
          return new stream_1.TreeStreamImpl(rootCst, (node) => this.iterateCst(node, context));
        }
        iterateCst(node, context) {
          if (!(0, syntax_tree_1.isCompositeCstNode)(node)) {
            return stream_1.EMPTY_STREAM;
          }
          const initial = context.indentation;
          return new stream_1.StreamImpl(() => ({ index: 0 }), (state) => {
            if (state.index < node.children.length) {
              return { done: false, value: node.children[state.index++] };
            } else {
              context.indentation = initial;
              return stream_1.DONE_RESULT;
            }
          });
        }
      };
      exports2.AbstractFormatter = AbstractFormatter;
      var DefaultNodeFormatter = class {
        constructor(astNode, collector) {
          this.astNode = astNode;
          this.collector = collector;
        }
        node(node) {
          return new FormattingRegion(node.$cstNode ? [node.$cstNode] : [], this.collector);
        }
        nodes(...nodes) {
          const cstNodes = [];
          for (const node of nodes) {
            if (node.$cstNode) {
              cstNodes.push(node.$cstNode);
            }
          }
          return new FormattingRegion(cstNodes, this.collector);
        }
        property(feature, index) {
          const cstNode = (0, grammar_util_1.findNodeForProperty)(this.astNode.$cstNode, feature, index);
          return new FormattingRegion(cstNode ? [cstNode] : [], this.collector);
        }
        properties(...features) {
          const nodes = [];
          for (const feature of features) {
            const cstNodes = (0, grammar_util_1.findNodesForProperty)(this.astNode.$cstNode, feature);
            nodes.push(...cstNodes);
          }
          return new FormattingRegion(nodes, this.collector);
        }
        keyword(keyword, index) {
          const cstNode = (0, grammar_util_1.findNodeForKeyword)(this.astNode.$cstNode, keyword, index);
          return new FormattingRegion(cstNode ? [cstNode] : [], this.collector);
        }
        keywords(...keywords) {
          const nodes = [];
          for (const feature of keywords) {
            const cstNodes = (0, grammar_util_1.findNodesForKeyword)(this.astNode.$cstNode, feature);
            nodes.push(...cstNodes);
          }
          return new FormattingRegion(nodes, this.collector);
        }
        cst(nodes) {
          return new FormattingRegion([...nodes], this.collector);
        }
        interior(start, end) {
          const startNodes = start.nodes;
          const endNodes = end.nodes;
          if (startNodes.length !== 1 || endNodes.length !== 1) {
            return new FormattingRegion([], this.collector);
          }
          let startNode = startNodes[0];
          let endNode = endNodes[0];
          if (startNode.offset > endNode.offset) {
            const intermediate = startNode;
            startNode = endNode;
            endNode = intermediate;
          }
          return new FormattingRegion((0, cst_util_1.getInteriorNodes)(startNode, endNode), this.collector);
        }
      };
      exports2.DefaultNodeFormatter = DefaultNodeFormatter;
      var FormattingRegion = class {
        constructor(nodes, collector) {
          this.nodes = nodes;
          this.collector = collector;
        }
        /**
         * Prepends the specified formatting to all nodes of this region.
         */
        prepend(formatting) {
          for (const node of this.nodes) {
            this.collector(node, "prepend", formatting);
          }
          return this;
        }
        /**
         * Appends the specified formatting to all nodes of this region.
         */
        append(formatting) {
          for (const node of this.nodes) {
            this.collector(node, "append", formatting);
          }
          return this;
        }
        /**
         * Sorrounds all nodes of this region with the specified formatting.
         * Functionally the same as invoking `prepend` and `append` with the same formatting.
         */
        surround(formatting) {
          for (const node of this.nodes) {
            this.collector(node, "prepend", formatting);
            this.collector(node, "append", formatting);
          }
          return this;
        }
        /**
         * Creates a copy of this region with a slice of the selected nodes.
         * For both start and end, a negative index can be used to indicate an offset from the end of the array.
         * For example, -2 refers to the second to last element of the array.
         * @param start The beginning index of the specified portion of the region. If start is undefined, then the slice begins at index 0.
         * @param end The end index of the specified portion of the region. This is exclusive of the element at the index 'end'. If end is undefined, then the slice extends to the end of the region.
         */
        slice(start, end) {
          return new FormattingRegion(this.nodes.slice(start, end), this.collector);
        }
      };
      exports2.FormattingRegion = FormattingRegion;
      var Formatting;
      (function(Formatting2) {
        function fit(...formattings) {
          return {
            options: {},
            moves: formattings.flatMap((e) => e.moves).sort(compareMoves)
          };
        }
        Formatting2.fit = fit;
        function noSpace(options) {
          return spaces(0, options);
        }
        Formatting2.noSpace = noSpace;
        function oneSpace(options) {
          return spaces(1, options);
        }
        Formatting2.oneSpace = oneSpace;
        function spaces(count, options) {
          return {
            options: options !== null && options !== void 0 ? options : {},
            moves: [{
              characters: count
            }]
          };
        }
        Formatting2.spaces = spaces;
        function newLine(options) {
          return newLines(1, options);
        }
        Formatting2.newLine = newLine;
        function newLines(count, options) {
          return {
            options: options !== null && options !== void 0 ? options : {},
            moves: [{
              lines: count
            }]
          };
        }
        Formatting2.newLines = newLines;
        function indent(options) {
          return {
            options: options !== null && options !== void 0 ? options : {},
            moves: [{
              tabs: 1,
              lines: 1
            }]
          };
        }
        Formatting2.indent = indent;
        function noIndent(options) {
          return {
            options: options !== null && options !== void 0 ? options : {},
            moves: [{
              tabs: 0
            }]
          };
        }
        Formatting2.noIndent = noIndent;
        function compareMoves(a, b) {
          var _a4, _b2, _c2, _d, _e, _f;
          const aLines = (_a4 = a.lines) !== null && _a4 !== void 0 ? _a4 : 0;
          const bLines = (_b2 = b.lines) !== null && _b2 !== void 0 ? _b2 : 0;
          const aTabs = (_c2 = a.tabs) !== null && _c2 !== void 0 ? _c2 : 0;
          const bTabs = (_d = b.tabs) !== null && _d !== void 0 ? _d : 0;
          const aSpaces = (_e = a.characters) !== null && _e !== void 0 ? _e : 0;
          const bSpaces = (_f = b.characters) !== null && _f !== void 0 ? _f : 0;
          if (aLines < bLines) {
            return -1;
          } else if (aLines > bLines) {
            return 1;
          } else if (aTabs < bTabs) {
            return -1;
          } else if (aTabs > bTabs) {
            return 1;
          } else if (aSpaces < bSpaces) {
            return -1;
          } else if (aSpaces > bSpaces) {
            return 1;
          } else {
            return 0;
          }
        }
      })(Formatting = exports2.Formatting || (exports2.Formatting = {}));
    }
  });

  // node_modules/langium/lib/grammar/lsp/grammar-formatter.js
  var require_grammar_formatter = __commonJS({
    "node_modules/langium/lib/grammar/lsp/grammar-formatter.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LangiumGrammarFormatter = void 0;
      var formatter_1 = require_formatter();
      var ast = __importStar(require_ast());
      var LangiumGrammarFormatter = class extends formatter_1.AbstractFormatter {
        format(node) {
          if (ast.isCrossReference(node)) {
            const formatter = this.getNodeFormatter(node);
            formatter.properties("type", "terminal").surround(formatter_1.Formatting.noSpace());
          } else if (ast.isParserRule(node)) {
            const formatter = this.getNodeFormatter(node);
            formatter.keywords("entry", "fragment", "returns").append(formatter_1.Formatting.oneSpace());
            if ((node.inferredType || node.returnType || node.dataType) && node.parameters.length === 0) {
              formatter.property("name").append(formatter_1.Formatting.oneSpace());
            } else {
              formatter.property("name").append(formatter_1.Formatting.noSpace());
            }
            formatter.properties("parameters").append(formatter_1.Formatting.noSpace());
            formatter.keywords(",").append(formatter_1.Formatting.oneSpace());
            formatter.keywords("<").append(formatter_1.Formatting.noSpace());
            const semicolon = formatter.keyword(";");
            const colon = formatter.keyword(":");
            colon.prepend(formatter_1.Formatting.noSpace());
            formatter.interior(colon, semicolon).prepend(formatter_1.Formatting.indent());
            semicolon.prepend(formatter_1.Formatting.fit(formatter_1.Formatting.noSpace(), formatter_1.Formatting.newLine()));
            formatter.node(node).prepend(formatter_1.Formatting.noIndent());
          } else if (ast.isTerminalRule(node)) {
            const formatter = this.getNodeFormatter(node);
            if (node.type) {
              formatter.property("name").append(formatter_1.Formatting.oneSpace());
              formatter.keyword("returns").append(formatter_1.Formatting.oneSpace());
            }
            formatter.keywords("hidden", "terminal", "fragment").append(formatter_1.Formatting.oneSpace());
            formatter.keyword(":").prepend(formatter_1.Formatting.noSpace());
            formatter.keyword(";").prepend(formatter_1.Formatting.fit(formatter_1.Formatting.noSpace(), formatter_1.Formatting.newLine()));
            formatter.node(node).prepend(formatter_1.Formatting.noIndent());
          } else if (ast.isAction(node)) {
            const formatter = this.getNodeFormatter(node);
            formatter.keyword("{").append(formatter_1.Formatting.noSpace());
            formatter.keywords(".", "+=", "=").surround(formatter_1.Formatting.noSpace());
            formatter.keyword("}").prepend(formatter_1.Formatting.noSpace());
          } else if (ast.isInferredType(node)) {
            const formatter = this.getNodeFormatter(node);
            formatter.keywords("infer", "infers").append(formatter_1.Formatting.oneSpace());
          } else if (ast.isAssignment(node)) {
            const formatter = this.getNodeFormatter(node);
            formatter.keywords("=", "+=", "?=").surround(formatter_1.Formatting.noSpace());
          } else if (ast.isRuleCall(node)) {
            const formatter = this.getNodeFormatter(node);
            formatter.keyword("<").surround(formatter_1.Formatting.noSpace());
            formatter.keyword(",").append(formatter_1.Formatting.oneSpace());
            formatter.properties("arguments").append(formatter_1.Formatting.noSpace());
          }
          if (ast.isAbstractElement(node)) {
            const formatter = this.getNodeFormatter(node);
            formatter.property("cardinality").prepend(formatter_1.Formatting.noSpace());
          }
        }
      };
      exports2.LangiumGrammarFormatter = LangiumGrammarFormatter;
    }
  });

  // node_modules/langium/lib/lsp/semantic-token-provider.js
  var require_semantic_token_provider = __commonJS({
    "node_modules/langium/lib/lsp/semantic-token-provider.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SemanticTokensDecoder = exports2.AbstractSemanticTokenProvider = exports2.SemanticTokensBuilder = exports2.DefaultSemanticTokenOptions = exports2.AllSemanticTokenModifiers = exports2.AllSemanticTokenTypes = void 0;
      var vscode_languageserver_1 = require_main4();
      var grammar_util_1 = require_grammar_util();
      var ast_util_1 = require_ast_util();
      var promise_util_1 = require_promise_util();
      var cst_util_1 = require_cst_util();
      exports2.AllSemanticTokenTypes = {
        [vscode_languageserver_1.SemanticTokenTypes.class]: 0,
        [vscode_languageserver_1.SemanticTokenTypes.comment]: 1,
        [vscode_languageserver_1.SemanticTokenTypes.enum]: 2,
        [vscode_languageserver_1.SemanticTokenTypes.enumMember]: 3,
        [vscode_languageserver_1.SemanticTokenTypes.event]: 4,
        [vscode_languageserver_1.SemanticTokenTypes.function]: 5,
        [vscode_languageserver_1.SemanticTokenTypes.interface]: 6,
        [vscode_languageserver_1.SemanticTokenTypes.keyword]: 7,
        [vscode_languageserver_1.SemanticTokenTypes.macro]: 8,
        [vscode_languageserver_1.SemanticTokenTypes.method]: 9,
        [vscode_languageserver_1.SemanticTokenTypes.modifier]: 10,
        [vscode_languageserver_1.SemanticTokenTypes.namespace]: 11,
        [vscode_languageserver_1.SemanticTokenTypes.number]: 12,
        [vscode_languageserver_1.SemanticTokenTypes.operator]: 13,
        [vscode_languageserver_1.SemanticTokenTypes.parameter]: 14,
        [vscode_languageserver_1.SemanticTokenTypes.property]: 15,
        [vscode_languageserver_1.SemanticTokenTypes.regexp]: 16,
        [vscode_languageserver_1.SemanticTokenTypes.string]: 17,
        [vscode_languageserver_1.SemanticTokenTypes.struct]: 18,
        [vscode_languageserver_1.SemanticTokenTypes.type]: 19,
        [vscode_languageserver_1.SemanticTokenTypes.typeParameter]: 20,
        [vscode_languageserver_1.SemanticTokenTypes.variable]: 21
      };
      exports2.AllSemanticTokenModifiers = {
        [vscode_languageserver_1.SemanticTokenModifiers.abstract]: 1 << 0,
        [vscode_languageserver_1.SemanticTokenModifiers.async]: 1 << 1,
        [vscode_languageserver_1.SemanticTokenModifiers.declaration]: 1 << 2,
        [vscode_languageserver_1.SemanticTokenModifiers.defaultLibrary]: 1 << 3,
        [vscode_languageserver_1.SemanticTokenModifiers.definition]: 1 << 4,
        [vscode_languageserver_1.SemanticTokenModifiers.deprecated]: 1 << 5,
        [vscode_languageserver_1.SemanticTokenModifiers.documentation]: 1 << 6,
        [vscode_languageserver_1.SemanticTokenModifiers.modification]: 1 << 7,
        [vscode_languageserver_1.SemanticTokenModifiers.readonly]: 1 << 8,
        [vscode_languageserver_1.SemanticTokenModifiers.static]: 1 << 9
      };
      exports2.DefaultSemanticTokenOptions = {
        legend: {
          tokenTypes: Object.keys(exports2.AllSemanticTokenTypes),
          tokenModifiers: Object.keys(exports2.AllSemanticTokenModifiers)
        },
        full: {
          delta: true
        },
        range: true
      };
      var SemanticTokensBuilder3 = class extends vscode_languageserver_1.SemanticTokensBuilder {
        constructor() {
          super(...arguments);
          this._tokens = [];
        }
        push(line, char, length, tokenType, tokenModifiers) {
          this._tokens.push({
            line,
            char,
            length,
            tokenType,
            tokenModifiers
          });
        }
        build() {
          this.applyTokens();
          return super.build();
        }
        buildEdits() {
          this.applyTokens();
          return super.buildEdits();
        }
        applyTokens() {
          for (const token of this._tokens.sort(this.compareTokens)) {
            super.push(token.line, token.char, token.length, token.tokenType, token.tokenModifiers);
          }
          this._tokens = [];
        }
        compareTokens(a, b) {
          if (a.line === b.line) {
            return a.char - b.char;
          }
          return a.line - b.line;
        }
      };
      exports2.SemanticTokensBuilder = SemanticTokensBuilder3;
      var AbstractSemanticTokenProvider = class {
        constructor(services) {
          this.tokensBuilders = /* @__PURE__ */ new Map();
          services.shared.workspace.TextDocuments.onDidClose((e) => {
            this.tokensBuilders.delete(e.document.uri);
          });
          services.shared.lsp.LanguageServer.onInitialize((params) => {
            var _a4;
            this.initialize((_a4 = params.capabilities.textDocument) === null || _a4 === void 0 ? void 0 : _a4.semanticTokens);
          });
        }
        initialize(clientCapabilities) {
          this.clientCapabilities = clientCapabilities;
        }
        async semanticHighlight(document2, _params, cancelToken = vscode_languageserver_1.CancellationToken.None) {
          this.currentRange = void 0;
          this.currentDocument = document2;
          this.currentTokensBuilder = this.getDocumentTokensBuilder(document2);
          await this.computeHighlighting(document2, this.createAcceptor(), cancelToken);
          return this.currentTokensBuilder.build();
        }
        async semanticHighlightRange(document2, params, cancelToken = vscode_languageserver_1.CancellationToken.None) {
          this.currentRange = params.range;
          this.currentDocument = document2;
          this.currentTokensBuilder = this.getDocumentTokensBuilder(document2);
          await this.computeHighlighting(document2, this.createAcceptor(), cancelToken);
          return this.currentTokensBuilder.build();
        }
        async semanticHighlightDelta(document2, params, cancelToken = vscode_languageserver_1.CancellationToken.None) {
          this.currentRange = void 0;
          this.currentDocument = document2;
          this.currentTokensBuilder = this.getDocumentTokensBuilder(document2);
          this.currentTokensBuilder.previousResult(params.previousResultId);
          await this.computeHighlighting(document2, this.createAcceptor(), cancelToken);
          return this.currentTokensBuilder.buildEdits();
        }
        createAcceptor() {
          const acceptor = (options) => {
            if ("line" in options) {
              this.highlightToken({
                range: {
                  start: {
                    line: options.line,
                    character: options.char
                  },
                  end: {
                    line: options.line,
                    character: options.char + options.length
                  }
                },
                type: options.type,
                modifier: options.modifier
              });
            } else if ("range" in options) {
              this.highlightToken(options);
            } else if ("keyword" in options) {
              this.highlightKeyword(options);
            } else if ("property" in options) {
              this.highlightProperty(options);
            } else {
              this.highlightNode({
                node: options.cst,
                type: options.type,
                modifier: options.modifier
              });
            }
          };
          return acceptor;
        }
        getDocumentTokensBuilder(document2) {
          const existing = this.tokensBuilders.get(document2.uri.toString());
          if (existing) {
            return existing;
          }
          const builder = new SemanticTokensBuilder3();
          this.tokensBuilders.set(document2.uri.toString(), builder);
          return builder;
        }
        async computeHighlighting(document2, acceptor, cancelToken) {
          const root = document2.parseResult.value;
          const treeIterator = (0, ast_util_1.streamAst)(root, { range: this.currentRange }).iterator();
          let result;
          do {
            result = treeIterator.next();
            if (!result.done) {
              await (0, promise_util_1.interruptAndCheck)(cancelToken);
              const node = result.value;
              if (this.highlightElement(node, acceptor) === "prune") {
                treeIterator.prune();
              }
            }
          } while (!result.done);
        }
        highlightToken(options) {
          var _a4;
          const { range, type } = options;
          let modifiers = options.modifier;
          if (this.currentRange && !(0, cst_util_1.inRange)(range, this.currentRange) || !this.currentDocument || !this.currentTokensBuilder) {
            return;
          }
          const intType = exports2.AllSemanticTokenTypes[type];
          let totalModifier = 0;
          if (modifiers !== void 0) {
            if (typeof modifiers === "string") {
              modifiers = [modifiers];
            }
            for (const modifier of modifiers) {
              const intModifier = exports2.AllSemanticTokenModifiers[modifier];
              totalModifier |= intModifier;
            }
          }
          const startLine = range.start.line;
          const endLine = range.end.line;
          if (startLine === endLine) {
            const char = range.start.character;
            const length = range.end.character - char;
            this.currentTokensBuilder.push(startLine, char, length, intType, totalModifier);
          } else if ((_a4 = this.clientCapabilities) === null || _a4 === void 0 ? void 0 : _a4.multilineTokenSupport) {
            const startChar = range.start.character;
            const startOffset = this.currentDocument.textDocument.offsetAt(range.start);
            const endOffset = this.currentDocument.textDocument.offsetAt(range.end);
            this.currentTokensBuilder.push(startLine, startChar, endOffset - startOffset, intType, totalModifier);
          } else {
            const firstLineStart = range.start;
            let nextLineOffset = this.currentDocument.textDocument.offsetAt({
              line: startLine + 1,
              character: 0
            });
            this.currentTokensBuilder.push(firstLineStart.line, firstLineStart.character, nextLineOffset - firstLineStart.character - 1, intType, totalModifier);
            for (let i = startLine + 1; i < endLine; i++) {
              const currentLineOffset = nextLineOffset;
              nextLineOffset = this.currentDocument.textDocument.offsetAt({
                line: i + 1,
                character: 0
              });
              this.currentTokensBuilder.push(i, 0, nextLineOffset - currentLineOffset - 1, intType, totalModifier);
            }
            this.currentTokensBuilder.push(endLine, 0, range.end.character, intType, totalModifier);
          }
        }
        highlightProperty(options) {
          const nodes = [];
          if (typeof options.index === "number") {
            const node = (0, grammar_util_1.findNodeForProperty)(options.node.$cstNode, options.property, options.index);
            if (node) {
              nodes.push(node);
            }
          } else {
            nodes.push(...(0, grammar_util_1.findNodesForProperty)(options.node.$cstNode, options.property));
          }
          const { type, modifier } = options;
          for (const node of nodes) {
            this.highlightNode({
              node,
              type,
              modifier
            });
          }
        }
        highlightKeyword(options) {
          const { node, keyword, type, index, modifier } = options;
          const nodes = [];
          if (typeof index === "number") {
            const keywordNode = (0, grammar_util_1.findNodeForKeyword)(node.$cstNode, keyword, index);
            if (keywordNode) {
              nodes.push(keywordNode);
            }
          } else {
            nodes.push(...(0, grammar_util_1.findNodesForKeyword)(node.$cstNode, keyword));
          }
          for (const keywordNode of nodes) {
            this.highlightNode({
              node: keywordNode,
              type,
              modifier
            });
          }
        }
        highlightNode(options) {
          const { node, type, modifier } = options;
          const range = node.range;
          this.highlightToken({
            range,
            type,
            modifier
          });
        }
      };
      exports2.AbstractSemanticTokenProvider = AbstractSemanticTokenProvider;
      var SemanticTokensDecoder;
      (function(SemanticTokensDecoder2) {
        function decode(tokens, document2) {
          const typeMap = /* @__PURE__ */ new Map();
          Object.entries(exports2.AllSemanticTokenTypes).forEach(([type, index]) => typeMap.set(index, type));
          let line = 0;
          let character = 0;
          return sliceIntoChunks(tokens.data, 5).map((t) => {
            line += t[0];
            if (t[0] !== 0) {
              character = 0;
            }
            character += t[1];
            const length = t[2];
            const offset = document2.textDocument.offsetAt({ line, character });
            return {
              offset,
              tokenType: typeMap.get(t[3]),
              tokenModifiers: t[4],
              text: document2.textDocument.getText({ start: { line, character }, end: { line, character: character + length } })
            };
          });
        }
        SemanticTokensDecoder2.decode = decode;
        function sliceIntoChunks(arr, chunkSize) {
          const res = [];
          for (let i = 0; i < arr.length; i += chunkSize) {
            const chunk = arr.slice(i, i + chunkSize);
            res.push(chunk);
          }
          return res;
        }
      })(SemanticTokensDecoder = exports2.SemanticTokensDecoder || (exports2.SemanticTokensDecoder = {}));
    }
  });

  // node_modules/langium/lib/grammar/lsp/grammar-semantic-tokens.js
  var require_grammar_semantic_tokens = __commonJS({
    "node_modules/langium/lib/grammar/lsp/grammar-semantic-tokens.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LangiumGrammarSemanticTokenProvider = void 0;
      var vscode_languageserver_1 = require_main4();
      var semantic_token_provider_1 = require_semantic_token_provider();
      var ast_1 = require_ast();
      var LangiumGrammarSemanticTokenProvider = class extends semantic_token_provider_1.AbstractSemanticTokenProvider {
        highlightElement(node, acceptor) {
          var _a4;
          if ((0, ast_1.isAssignment)(node)) {
            acceptor({
              node,
              property: "feature",
              type: vscode_languageserver_1.SemanticTokenTypes.property
            });
          } else if ((0, ast_1.isAction)(node)) {
            if (node.feature) {
              acceptor({
                node,
                property: "feature",
                type: vscode_languageserver_1.SemanticTokenTypes.property
              });
            }
          } else if ((0, ast_1.isReturnType)(node)) {
            acceptor({
              node,
              property: "name",
              type: vscode_languageserver_1.SemanticTokenTypes.type
            });
          } else if ((0, ast_1.isSimpleType)(node)) {
            if (node.primitiveType || node.typeRef) {
              acceptor({
                node,
                property: node.primitiveType ? "primitiveType" : "typeRef",
                type: vscode_languageserver_1.SemanticTokenTypes.type
              });
            }
          } else if ((0, ast_1.isParameter)(node)) {
            acceptor({
              node,
              property: "name",
              type: vscode_languageserver_1.SemanticTokenTypes.parameter
            });
          } else if ((0, ast_1.isParameterReference)(node)) {
            acceptor({
              node,
              property: "parameter",
              type: vscode_languageserver_1.SemanticTokenTypes.parameter
            });
          } else if ((0, ast_1.isRuleCall)(node)) {
            if ((_a4 = node.rule.ref) === null || _a4 === void 0 ? void 0 : _a4.fragment) {
              acceptor({
                node,
                property: "rule",
                type: vscode_languageserver_1.SemanticTokenTypes.type
              });
            }
          } else if ((0, ast_1.isTypeAttribute)(node)) {
            acceptor({
              node,
              property: "name",
              type: vscode_languageserver_1.SemanticTokenTypes.property
            });
          }
        }
      };
      exports2.LangiumGrammarSemanticTokenProvider = LangiumGrammarSemanticTokenProvider;
    }
  });

  // node_modules/langium/lib/grammar/references/grammar-naming.js
  var require_grammar_naming = __commonJS({
    "node_modules/langium/lib/grammar/references/grammar-naming.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LangiumGrammarNameProvider = void 0;
      var name_provider_1 = require_name_provider();
      var grammar_util_1 = require_grammar_util();
      var ast_1 = require_ast();
      var LangiumGrammarNameProvider = class extends name_provider_1.DefaultNameProvider {
        getName(node) {
          if ((0, ast_1.isAssignment)(node)) {
            return node.feature;
          } else {
            return super.getName(node);
          }
        }
        getNameNode(node) {
          if ((0, ast_1.isAssignment)(node)) {
            return (0, grammar_util_1.findNodeForProperty)(node.$cstNode, "feature");
          } else {
            return super.getNameNode(node);
          }
        }
      };
      exports2.LangiumGrammarNameProvider = LangiumGrammarNameProvider;
    }
  });

  // node_modules/langium/lib/references/references.js
  var require_references = __commonJS({
    "node_modules/langium/lib/references/references.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DefaultReferences = void 0;
      var grammar_util_1 = require_grammar_util();
      var syntax_tree_1 = require_syntax_tree();
      var ast_util_1 = require_ast_util();
      var cst_util_1 = require_cst_util();
      var stream_1 = require_stream();
      var uri_util_1 = require_uri_util();
      var DefaultReferences = class {
        constructor(services) {
          this.nameProvider = services.references.NameProvider;
          this.index = services.shared.workspace.IndexManager;
          this.nodeLocator = services.workspace.AstNodeLocator;
        }
        findDeclaration(sourceCstNode) {
          if (sourceCstNode) {
            const assignment = (0, grammar_util_1.findAssignment)(sourceCstNode);
            const nodeElem = sourceCstNode.element;
            if (assignment && nodeElem) {
              const reference = nodeElem[assignment.feature];
              if ((0, syntax_tree_1.isReference)(reference)) {
                return reference.ref;
              } else if (Array.isArray(reference)) {
                for (const ref of reference) {
                  if ((0, syntax_tree_1.isReference)(ref) && ref.$refNode && ref.$refNode.offset <= sourceCstNode.offset && ref.$refNode.end >= sourceCstNode.end) {
                    return ref.ref;
                  }
                }
              }
            }
            if (nodeElem) {
              const nameNode = this.nameProvider.getNameNode(nodeElem);
              if (nameNode && (nameNode === sourceCstNode || (0, cst_util_1.isCstChildNode)(sourceCstNode, nameNode))) {
                return nodeElem;
              }
            }
          }
          return void 0;
        }
        findDeclarationNode(sourceCstNode) {
          const astNode = this.findDeclaration(sourceCstNode);
          if (astNode === null || astNode === void 0 ? void 0 : astNode.$cstNode) {
            const targetNode = this.nameProvider.getNameNode(astNode);
            return targetNode !== null && targetNode !== void 0 ? targetNode : astNode.$cstNode;
          }
          return void 0;
        }
        findReferences(targetNode, options) {
          const refs = [];
          if (options.includeDeclaration) {
            const ref = this.getReferenceToSelf(targetNode);
            if (ref) {
              refs.push(ref);
            }
          }
          let indexReferences = this.index.findAllReferences(targetNode, this.nodeLocator.getAstNodePath(targetNode));
          if (options.documentUri) {
            indexReferences = indexReferences.filter((ref) => (0, uri_util_1.equalURI)(ref.sourceUri, options.documentUri));
          }
          refs.push(...indexReferences);
          return (0, stream_1.stream)(refs);
        }
        getReferenceToSelf(targetNode) {
          const nameNode = this.nameProvider.getNameNode(targetNode);
          if (nameNode) {
            const doc = (0, ast_util_1.getDocument)(targetNode);
            const path = this.nodeLocator.getAstNodePath(targetNode);
            return {
              sourceUri: doc.uri,
              sourcePath: path,
              targetUri: doc.uri,
              targetPath: path,
              segment: (0, cst_util_1.toDocumentSegment)(nameNode),
              local: true
            };
          }
          return void 0;
        }
      };
      exports2.DefaultReferences = DefaultReferences;
    }
  });

  // node_modules/langium/lib/grammar/references/grammar-references.js
  var require_grammar_references = __commonJS({
    "node_modules/langium/lib/grammar/references/grammar-references.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LangiumGrammarReferences = void 0;
      var references_1 = require_references();
      var ast_util_1 = require_ast_util();
      var cst_util_1 = require_cst_util();
      var grammar_util_1 = require_grammar_util();
      var stream_1 = require_stream();
      var uri_util_1 = require_uri_util();
      var ast_1 = require_ast();
      var internal_grammar_util_1 = require_internal_grammar_util();
      var types_util_1 = require_types_util();
      var LangiumGrammarReferences = class extends references_1.DefaultReferences {
        constructor(services) {
          super(services);
          this.documents = services.shared.workspace.LangiumDocuments;
        }
        findDeclaration(sourceCstNode) {
          const nodeElem = sourceCstNode.element;
          const assignment = (0, grammar_util_1.findAssignment)(sourceCstNode);
          if (assignment && assignment.feature === "feature") {
            if ((0, ast_1.isAssignment)(nodeElem)) {
              return this.findAssignmentDeclaration(nodeElem);
            } else if ((0, ast_1.isAction)(nodeElem)) {
              return this.findActionDeclaration(nodeElem);
            }
          }
          return super.findDeclaration(sourceCstNode);
        }
        findReferences(targetNode, options) {
          var _a4;
          if ((0, ast_1.isTypeAttribute)(targetNode)) {
            return this.findReferencesToTypeAttribute(targetNode, (_a4 = options.includeDeclaration) !== null && _a4 !== void 0 ? _a4 : false);
          } else {
            return super.findReferences(targetNode, options);
          }
        }
        findReferencesToTypeAttribute(targetNode, includeDeclaration) {
          const refs = [];
          const interfaceNode = (0, ast_util_1.getContainerOfType)(targetNode, ast_1.isInterface);
          if (interfaceNode) {
            if (includeDeclaration) {
              const ref = this.getReferenceToSelf(targetNode);
              if (ref) {
                refs.push(ref);
              }
            }
            const interfaces = (0, types_util_1.collectChildrenTypes)(interfaceNode, this, this.documents, this.nodeLocator);
            const targetRules = [];
            interfaces.forEach((interf) => {
              const rules = this.findRulesWithReturnType(interf);
              targetRules.push(...rules);
            });
            targetRules.forEach((rule) => {
              const references = this.createReferencesToAttribute(rule, targetNode);
              refs.push(...references);
            });
          }
          return (0, stream_1.stream)(refs);
        }
        createReferencesToAttribute(ruleOrAction, attribute) {
          const refs = [];
          if ((0, ast_1.isParserRule)(ruleOrAction)) {
            const assignment = (0, internal_grammar_util_1.extractAssignments)(ruleOrAction.definition).find((a) => a.feature === attribute.name);
            if (assignment === null || assignment === void 0 ? void 0 : assignment.$cstNode) {
              const leaf = this.nameProvider.getNameNode(assignment);
              if (leaf) {
                refs.push({
                  sourceUri: (0, ast_util_1.getDocument)(assignment).uri,
                  sourcePath: this.nodeLocator.getAstNodePath(assignment),
                  targetUri: (0, ast_util_1.getDocument)(attribute).uri,
                  targetPath: this.nodeLocator.getAstNodePath(attribute),
                  segment: (0, cst_util_1.toDocumentSegment)(leaf),
                  local: (0, uri_util_1.equalURI)((0, ast_util_1.getDocument)(assignment).uri, (0, ast_util_1.getDocument)(attribute).uri)
                });
              }
            }
          } else {
            if (ruleOrAction.feature === attribute.name) {
              const leaf = (0, grammar_util_1.findNodeForProperty)(ruleOrAction.$cstNode, "feature");
              if (leaf) {
                refs.push({
                  sourceUri: (0, ast_util_1.getDocument)(ruleOrAction).uri,
                  sourcePath: this.nodeLocator.getAstNodePath(ruleOrAction),
                  targetUri: (0, ast_util_1.getDocument)(attribute).uri,
                  targetPath: this.nodeLocator.getAstNodePath(attribute),
                  segment: (0, cst_util_1.toDocumentSegment)(leaf),
                  local: (0, uri_util_1.equalURI)((0, ast_util_1.getDocument)(ruleOrAction).uri, (0, ast_util_1.getDocument)(attribute).uri)
                });
              }
            }
            const parserRule = (0, ast_util_1.getContainerOfType)(ruleOrAction, ast_1.isParserRule);
            refs.push(...this.createReferencesToAttribute(parserRule, attribute));
          }
          return refs;
        }
        findAssignmentDeclaration(assignment) {
          var _a4;
          const parserRule = (0, ast_util_1.getContainerOfType)(assignment, ast_1.isParserRule);
          const action = (0, internal_grammar_util_1.getActionAtElement)(assignment);
          if (action) {
            const actionDeclaration = this.findActionDeclaration(action, assignment.feature);
            if (actionDeclaration) {
              return actionDeclaration;
            }
          }
          if ((_a4 = parserRule === null || parserRule === void 0 ? void 0 : parserRule.returnType) === null || _a4 === void 0 ? void 0 : _a4.ref) {
            if ((0, ast_1.isInterface)(parserRule.returnType.ref) || (0, ast_1.isType)(parserRule.returnType.ref)) {
              const interfaces = (0, types_util_1.collectSuperTypes)(parserRule.returnType.ref);
              for (const interf of interfaces) {
                const typeAttribute = interf.attributes.find((att) => att.name === assignment.feature);
                if (typeAttribute) {
                  return typeAttribute;
                }
              }
            }
          }
          return assignment;
        }
        findActionDeclaration(action, featureName) {
          var _a4;
          if ((_a4 = action.type) === null || _a4 === void 0 ? void 0 : _a4.ref) {
            const feature = featureName !== null && featureName !== void 0 ? featureName : action.feature;
            const interfaces = (0, types_util_1.collectSuperTypes)(action.type.ref);
            for (const interf of interfaces) {
              const typeAttribute = interf.attributes.find((att) => att.name === feature);
              if (typeAttribute) {
                return typeAttribute;
              }
            }
          }
          return void 0;
        }
        findRulesWithReturnType(interf) {
          const rules = [];
          const refs = this.index.findAllReferences(interf, this.nodeLocator.getAstNodePath(interf));
          refs.forEach((ref) => {
            const doc = this.documents.getOrCreateDocument(ref.sourceUri);
            const astNode = this.nodeLocator.getAstNode(doc.parseResult.value, ref.sourcePath);
            if ((0, ast_1.isParserRule)(astNode) || (0, ast_1.isAction)(astNode)) {
              rules.push(astNode);
            }
          });
          return rules;
        }
      };
      exports2.LangiumGrammarReferences = LangiumGrammarReferences;
    }
  });

  // node_modules/langium/lib/lsp/completion/follow-element-computation.js
  var require_follow_element_computation = __commonJS({
    "node_modules/langium/lib/lsp/completion/follow-element-computation.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.findFirstFeatures = exports2.findNextFeatures = void 0;
      var ast = __importStar(require_ast());
      var internal_grammar_util_1 = require_internal_grammar_util();
      var syntax_tree_1 = require_syntax_tree();
      var ast_util_1 = require_ast_util();
      var grammar_util_1 = require_grammar_util();
      function findNextFeatures(featureStack, unparsedTokens) {
        const context = {
          stacks: featureStack,
          tokens: unparsedTokens
        };
        interpretTokens(context);
        context.stacks.flat().forEach((feature) => {
          feature.property = void 0;
        });
        const nextStacks = findNextFeatureStacks(context.stacks);
        return nextStacks.map((e) => e[e.length - 1]);
      }
      exports2.findNextFeatures = findNextFeatures;
      function findNextFeaturesInternal(options) {
        const { next, cardinalities, visited, plus } = options;
        const features = [];
        const feature = next.feature;
        if (visited.has(feature)) {
          return [];
        } else {
          visited.add(feature);
        }
        let parent;
        let item = feature;
        while (item.$container) {
          if (ast.isGroup(item.$container)) {
            parent = item.$container;
            break;
          } else if (ast.isAbstractElement(item.$container)) {
            item = item.$container;
          } else {
            break;
          }
        }
        if ((0, internal_grammar_util_1.isArrayCardinality)(item.cardinality)) {
          const repeatingFeatures = findFirstFeaturesInternal({
            next: {
              feature: item,
              type: next.type,
              new: false
            },
            cardinalities,
            visited,
            plus
          });
          for (const repeatingFeature of repeatingFeatures) {
            plus.add(repeatingFeature.feature);
          }
          features.push(...repeatingFeatures);
        }
        if (parent) {
          const ownIndex = parent.elements.indexOf(item);
          if (ownIndex !== void 0 && ownIndex < parent.elements.length - 1) {
            features.push(...findNextFeaturesInGroup({
              feature: parent,
              type: next.type,
              new: false
            }, ownIndex + 1, cardinalities, visited, plus));
          }
          if (features.every((e) => (0, internal_grammar_util_1.isOptionalCardinality)(e.feature.cardinality) || (0, internal_grammar_util_1.isOptionalCardinality)(cardinalities.get(e.feature)) || plus.has(e.feature))) {
            features.push(...findNextFeaturesInternal({
              next: {
                feature: parent,
                type: next.type,
                new: false
              },
              cardinalities,
              visited,
              plus
            }));
          }
        }
        return features;
      }
      function findFirstFeatures(next) {
        if ((0, syntax_tree_1.isAstNode)(next)) {
          next = { feature: next };
        }
        return findFirstFeaturesInternal({ next, cardinalities: /* @__PURE__ */ new Map(), visited: /* @__PURE__ */ new Set(), plus: /* @__PURE__ */ new Set() });
      }
      exports2.findFirstFeatures = findFirstFeatures;
      function findFirstFeaturesInternal(options) {
        var _a4, _b2, _c2;
        const { next, cardinalities, visited, plus } = options;
        if (next === void 0) {
          return [];
        }
        const { feature, type } = next;
        if (ast.isGroup(feature)) {
          if (visited.has(feature)) {
            return [];
          } else {
            visited.add(feature);
          }
        }
        if (ast.isGroup(feature)) {
          return findNextFeaturesInGroup(next, 0, cardinalities, visited, plus).map((e) => modifyCardinality(e, feature.cardinality, cardinalities));
        } else if (ast.isAlternatives(feature) || ast.isUnorderedGroup(feature)) {
          return feature.elements.flatMap((e) => findFirstFeaturesInternal({
            next: { feature: e, new: false, type },
            cardinalities,
            visited,
            plus
          })).map((e) => modifyCardinality(e, feature.cardinality, cardinalities));
        } else if (ast.isAssignment(feature)) {
          const assignmentNext = {
            feature: feature.terminal,
            new: false,
            type,
            property: (_a4 = next.property) !== null && _a4 !== void 0 ? _a4 : feature.feature
          };
          return findFirstFeaturesInternal({ next: assignmentNext, cardinalities, visited, plus }).map((e) => modifyCardinality(e, feature.cardinality, cardinalities));
        } else if (ast.isAction(feature)) {
          return findNextFeaturesInternal({
            next: {
              feature,
              new: true,
              type: (0, internal_grammar_util_1.getTypeName)(feature),
              property: (_b2 = next.property) !== null && _b2 !== void 0 ? _b2 : feature.feature
            },
            cardinalities,
            visited,
            plus
          });
        } else if (ast.isRuleCall(feature) && ast.isParserRule(feature.rule.ref)) {
          const rule = feature.rule.ref;
          const ruleCallNext = {
            feature: rule.definition,
            new: true,
            type: rule.fragment ? void 0 : (_c2 = (0, internal_grammar_util_1.getExplicitRuleType)(rule)) !== null && _c2 !== void 0 ? _c2 : rule.name,
            property: next.property
          };
          return findFirstFeaturesInternal({ next: ruleCallNext, cardinalities, visited, plus }).map((e) => modifyCardinality(e, feature.cardinality, cardinalities));
        } else {
          return [next];
        }
      }
      function modifyCardinality(next, cardinality, cardinalities) {
        cardinalities.set(next.feature, cardinality);
        return next;
      }
      function findNextFeaturesInGroup(next, index, cardinalities, visited, plus) {
        var _a4;
        const features = [];
        let firstFeature;
        while (index < next.feature.elements.length) {
          firstFeature = { feature: next.feature.elements[index++], new: false, type: next.type };
          features.push(...findFirstFeaturesInternal({
            next: firstFeature,
            cardinalities,
            visited,
            plus
          }));
          if (!(0, internal_grammar_util_1.isOptionalCardinality)((_a4 = firstFeature.feature.cardinality) !== null && _a4 !== void 0 ? _a4 : cardinalities.get(firstFeature.feature))) {
            break;
          }
        }
        return features;
      }
      function interpretTokens(context) {
        for (const token of context.tokens) {
          const nextFeatureStacks = findNextFeatureStacks(context.stacks, token);
          context.stacks = nextFeatureStacks;
        }
      }
      function findNextFeatureStacks(stacks, token) {
        const newStacks = [];
        for (const stack of stacks) {
          newStacks.push(...interpretStackToken(stack, token));
        }
        return newStacks;
      }
      function interpretStackToken(stack, token) {
        const cardinalities = /* @__PURE__ */ new Map();
        const plus = new Set(stack.map((e) => e.feature).filter(isPlusFeature));
        const newStacks = [];
        while (stack.length > 0) {
          const top = stack.pop();
          const allNextFeatures = findNextFeaturesInternal({
            next: top,
            cardinalities,
            plus,
            visited: /* @__PURE__ */ new Set()
          }).filter((next) => token ? featureMatches(next.feature, token) : true);
          for (const nextFeature of allNextFeatures) {
            newStacks.push([...stack, nextFeature]);
          }
          if (!allNextFeatures.every((e) => (0, internal_grammar_util_1.isOptionalCardinality)(e.feature.cardinality) || (0, internal_grammar_util_1.isOptionalCardinality)(cardinalities.get(e.feature)))) {
            break;
          }
        }
        return newStacks;
      }
      function isPlusFeature(feature) {
        if (feature.cardinality === "+") {
          return true;
        }
        const assignment = (0, ast_util_1.getContainerOfType)(feature, ast.isAssignment);
        if (assignment && assignment.cardinality === "+") {
          return true;
        }
        return false;
      }
      function featureMatches(feature, token) {
        if (ast.isKeyword(feature)) {
          const content = feature.value;
          return content === token.image;
        } else if (ast.isRuleCall(feature)) {
          return ruleMatches(feature.rule.ref, token);
        } else if (ast.isCrossReference(feature)) {
          const crossRefTerminal = (0, grammar_util_1.getCrossReferenceTerminal)(feature);
          if (crossRefTerminal) {
            return featureMatches(crossRefTerminal, token);
          }
        }
        return false;
      }
      function ruleMatches(rule, token) {
        if (ast.isParserRule(rule)) {
          const ruleFeatures = findFirstFeatures(rule.definition);
          return ruleFeatures.some((e) => featureMatches(e.feature, token));
        } else if (ast.isTerminalRule(rule)) {
          return new RegExp((0, internal_grammar_util_1.terminalRegex)(rule)).test(token.image);
        } else {
          return false;
        }
      }
    }
  });

  // node_modules/langium/lib/lsp/completion/completion-provider.js
  var require_completion_provider = __commonJS({
    "node_modules/langium/lib/lsp/completion/completion-provider.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DefaultCompletionProvider = exports2.mergeCompletionProviderOptions = void 0;
      var vscode_languageserver_1 = require_main4();
      var ast = __importStar(require_ast());
      var internal_grammar_util_1 = require_internal_grammar_util();
      var ast_util_1 = require_ast_util();
      var cst_util_1 = require_cst_util();
      var grammar_util_1 = require_grammar_util();
      var stream_1 = require_stream();
      var follow_element_computation_1 = require_follow_element_computation();
      function mergeCompletionProviderOptions(options) {
        const triggerCharacters = Array.from(new Set(options.flatMap((option) => {
          var _a4;
          return (_a4 = option === null || option === void 0 ? void 0 : option.triggerCharacters) !== null && _a4 !== void 0 ? _a4 : [];
        })));
        const allCommitCharacters = Array.from(new Set(options.flatMap((option) => {
          var _a4;
          return (_a4 = option === null || option === void 0 ? void 0 : option.allCommitCharacters) !== null && _a4 !== void 0 ? _a4 : [];
        })));
        return {
          triggerCharacters: triggerCharacters.length > 0 ? triggerCharacters : void 0,
          allCommitCharacters: allCommitCharacters.length > 0 ? allCommitCharacters : void 0
        };
      }
      exports2.mergeCompletionProviderOptions = mergeCompletionProviderOptions;
      var DefaultCompletionProvider = class {
        constructor(services) {
          this.scopeProvider = services.references.ScopeProvider;
          this.grammar = services.Grammar;
          this.completionParser = services.parser.CompletionParser;
          this.nameProvider = services.references.NameProvider;
          this.grammarConfig = services.parser.GrammarConfig;
        }
        async getCompletion(document2, params) {
          var _a4, _b2;
          const root = document2.parseResult.value;
          const cst = root.$cstNode;
          if (!cst) {
            return void 0;
          }
          const items = [];
          const textDocument = document2.textDocument;
          const text = textDocument.getText();
          const offset = textDocument.offsetAt(params.position);
          const acceptor = (value) => {
            const completionItem = this.fillCompletionItem(textDocument, offset, value);
            if (completionItem) {
              items.push(completionItem);
            }
          };
          const lastTokenOffset = this.backtrackToAnyToken(text, offset);
          const astNode = (_a4 = (0, cst_util_1.findLeafNodeAtOffset)(cst, lastTokenOffset)) === null || _a4 === void 0 ? void 0 : _a4.element;
          const context = {
            document: document2,
            textDocument,
            node: astNode,
            offset,
            position: params.position
          };
          if (!astNode) {
            const parserRule = (0, grammar_util_1.getEntryRule)(this.grammar);
            await this.completionForRule(context, parserRule, acceptor);
            return vscode_languageserver_1.CompletionList.create(this.deduplicateItems(items), true);
          }
          const contexts = [context];
          if (lastTokenOffset === offset && lastTokenOffset > 0) {
            const previousAstNode = (_b2 = (0, cst_util_1.findLeafNodeAtOffset)(cst, lastTokenOffset - 1)) === null || _b2 === void 0 ? void 0 : _b2.element;
            if (previousAstNode !== astNode) {
              contexts.push({
                document: document2,
                textDocument,
                node: previousAstNode,
                offset,
                position: params.position
              });
            }
          }
          const parserStart = this.backtrackToTokenStart(text, offset);
          const beforeFeatures = this.findFeaturesAt(textDocument, parserStart);
          let afterFeatures = [];
          const reparse = this.canReparse() && offset !== parserStart;
          if (reparse) {
            afterFeatures = this.findFeaturesAt(textDocument, offset);
          }
          const distinctionFunction = (element) => {
            if (ast.isKeyword(element.feature)) {
              return element.feature.value;
            } else {
              return element.feature;
            }
          };
          await Promise.all((0, stream_1.stream)(beforeFeatures).distinct(distinctionFunction).map((e) => this.completionForContexts(contexts, e, acceptor)));
          if (reparse) {
            await Promise.all((0, stream_1.stream)(afterFeatures).exclude(beforeFeatures, distinctionFunction).distinct(distinctionFunction).map((e) => this.completionForContexts(contexts, e, acceptor)));
          }
          return vscode_languageserver_1.CompletionList.create(this.deduplicateItems(items), true);
        }
        /**
         * The completion algorithm could yield the same reference/keyword multiple times.
         *
         * This methods deduplicates these items afterwards before returning to the client.
         * Unique items are identified as a combination of `kind`, `label` and `detail`
         */
        deduplicateItems(items) {
          return (0, stream_1.stream)(items).distinct((item) => `${item.kind}_${item.label}_${item.detail}`).toArray();
        }
        /**
         * Determines whether the completion parser will reparse the input at the point of completion.
         * By default, this returns `false`, indicating that the completion will only look for completion results starting from the token at the cursor position.
         * Override this and return `true` to indicate that the completion should parse the input a second time.
         * This might add some missing completions at the cost at parsing the input twice.
         */
        canReparse() {
          return false;
        }
        findFeaturesAt(document2, offset) {
          const text = document2.getText({
            start: vscode_languageserver_1.Position.create(0, 0),
            end: document2.positionAt(offset)
          });
          const parserResult = this.completionParser.parse(text);
          const tokens = parserResult.tokens;
          if (parserResult.tokenIndex === 0) {
            const parserRule = (0, grammar_util_1.getEntryRule)(this.grammar);
            const firstFeatures = (0, follow_element_computation_1.findFirstFeatures)({
              feature: parserRule.definition,
              new: true,
              type: (0, internal_grammar_util_1.getExplicitRuleType)(parserRule)
            });
            if (tokens.length > 0) {
              tokens.shift();
              return (0, follow_element_computation_1.findNextFeatures)(firstFeatures.map((e) => [e]), tokens);
            } else {
              return firstFeatures;
            }
          }
          const leftoverTokens = [...tokens].splice(parserResult.tokenIndex);
          const features = (0, follow_element_computation_1.findNextFeatures)([parserResult.elementStack.map((feature) => ({ feature }))], leftoverTokens);
          return features;
        }
        backtrackToAnyToken(text, offset) {
          if (offset >= text.length) {
            offset = text.length - 1;
          }
          while (offset > 0 && /\s/.test(text.charAt(offset))) {
            offset--;
          }
          return offset;
        }
        backtrackToTokenStart(text, offset) {
          if (offset < 1) {
            return offset;
          }
          const wordRegex = this.grammarConfig.nameRegexp;
          let lastCharacter = text.charAt(offset - 1);
          while (offset > 0 && wordRegex.test(lastCharacter)) {
            offset--;
            lastCharacter = text.charAt(offset - 1);
          }
          return offset;
        }
        async completionForRule(context, rule, acceptor) {
          if (ast.isParserRule(rule)) {
            const firstFeatures = (0, follow_element_computation_1.findFirstFeatures)(rule.definition);
            await Promise.all(firstFeatures.map((next) => this.completionFor(context, next, acceptor)));
          }
        }
        async completionForContexts(contexts, next, acceptor) {
          for (const context of contexts) {
            await this.completionFor(context, next, acceptor);
          }
        }
        completionFor(context, next, acceptor) {
          if (ast.isKeyword(next.feature)) {
            return this.completionForKeyword(context, next.feature, acceptor);
          } else if (ast.isCrossReference(next.feature) && context.node) {
            return this.completionForCrossReference(context, next, acceptor);
          }
        }
        completionForCrossReference(context, crossRef, acceptor) {
          const assignment = (0, ast_util_1.getContainerOfType)(crossRef.feature, ast.isAssignment);
          let node = context.node;
          if (assignment && node) {
            if (crossRef.type && (crossRef.new || node.$type !== crossRef.type)) {
              node = {
                $type: crossRef.type,
                $container: node,
                $containerProperty: crossRef.property
              };
            }
            if (!context) {
              return;
            }
            const refInfo = {
              reference: {},
              container: node,
              property: assignment.feature
            };
            try {
              const scope = this.scopeProvider.getScope(refInfo);
              const duplicateStore = /* @__PURE__ */ new Set();
              scope.getAllElements().forEach((e) => {
                if (!duplicateStore.has(e.name) && this.filterCrossReference(e)) {
                  acceptor(this.createReferenceCompletionItem(e));
                  duplicateStore.add(e.name);
                }
              });
            } catch (err) {
              console.error(err);
            }
          }
        }
        /**
         * Override this method to change how reference completion items are created.
         * Most notably useful to change the `kind` property which indicates which icon to display on the client.
         *
         * @param nodeDescription The description of a reference candidate
         * @returns A partial completion item
         */
        createReferenceCompletionItem(nodeDescription) {
          return {
            nodeDescription,
            kind: vscode_languageserver_1.CompletionItemKind.Reference,
            detail: nodeDescription.type,
            sortText: "0"
          };
        }
        filterCrossReference(_nodeDescription) {
          return true;
        }
        completionForKeyword(context, keyword, acceptor) {
          if (!keyword.value.match(/[\w]/)) {
            return;
          }
          acceptor({
            label: keyword.value,
            kind: vscode_languageserver_1.CompletionItemKind.Keyword,
            detail: "Keyword",
            sortText: "1"
          });
        }
        fillCompletionItem(document2, offset, item) {
          var _a4, _b2;
          let label;
          if (typeof item.label === "string") {
            label = item.label;
          } else if ("node" in item) {
            const name = this.nameProvider.getName(item.node);
            if (!name) {
              return void 0;
            }
            label = name;
          } else if ("nodeDescription" in item) {
            label = item.nodeDescription.name;
          } else {
            return void 0;
          }
          let insertText;
          if (typeof ((_a4 = item.textEdit) === null || _a4 === void 0 ? void 0 : _a4.newText) === "string") {
            insertText = item.textEdit.newText;
          } else if (typeof item.insertText === "string") {
            insertText = item.insertText;
          } else {
            insertText = label;
          }
          const textEdit = (_b2 = item.textEdit) !== null && _b2 !== void 0 ? _b2 : this.buildCompletionTextEdit(document2, offset, label, insertText);
          if (!textEdit) {
            return void 0;
          }
          const completionItem = {
            additionalTextEdits: item.additionalTextEdits,
            command: item.command,
            commitCharacters: item.commitCharacters,
            data: item.data,
            detail: item.detail,
            documentation: item.documentation,
            filterText: item.filterText,
            insertText: item.insertText,
            insertTextFormat: item.insertTextFormat,
            insertTextMode: item.insertTextMode,
            kind: item.kind,
            labelDetails: item.labelDetails,
            preselect: item.preselect,
            sortText: item.sortText,
            tags: item.tags,
            textEditText: item.textEditText,
            textEdit,
            label
          };
          return completionItem;
        }
        buildCompletionTextEdit(document2, offset, label, newText) {
          const content = document2.getText();
          const tokenStart = this.backtrackToTokenStart(content, offset);
          const identifier = content.substring(tokenStart, offset);
          if (this.charactersFuzzyMatch(identifier, label)) {
            const start = document2.positionAt(tokenStart);
            const end = document2.positionAt(offset);
            return {
              newText,
              range: {
                start,
                end
              }
            };
          } else {
            return void 0;
          }
        }
        isWordCharacterAt(content, index) {
          return this.grammarConfig.nameRegexp.test(content.charAt(index));
        }
        charactersFuzzyMatch(existingValue, completionValue) {
          if (existingValue.length === 0) {
            return true;
          }
          completionValue = completionValue.toLowerCase();
          let matchedFirstCharacter = false;
          let previous;
          let character = 0;
          const len = completionValue.length;
          for (let i = 0; i < len; i++) {
            const strChar = completionValue.charCodeAt(i);
            const testChar = existingValue.charCodeAt(character);
            if (strChar === testChar || this.toUpperCharCode(strChar) === this.toUpperCharCode(testChar)) {
              matchedFirstCharacter || (matchedFirstCharacter = previous === void 0 || // Beginning of word
              this.isWordTransition(previous, strChar));
              if (matchedFirstCharacter) {
                character++;
              }
              if (character === existingValue.length) {
                return true;
              }
            }
            previous = strChar;
          }
          return false;
        }
        isWordTransition(previous, current) {
          return a <= previous && previous <= z && A <= current && current <= Z || // camelCase transition
          previous === _ && current !== _;
        }
        toUpperCharCode(charCode) {
          if (a <= charCode && charCode <= z) {
            return charCode - 32;
          }
          return charCode;
        }
      };
      exports2.DefaultCompletionProvider = DefaultCompletionProvider;
      var a = "a".charCodeAt(0);
      var z = "z".charCodeAt(0);
      var A = "A".charCodeAt(0);
      var Z = "Z".charCodeAt(0);
      var _ = "_".charCodeAt(0);
    }
  });

  // node_modules/langium/lib/lsp/call-hierarchy-provider.js
  var require_call_hierarchy_provider = __commonJS({
    "node_modules/langium/lib/lsp/call-hierarchy-provider.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.AbstractCallHierarchyProvider = void 0;
      var vscode_languageserver_1 = require_main4();
      var vscode_uri_1 = require_umd();
      var cst_util_1 = require_cst_util();
      var AbstractCallHierarchyProvider = class {
        constructor(services) {
          this.grammarConfig = services.parser.GrammarConfig;
          this.nameProvider = services.references.NameProvider;
          this.documents = services.shared.workspace.LangiumDocuments;
          this.references = services.references.References;
        }
        prepareCallHierarchy(document2, params) {
          const rootNode = document2.parseResult.value;
          const targetNode = (0, cst_util_1.findDeclarationNodeAtOffset)(rootNode.$cstNode, document2.textDocument.offsetAt(params.position), this.grammarConfig.nameRegexp);
          if (!targetNode) {
            return void 0;
          }
          const declarationNode = this.references.findDeclarationNode(targetNode);
          if (!declarationNode) {
            return void 0;
          }
          return this.getCallHierarchyItems(declarationNode.element, document2);
        }
        getCallHierarchyItems(targetNode, document2) {
          const nameNode = this.nameProvider.getNameNode(targetNode);
          const name = this.nameProvider.getName(targetNode);
          if (!nameNode || !targetNode.$cstNode || name === void 0) {
            return void 0;
          }
          return [Object.assign({ kind: vscode_languageserver_1.SymbolKind.Method, name, range: targetNode.$cstNode.range, selectionRange: nameNode.range, uri: document2.uri.toString() }, this.getCallHierarchyItem(targetNode))];
        }
        getCallHierarchyItem(_targetNode) {
          return void 0;
        }
        incomingCalls(params) {
          const document2 = this.documents.getOrCreateDocument(vscode_uri_1.URI.parse(params.item.uri));
          const rootNode = document2.parseResult.value;
          const targetNode = (0, cst_util_1.findDeclarationNodeAtOffset)(rootNode.$cstNode, document2.textDocument.offsetAt(params.item.range.start), this.grammarConfig.nameRegexp);
          if (!targetNode) {
            return void 0;
          }
          const references = this.references.findReferences(targetNode.element, {
            includeDeclaration: false
          });
          return this.getIncomingCalls(targetNode.element, references);
        }
        outgoingCalls(params) {
          const document2 = this.documents.getOrCreateDocument(vscode_uri_1.URI.parse(params.item.uri));
          const rootNode = document2.parseResult.value;
          const targetNode = (0, cst_util_1.findDeclarationNodeAtOffset)(rootNode.$cstNode, document2.textDocument.offsetAt(params.item.range.start), this.grammarConfig.nameRegexp);
          if (!targetNode) {
            return void 0;
          }
          return this.getOutgoingCalls(targetNode.element);
        }
      };
      exports2.AbstractCallHierarchyProvider = AbstractCallHierarchyProvider;
    }
  });

  // node_modules/langium/lib/lsp/code-action.js
  var require_code_action = __commonJS({
    "node_modules/langium/lib/lsp/code-action.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
    }
  });

  // node_modules/langium/lib/lsp/code-lens-provider.js
  var require_code_lens_provider = __commonJS({
    "node_modules/langium/lib/lsp/code-lens-provider.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
    }
  });

  // node_modules/langium/lib/lsp/declaration-provider.js
  var require_declaration_provider = __commonJS({
    "node_modules/langium/lib/lsp/declaration-provider.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
    }
  });

  // node_modules/langium/lib/lsp/definition-provider.js
  var require_definition_provider = __commonJS({
    "node_modules/langium/lib/lsp/definition-provider.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DefaultDefinitionProvider = void 0;
      var vscode_languageserver_1 = require_main4();
      var ast_util_1 = require_ast_util();
      var cst_util_1 = require_cst_util();
      var DefaultDefinitionProvider = class {
        constructor(services) {
          this.nameProvider = services.references.NameProvider;
          this.references = services.references.References;
          this.grammarConfig = services.parser.GrammarConfig;
        }
        getDefinition(document2, params) {
          const rootNode = document2.parseResult.value;
          if (rootNode.$cstNode) {
            const cst = rootNode.$cstNode;
            const sourceCstNode = (0, cst_util_1.findDeclarationNodeAtOffset)(cst, document2.textDocument.offsetAt(params.position), this.grammarConfig.nameRegexp);
            if (sourceCstNode) {
              return this.collectLocationLinks(sourceCstNode, params);
            }
          }
          return void 0;
        }
        collectLocationLinks(sourceCstNode, _params) {
          var _a4;
          const goToLink = this.findLink(sourceCstNode);
          if (goToLink) {
            return [vscode_languageserver_1.LocationLink.create(goToLink.targetDocument.textDocument.uri, ((_a4 = goToLink.target.element.$cstNode) !== null && _a4 !== void 0 ? _a4 : goToLink.target).range, goToLink.target.range, goToLink.source.range)];
          }
          return void 0;
        }
        findLink(source) {
          const target = this.references.findDeclarationNode(source);
          if (target === null || target === void 0 ? void 0 : target.element) {
            const targetDocument = (0, ast_util_1.getDocument)(target.element);
            if (target && targetDocument) {
              return { source, target, targetDocument };
            }
          }
          return void 0;
        }
      };
      exports2.DefaultDefinitionProvider = DefaultDefinitionProvider;
    }
  });

  // node_modules/langium/lib/lsp/document-highlight-provider.js
  var require_document_highlight_provider = __commonJS({
    "node_modules/langium/lib/lsp/document-highlight-provider.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DefaultDocumentHighlightProvider = void 0;
      var vscode_languageserver_1 = require_main4();
      var ast_util_1 = require_ast_util();
      var cst_util_1 = require_cst_util();
      var uri_util_1 = require_uri_util();
      var DefaultDocumentHighlightProvider = class {
        constructor(services) {
          this.references = services.references.References;
          this.nameProvider = services.references.NameProvider;
          this.grammarConfig = services.parser.GrammarConfig;
        }
        getDocumentHighlight(document2, params) {
          const rootNode = document2.parseResult.value.$cstNode;
          if (!rootNode) {
            return void 0;
          }
          const selectedNode = (0, cst_util_1.findDeclarationNodeAtOffset)(rootNode, document2.textDocument.offsetAt(params.position), this.grammarConfig.nameRegexp);
          if (!selectedNode) {
            return void 0;
          }
          const targetAstNode = this.references.findDeclaration(selectedNode);
          if (targetAstNode) {
            const includeDeclaration = (0, uri_util_1.equalURI)((0, ast_util_1.getDocument)(targetAstNode).uri, document2.uri);
            const options = { documentUri: document2.uri, includeDeclaration };
            const references = this.references.findReferences(targetAstNode, options);
            return references.map((ref) => this.createDocumentHighlight(ref)).toArray();
          }
          return void 0;
        }
        /**
        * Override this method to determine the highlight kind of the given reference.
        */
        createDocumentHighlight(reference) {
          return vscode_languageserver_1.DocumentHighlight.create(reference.segment.range);
        }
      };
      exports2.DefaultDocumentHighlightProvider = DefaultDocumentHighlightProvider;
    }
  });

  // node_modules/langium/lib/lsp/document-link-provider.js
  var require_document_link_provider = __commonJS({
    "node_modules/langium/lib/lsp/document-link-provider.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
    }
  });

  // node_modules/langium/lib/lsp/document-symbol-provider.js
  var require_document_symbol_provider = __commonJS({
    "node_modules/langium/lib/lsp/document-symbol-provider.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DefaultDocumentSymbolProvider = void 0;
      var vscode_languageserver_1 = require_main4();
      var ast_util_1 = require_ast_util();
      var DefaultDocumentSymbolProvider = class {
        constructor(services) {
          this.nameProvider = services.references.NameProvider;
        }
        getSymbols(document2) {
          return this.getSymbol(document2, document2.parseResult.value);
        }
        getSymbol(document2, astNode) {
          const node = astNode.$cstNode;
          const nameNode = this.nameProvider.getNameNode(astNode);
          if (nameNode && node) {
            const name = this.nameProvider.getName(astNode);
            return [{
              kind: this.getSymbolKind(astNode.$type),
              name: name !== null && name !== void 0 ? name : nameNode.text,
              range: node.range,
              selectionRange: nameNode.range,
              children: this.getChildSymbols(document2, astNode)
            }];
          } else {
            return this.getChildSymbols(document2, astNode) || [];
          }
        }
        getChildSymbols(document2, astNode) {
          const children = [];
          for (const child of (0, ast_util_1.streamContents)(astNode)) {
            const result = this.getSymbol(document2, child);
            children.push(...result);
          }
          if (children.length > 0) {
            return children;
          }
          return void 0;
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        getSymbolKind(type) {
          return vscode_languageserver_1.SymbolKind.Field;
        }
      };
      exports2.DefaultDocumentSymbolProvider = DefaultDocumentSymbolProvider;
    }
  });

  // node_modules/langium/lib/lsp/execute-command-handler.js
  var require_execute_command_handler = __commonJS({
    "node_modules/langium/lib/lsp/execute-command-handler.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.AbstractExecuteCommandHandler = void 0;
      var vscode_languageserver_1 = require_main4();
      var AbstractExecuteCommandHandler = class {
        get commands() {
          return Array.from(this.registeredCommands.keys());
        }
        constructor() {
          this.registeredCommands = /* @__PURE__ */ new Map();
          this.registerCommands(this.createCommandAcceptor());
        }
        async executeCommand(name, args, cancelToken = vscode_languageserver_1.CancellationToken.None) {
          const command = this.registeredCommands.get(name);
          if (command) {
            return command(args, cancelToken);
          } else {
            return void 0;
          }
        }
        createCommandAcceptor() {
          return (name, execute) => this.registeredCommands.set(name, execute);
        }
      };
      exports2.AbstractExecuteCommandHandler = AbstractExecuteCommandHandler;
    }
  });

  // node_modules/langium/lib/lsp/hover-provider.js
  var require_hover_provider = __commonJS({
    "node_modules/langium/lib/lsp/hover-provider.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.MultilineCommentHoverProvider = exports2.AstNodeHoverProvider = void 0;
      var cst_util_1 = require_cst_util();
      var AstNodeHoverProvider = class {
        constructor(services) {
          this.references = services.references.References;
          this.grammarConfig = services.parser.GrammarConfig;
        }
        getHoverContent(document2, params) {
          var _a4, _b2;
          const rootNode = (_b2 = (_a4 = document2.parseResult) === null || _a4 === void 0 ? void 0 : _a4.value) === null || _b2 === void 0 ? void 0 : _b2.$cstNode;
          if (rootNode) {
            const offset = document2.textDocument.offsetAt(params.position);
            const cstNode = (0, cst_util_1.findDeclarationNodeAtOffset)(rootNode, offset, this.grammarConfig.nameRegexp);
            if (cstNode && cstNode.offset + cstNode.length > offset) {
              const targetNode = this.references.findDeclaration(cstNode);
              if (targetNode) {
                return this.getAstNodeHoverContent(targetNode);
              }
            }
          }
          return void 0;
        }
      };
      exports2.AstNodeHoverProvider = AstNodeHoverProvider;
      var MultilineCommentHoverProvider = class extends AstNodeHoverProvider {
        constructor(services) {
          super(services);
          this.documentationProvider = services.documentation.DocumentationProvider;
        }
        getAstNodeHoverContent(node) {
          const content = this.documentationProvider.getDocumentation(node);
          if (content) {
            return {
              contents: {
                kind: "markdown",
                value: content
              }
            };
          }
          return void 0;
        }
      };
      exports2.MultilineCommentHoverProvider = MultilineCommentHoverProvider;
    }
  });

  // node_modules/langium/lib/lsp/implementation-provider.js
  var require_implementation_provider = __commonJS({
    "node_modules/langium/lib/lsp/implementation-provider.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.AbstractGoToImplementationProvider = void 0;
      var vscode_languageserver_1 = require_main4();
      var cst_util_1 = require_cst_util();
      var AbstractGoToImplementationProvider = class {
        constructor(services) {
          this.references = services.references.References;
          this.grammarConfig = services.parser.GrammarConfig;
        }
        getImplementation(document2, params, cancelToken = vscode_languageserver_1.CancellationToken.None) {
          const rootNode = document2.parseResult.value;
          if (rootNode.$cstNode) {
            const sourceCstNode = (0, cst_util_1.findDeclarationNodeAtOffset)(rootNode.$cstNode, document2.textDocument.offsetAt(params.position), this.grammarConfig.nameRegexp);
            if (sourceCstNode) {
              const nodeDeclaration = this.references.findDeclaration(sourceCstNode);
              if (nodeDeclaration) {
                return this.collectGoToImplementationLocationLinks(nodeDeclaration, cancelToken);
              }
            }
          }
          return void 0;
        }
      };
      exports2.AbstractGoToImplementationProvider = AbstractGoToImplementationProvider;
    }
  });

  // node_modules/langium/lib/lsp/inlay-hint-provider.js
  var require_inlay_hint_provider = __commonJS({
    "node_modules/langium/lib/lsp/inlay-hint-provider.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.AbstractInlayHintProvider = void 0;
      var vscode_languageserver_1 = require_main4();
      var ast_util_1 = require_ast_util();
      var promise_util_1 = require_promise_util();
      var AbstractInlayHintProvider = class {
        async getInlayHints(document2, params, cancelToken = vscode_languageserver_1.CancellationToken.None) {
          const root = document2.parseResult.value;
          const inlayHints = [];
          const acceptor = (hint) => inlayHints.push(hint);
          for (const node of (0, ast_util_1.streamAst)(root, { range: params.range })) {
            await (0, promise_util_1.interruptAndCheck)(cancelToken);
            this.computeInlayHint(node, acceptor);
          }
          return inlayHints;
        }
      };
      exports2.AbstractInlayHintProvider = AbstractInlayHintProvider;
    }
  });

  // node_modules/langium/lib/workspace/documents.js
  var require_documents = __commonJS({
    "node_modules/langium/lib/workspace/documents.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DefaultLangiumDocuments = exports2.DefaultLangiumDocumentFactory = exports2.DocumentState = void 0;
      var vscode_languageserver_textdocument_1 = require_main5();
      var vscode_uri_1 = require_umd();
      var stream_1 = require_stream();
      var DocumentState;
      (function(DocumentState2) {
        DocumentState2[DocumentState2["Changed"] = 0] = "Changed";
        DocumentState2[DocumentState2["Parsed"] = 1] = "Parsed";
        DocumentState2[DocumentState2["IndexedContent"] = 2] = "IndexedContent";
        DocumentState2[DocumentState2["ComputedScopes"] = 3] = "ComputedScopes";
        DocumentState2[DocumentState2["Linked"] = 4] = "Linked";
        DocumentState2[DocumentState2["IndexedReferences"] = 5] = "IndexedReferences";
        DocumentState2[DocumentState2["Validated"] = 6] = "Validated";
      })(DocumentState = exports2.DocumentState || (exports2.DocumentState = {}));
      var DefaultLangiumDocumentFactory = class {
        constructor(services) {
          this.serviceRegistry = services.ServiceRegistry;
          this.textDocuments = services.workspace.TextDocuments;
          this.fileSystemProvider = services.workspace.FileSystemProvider;
        }
        fromTextDocument(textDocument, uri) {
          return this.create(uri !== null && uri !== void 0 ? uri : vscode_uri_1.URI.parse(textDocument.uri), textDocument);
        }
        fromString(text, uri) {
          return this.create(uri, text);
        }
        fromModel(model, uri) {
          return this.create(uri, { $model: model });
        }
        create(uri, content) {
          content !== null && content !== void 0 ? content : content = this.textDocuments.get(uri.toString());
          content !== null && content !== void 0 ? content : content = this.getContentFromFileSystem(uri);
          if (typeof content === "string") {
            const parseResult = this.parse(uri, content);
            return this.createLangiumDocument(parseResult, uri, void 0, content);
          } else if ("$model" in content) {
            const parseResult = { value: content.$model, parserErrors: [], lexerErrors: [] };
            return this.createLangiumDocument(parseResult, uri);
          } else {
            const parseResult = this.parse(uri, content.getText());
            return this.createLangiumDocument(parseResult, uri, content);
          }
        }
        /**
         * Create a LangiumDocument from a given parse result.
         *
         * A TextDocument is created on demand if it is not provided as argument here. Usually this
         * should not be necessary because the main purpose of the TextDocument is to convert between
         * text ranges and offsets, which is done solely in LSP request handling.
         *
         * With the introduction of {@link update} below this method is supposed to be mainly called
         * during workspace initialization and on addition/recognition of new files, while changes in
         * existing documents are processed via {@link update}.
         */
        createLangiumDocument(parseResult, uri, textDocument, text) {
          let document2;
          if (textDocument) {
            document2 = {
              parseResult,
              uri,
              state: DocumentState.Parsed,
              references: [],
              textDocument
            };
          } else {
            const textDocumentGetter = this.createTextDocumentGetter(uri, text);
            document2 = {
              parseResult,
              uri,
              state: DocumentState.Parsed,
              references: [],
              get textDocument() {
                return textDocumentGetter();
              }
            };
          }
          parseResult.value.$document = document2;
          return document2;
        }
        update(document2) {
          const textDocument = this.textDocuments.get(document2.uri.toString());
          const text = textDocument ? textDocument.getText() : this.getContentFromFileSystem(document2.uri);
          if (textDocument) {
            Object.defineProperty(document2, "textDocument", {
              value: textDocument
            });
          } else {
            const textDocumentGetter = this.createTextDocumentGetter(document2.uri, text);
            Object.defineProperty(document2, "textDocument", {
              get: textDocumentGetter
            });
          }
          document2.parseResult = this.parse(document2.uri, text);
          document2.parseResult.value.$document = document2;
          document2.state = DocumentState.Parsed;
          return document2;
        }
        getContentFromFileSystem(uri) {
          return this.fileSystemProvider.readFileSync(uri);
        }
        parse(uri, text) {
          const services = this.serviceRegistry.getServices(uri);
          return services.parser.LangiumParser.parse(text);
        }
        createTextDocumentGetter(uri, text) {
          const serviceRegistry = this.serviceRegistry;
          let textDoc = void 0;
          return () => {
            return textDoc !== null && textDoc !== void 0 ? textDoc : textDoc = vscode_languageserver_textdocument_1.TextDocument.create(uri.toString(), serviceRegistry.getServices(uri).LanguageMetaData.languageId, 0, text !== null && text !== void 0 ? text : "");
          };
        }
      };
      exports2.DefaultLangiumDocumentFactory = DefaultLangiumDocumentFactory;
      var DefaultLangiumDocuments = class {
        constructor(services) {
          this.documentMap = /* @__PURE__ */ new Map();
          this.langiumDocumentFactory = services.workspace.LangiumDocumentFactory;
        }
        get all() {
          return (0, stream_1.stream)(this.documentMap.values());
        }
        addDocument(document2) {
          const uriString = document2.uri.toString();
          if (this.documentMap.has(uriString)) {
            throw new Error(`A document with the URI '${uriString}' is already present.`);
          }
          this.documentMap.set(uriString, document2);
        }
        getOrCreateDocument(uri) {
          const uriString = uri.toString();
          let langiumDoc = this.documentMap.get(uriString);
          if (langiumDoc) {
            return langiumDoc;
          }
          langiumDoc = this.langiumDocumentFactory.create(uri);
          this.documentMap.set(uriString, langiumDoc);
          return langiumDoc;
        }
        hasDocument(uri) {
          return this.documentMap.has(uri.toString());
        }
        invalidateDocument(uri) {
          const uriString = uri.toString();
          const langiumDoc = this.documentMap.get(uriString);
          if (langiumDoc) {
            langiumDoc.state = DocumentState.Changed;
            langiumDoc.references = [];
            langiumDoc.precomputedScopes = void 0;
            langiumDoc.diagnostics = [];
          }
          return langiumDoc;
        }
        deleteDocument(uri) {
          const uriString = uri.toString();
          const langiumDoc = this.documentMap.get(uriString);
          if (langiumDoc) {
            langiumDoc.state = DocumentState.Changed;
            this.documentMap.delete(uriString);
          }
          return langiumDoc;
        }
      };
      exports2.DefaultLangiumDocuments = DefaultLangiumDocuments;
    }
  });

  // node_modules/langium/lib/lsp/signature-help-provider.js
  var require_signature_help_provider = __commonJS({
    "node_modules/langium/lib/lsp/signature-help-provider.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.mergeSignatureHelpOptions = exports2.AbstractSignatureHelpProvider = void 0;
      var vscode_languageserver_1 = require_main4();
      var cst_util_1 = require_cst_util();
      var AbstractSignatureHelpProvider = class {
        provideSignatureHelp(document2, params, cancelToken = vscode_languageserver_1.CancellationToken.None) {
          const rootNode = document2.parseResult.value;
          const cst = rootNode.$cstNode;
          if (cst) {
            const sourceCstNode = (0, cst_util_1.findLeafNodeAtOffset)(cst, document2.textDocument.offsetAt(params.position));
            if (sourceCstNode) {
              return this.getSignatureFromElement(sourceCstNode.element, cancelToken);
            }
          }
          return void 0;
        }
        /**
         * Override this getter to return the list of triggering characters for your language. To deactivate the signature help, return an empty object.
         */
        get signatureHelpOptions() {
          return {
            triggerCharacters: ["("],
            retriggerCharacters: [","]
          };
        }
      };
      exports2.AbstractSignatureHelpProvider = AbstractSignatureHelpProvider;
      function mergeSignatureHelpOptions(options) {
        const triggerCharacters = [];
        const retriggerCharacters = [];
        options.forEach((option) => {
          if (option === null || option === void 0 ? void 0 : option.triggerCharacters) {
            triggerCharacters.push(...option.triggerCharacters);
          }
          if (option === null || option === void 0 ? void 0 : option.retriggerCharacters) {
            retriggerCharacters.push(...option.retriggerCharacters);
          }
        });
        const mergedOptions = {
          triggerCharacters: triggerCharacters.length > 0 ? Array.from(new Set(triggerCharacters)).sort() : void 0,
          retriggerCharacters: retriggerCharacters.length > 0 ? Array.from(new Set(retriggerCharacters)).sort() : void 0
        };
        return mergedOptions.triggerCharacters ? mergedOptions : void 0;
      }
      exports2.mergeSignatureHelpOptions = mergeSignatureHelpOptions;
    }
  });

  // node_modules/langium/lib/lsp/language-server.js
  var require_language_server = __commonJS({
    "node_modules/langium/lib/lsp/language-server.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createRequestHandler = exports2.createServerRequestHandler = exports2.createCallHierarchyRequestHandler = exports2.addCallHierarchyHandler = exports2.addCodeLensHandler = exports2.addSignatureHelpHandler = exports2.addDocumentLinkHandler = exports2.addExecuteCommandHandler = exports2.addConfigurationChangeHandler = exports2.addSemanticTokenHandler = exports2.addInlayHintHandler = exports2.addRenameHandler = exports2.addFormattingHandler = exports2.addFoldingRangeHandler = exports2.addHoverHandler = exports2.addDocumentHighlightsHandler = exports2.addGoToDeclarationHandler = exports2.addGoToImplementationHandler = exports2.addGoToTypeDefinitionHandler = exports2.addGotoDefinitionHandler = exports2.addDocumentSymbolHandler = exports2.addCodeActionHandler = exports2.addFindReferencesHandler = exports2.addCompletionHandler = exports2.addDiagnosticsHandler = exports2.addDocumentsHandler = exports2.startLanguageServer = exports2.DefaultLanguageServer = void 0;
      var vscode_languageserver_1 = require_main4();
      var vscode_uri_1 = require_umd();
      var dependency_injection_1 = require_dependency_injection();
      var promise_util_1 = require_promise_util();
      var documents_1 = require_documents();
      var completion_provider_1 = require_completion_provider();
      var semantic_token_provider_1 = require_semantic_token_provider();
      var signature_help_provider_1 = require_signature_help_provider();
      var DefaultLanguageServer = class {
        constructor(services) {
          this.onInitializeEmitter = new vscode_languageserver_1.Emitter();
          this.onInitializedEmitter = new vscode_languageserver_1.Emitter();
          this.services = services;
        }
        get onInitialize() {
          return this.onInitializeEmitter.event;
        }
        get onInitialized() {
          return this.onInitializedEmitter.event;
        }
        async initialize(params) {
          this.eagerLoadServices();
          this.onInitializeEmitter.fire(params);
          this.onInitializeEmitter.dispose();
          return this.buildInitializeResult(params);
        }
        /**
         * Eagerly loads all services before emitting the `onInitialize` event.
         * Ensures that all services are able to catch the event.
         */
        eagerLoadServices() {
          (0, dependency_injection_1.eagerLoad)(this.services);
          this.services.ServiceRegistry.all.forEach((language2) => (0, dependency_injection_1.eagerLoad)(language2));
        }
        hasService(callback) {
          return this.services.ServiceRegistry.all.some((language2) => callback(language2) !== void 0);
        }
        buildInitializeResult(_params) {
          var _a4;
          const languages2 = this.services.ServiceRegistry.all;
          const hasFormattingService = this.hasService((e) => e.lsp.Formatter);
          const formattingOnTypeOptions = languages2.map((e) => {
            var _a5;
            return (_a5 = e.lsp.Formatter) === null || _a5 === void 0 ? void 0 : _a5.formatOnTypeOptions;
          }).find((e) => Boolean(e));
          const hasCodeActionProvider = this.hasService((e) => e.lsp.CodeActionProvider);
          const hasSemanticTokensProvider = this.hasService((e) => e.lsp.SemanticTokenProvider);
          const commandNames = (_a4 = this.services.lsp.ExecuteCommandHandler) === null || _a4 === void 0 ? void 0 : _a4.commands;
          const documentLinkProvider = this.services.lsp.DocumentLinkProvider;
          const signatureHelpOptions = (0, signature_help_provider_1.mergeSignatureHelpOptions)(languages2.map((e) => {
            var _a5;
            return (_a5 = e.lsp.SignatureHelp) === null || _a5 === void 0 ? void 0 : _a5.signatureHelpOptions;
          }));
          const hasGoToTypeProvider = this.hasService((e) => e.lsp.TypeProvider);
          const hasGoToImplementationProvider = this.hasService((e) => e.lsp.ImplementationProvider);
          const hasCompletionProvider = this.hasService((e) => e.lsp.CompletionProvider);
          const completionOptions = (0, completion_provider_1.mergeCompletionProviderOptions)(languages2.map((e) => {
            var _a5;
            return (_a5 = e.lsp.CompletionProvider) === null || _a5 === void 0 ? void 0 : _a5.completionOptions;
          }));
          const hasReferencesProvider = this.hasService((e) => e.lsp.ReferencesProvider);
          const hasDocumentSymbolProvider = this.hasService((e) => e.lsp.DocumentSymbolProvider);
          const hasDefinitionProvider = this.hasService((e) => e.lsp.DefinitionProvider);
          const hasDocumentHighlightProvider = this.hasService((e) => e.lsp.DocumentHighlightProvider);
          const hasFoldingRangeProvider = this.hasService((e) => e.lsp.FoldingRangeProvider);
          const hasHoverProvider = this.hasService((e) => e.lsp.HoverProvider);
          const hasRenameProvider = this.hasService((e) => e.lsp.RenameProvider);
          const hasCallHierarchyProvider = this.hasService((e) => e.lsp.CallHierarchyProvider);
          const codeLensProvider = this.services.lsp.CodeLensProvider;
          const hasDeclarationProvider = this.hasService((e) => e.lsp.DeclarationProvider);
          const inlayHintProvider = this.services.lsp.InlayHintProvider;
          const result = {
            capabilities: {
              workspace: {
                workspaceFolders: {
                  supported: true
                }
              },
              executeCommandProvider: commandNames && {
                commands: commandNames
              },
              textDocumentSync: vscode_languageserver_1.TextDocumentSyncKind.Incremental,
              completionProvider: hasCompletionProvider ? completionOptions : void 0,
              referencesProvider: hasReferencesProvider,
              documentSymbolProvider: hasDocumentSymbolProvider,
              definitionProvider: hasDefinitionProvider,
              typeDefinitionProvider: hasGoToTypeProvider,
              documentHighlightProvider: hasDocumentHighlightProvider,
              codeActionProvider: hasCodeActionProvider,
              documentFormattingProvider: hasFormattingService,
              documentRangeFormattingProvider: hasFormattingService,
              documentOnTypeFormattingProvider: formattingOnTypeOptions,
              foldingRangeProvider: hasFoldingRangeProvider,
              hoverProvider: hasHoverProvider,
              renameProvider: hasRenameProvider ? {
                prepareProvider: true
              } : void 0,
              semanticTokensProvider: hasSemanticTokensProvider ? semantic_token_provider_1.DefaultSemanticTokenOptions : void 0,
              signatureHelpProvider: signatureHelpOptions,
              implementationProvider: hasGoToImplementationProvider,
              callHierarchyProvider: hasCallHierarchyProvider ? {} : void 0,
              documentLinkProvider: documentLinkProvider ? { resolveProvider: Boolean(documentLinkProvider.resolveDocumentLink) } : void 0,
              codeLensProvider: codeLensProvider ? { resolveProvider: Boolean(codeLensProvider.resolveCodeLens) } : void 0,
              declarationProvider: hasDeclarationProvider,
              inlayHintProvider: inlayHintProvider ? { resolveProvider: Boolean(inlayHintProvider.resolveInlayHint) } : void 0
            }
          };
          return result;
        }
        async initialized(params) {
          this.onInitializedEmitter.fire(params);
          this.onInitializedEmitter.dispose();
        }
      };
      exports2.DefaultLanguageServer = DefaultLanguageServer;
      function startLanguageServer(services) {
        const connection = services.lsp.Connection;
        if (!connection) {
          throw new Error("Starting a language server requires the languageServer.Connection service to be set.");
        }
        addDocumentsHandler(connection, services);
        addDiagnosticsHandler(connection, services);
        addCompletionHandler(connection, services);
        addFindReferencesHandler(connection, services);
        addDocumentSymbolHandler(connection, services);
        addGotoDefinitionHandler(connection, services);
        addGoToTypeDefinitionHandler(connection, services);
        addGoToImplementationHandler(connection, services);
        addDocumentHighlightsHandler(connection, services);
        addFoldingRangeHandler(connection, services);
        addFormattingHandler(connection, services);
        addCodeActionHandler(connection, services);
        addRenameHandler(connection, services);
        addHoverHandler(connection, services);
        addInlayHintHandler(connection, services);
        addSemanticTokenHandler(connection, services);
        addExecuteCommandHandler(connection, services);
        addSignatureHelpHandler(connection, services);
        addCallHierarchyHandler(connection, services);
        addCodeLensHandler(connection, services);
        addDocumentLinkHandler(connection, services);
        addConfigurationChangeHandler(connection, services);
        addGoToDeclarationHandler(connection, services);
        connection.onInitialize((params) => {
          return services.lsp.LanguageServer.initialize(params);
        });
        connection.onInitialized((params) => {
          return services.lsp.LanguageServer.initialized(params);
        });
        const documents = services.workspace.TextDocuments;
        documents.listen(connection);
        connection.listen();
      }
      exports2.startLanguageServer = startLanguageServer;
      function addDocumentsHandler(connection, services) {
        const documentBuilder = services.workspace.DocumentBuilder;
        const mutex = services.workspace.MutexLock;
        function onDidChange(changed, deleted) {
          mutex.lock((token) => documentBuilder.update(changed, deleted, token));
        }
        const documents = services.workspace.TextDocuments;
        documents.onDidChangeContent((change) => {
          onDidChange([vscode_uri_1.URI.parse(change.document.uri)], []);
        });
        connection.onDidChangeWatchedFiles((params) => {
          const changedUris = [];
          const deletedUris = [];
          for (const change of params.changes) {
            const uri = vscode_uri_1.URI.parse(change.uri);
            if (change.type === vscode_languageserver_1.FileChangeType.Deleted) {
              deletedUris.push(uri);
            } else {
              changedUris.push(uri);
            }
          }
          onDidChange(changedUris, deletedUris);
        });
      }
      exports2.addDocumentsHandler = addDocumentsHandler;
      function addDiagnosticsHandler(connection, services) {
        const documentBuilder = services.workspace.DocumentBuilder;
        documentBuilder.onBuildPhase(documents_1.DocumentState.Validated, async (documents, cancelToken) => {
          for (const document2 of documents) {
            if (document2.diagnostics) {
              connection.sendDiagnostics({
                uri: document2.uri.toString(),
                diagnostics: document2.diagnostics
              });
            }
            if (cancelToken.isCancellationRequested) {
              return;
            }
          }
        });
      }
      exports2.addDiagnosticsHandler = addDiagnosticsHandler;
      function addCompletionHandler(connection, services) {
        connection.onCompletion(createRequestHandler((services2, document2, params, cancelToken) => {
          var _a4;
          return (_a4 = services2.lsp.CompletionProvider) === null || _a4 === void 0 ? void 0 : _a4.getCompletion(document2, params, cancelToken);
        }, services));
      }
      exports2.addCompletionHandler = addCompletionHandler;
      function addFindReferencesHandler(connection, services) {
        connection.onReferences(createRequestHandler((services2, document2, params, cancelToken) => {
          var _a4;
          return (_a4 = services2.lsp.ReferencesProvider) === null || _a4 === void 0 ? void 0 : _a4.findReferences(document2, params, cancelToken);
        }, services));
      }
      exports2.addFindReferencesHandler = addFindReferencesHandler;
      function addCodeActionHandler(connection, services) {
        connection.onCodeAction(createRequestHandler((services2, document2, params, cancelToken) => {
          var _a4;
          return (_a4 = services2.lsp.CodeActionProvider) === null || _a4 === void 0 ? void 0 : _a4.getCodeActions(document2, params, cancelToken);
        }, services));
      }
      exports2.addCodeActionHandler = addCodeActionHandler;
      function addDocumentSymbolHandler(connection, services) {
        connection.onDocumentSymbol(createRequestHandler((services2, document2, params, cancelToken) => {
          var _a4;
          return (_a4 = services2.lsp.DocumentSymbolProvider) === null || _a4 === void 0 ? void 0 : _a4.getSymbols(document2, params, cancelToken);
        }, services));
      }
      exports2.addDocumentSymbolHandler = addDocumentSymbolHandler;
      function addGotoDefinitionHandler(connection, services) {
        connection.onDefinition(createRequestHandler((services2, document2, params, cancelToken) => {
          var _a4;
          return (_a4 = services2.lsp.DefinitionProvider) === null || _a4 === void 0 ? void 0 : _a4.getDefinition(document2, params, cancelToken);
        }, services));
      }
      exports2.addGotoDefinitionHandler = addGotoDefinitionHandler;
      function addGoToTypeDefinitionHandler(connection, services) {
        connection.onTypeDefinition(createRequestHandler((services2, document2, params, cancelToken) => {
          var _a4;
          return (_a4 = services2.lsp.TypeProvider) === null || _a4 === void 0 ? void 0 : _a4.getTypeDefinition(document2, params, cancelToken);
        }, services));
      }
      exports2.addGoToTypeDefinitionHandler = addGoToTypeDefinitionHandler;
      function addGoToImplementationHandler(connection, services) {
        connection.onImplementation(createRequestHandler((services2, document2, params, cancelToken) => {
          var _a4;
          return (_a4 = services2.lsp.ImplementationProvider) === null || _a4 === void 0 ? void 0 : _a4.getImplementation(document2, params, cancelToken);
        }, services));
      }
      exports2.addGoToImplementationHandler = addGoToImplementationHandler;
      function addGoToDeclarationHandler(connection, services) {
        connection.onDeclaration(createRequestHandler((services2, document2, params, cancelToken) => {
          var _a4;
          return (_a4 = services2.lsp.DeclarationProvider) === null || _a4 === void 0 ? void 0 : _a4.getDeclaration(document2, params, cancelToken);
        }, services));
      }
      exports2.addGoToDeclarationHandler = addGoToDeclarationHandler;
      function addDocumentHighlightsHandler(connection, services) {
        connection.onDocumentHighlight(createRequestHandler((services2, document2, params, cancelToken) => {
          var _a4;
          return (_a4 = services2.lsp.DocumentHighlightProvider) === null || _a4 === void 0 ? void 0 : _a4.getDocumentHighlight(document2, params, cancelToken);
        }, services));
      }
      exports2.addDocumentHighlightsHandler = addDocumentHighlightsHandler;
      function addHoverHandler(connection, services) {
        connection.onHover(createRequestHandler((services2, document2, params, cancelToken) => {
          var _a4;
          return (_a4 = services2.lsp.HoverProvider) === null || _a4 === void 0 ? void 0 : _a4.getHoverContent(document2, params, cancelToken);
        }, services));
      }
      exports2.addHoverHandler = addHoverHandler;
      function addFoldingRangeHandler(connection, services) {
        connection.onFoldingRanges(createRequestHandler((services2, document2, params, cancelToken) => {
          var _a4;
          return (_a4 = services2.lsp.FoldingRangeProvider) === null || _a4 === void 0 ? void 0 : _a4.getFoldingRanges(document2, params, cancelToken);
        }, services));
      }
      exports2.addFoldingRangeHandler = addFoldingRangeHandler;
      function addFormattingHandler(connection, services) {
        connection.onDocumentFormatting(createRequestHandler((services2, document2, params, cancelToken) => {
          var _a4;
          return (_a4 = services2.lsp.Formatter) === null || _a4 === void 0 ? void 0 : _a4.formatDocument(document2, params, cancelToken);
        }, services));
        connection.onDocumentRangeFormatting(createRequestHandler((services2, document2, params, cancelToken) => {
          var _a4;
          return (_a4 = services2.lsp.Formatter) === null || _a4 === void 0 ? void 0 : _a4.formatDocumentRange(document2, params, cancelToken);
        }, services));
        connection.onDocumentOnTypeFormatting(createRequestHandler((services2, document2, params, cancelToken) => {
          var _a4;
          return (_a4 = services2.lsp.Formatter) === null || _a4 === void 0 ? void 0 : _a4.formatDocumentOnType(document2, params, cancelToken);
        }, services));
      }
      exports2.addFormattingHandler = addFormattingHandler;
      function addRenameHandler(connection, services) {
        connection.onRenameRequest(createRequestHandler((services2, document2, params, cancelToken) => {
          var _a4;
          return (_a4 = services2.lsp.RenameProvider) === null || _a4 === void 0 ? void 0 : _a4.rename(document2, params, cancelToken);
        }, services));
        connection.onPrepareRename(createRequestHandler((services2, document2, params, cancelToken) => {
          var _a4;
          return (_a4 = services2.lsp.RenameProvider) === null || _a4 === void 0 ? void 0 : _a4.prepareRename(document2, params, cancelToken);
        }, services));
      }
      exports2.addRenameHandler = addRenameHandler;
      function addInlayHintHandler(connection, services) {
        var _a4;
        const inlayHintProvider = services.lsp.InlayHintProvider;
        if (inlayHintProvider) {
          connection.languages.inlayHint.on(createServerRequestHandler((_, document2, params, cancelToken) => inlayHintProvider.getInlayHints(document2, params, cancelToken), services));
          const resolveInlayHint = (_a4 = inlayHintProvider.resolveInlayHint) === null || _a4 === void 0 ? void 0 : _a4.bind(inlayHintProvider);
          if (resolveInlayHint) {
            connection.languages.inlayHint.resolve(async (inlayHint, token) => {
              try {
                return await resolveInlayHint(inlayHint, token);
              } catch (err) {
                return responseError(err);
              }
            });
          }
        }
      }
      exports2.addInlayHintHandler = addInlayHintHandler;
      function addSemanticTokenHandler(connection, services) {
        const emptyResult = { data: [] };
        connection.languages.semanticTokens.on(createServerRequestHandler((services2, document2, params, cancelToken) => {
          if (services2.lsp.SemanticTokenProvider) {
            return services2.lsp.SemanticTokenProvider.semanticHighlight(document2, params, cancelToken);
          }
          return emptyResult;
        }, services));
        connection.languages.semanticTokens.onDelta(createServerRequestHandler((services2, document2, params, cancelToken) => {
          if (services2.lsp.SemanticTokenProvider) {
            return services2.lsp.SemanticTokenProvider.semanticHighlightDelta(document2, params, cancelToken);
          }
          return emptyResult;
        }, services));
        connection.languages.semanticTokens.onRange(createServerRequestHandler((services2, document2, params, cancelToken) => {
          if (services2.lsp.SemanticTokenProvider) {
            return services2.lsp.SemanticTokenProvider.semanticHighlightRange(document2, params, cancelToken);
          }
          return emptyResult;
        }, services));
      }
      exports2.addSemanticTokenHandler = addSemanticTokenHandler;
      function addConfigurationChangeHandler(connection, services) {
        connection.onDidChangeConfiguration((change) => {
          if (change.settings) {
            services.workspace.ConfigurationProvider.updateConfiguration(change);
          }
        });
      }
      exports2.addConfigurationChangeHandler = addConfigurationChangeHandler;
      function addExecuteCommandHandler(connection, services) {
        const commandHandler = services.lsp.ExecuteCommandHandler;
        if (commandHandler) {
          connection.onExecuteCommand(async (params, token) => {
            var _a4;
            try {
              return await commandHandler.executeCommand(params.command, (_a4 = params.arguments) !== null && _a4 !== void 0 ? _a4 : [], token);
            } catch (err) {
              return responseError(err);
            }
          });
        }
      }
      exports2.addExecuteCommandHandler = addExecuteCommandHandler;
      function addDocumentLinkHandler(connection, services) {
        var _a4;
        const documentLinkProvider = services.lsp.DocumentLinkProvider;
        if (documentLinkProvider) {
          connection.onDocumentLinks(createServerRequestHandler((_, document2, params, cancelToken) => documentLinkProvider.getDocumentLinks(document2, params, cancelToken), services));
          const resolveDocumentLink = (_a4 = documentLinkProvider.resolveDocumentLink) === null || _a4 === void 0 ? void 0 : _a4.bind(documentLinkProvider);
          if (resolveDocumentLink) {
            connection.onDocumentLinkResolve(async (documentLink, token) => {
              try {
                return await resolveDocumentLink(documentLink, token);
              } catch (err) {
                return responseError(err);
              }
            });
          }
        }
      }
      exports2.addDocumentLinkHandler = addDocumentLinkHandler;
      function addSignatureHelpHandler(connection, services) {
        connection.onSignatureHelp(createServerRequestHandler((services2, document2, params, cancelToken) => {
          var _a4;
          return (_a4 = services2.lsp.SignatureHelp) === null || _a4 === void 0 ? void 0 : _a4.provideSignatureHelp(document2, params, cancelToken);
        }, services));
      }
      exports2.addSignatureHelpHandler = addSignatureHelpHandler;
      function addCodeLensHandler(connection, services) {
        var _a4;
        const codeLensProvider = services.lsp.CodeLensProvider;
        if (codeLensProvider) {
          connection.onCodeLens(createServerRequestHandler((_, document2, params, cancelToken) => codeLensProvider.provideCodeLens(document2, params, cancelToken), services));
          const resolveCodeLens = (_a4 = codeLensProvider.resolveCodeLens) === null || _a4 === void 0 ? void 0 : _a4.bind(codeLensProvider);
          if (resolveCodeLens) {
            connection.onCodeLensResolve(async (codeLens, token) => {
              try {
                return await resolveCodeLens(codeLens, token);
              } catch (err) {
                return responseError(err);
              }
            });
          }
        }
      }
      exports2.addCodeLensHandler = addCodeLensHandler;
      function addCallHierarchyHandler(connection, services) {
        connection.languages.callHierarchy.onPrepare(createServerRequestHandler((services2, document2, params, cancelToken) => {
          var _a4;
          if (services2.lsp.CallHierarchyProvider) {
            return (_a4 = services2.lsp.CallHierarchyProvider.prepareCallHierarchy(document2, params, cancelToken)) !== null && _a4 !== void 0 ? _a4 : null;
          }
          return null;
        }, services));
        connection.languages.callHierarchy.onIncomingCalls(createCallHierarchyRequestHandler((services2, params, cancelToken) => {
          var _a4;
          if (services2.lsp.CallHierarchyProvider) {
            return (_a4 = services2.lsp.CallHierarchyProvider.incomingCalls(params, cancelToken)) !== null && _a4 !== void 0 ? _a4 : null;
          }
          return null;
        }, services));
        connection.languages.callHierarchy.onOutgoingCalls(createCallHierarchyRequestHandler((services2, params, cancelToken) => {
          var _a4;
          if (services2.lsp.CallHierarchyProvider) {
            return (_a4 = services2.lsp.CallHierarchyProvider.outgoingCalls(params, cancelToken)) !== null && _a4 !== void 0 ? _a4 : null;
          }
          return null;
        }, services));
      }
      exports2.addCallHierarchyHandler = addCallHierarchyHandler;
      function createCallHierarchyRequestHandler(serviceCall, sharedServices) {
        const serviceRegistry = sharedServices.ServiceRegistry;
        return async (params, cancelToken) => {
          const uri = vscode_uri_1.URI.parse(params.item.uri);
          const language2 = serviceRegistry.getServices(uri);
          if (!language2) {
            const message = `Could not find service instance for uri: '${uri.toString()}'`;
            console.error(message);
            throw new Error(message);
          }
          try {
            return await serviceCall(language2, params, cancelToken);
          } catch (err) {
            return responseError(err);
          }
        };
      }
      exports2.createCallHierarchyRequestHandler = createCallHierarchyRequestHandler;
      function createServerRequestHandler(serviceCall, sharedServices) {
        const documents = sharedServices.workspace.LangiumDocuments;
        const serviceRegistry = sharedServices.ServiceRegistry;
        return async (params, cancelToken) => {
          const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
          const language2 = serviceRegistry.getServices(uri);
          if (!language2) {
            console.error(`Could not find service instance for uri: '${uri.toString()}'`);
            throw new Error();
          }
          const document2 = documents.getOrCreateDocument(uri);
          if (!document2) {
            throw new Error();
          }
          try {
            return await serviceCall(language2, document2, params, cancelToken);
          } catch (err) {
            return responseError(err);
          }
        };
      }
      exports2.createServerRequestHandler = createServerRequestHandler;
      function createRequestHandler(serviceCall, sharedServices) {
        const documents = sharedServices.workspace.LangiumDocuments;
        const serviceRegistry = sharedServices.ServiceRegistry;
        return async (params, cancelToken) => {
          const uri = vscode_uri_1.URI.parse(params.textDocument.uri);
          const language2 = serviceRegistry.getServices(uri);
          if (!language2) {
            console.error(`Could not find service instance for uri: '${uri.toString()}'`);
            return null;
          }
          const document2 = documents.getOrCreateDocument(uri);
          if (!document2) {
            return null;
          }
          try {
            return await serviceCall(language2, document2, params, cancelToken);
          } catch (err) {
            return responseError(err);
          }
        };
      }
      exports2.createRequestHandler = createRequestHandler;
      function responseError(err) {
        if ((0, promise_util_1.isOperationCancelled)(err)) {
          return new vscode_languageserver_1.ResponseError(vscode_languageserver_1.LSPErrorCodes.RequestCancelled, "The request has been cancelled.");
        }
        if (err instanceof vscode_languageserver_1.ResponseError) {
          return err;
        }
        throw err;
      }
    }
  });

  // node_modules/langium/lib/lsp/references-provider.js
  var require_references_provider = __commonJS({
    "node_modules/langium/lib/lsp/references-provider.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DefaultReferencesProvider = void 0;
      var vscode_languageserver_1 = require_main4();
      var cst_util_1 = require_cst_util();
      var DefaultReferencesProvider = class {
        constructor(services) {
          this.nameProvider = services.references.NameProvider;
          this.references = services.references.References;
          this.grammarConfig = services.parser.GrammarConfig;
        }
        findReferences(document2, params) {
          const rootNode = document2.parseResult.value.$cstNode;
          if (!rootNode) {
            return [];
          }
          const selectedNode = (0, cst_util_1.findDeclarationNodeAtOffset)(rootNode, document2.textDocument.offsetAt(params.position), this.grammarConfig.nameRegexp);
          if (!selectedNode) {
            return [];
          }
          return this.getReferences(selectedNode, params, document2);
        }
        getReferences(selectedNode, params, _document) {
          const locations = [];
          const targetAstNode = this.references.findDeclaration(selectedNode);
          if (targetAstNode) {
            const options = { includeDeclaration: params.context.includeDeclaration };
            this.references.findReferences(targetAstNode, options).forEach((reference) => {
              locations.push(vscode_languageserver_1.Location.create(reference.sourceUri.toString(), reference.segment.range));
            });
          }
          return locations;
        }
      };
      exports2.DefaultReferencesProvider = DefaultReferencesProvider;
    }
  });

  // node_modules/langium/lib/lsp/rename-provider.js
  var require_rename_provider = __commonJS({
    "node_modules/langium/lib/lsp/rename-provider.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DefaultRenameProvider = void 0;
      var vscode_languageserver_1 = require_main4();
      var name_provider_1 = require_name_provider();
      var cst_util_1 = require_cst_util();
      var DefaultRenameProvider = class {
        constructor(services) {
          this.references = services.references.References;
          this.nameProvider = services.references.NameProvider;
          this.grammarConfig = services.parser.GrammarConfig;
        }
        async rename(document2, params) {
          const changes = {};
          const rootNode = document2.parseResult.value.$cstNode;
          if (!rootNode)
            return void 0;
          const offset = document2.textDocument.offsetAt(params.position);
          const leafNode = (0, cst_util_1.findDeclarationNodeAtOffset)(rootNode, offset, this.grammarConfig.nameRegexp);
          if (!leafNode)
            return void 0;
          const targetNode = this.references.findDeclaration(leafNode);
          if (!targetNode)
            return void 0;
          const options = { onlyLocal: false, includeDeclaration: true };
          const references = this.references.findReferences(targetNode, options);
          references.forEach((ref) => {
            const change = vscode_languageserver_1.TextEdit.replace(ref.segment.range, params.newName);
            const uri = ref.sourceUri.toString();
            if (changes[uri]) {
              changes[uri].push(change);
            } else {
              changes[uri] = [change];
            }
          });
          return { changes };
        }
        prepareRename(document2, params) {
          return this.renameNodeRange(document2, params.position);
        }
        renameNodeRange(doc, position) {
          const rootNode = doc.parseResult.value.$cstNode;
          const offset = doc.textDocument.offsetAt(position);
          if (rootNode && offset) {
            const leafNode = (0, cst_util_1.findDeclarationNodeAtOffset)(rootNode, offset, this.grammarConfig.nameRegexp);
            if (!leafNode) {
              return void 0;
            }
            const isCrossRef = this.references.findDeclaration(leafNode);
            if (isCrossRef || this.isNameNode(leafNode)) {
              return leafNode.range;
            }
          }
          return void 0;
        }
        isNameNode(leafNode) {
          return (leafNode === null || leafNode === void 0 ? void 0 : leafNode.element) && (0, name_provider_1.isNamed)(leafNode.element) && leafNode === this.nameProvider.getNameNode(leafNode.element);
        }
      };
      exports2.DefaultRenameProvider = DefaultRenameProvider;
    }
  });

  // node_modules/langium/lib/lsp/type-provider.js
  var require_type_provider = __commonJS({
    "node_modules/langium/lib/lsp/type-provider.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.AbstractTypeDefinitionProvider = void 0;
      var vscode_languageserver_1 = require_main4();
      var cst_util_1 = require_cst_util();
      var AbstractTypeDefinitionProvider = class {
        constructor(services) {
          this.references = services.references.References;
        }
        getTypeDefinition(document2, params, cancelToken = vscode_languageserver_1.CancellationToken.None) {
          const rootNode = document2.parseResult.value;
          if (rootNode.$cstNode) {
            const sourceCstNode = (0, cst_util_1.findDeclarationNodeAtOffset)(rootNode.$cstNode, document2.textDocument.offsetAt(params.position));
            if (sourceCstNode) {
              const nodeDeclaration = this.references.findDeclaration(sourceCstNode);
              if (nodeDeclaration) {
                return this.collectGoToTypeLocationLinks(nodeDeclaration, cancelToken);
              }
            }
          }
          return void 0;
        }
      };
      exports2.AbstractTypeDefinitionProvider = AbstractTypeDefinitionProvider;
    }
  });

  // node_modules/langium/lib/lsp/index.js
  var require_lsp = __commonJS({
    "node_modules/langium/lib/lsp/index.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_completion_provider(), exports2);
      __exportStar(require_follow_element_computation(), exports2);
      __exportStar(require_call_hierarchy_provider(), exports2);
      __exportStar(require_code_action(), exports2);
      __exportStar(require_code_lens_provider(), exports2);
      __exportStar(require_declaration_provider(), exports2);
      __exportStar(require_definition_provider(), exports2);
      __exportStar(require_document_highlight_provider(), exports2);
      __exportStar(require_document_link_provider(), exports2);
      __exportStar(require_document_symbol_provider(), exports2);
      __exportStar(require_execute_command_handler(), exports2);
      __exportStar(require_folding_range_provider(), exports2);
      __exportStar(require_formatter(), exports2);
      __exportStar(require_hover_provider(), exports2);
      __exportStar(require_implementation_provider(), exports2);
      __exportStar(require_inlay_hint_provider(), exports2);
      __exportStar(require_language_server(), exports2);
      __exportStar(require_references_provider(), exports2);
      __exportStar(require_rename_provider(), exports2);
      __exportStar(require_semantic_token_provider(), exports2);
      __exportStar(require_signature_help_provider(), exports2);
      __exportStar(require_type_provider(), exports2);
    }
  });

  // node_modules/langium/lib/grammar/lsp/grammar-definition.js
  var require_grammar_definition = __commonJS({
    "node_modules/langium/lib/grammar/lsp/grammar-definition.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LangiumGrammarDefinitionProvider = void 0;
      var vscode_languageserver_1 = require_main4();
      var lsp_1 = require_lsp();
      var ast_util_1 = require_ast_util();
      var grammar_util_1 = require_grammar_util();
      var ast_1 = require_ast();
      var internal_grammar_util_1 = require_internal_grammar_util();
      var LangiumGrammarDefinitionProvider = class extends lsp_1.DefaultDefinitionProvider {
        constructor(services) {
          super(services);
          this.documents = services.shared.workspace.LangiumDocuments;
        }
        collectLocationLinks(sourceCstNode, _params) {
          var _a4, _b2, _c2, _d, _e, _f;
          const pathFeature = "path";
          if ((0, ast_1.isGrammarImport)(sourceCstNode.element) && ((_a4 = (0, grammar_util_1.findAssignment)(sourceCstNode)) === null || _a4 === void 0 ? void 0 : _a4.feature) === pathFeature) {
            const importedGrammar = (0, internal_grammar_util_1.resolveImport)(this.documents, sourceCstNode.element);
            if (importedGrammar === null || importedGrammar === void 0 ? void 0 : importedGrammar.$document) {
              const targetObject = (_b2 = this.findTargetObject(importedGrammar)) !== null && _b2 !== void 0 ? _b2 : importedGrammar;
              const selectionRange = (_d = (_c2 = this.nameProvider.getNameNode(targetObject)) === null || _c2 === void 0 ? void 0 : _c2.range) !== null && _d !== void 0 ? _d : vscode_languageserver_1.Range.create(0, 0, 0, 0);
              const previewRange = (_f = (_e = targetObject.$cstNode) === null || _e === void 0 ? void 0 : _e.range) !== null && _f !== void 0 ? _f : vscode_languageserver_1.Range.create(0, 0, 0, 0);
              return [
                vscode_languageserver_1.LocationLink.create(importedGrammar.$document.uri.toString(), previewRange, selectionRange, sourceCstNode.range)
              ];
            }
            return void 0;
          }
          return super.collectLocationLinks(sourceCstNode, _params);
        }
        findTargetObject(importedGrammar) {
          if (importedGrammar.isDeclared) {
            return importedGrammar;
          }
          return (0, ast_util_1.streamContents)(importedGrammar).head();
        }
      };
      exports2.LangiumGrammarDefinitionProvider = LangiumGrammarDefinitionProvider;
    }
  });

  // node_modules/langium/lib/grammar/lsp/grammar-call-hierarchy.js
  var require_grammar_call_hierarchy = __commonJS({
    "node_modules/langium/lib/grammar/lsp/grammar-call-hierarchy.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LangiumGrammarCallHierarchyProvider = void 0;
      var vscode_languageserver_1 = require_main4();
      var call_hierarchy_provider_1 = require_call_hierarchy_provider();
      var ast_util_1 = require_ast_util();
      var cst_util_1 = require_cst_util();
      var ast_1 = require_ast();
      var LangiumGrammarCallHierarchyProvider = class extends call_hierarchy_provider_1.AbstractCallHierarchyProvider {
        getIncomingCalls(node, references) {
          if (!(0, ast_1.isParserRule)(node)) {
            return void 0;
          }
          const uniqueRules = /* @__PURE__ */ new Map();
          references.forEach((ref) => {
            const doc = this.documents.getOrCreateDocument(ref.sourceUri);
            const rootNode = doc.parseResult.value;
            if (!rootNode.$cstNode) {
              return;
            }
            const targetNode = (0, cst_util_1.findLeafNodeAtOffset)(rootNode.$cstNode, ref.segment.offset);
            if (!targetNode) {
              return;
            }
            const parserRule = (0, ast_util_1.getContainerOfType)(targetNode.element, ast_1.isParserRule);
            if (!parserRule || !parserRule.$cstNode) {
              return;
            }
            const nameNode = this.nameProvider.getNameNode(parserRule);
            if (!nameNode) {
              return;
            }
            const refDocUri = ref.sourceUri.toString();
            const ruleId = refDocUri + "@" + nameNode.text;
            uniqueRules.has(ruleId) ? uniqueRules.set(ruleId, { parserRule: parserRule.$cstNode, nameNode, targetNodes: [...uniqueRules.get(ruleId).targetNodes, targetNode], docUri: refDocUri }) : uniqueRules.set(ruleId, { parserRule: parserRule.$cstNode, nameNode, targetNodes: [targetNode], docUri: refDocUri });
          });
          if (uniqueRules.size === 0) {
            return void 0;
          }
          return Array.from(uniqueRules.values()).map((rule) => ({
            from: {
              kind: vscode_languageserver_1.SymbolKind.Method,
              name: rule.nameNode.text,
              range: rule.parserRule.range,
              selectionRange: rule.nameNode.range,
              uri: rule.docUri
            },
            fromRanges: rule.targetNodes.map((node2) => node2.range)
          }));
        }
        getOutgoingCalls(node) {
          if (!(0, ast_1.isParserRule)(node)) {
            return void 0;
          }
          const ruleCalls = (0, ast_util_1.streamAllContents)(node).filter(ast_1.isRuleCall).toArray();
          const uniqueRules = /* @__PURE__ */ new Map();
          ruleCalls.forEach((ruleCall) => {
            var _a4;
            const cstNode = ruleCall.$cstNode;
            if (!cstNode) {
              return;
            }
            const refCstNode = (_a4 = ruleCall.rule.ref) === null || _a4 === void 0 ? void 0 : _a4.$cstNode;
            if (!refCstNode) {
              return;
            }
            const refNameNode = this.nameProvider.getNameNode(refCstNode.element);
            if (!refNameNode) {
              return;
            }
            const refDocUri = (0, ast_util_1.getDocument)(refCstNode.element).uri.toString();
            const ruleId = refDocUri + "@" + refNameNode.text;
            uniqueRules.has(ruleId) ? uniqueRules.set(ruleId, { refCstNode, to: refNameNode, from: [...uniqueRules.get(ruleId).from, cstNode.range], docUri: refDocUri }) : uniqueRules.set(ruleId, { refCstNode, to: refNameNode, from: [cstNode.range], docUri: refDocUri });
          });
          if (uniqueRules.size === 0) {
            return void 0;
          }
          return Array.from(uniqueRules.values()).map((rule) => ({
            to: {
              kind: vscode_languageserver_1.SymbolKind.Method,
              name: rule.to.text,
              range: rule.refCstNode.range,
              selectionRange: rule.to.range,
              uri: rule.docUri
            },
            fromRanges: rule.from
          }));
        }
      };
      exports2.LangiumGrammarCallHierarchyProvider = LangiumGrammarCallHierarchyProvider;
    }
  });

  // node_modules/langium/lib/grammar/validation/validation-resources-collector.js
  var require_validation_resources_collector = __commonJS({
    "node_modules/langium/lib/grammar/validation/validation-resources-collector.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LangiumGrammarValidationResourcesCollector = void 0;
      var collections_1 = require_collections();
      var stream_1 = require_stream();
      var ast_1 = require_ast();
      var internal_grammar_util_1 = require_internal_grammar_util();
      var types_util_1 = require_types_util();
      var ast_collector_1 = require_ast_collector();
      var LangiumGrammarValidationResourcesCollector = class {
        constructor(services) {
          this.documents = services.shared.workspace.LangiumDocuments;
        }
        collectValidationResources(grammar) {
          const typeResources = (0, ast_collector_1.collectValidationAst)(grammar, this.documents);
          return {
            typeToValidationInfo: this.collectValidationInfo(typeResources),
            typeToSuperProperties: this.collectSuperProperties(typeResources)
          };
        }
        collectValidationInfo({ astResources, inferred, declared }) {
          const res = /* @__PURE__ */ new Map();
          const typeNameToRulesActions = collectNameToRulesActions(astResources);
          for (const type of (0, types_util_1.mergeTypesAndInterfaces)(inferred)) {
            res.set(type.name, { inferred: type, inferredNodes: typeNameToRulesActions.get(type.name) });
          }
          const typeNametoInterfacesUnions = (0, stream_1.stream)(astResources.interfaces).concat(astResources.types).reduce((acc, type) => acc.set(type.name, type), /* @__PURE__ */ new Map());
          for (const type of (0, types_util_1.mergeTypesAndInterfaces)(declared)) {
            const node = typeNametoInterfacesUnions.get(type.name);
            if (node) {
              const inferred2 = res.get(type.name);
              res.set(type.name, Object.assign(Object.assign({}, inferred2 !== null && inferred2 !== void 0 ? inferred2 : {}), { declared: type, declaredNode: node }));
            }
          }
          return res;
        }
        collectSuperProperties({ inferred, declared }) {
          const typeToSuperProperties = /* @__PURE__ */ new Map();
          const interfaces = (0, types_util_1.mergeInterfaces)(inferred, declared);
          const interfaceMap = new Map(interfaces.map((e) => [e.name, e]));
          for (const type of (0, types_util_1.mergeInterfaces)(inferred, declared)) {
            typeToSuperProperties.set(type.name, this.addSuperProperties(type, interfaceMap, /* @__PURE__ */ new Set()));
          }
          return typeToSuperProperties;
        }
        addSuperProperties(interfaceType, map, visited) {
          if (visited.has(interfaceType.name)) {
            return [];
          }
          visited.add(interfaceType.name);
          const properties = [...interfaceType.properties];
          for (const superType of interfaceType.superTypes) {
            const value = map.get(superType.name);
            if (value) {
              properties.push(...this.addSuperProperties(value, map, visited));
            }
          }
          return properties;
        }
      };
      exports2.LangiumGrammarValidationResourcesCollector = LangiumGrammarValidationResourcesCollector;
      function collectNameToRulesActions({ parserRules, datatypeRules }) {
        const acc = new collections_1.MultiMap();
        (0, stream_1.stream)(parserRules).concat(datatypeRules).forEach((rule) => acc.add((0, internal_grammar_util_1.getRuleType)(rule), rule));
        function collectActions(element) {
          if ((0, ast_1.isAction)(element)) {
            const name = (0, internal_grammar_util_1.getActionType)(element);
            if (name) {
              acc.add(name, element);
            }
          }
          if ((0, ast_1.isAlternatives)(element) || (0, ast_1.isGroup)(element) || (0, ast_1.isUnorderedGroup)(element)) {
            element.elements.forEach((e) => collectActions(e));
          }
        }
        parserRules.forEach((rule) => collectActions(rule.definition));
        return acc;
      }
    }
  });

  // node_modules/langium/lib/grammar/workspace/documents.js
  var require_documents2 = __commonJS({
    "node_modules/langium/lib/grammar/workspace/documents.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.isInferredAndDeclared = exports2.isInferred = exports2.isDeclared = void 0;
      function isDeclared(type) {
        return type && "declared" in type;
      }
      exports2.isDeclared = isDeclared;
      function isInferred(type) {
        return type && "inferred" in type;
      }
      exports2.isInferred = isInferred;
      function isInferredAndDeclared(type) {
        return type && "inferred" in type && "declared" in type;
      }
      exports2.isInferredAndDeclared = isInferredAndDeclared;
    }
  });

  // node_modules/langium/lib/grammar/validation/types-validator.js
  var require_types_validator = __commonJS({
    "node_modules/langium/lib/grammar/validation/types-validator.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LangiumGrammarTypesValidator = exports2.registerTypeValidationChecks = void 0;
      var ast = __importStar(require_ast());
      var collections_1 = require_collections();
      var internal_grammar_util_1 = require_internal_grammar_util();
      var types_1 = require_types();
      var documents_1 = require_documents2();
      function registerTypeValidationChecks(services) {
        const registry = services.validation.ValidationRegistry;
        const typesValidator = services.validation.LangiumGrammarTypesValidator;
        const checks = {
          Action: [
            typesValidator.checkActionIsNotUnionType
          ],
          Grammar: [
            typesValidator.checkDeclaredTypesConsistency,
            typesValidator.checkDeclaredAndInferredTypesConsistency
          ]
        };
        registry.register(checks, typesValidator);
      }
      exports2.registerTypeValidationChecks = registerTypeValidationChecks;
      var LangiumGrammarTypesValidator = class {
        checkDeclaredTypesConsistency(grammar, accept) {
          var _a4;
          const validationResources = (_a4 = grammar.$document) === null || _a4 === void 0 ? void 0 : _a4.validationResources;
          if (validationResources) {
            for (const typeInfo of validationResources.typeToValidationInfo.values()) {
              if ((0, documents_1.isDeclared)(typeInfo) && (0, types_1.isInterfaceType)(typeInfo.declared) && ast.isInterface(typeInfo.declaredNode)) {
                const declInterface = typeInfo;
                validateInterfaceSuperTypes(declInterface, accept);
                validateSuperTypesConsistency(declInterface, accept);
              }
            }
          }
        }
        checkDeclaredAndInferredTypesConsistency(grammar, accept) {
          var _a4;
          const validationResources = (_a4 = grammar.$document) === null || _a4 === void 0 ? void 0 : _a4.validationResources;
          if (validationResources) {
            for (const typeInfo of validationResources.typeToValidationInfo.values()) {
              if ((0, documents_1.isInferred)(typeInfo) && typeInfo.inferred instanceof types_1.InterfaceType) {
                validateInferredInterface(typeInfo.inferred, accept);
              }
              if ((0, documents_1.isInferredAndDeclared)(typeInfo)) {
                validateDeclaredAndInferredConsistency(typeInfo, validationResources, accept);
              }
            }
          }
        }
        checkActionIsNotUnionType(action, accept) {
          if (ast.isType(action.type)) {
            accept("error", "Actions cannot create union types.", { node: action, property: "type" });
          }
        }
      };
      exports2.LangiumGrammarTypesValidator = LangiumGrammarTypesValidator;
      function validateInferredInterface(inferredInterface, accept) {
        inferredInterface.properties.forEach((prop) => {
          var _a4;
          const flattened = (0, types_1.flattenPropertyUnion)(prop.type);
          if (flattened.length > 1) {
            const typeKind = (type) => (0, types_1.isReferenceType)(type) ? "ref" : "other";
            const firstKind = typeKind(flattened[0]);
            if (flattened.slice(1).some((type) => typeKind(type) !== firstKind)) {
              const targetNode = (_a4 = prop.astNodes.values().next()) === null || _a4 === void 0 ? void 0 : _a4.value;
              if (targetNode) {
                accept("error", `Mixing a cross-reference with other types is not supported. Consider splitting property "${prop.name}" into two or more different properties.`, { node: targetNode });
              }
            }
          }
        });
      }
      function validateInterfaceSuperTypes({ declared, declaredNode }, accept) {
        Array.from(declared.superTypes).forEach((superType, i) => {
          if (superType) {
            if ((0, types_1.isUnionType)(superType)) {
              accept("error", "Interfaces cannot extend union types.", { node: declaredNode, property: "superTypes", index: i });
            }
            if (!superType.declared) {
              accept("error", "Extending an inferred type is discouraged.", { node: declaredNode, property: "superTypes", index: i });
            }
          }
        });
      }
      function validateSuperTypesConsistency({ declared, declaredNode }, accept) {
        const nameToProp = declared.properties.reduce((acc, e) => acc.add(e.name, e), new collections_1.MultiMap());
        for (const [name, props] of nameToProp.entriesGroupedByKey()) {
          if (props.length > 1) {
            for (const prop of props) {
              accept("error", `Cannot have two properties with the same name '${name}'.`, {
                node: Array.from(prop.astNodes)[0],
                property: "name"
              });
            }
          }
        }
        const allSuperTypes = Array.from(declared.superTypes);
        for (let i = 0; i < allSuperTypes.length; i++) {
          for (let j = i + 1; j < allSuperTypes.length; j++) {
            const outerType = allSuperTypes[i];
            const innerType = allSuperTypes[j];
            const outerProps = (0, types_1.isInterfaceType)(outerType) ? outerType.superProperties : [];
            const innerProps = (0, types_1.isInterfaceType)(innerType) ? innerType.superProperties : [];
            const nonIdentical = getNonIdenticalProps(outerProps, innerProps);
            if (nonIdentical.length > 0) {
              accept("error", `Cannot simultaneously inherit from '${outerType}' and '${innerType}'. Their ${nonIdentical.map((e) => "'" + e + "'").join(", ")} properties are not identical.`, {
                node: declaredNode,
                property: "name"
              });
            }
          }
        }
        const allSuperProps = /* @__PURE__ */ new Set();
        for (const superType of allSuperTypes) {
          const props = (0, types_1.isInterfaceType)(superType) ? superType.superProperties : [];
          for (const prop of props) {
            allSuperProps.add(prop.name);
          }
        }
        for (const ownProp of declared.properties) {
          if (allSuperProps.has(ownProp.name)) {
            const propNode = declaredNode.attributes.find((e) => e.name === ownProp.name);
            if (propNode) {
              accept("error", `Cannot redeclare property '${ownProp.name}'. It is already inherited from another interface.`, {
                node: propNode,
                property: "name"
              });
            }
          }
        }
      }
      function getNonIdenticalProps(a, b) {
        const nonIdentical = [];
        for (const outerProp of a) {
          const innerProp = b.find((e) => e.name === outerProp.name);
          if (innerProp && !arePropTypesIdentical(outerProp, innerProp)) {
            nonIdentical.push(outerProp.name);
          }
        }
        return nonIdentical;
      }
      function arePropTypesIdentical(a, b) {
        return (0, types_1.isTypeAssignable)(a.type, b.type) && (0, types_1.isTypeAssignable)(b.type, a.type);
      }
      function validateDeclaredAndInferredConsistency(typeInfo, resources, accept) {
        const { inferred, declared, declaredNode, inferredNodes } = typeInfo;
        const typeName = declared.name;
        const applyErrorToRulesAndActions = (msgPostfix) => (errorMsg) => inferredNodes.forEach((node) => accept("error", `${errorMsg}${msgPostfix ? ` ${msgPostfix}` : ""}.`, (node === null || node === void 0 ? void 0 : node.inferredType) ? { node: node === null || node === void 0 ? void 0 : node.inferredType, property: "name" } : { node, property: ast.isAction(node) ? "type" : "name" }));
        const applyErrorToProperties = (nodes, errorMessage) => nodes.forEach((node) => accept("error", errorMessage, { node, property: ast.isAssignment(node) || ast.isAction(node) ? "feature" : "name" }));
        const applyMissingPropErrorToRules = (missingProp) => {
          inferredNodes.forEach((node) => {
            if (ast.isParserRule(node)) {
              const assignments = (0, internal_grammar_util_1.extractAssignments)(node.definition);
              if (assignments.find((e) => e.feature === missingProp) === void 0) {
                accept("error", `Property '${missingProp}' is missing in a rule '${node.name}', but is required in type '${typeName}'.`, {
                  node,
                  property: "parameters"
                });
              }
            }
          });
        };
        if ((0, types_1.isUnionType)(inferred) && (0, types_1.isUnionType)(declared)) {
          validateAlternativesConsistency(inferred.type, declared.type, applyErrorToRulesAndActions(`in a rule that returns type '${typeName}'`));
        } else if ((0, types_1.isInterfaceType)(inferred) && (0, types_1.isInterfaceType)(declared)) {
          validatePropertiesConsistency(inferred, declared, resources, applyErrorToRulesAndActions(`in a rule that returns type '${typeName}'`), applyErrorToProperties, applyMissingPropErrorToRules);
        } else {
          const errorMessage = `Inferred and declared versions of type '${typeName}' both have to be interfaces or unions.`;
          applyErrorToRulesAndActions()(errorMessage);
          accept("error", errorMessage, { node: declaredNode, property: "name" });
        }
      }
      function validateAlternativesConsistency(inferred, declared, applyErrorToInferredTypes) {
        if (!(0, types_1.isTypeAssignable)(inferred, declared)) {
          applyErrorToInferredTypes(`Cannot assign type '${(0, types_1.propertyTypeToString)(inferred, "DeclaredType")}' to '${(0, types_1.propertyTypeToString)(declared, "DeclaredType")}'`);
        }
      }
      function isOptionalProperty(prop) {
        return prop.optional || (0, types_1.isMandatoryPropertyType)(prop.type);
      }
      function validatePropertiesConsistency(inferred, declared, resources, applyErrorToType, applyErrorToProperties, applyMissingPropErrorToRules) {
        const ownInferredProps = new Set(inferred.properties.map((e) => e.name));
        const allInferredProps = new Map(inferred.allProperties.map((e) => [e.name, e]));
        const declaredProps = new Map(declared.superProperties.map((e) => [e.name, e]));
        const matchingProp = (type) => {
          if ((0, types_1.isPropertyUnion)(type))
            return { types: type.types.map((t) => matchingProp(t)) };
          if ((0, types_1.isReferenceType)(type))
            return { referenceType: matchingProp(type.referenceType) };
          if ((0, types_1.isArrayType)(type))
            return { elementType: matchingProp(type.elementType) };
          if ((0, types_1.isValueType)(type)) {
            const resource = resources.typeToValidationInfo.get(type.value.name);
            if (!resource)
              return type;
            return { value: "declared" in resource ? resource.declared : resource.inferred };
          }
          return type;
        };
        for (const [name, foundProp] of allInferredProps.entries()) {
          const expectedProp = declaredProps.get(name);
          if (expectedProp) {
            const foundTypeAsStr = (0, types_1.propertyTypeToString)(foundProp.type, "DeclaredType");
            const expectedTypeAsStr = (0, types_1.propertyTypeToString)(expectedProp.type, "DeclaredType");
            const typeAlternativesErrors = (0, types_1.isTypeAssignable)(matchingProp(foundProp.type), expectedProp.type);
            if (!typeAlternativesErrors) {
              const errorMsgPrefix = `The assigned type '${foundTypeAsStr}' is not compatible with the declared property '${name}' of type '${expectedTypeAsStr}'.`;
              applyErrorToProperties(foundProp.astNodes, errorMsgPrefix);
            }
            if (foundProp.optional && !isOptionalProperty(expectedProp)) {
              applyMissingPropErrorToRules(name);
            }
          } else if (ownInferredProps.has(name)) {
            applyErrorToProperties(foundProp.astNodes, `A property '${name}' is not expected.`);
          }
        }
        const missingProps = /* @__PURE__ */ new Set();
        for (const [name, expectedProperties] of declaredProps.entries()) {
          const foundProperty = allInferredProps.get(name);
          if (!foundProperty && !isOptionalProperty(expectedProperties)) {
            missingProps.add(name);
          }
        }
        if (missingProps.size > 0) {
          const prefix = missingProps.size > 1 ? "Properties" : "A property";
          const postfix = missingProps.size > 1 ? "are expected" : "is expected";
          const props = Array.from(missingProps).map((e) => `'${e}'`).sort().join(", ");
          applyErrorToType(`${prefix} ${props} ${postfix}.`);
        }
      }
    }
  });

  // node_modules/langium/lib/grammar/langium-grammar-module.js
  var require_langium_grammar_module = __commonJS({
    "node_modules/langium/lib/grammar/langium-grammar-module.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createLangiumGrammarServices = exports2.LangiumGrammarModule = void 0;
      var default_module_1 = require_default_module();
      var dependency_injection_1 = require_dependency_injection();
      var module_1 = require_module();
      var grammar_scope_1 = require_grammar_scope();
      var validator_1 = require_validator();
      var grammar_code_actions_1 = require_grammar_code_actions();
      var grammar_folding_ranges_1 = require_grammar_folding_ranges();
      var grammar_formatter_1 = require_grammar_formatter();
      var grammar_semantic_tokens_1 = require_grammar_semantic_tokens();
      var grammar_naming_1 = require_grammar_naming();
      var grammar_references_1 = require_grammar_references();
      var grammar_definition_1 = require_grammar_definition();
      var grammar_call_hierarchy_1 = require_grammar_call_hierarchy();
      var validation_resources_collector_1 = require_validation_resources_collector();
      var types_validator_1 = require_types_validator();
      var promise_util_1 = require_promise_util();
      var documents_1 = require_documents();
      exports2.LangiumGrammarModule = {
        validation: {
          LangiumGrammarValidator: (services) => new validator_1.LangiumGrammarValidator(services),
          ValidationResourcesCollector: (services) => new validation_resources_collector_1.LangiumGrammarValidationResourcesCollector(services),
          LangiumGrammarTypesValidator: () => new types_validator_1.LangiumGrammarTypesValidator()
        },
        lsp: {
          FoldingRangeProvider: (services) => new grammar_folding_ranges_1.LangiumGrammarFoldingRangeProvider(services),
          CodeActionProvider: (services) => new grammar_code_actions_1.LangiumGrammarCodeActionProvider(services),
          SemanticTokenProvider: (services) => new grammar_semantic_tokens_1.LangiumGrammarSemanticTokenProvider(services),
          Formatter: () => new grammar_formatter_1.LangiumGrammarFormatter(),
          DefinitionProvider: (services) => new grammar_definition_1.LangiumGrammarDefinitionProvider(services),
          CallHierarchyProvider: (services) => new grammar_call_hierarchy_1.LangiumGrammarCallHierarchyProvider(services)
        },
        references: {
          ScopeComputation: (services) => new grammar_scope_1.LangiumGrammarScopeComputation(services),
          ScopeProvider: (services) => new grammar_scope_1.LangiumGrammarScopeProvider(services),
          References: (services) => new grammar_references_1.LangiumGrammarReferences(services),
          NameProvider: () => new grammar_naming_1.LangiumGrammarNameProvider()
        }
      };
      function createLangiumGrammarServices(context, sharedModule) {
        const shared = (0, dependency_injection_1.inject)((0, default_module_1.createDefaultSharedModule)(context), module_1.LangiumGrammarGeneratedSharedModule, sharedModule);
        const grammar = (0, dependency_injection_1.inject)((0, default_module_1.createDefaultModule)({ shared }), module_1.LangiumGrammarGeneratedModule, exports2.LangiumGrammarModule);
        addTypeCollectionPhase(shared, grammar);
        shared.ServiceRegistry.register(grammar);
        (0, validator_1.registerValidationChecks)(grammar);
        (0, types_validator_1.registerTypeValidationChecks)(grammar);
        return { shared, grammar };
      }
      exports2.createLangiumGrammarServices = createLangiumGrammarServices;
      function addTypeCollectionPhase(sharedServices, grammarServices) {
        const documentBuilder = sharedServices.workspace.DocumentBuilder;
        documentBuilder.onBuildPhase(documents_1.DocumentState.IndexedReferences, async (documents, cancelToken) => {
          for (const document2 of documents) {
            await (0, promise_util_1.interruptAndCheck)(cancelToken);
            const typeCollector = grammarServices.validation.ValidationResourcesCollector;
            const grammar = document2.parseResult.value;
            document2.validationResources = typeCollector.collectValidationResources(grammar);
          }
        });
      }
    }
  });

  // node_modules/langium/lib/workspace/file-system-provider.js
  var require_file_system_provider = __commonJS({
    "node_modules/langium/lib/workspace/file-system-provider.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.EmptyFileSystem = exports2.EmptyFileSystemProvider = void 0;
      var EmptyFileSystemProvider = class {
        readFile() {
          throw new Error("Method not implemented.");
        }
        readFileSync() {
          throw new Error("Method not implemented.");
        }
        async readDirectory() {
          return [];
        }
      };
      exports2.EmptyFileSystemProvider = EmptyFileSystemProvider;
      exports2.EmptyFileSystem = {
        fileSystemProvider: () => new EmptyFileSystemProvider()
      };
    }
  });

  // node_modules/langium/lib/utils/grammar-util.js
  var require_grammar_util = __commonJS({
    "node_modules/langium/lib/utils/grammar-util.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createServicesForGrammar = exports2.loadGrammarFromJson = exports2.findNameAssignment = exports2.findAssignment = exports2.findNodesForKeywordInternal = exports2.findNodeForKeyword = exports2.findNodesForKeyword = exports2.findNodeForProperty = exports2.findNodesForProperty = exports2.isCommentTerminal = exports2.getCrossReferenceTerminal = exports2.getAllReachableRules = exports2.getHiddenRules = exports2.getEntryRule = void 0;
      var vscode_uri_1 = require_umd();
      var default_module_1 = require_default_module();
      var dependency_injection_1 = require_dependency_injection();
      var ast_reflection_interpreter_1 = require_ast_reflection_interpreter();
      var ast = __importStar(require_ast());
      var internal_grammar_util_1 = require_internal_grammar_util();
      var langium_grammar_module_1 = require_langium_grammar_module();
      var syntax_tree_1 = require_syntax_tree();
      var ast_util_1 = require_ast_util();
      var cst_util_1 = require_cst_util();
      var file_system_provider_1 = require_file_system_provider();
      function getEntryRule(grammar) {
        return grammar.rules.find((e) => ast.isParserRule(e) && e.entry);
      }
      exports2.getEntryRule = getEntryRule;
      function getHiddenRules(grammar) {
        return grammar.rules.filter((e) => ast.isTerminalRule(e) && e.hidden);
      }
      exports2.getHiddenRules = getHiddenRules;
      function getAllReachableRules(grammar, allTerminals) {
        const ruleNames = /* @__PURE__ */ new Set();
        const entryRule = getEntryRule(grammar);
        if (!entryRule) {
          return new Set(grammar.rules);
        }
        const topMostRules = [entryRule].concat(getHiddenRules(grammar));
        for (const rule of topMostRules) {
          ruleDfs(rule, ruleNames, allTerminals);
        }
        const rules = /* @__PURE__ */ new Set();
        for (const rule of grammar.rules) {
          if (ruleNames.has(rule.name) || ast.isTerminalRule(rule) && rule.hidden) {
            rules.add(rule);
          }
        }
        return rules;
      }
      exports2.getAllReachableRules = getAllReachableRules;
      function ruleDfs(rule, visitedSet, allTerminals) {
        visitedSet.add(rule.name);
        (0, ast_util_1.streamAllContents)(rule).forEach((node) => {
          if (ast.isRuleCall(node) || allTerminals && ast.isTerminalRuleCall(node)) {
            const refRule = node.rule.ref;
            if (refRule && !visitedSet.has(refRule.name)) {
              ruleDfs(refRule, visitedSet, allTerminals);
            }
          }
        });
      }
      function getCrossReferenceTerminal(crossRef) {
        if (crossRef.terminal) {
          return crossRef.terminal;
        } else if (crossRef.type.ref) {
          const nameAssigment = findNameAssignment(crossRef.type.ref);
          return nameAssigment === null || nameAssigment === void 0 ? void 0 : nameAssigment.terminal;
        }
        return void 0;
      }
      exports2.getCrossReferenceTerminal = getCrossReferenceTerminal;
      function isCommentTerminal(terminalRule) {
        return terminalRule.hidden && !" ".match((0, internal_grammar_util_1.terminalRegex)(terminalRule));
      }
      exports2.isCommentTerminal = isCommentTerminal;
      function findNodesForProperty(node, property) {
        if (!node || !property) {
          return [];
        }
        return findNodesForPropertyInternal(node, property, node.element, true);
      }
      exports2.findNodesForProperty = findNodesForProperty;
      function findNodeForProperty(node, property, index) {
        if (!node || !property) {
          return void 0;
        }
        const nodes = findNodesForPropertyInternal(node, property, node.element, true);
        if (nodes.length === 0) {
          return void 0;
        }
        if (index !== void 0) {
          index = Math.max(0, Math.min(index, nodes.length - 1));
        } else {
          index = 0;
        }
        return nodes[index];
      }
      exports2.findNodeForProperty = findNodeForProperty;
      function findNodesForPropertyInternal(node, property, element, first) {
        if (!first) {
          const nodeFeature = (0, ast_util_1.getContainerOfType)(node.feature, ast.isAssignment);
          if (nodeFeature && nodeFeature.feature === property) {
            return [node];
          }
        }
        if ((0, syntax_tree_1.isCompositeCstNode)(node) && node.element === element) {
          return node.children.flatMap((e) => findNodesForPropertyInternal(e, property, element, false));
        }
        return [];
      }
      function findNodesForKeyword(node, keyword) {
        if (!node) {
          return [];
        }
        return findNodesForKeywordInternal(node, keyword, node === null || node === void 0 ? void 0 : node.element);
      }
      exports2.findNodesForKeyword = findNodesForKeyword;
      function findNodeForKeyword(node, keyword, index) {
        if (!node) {
          return void 0;
        }
        const nodes = findNodesForKeywordInternal(node, keyword, node === null || node === void 0 ? void 0 : node.element);
        if (nodes.length === 0) {
          return void 0;
        }
        if (index !== void 0) {
          index = Math.max(0, Math.min(index, nodes.length - 1));
        } else {
          index = 0;
        }
        return nodes[index];
      }
      exports2.findNodeForKeyword = findNodeForKeyword;
      function findNodesForKeywordInternal(node, keyword, element) {
        if (node.element !== element) {
          return [];
        }
        if (ast.isKeyword(node.feature) && node.feature.value === keyword) {
          return [node];
        }
        const treeIterator = (0, cst_util_1.streamCst)(node).iterator();
        let result;
        const keywordNodes = [];
        do {
          result = treeIterator.next();
          if (!result.done) {
            const childNode = result.value;
            if (childNode.element === element) {
              if (ast.isKeyword(childNode.feature) && childNode.feature.value === keyword) {
                keywordNodes.push(childNode);
              }
            } else {
              treeIterator.prune();
            }
          }
        } while (!result.done);
        return keywordNodes;
      }
      exports2.findNodesForKeywordInternal = findNodesForKeywordInternal;
      function findAssignment(cstNode) {
        var _a4;
        const astNode = cstNode.element;
        while (astNode === ((_a4 = cstNode.parent) === null || _a4 === void 0 ? void 0 : _a4.element)) {
          const assignment = (0, ast_util_1.getContainerOfType)(cstNode.feature, ast.isAssignment);
          if (assignment) {
            return assignment;
          }
          cstNode = cstNode.parent;
        }
        return void 0;
      }
      exports2.findAssignment = findAssignment;
      function findNameAssignment(type) {
        if (ast.isInferredType(type)) {
          type = type.$container;
        }
        return findNameAssignmentInternal(type, /* @__PURE__ */ new Map());
      }
      exports2.findNameAssignment = findNameAssignment;
      function findNameAssignmentInternal(type, cache) {
        var _a4;
        function go(node, refType) {
          let childAssignment = void 0;
          const parentAssignment = (0, ast_util_1.getContainerOfType)(node, ast.isAssignment);
          if (!parentAssignment) {
            childAssignment = findNameAssignmentInternal(refType, cache);
          }
          cache.set(type, childAssignment);
          return childAssignment;
        }
        if (cache.has(type))
          return cache.get(type);
        cache.set(type, void 0);
        for (const node of (0, ast_util_1.streamAllContents)(type)) {
          if (ast.isAssignment(node) && node.feature.toLowerCase() === "name") {
            cache.set(type, node);
            return node;
          } else if (ast.isRuleCall(node) && ast.isParserRule(node.rule.ref)) {
            return go(node, node.rule.ref);
          } else if (ast.isSimpleType(node) && ((_a4 = node.typeRef) === null || _a4 === void 0 ? void 0 : _a4.ref)) {
            return go(node, node.typeRef.ref);
          }
        }
        return void 0;
      }
      function loadGrammarFromJson(json) {
        var _a4;
        const services = (0, langium_grammar_module_1.createLangiumGrammarServices)(file_system_provider_1.EmptyFileSystem).grammar;
        const astNode = services.serializer.JsonSerializer.deserialize(json);
        services.shared.workspace.LangiumDocumentFactory.fromModel(astNode, vscode_uri_1.URI.parse(`memory://${(_a4 = astNode.name) !== null && _a4 !== void 0 ? _a4 : "grammar"}.langium`));
        return astNode;
      }
      exports2.loadGrammarFromJson = loadGrammarFromJson;
      async function createServicesForGrammar(config) {
        var _a4, _b2, _c2, _d, _e, _f;
        const grammarServices = (_a4 = config.grammarServices) !== null && _a4 !== void 0 ? _a4 : (0, langium_grammar_module_1.createLangiumGrammarServices)(file_system_provider_1.EmptyFileSystem).grammar;
        const uri = vscode_uri_1.URI.parse("memory:///grammar.langium");
        const factory = grammarServices.shared.workspace.LangiumDocumentFactory;
        const grammarDocument = typeof config.grammar === "string" ? factory.fromString(config.grammar, uri) : (0, ast_util_1.getDocument)(config.grammar);
        const grammarNode = grammarDocument.parseResult.value;
        const documentBuilder = grammarServices.shared.workspace.DocumentBuilder;
        await documentBuilder.build([grammarDocument], { validationChecks: "none" });
        const parserConfig = (_b2 = config.parserConfig) !== null && _b2 !== void 0 ? _b2 : {
          skipValidations: false
        };
        const languageMetaData = (_c2 = config.languageMetaData) !== null && _c2 !== void 0 ? _c2 : {
          caseInsensitive: false,
          fileExtensions: [`.${(_e = (_d = grammarNode.name) === null || _d === void 0 ? void 0 : _d.toLowerCase()) !== null && _e !== void 0 ? _e : "unknown"}`],
          languageId: (_f = grammarNode.name) !== null && _f !== void 0 ? _f : "UNKNOWN"
        };
        const generatedSharedModule = {
          AstReflection: () => (0, ast_reflection_interpreter_1.interpretAstReflection)(grammarNode)
        };
        const generatedModule = {
          Grammar: () => grammarNode,
          LanguageMetaData: () => languageMetaData,
          parser: {
            ParserConfig: () => parserConfig
          }
        };
        const shared = (0, dependency_injection_1.inject)((0, default_module_1.createDefaultSharedModule)(file_system_provider_1.EmptyFileSystem), generatedSharedModule, config.sharedModule);
        const services = (0, dependency_injection_1.inject)((0, default_module_1.createDefaultModule)({ shared }), generatedModule, config.module);
        shared.ServiceRegistry.register(services);
        return services;
      }
      exports2.createServicesForGrammar = createServicesForGrammar;
    }
  });

  // node_modules/langium/lib/grammar/grammar-config.js
  var require_grammar_config = __commonJS({
    "node_modules/langium/lib/grammar/grammar-config.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createGrammarConfig = void 0;
      var cst_util_1 = require_cst_util();
      var grammar_util_1 = require_grammar_util();
      var regex_util_1 = require_regex_util();
      var ast_1 = require_ast();
      var internal_grammar_util_1 = require_internal_grammar_util();
      function createGrammarConfig(services) {
        const rules = [];
        const grammar = services.Grammar;
        for (const rule of grammar.rules) {
          if ((0, ast_1.isTerminalRule)(rule) && (0, grammar_util_1.isCommentTerminal)(rule) && (0, regex_util_1.isMultilineComment)((0, internal_grammar_util_1.terminalRegex)(rule))) {
            rules.push(rule.name);
          }
        }
        return {
          multilineCommentRules: rules,
          nameRegexp: cst_util_1.DefaultNameRegexp
        };
      }
      exports2.createGrammarConfig = createGrammarConfig;
    }
  });

  // node_modules/chevrotain/lib/src/version.js
  var require_version = __commonJS({
    "node_modules/chevrotain/lib/src/version.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.VERSION = void 0;
      exports2.VERSION = "10.4.2";
    }
  });

  // node_modules/lodash/_isPrototype.js
  var require_isPrototype = __commonJS({
    "node_modules/lodash/_isPrototype.js"(exports2, module2) {
      var objectProto = Object.prototype;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      module2.exports = isPrototype;
    }
  });

  // node_modules/lodash/_overArg.js
  var require_overArg = __commonJS({
    "node_modules/lodash/_overArg.js"(exports2, module2) {
      function overArg(func, transform2) {
        return function(arg) {
          return func(transform2(arg));
        };
      }
      module2.exports = overArg;
    }
  });

  // node_modules/lodash/_nativeKeys.js
  var require_nativeKeys = __commonJS({
    "node_modules/lodash/_nativeKeys.js"(exports2, module2) {
      var overArg = require_overArg();
      var nativeKeys = overArg(Object.keys, Object);
      module2.exports = nativeKeys;
    }
  });

  // node_modules/lodash/_baseKeys.js
  var require_baseKeys = __commonJS({
    "node_modules/lodash/_baseKeys.js"(exports2, module2) {
      var isPrototype = require_isPrototype();
      var nativeKeys = require_nativeKeys();
      var objectProto = Object.prototype;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result = [];
        for (var key in Object(object)) {
          if (hasOwnProperty2.call(object, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      module2.exports = baseKeys;
    }
  });

  // node_modules/lodash/_freeGlobal.js
  var require_freeGlobal = __commonJS({
    "node_modules/lodash/_freeGlobal.js"(exports2, module2) {
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      module2.exports = freeGlobal;
    }
  });

  // node_modules/lodash/_root.js
  var require_root = __commonJS({
    "node_modules/lodash/_root.js"(exports2, module2) {
      var freeGlobal = require_freeGlobal();
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      module2.exports = root;
    }
  });

  // node_modules/lodash/_Symbol.js
  var require_Symbol = __commonJS({
    "node_modules/lodash/_Symbol.js"(exports2, module2) {
      var root = require_root();
      var Symbol2 = root.Symbol;
      module2.exports = Symbol2;
    }
  });

  // node_modules/lodash/_getRawTag.js
  var require_getRawTag = __commonJS({
    "node_modules/lodash/_getRawTag.js"(exports2, module2) {
      var Symbol2 = require_Symbol();
      var objectProto = Object.prototype;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      var nativeObjectToString = objectProto.toString;
      var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
      function getRawTag(value) {
        var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = void 0;
          var unmasked = true;
        } catch (e) {
        }
        var result = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result;
      }
      module2.exports = getRawTag;
    }
  });

  // node_modules/lodash/_objectToString.js
  var require_objectToString = __commonJS({
    "node_modules/lodash/_objectToString.js"(exports2, module2) {
      var objectProto = Object.prototype;
      var nativeObjectToString = objectProto.toString;
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      module2.exports = objectToString;
    }
  });

  // node_modules/lodash/_baseGetTag.js
  var require_baseGetTag = __commonJS({
    "node_modules/lodash/_baseGetTag.js"(exports2, module2) {
      var Symbol2 = require_Symbol();
      var getRawTag = require_getRawTag();
      var objectToString = require_objectToString();
      var nullTag = "[object Null]";
      var undefinedTag = "[object Undefined]";
      var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }
      module2.exports = baseGetTag;
    }
  });

  // node_modules/lodash/isObject.js
  var require_isObject = __commonJS({
    "node_modules/lodash/isObject.js"(exports2, module2) {
      function isObject2(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      module2.exports = isObject2;
    }
  });

  // node_modules/lodash/isFunction.js
  var require_isFunction = __commonJS({
    "node_modules/lodash/isFunction.js"(exports2, module2) {
      var baseGetTag = require_baseGetTag();
      var isObject2 = require_isObject();
      var asyncTag = "[object AsyncFunction]";
      var funcTag = "[object Function]";
      var genTag = "[object GeneratorFunction]";
      var proxyTag = "[object Proxy]";
      function isFunction(value) {
        if (!isObject2(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      module2.exports = isFunction;
    }
  });

  // node_modules/lodash/_coreJsData.js
  var require_coreJsData = __commonJS({
    "node_modules/lodash/_coreJsData.js"(exports2, module2) {
      var root = require_root();
      var coreJsData = root["__core-js_shared__"];
      module2.exports = coreJsData;
    }
  });

  // node_modules/lodash/_isMasked.js
  var require_isMasked = __commonJS({
    "node_modules/lodash/_isMasked.js"(exports2, module2) {
      var coreJsData = require_coreJsData();
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      module2.exports = isMasked;
    }
  });

  // node_modules/lodash/_toSource.js
  var require_toSource = __commonJS({
    "node_modules/lodash/_toSource.js"(exports2, module2) {
      var funcProto = Function.prototype;
      var funcToString = funcProto.toString;
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      module2.exports = toSource;
    }
  });

  // node_modules/lodash/_baseIsNative.js
  var require_baseIsNative = __commonJS({
    "node_modules/lodash/_baseIsNative.js"(exports2, module2) {
      var isFunction = require_isFunction();
      var isMasked = require_isMasked();
      var isObject2 = require_isObject();
      var toSource = require_toSource();
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var funcProto = Function.prototype;
      var objectProto = Object.prototype;
      var funcToString = funcProto.toString;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      var reIsNative = RegExp(
        "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      function baseIsNative(value) {
        if (!isObject2(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      module2.exports = baseIsNative;
    }
  });

  // node_modules/lodash/_getValue.js
  var require_getValue = __commonJS({
    "node_modules/lodash/_getValue.js"(exports2, module2) {
      function getValue(object, key) {
        return object == null ? void 0 : object[key];
      }
      module2.exports = getValue;
    }
  });

  // node_modules/lodash/_getNative.js
  var require_getNative = __commonJS({
    "node_modules/lodash/_getNative.js"(exports2, module2) {
      var baseIsNative = require_baseIsNative();
      var getValue = require_getValue();
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : void 0;
      }
      module2.exports = getNative;
    }
  });

  // node_modules/lodash/_DataView.js
  var require_DataView = __commonJS({
    "node_modules/lodash/_DataView.js"(exports2, module2) {
      var getNative = require_getNative();
      var root = require_root();
      var DataView2 = getNative(root, "DataView");
      module2.exports = DataView2;
    }
  });

  // node_modules/lodash/_Map.js
  var require_Map = __commonJS({
    "node_modules/lodash/_Map.js"(exports2, module2) {
      var getNative = require_getNative();
      var root = require_root();
      var Map2 = getNative(root, "Map");
      module2.exports = Map2;
    }
  });

  // node_modules/lodash/_Promise.js
  var require_Promise = __commonJS({
    "node_modules/lodash/_Promise.js"(exports2, module2) {
      var getNative = require_getNative();
      var root = require_root();
      var Promise2 = getNative(root, "Promise");
      module2.exports = Promise2;
    }
  });

  // node_modules/lodash/_Set.js
  var require_Set = __commonJS({
    "node_modules/lodash/_Set.js"(exports2, module2) {
      var getNative = require_getNative();
      var root = require_root();
      var Set2 = getNative(root, "Set");
      module2.exports = Set2;
    }
  });

  // node_modules/lodash/_WeakMap.js
  var require_WeakMap = __commonJS({
    "node_modules/lodash/_WeakMap.js"(exports2, module2) {
      var getNative = require_getNative();
      var root = require_root();
      var WeakMap2 = getNative(root, "WeakMap");
      module2.exports = WeakMap2;
    }
  });

  // node_modules/lodash/_getTag.js
  var require_getTag = __commonJS({
    "node_modules/lodash/_getTag.js"(exports2, module2) {
      var DataView2 = require_DataView();
      var Map2 = require_Map();
      var Promise2 = require_Promise();
      var Set2 = require_Set();
      var WeakMap2 = require_WeakMap();
      var baseGetTag = require_baseGetTag();
      var toSource = require_toSource();
      var mapTag = "[object Map]";
      var objectTag = "[object Object]";
      var promiseTag = "[object Promise]";
      var setTag = "[object Set]";
      var weakMapTag = "[object WeakMap]";
      var dataViewTag = "[object DataView]";
      var dataViewCtorString = toSource(DataView2);
      var mapCtorString = toSource(Map2);
      var promiseCtorString = toSource(Promise2);
      var setCtorString = toSource(Set2);
      var weakMapCtorString = toSource(WeakMap2);
      var getTag = baseGetTag;
      if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
        getTag = function(value) {
          var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result;
        };
      }
      module2.exports = getTag;
    }
  });

  // node_modules/lodash/isObjectLike.js
  var require_isObjectLike = __commonJS({
    "node_modules/lodash/isObjectLike.js"(exports2, module2) {
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      module2.exports = isObjectLike;
    }
  });

  // node_modules/lodash/_baseIsArguments.js
  var require_baseIsArguments = __commonJS({
    "node_modules/lodash/_baseIsArguments.js"(exports2, module2) {
      var baseGetTag = require_baseGetTag();
      var isObjectLike = require_isObjectLike();
      var argsTag = "[object Arguments]";
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      module2.exports = baseIsArguments;
    }
  });

  // node_modules/lodash/isArguments.js
  var require_isArguments = __commonJS({
    "node_modules/lodash/isArguments.js"(exports2, module2) {
      var baseIsArguments = require_baseIsArguments();
      var isObjectLike = require_isObjectLike();
      var objectProto = Object.prototype;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      var propertyIsEnumerable = objectProto.propertyIsEnumerable;
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      module2.exports = isArguments;
    }
  });

  // node_modules/lodash/isArray.js
  var require_isArray = __commonJS({
    "node_modules/lodash/isArray.js"(exports2, module2) {
      var isArray = Array.isArray;
      module2.exports = isArray;
    }
  });

  // node_modules/lodash/isLength.js
  var require_isLength = __commonJS({
    "node_modules/lodash/isLength.js"(exports2, module2) {
      var MAX_SAFE_INTEGER = 9007199254740991;
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      module2.exports = isLength;
    }
  });

  // node_modules/lodash/isArrayLike.js
  var require_isArrayLike = __commonJS({
    "node_modules/lodash/isArrayLike.js"(exports2, module2) {
      var isFunction = require_isFunction();
      var isLength = require_isLength();
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      module2.exports = isArrayLike;
    }
  });

  // node_modules/lodash/stubFalse.js
  var require_stubFalse = __commonJS({
    "node_modules/lodash/stubFalse.js"(exports2, module2) {
      function stubFalse() {
        return false;
      }
      module2.exports = stubFalse;
    }
  });

  // node_modules/lodash/isBuffer.js
  var require_isBuffer = __commonJS({
    "node_modules/lodash/isBuffer.js"(exports2, module2) {
      var root = require_root();
      var stubFalse = require_stubFalse();
      var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer2 = moduleExports ? root.Buffer : void 0;
      var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
      var isBuffer = nativeIsBuffer || stubFalse;
      module2.exports = isBuffer;
    }
  });

  // node_modules/lodash/_baseIsTypedArray.js
  var require_baseIsTypedArray = __commonJS({
    "node_modules/lodash/_baseIsTypedArray.js"(exports2, module2) {
      var baseGetTag = require_baseGetTag();
      var isLength = require_isLength();
      var isObjectLike = require_isObjectLike();
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var funcTag = "[object Function]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var objectTag = "[object Object]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var weakMapTag = "[object WeakMap]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var float32Tag = "[object Float32Array]";
      var float64Tag = "[object Float64Array]";
      var int8Tag = "[object Int8Array]";
      var int16Tag = "[object Int16Array]";
      var int32Tag = "[object Int32Array]";
      var uint8Tag = "[object Uint8Array]";
      var uint8ClampedTag = "[object Uint8ClampedArray]";
      var uint16Tag = "[object Uint16Array]";
      var uint32Tag = "[object Uint32Array]";
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      module2.exports = baseIsTypedArray;
    }
  });

  // node_modules/lodash/_baseUnary.js
  var require_baseUnary = __commonJS({
    "node_modules/lodash/_baseUnary.js"(exports2, module2) {
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      module2.exports = baseUnary;
    }
  });

  // node_modules/lodash/_nodeUtil.js
  var require_nodeUtil = __commonJS({
    "node_modules/lodash/_nodeUtil.js"(exports2, module2) {
      var freeGlobal = require_freeGlobal();
      var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      module2.exports = nodeUtil;
    }
  });

  // node_modules/lodash/isTypedArray.js
  var require_isTypedArray = __commonJS({
    "node_modules/lodash/isTypedArray.js"(exports2, module2) {
      var baseIsTypedArray = require_baseIsTypedArray();
      var baseUnary = require_baseUnary();
      var nodeUtil = require_nodeUtil();
      var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      module2.exports = isTypedArray2;
    }
  });

  // node_modules/lodash/isEmpty.js
  var require_isEmpty = __commonJS({
    "node_modules/lodash/isEmpty.js"(exports2, module2) {
      var baseKeys = require_baseKeys();
      var getTag = require_getTag();
      var isArguments = require_isArguments();
      var isArray = require_isArray();
      var isArrayLike = require_isArrayLike();
      var isBuffer = require_isBuffer();
      var isPrototype = require_isPrototype();
      var isTypedArray2 = require_isTypedArray();
      var mapTag = "[object Map]";
      var setTag = "[object Set]";
      var objectProto = Object.prototype;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      function isEmpty(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray2(value) || isArguments(value))) {
          return !value.length;
        }
        var tag = getTag(value);
        if (tag == mapTag || tag == setTag) {
          return !value.size;
        }
        if (isPrototype(value)) {
          return !baseKeys(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty2.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      module2.exports = isEmpty;
    }
  });

  // node_modules/lodash/_arrayMap.js
  var require_arrayMap = __commonJS({
    "node_modules/lodash/_arrayMap.js"(exports2, module2) {
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      module2.exports = arrayMap;
    }
  });

  // node_modules/lodash/_listCacheClear.js
  var require_listCacheClear = __commonJS({
    "node_modules/lodash/_listCacheClear.js"(exports2, module2) {
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      module2.exports = listCacheClear;
    }
  });

  // node_modules/lodash/eq.js
  var require_eq = __commonJS({
    "node_modules/lodash/eq.js"(exports2, module2) {
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      module2.exports = eq;
    }
  });

  // node_modules/lodash/_assocIndexOf.js
  var require_assocIndexOf = __commonJS({
    "node_modules/lodash/_assocIndexOf.js"(exports2, module2) {
      var eq = require_eq();
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      module2.exports = assocIndexOf;
    }
  });

  // node_modules/lodash/_listCacheDelete.js
  var require_listCacheDelete = __commonJS({
    "node_modules/lodash/_listCacheDelete.js"(exports2, module2) {
      var assocIndexOf = require_assocIndexOf();
      var arrayProto = Array.prototype;
      var splice = arrayProto.splice;
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      module2.exports = listCacheDelete;
    }
  });

  // node_modules/lodash/_listCacheGet.js
  var require_listCacheGet = __commonJS({
    "node_modules/lodash/_listCacheGet.js"(exports2, module2) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? void 0 : data[index][1];
      }
      module2.exports = listCacheGet;
    }
  });

  // node_modules/lodash/_listCacheHas.js
  var require_listCacheHas = __commonJS({
    "node_modules/lodash/_listCacheHas.js"(exports2, module2) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      module2.exports = listCacheHas;
    }
  });

  // node_modules/lodash/_listCacheSet.js
  var require_listCacheSet = __commonJS({
    "node_modules/lodash/_listCacheSet.js"(exports2, module2) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      module2.exports = listCacheSet;
    }
  });

  // node_modules/lodash/_ListCache.js
  var require_ListCache = __commonJS({
    "node_modules/lodash/_ListCache.js"(exports2, module2) {
      var listCacheClear = require_listCacheClear();
      var listCacheDelete = require_listCacheDelete();
      var listCacheGet = require_listCacheGet();
      var listCacheHas = require_listCacheHas();
      var listCacheSet = require_listCacheSet();
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      module2.exports = ListCache;
    }
  });

  // node_modules/lodash/_stackClear.js
  var require_stackClear = __commonJS({
    "node_modules/lodash/_stackClear.js"(exports2, module2) {
      var ListCache = require_ListCache();
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      module2.exports = stackClear;
    }
  });

  // node_modules/lodash/_stackDelete.js
  var require_stackDelete = __commonJS({
    "node_modules/lodash/_stackDelete.js"(exports2, module2) {
      function stackDelete(key) {
        var data = this.__data__, result = data["delete"](key);
        this.size = data.size;
        return result;
      }
      module2.exports = stackDelete;
    }
  });

  // node_modules/lodash/_stackGet.js
  var require_stackGet = __commonJS({
    "node_modules/lodash/_stackGet.js"(exports2, module2) {
      function stackGet(key) {
        return this.__data__.get(key);
      }
      module2.exports = stackGet;
    }
  });

  // node_modules/lodash/_stackHas.js
  var require_stackHas = __commonJS({
    "node_modules/lodash/_stackHas.js"(exports2, module2) {
      function stackHas(key) {
        return this.__data__.has(key);
      }
      module2.exports = stackHas;
    }
  });

  // node_modules/lodash/_nativeCreate.js
  var require_nativeCreate = __commonJS({
    "node_modules/lodash/_nativeCreate.js"(exports2, module2) {
      var getNative = require_getNative();
      var nativeCreate = getNative(Object, "create");
      module2.exports = nativeCreate;
    }
  });

  // node_modules/lodash/_hashClear.js
  var require_hashClear = __commonJS({
    "node_modules/lodash/_hashClear.js"(exports2, module2) {
      var nativeCreate = require_nativeCreate();
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      module2.exports = hashClear;
    }
  });

  // node_modules/lodash/_hashDelete.js
  var require_hashDelete = __commonJS({
    "node_modules/lodash/_hashDelete.js"(exports2, module2) {
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }
      module2.exports = hashDelete;
    }
  });

  // node_modules/lodash/_hashGet.js
  var require_hashGet = __commonJS({
    "node_modules/lodash/_hashGet.js"(exports2, module2) {
      var nativeCreate = require_nativeCreate();
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var objectProto = Object.prototype;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED ? void 0 : result;
        }
        return hasOwnProperty2.call(data, key) ? data[key] : void 0;
      }
      module2.exports = hashGet;
    }
  });

  // node_modules/lodash/_hashHas.js
  var require_hashHas = __commonJS({
    "node_modules/lodash/_hashHas.js"(exports2, module2) {
      var nativeCreate = require_nativeCreate();
      var objectProto = Object.prototype;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
      }
      module2.exports = hashHas;
    }
  });

  // node_modules/lodash/_hashSet.js
  var require_hashSet = __commonJS({
    "node_modules/lodash/_hashSet.js"(exports2, module2) {
      var nativeCreate = require_nativeCreate();
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
        return this;
      }
      module2.exports = hashSet;
    }
  });

  // node_modules/lodash/_Hash.js
  var require_Hash = __commonJS({
    "node_modules/lodash/_Hash.js"(exports2, module2) {
      var hashClear = require_hashClear();
      var hashDelete = require_hashDelete();
      var hashGet = require_hashGet();
      var hashHas = require_hashHas();
      var hashSet = require_hashSet();
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      module2.exports = Hash;
    }
  });

  // node_modules/lodash/_mapCacheClear.js
  var require_mapCacheClear = __commonJS({
    "node_modules/lodash/_mapCacheClear.js"(exports2, module2) {
      var Hash = require_Hash();
      var ListCache = require_ListCache();
      var Map2 = require_Map();
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      module2.exports = mapCacheClear;
    }
  });

  // node_modules/lodash/_isKeyable.js
  var require_isKeyable = __commonJS({
    "node_modules/lodash/_isKeyable.js"(exports2, module2) {
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      module2.exports = isKeyable;
    }
  });

  // node_modules/lodash/_getMapData.js
  var require_getMapData = __commonJS({
    "node_modules/lodash/_getMapData.js"(exports2, module2) {
      var isKeyable = require_isKeyable();
      function getMapData(map, key) {
        var data = map.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      module2.exports = getMapData;
    }
  });

  // node_modules/lodash/_mapCacheDelete.js
  var require_mapCacheDelete = __commonJS({
    "node_modules/lodash/_mapCacheDelete.js"(exports2, module2) {
      var getMapData = require_getMapData();
      function mapCacheDelete(key) {
        var result = getMapData(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
      }
      module2.exports = mapCacheDelete;
    }
  });

  // node_modules/lodash/_mapCacheGet.js
  var require_mapCacheGet = __commonJS({
    "node_modules/lodash/_mapCacheGet.js"(exports2, module2) {
      var getMapData = require_getMapData();
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      module2.exports = mapCacheGet;
    }
  });

  // node_modules/lodash/_mapCacheHas.js
  var require_mapCacheHas = __commonJS({
    "node_modules/lodash/_mapCacheHas.js"(exports2, module2) {
      var getMapData = require_getMapData();
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      module2.exports = mapCacheHas;
    }
  });

  // node_modules/lodash/_mapCacheSet.js
  var require_mapCacheSet = __commonJS({
    "node_modules/lodash/_mapCacheSet.js"(exports2, module2) {
      var getMapData = require_getMapData();
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size = data.size;
        data.set(key, value);
        this.size += data.size == size ? 0 : 1;
        return this;
      }
      module2.exports = mapCacheSet;
    }
  });

  // node_modules/lodash/_MapCache.js
  var require_MapCache = __commonJS({
    "node_modules/lodash/_MapCache.js"(exports2, module2) {
      var mapCacheClear = require_mapCacheClear();
      var mapCacheDelete = require_mapCacheDelete();
      var mapCacheGet = require_mapCacheGet();
      var mapCacheHas = require_mapCacheHas();
      var mapCacheSet = require_mapCacheSet();
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      module2.exports = MapCache;
    }
  });

  // node_modules/lodash/_stackSet.js
  var require_stackSet = __commonJS({
    "node_modules/lodash/_stackSet.js"(exports2, module2) {
      var ListCache = require_ListCache();
      var Map2 = require_Map();
      var MapCache = require_MapCache();
      var LARGE_ARRAY_SIZE = 200;
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      module2.exports = stackSet;
    }
  });

  // node_modules/lodash/_Stack.js
  var require_Stack = __commonJS({
    "node_modules/lodash/_Stack.js"(exports2, module2) {
      var ListCache = require_ListCache();
      var stackClear = require_stackClear();
      var stackDelete = require_stackDelete();
      var stackGet = require_stackGet();
      var stackHas = require_stackHas();
      var stackSet = require_stackSet();
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      module2.exports = Stack;
    }
  });

  // node_modules/lodash/_setCacheAdd.js
  var require_setCacheAdd = __commonJS({
    "node_modules/lodash/_setCacheAdd.js"(exports2, module2) {
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      module2.exports = setCacheAdd;
    }
  });

  // node_modules/lodash/_setCacheHas.js
  var require_setCacheHas = __commonJS({
    "node_modules/lodash/_setCacheHas.js"(exports2, module2) {
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      module2.exports = setCacheHas;
    }
  });

  // node_modules/lodash/_SetCache.js
  var require_SetCache = __commonJS({
    "node_modules/lodash/_SetCache.js"(exports2, module2) {
      var MapCache = require_MapCache();
      var setCacheAdd = require_setCacheAdd();
      var setCacheHas = require_setCacheHas();
      function SetCache(values) {
        var index = -1, length = values == null ? 0 : values.length;
        this.__data__ = new MapCache();
        while (++index < length) {
          this.add(values[index]);
        }
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      module2.exports = SetCache;
    }
  });

  // node_modules/lodash/_arraySome.js
  var require_arraySome = __commonJS({
    "node_modules/lodash/_arraySome.js"(exports2, module2) {
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      module2.exports = arraySome;
    }
  });

  // node_modules/lodash/_cacheHas.js
  var require_cacheHas = __commonJS({
    "node_modules/lodash/_cacheHas.js"(exports2, module2) {
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      module2.exports = cacheHas;
    }
  });

  // node_modules/lodash/_equalArrays.js
  var require_equalArrays = __commonJS({
    "node_modules/lodash/_equalArrays.js"(exports2, module2) {
      var SetCache = require_SetCache();
      var arraySome = require_arraySome();
      var cacheHas = require_cacheHas();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
        stack.set(array, other);
        stack.set(other, array);
        while (++index < arrLength) {
          var arrValue = array[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
          }
          if (compared !== void 0) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result;
      }
      module2.exports = equalArrays;
    }
  });

  // node_modules/lodash/_Uint8Array.js
  var require_Uint8Array = __commonJS({
    "node_modules/lodash/_Uint8Array.js"(exports2, module2) {
      var root = require_root();
      var Uint8Array2 = root.Uint8Array;
      module2.exports = Uint8Array2;
    }
  });

  // node_modules/lodash/_mapToArray.js
  var require_mapToArray = __commonJS({
    "node_modules/lodash/_mapToArray.js"(exports2, module2) {
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      module2.exports = mapToArray;
    }
  });

  // node_modules/lodash/_setToArray.js
  var require_setToArray = __commonJS({
    "node_modules/lodash/_setToArray.js"(exports2, module2) {
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      module2.exports = setToArray;
    }
  });

  // node_modules/lodash/_equalByTag.js
  var require_equalByTag = __commonJS({
    "node_modules/lodash/_equalByTag.js"(exports2, module2) {
      var Symbol2 = require_Symbol();
      var Uint8Array2 = require_Uint8Array();
      var eq = require_eq();
      var equalArrays = require_equalArrays();
      var mapToArray = require_mapToArray();
      var setToArray = require_setToArray();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var symbolTag = "[object Symbol]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
      var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object, other);
            var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      module2.exports = equalByTag;
    }
  });

  // node_modules/lodash/_arrayPush.js
  var require_arrayPush = __commonJS({
    "node_modules/lodash/_arrayPush.js"(exports2, module2) {
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      module2.exports = arrayPush;
    }
  });

  // node_modules/lodash/_baseGetAllKeys.js
  var require_baseGetAllKeys = __commonJS({
    "node_modules/lodash/_baseGetAllKeys.js"(exports2, module2) {
      var arrayPush = require_arrayPush();
      var isArray = require_isArray();
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result = keysFunc(object);
        return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
      }
      module2.exports = baseGetAllKeys;
    }
  });

  // node_modules/lodash/_arrayFilter.js
  var require_arrayFilter = __commonJS({
    "node_modules/lodash/_arrayFilter.js"(exports2, module2) {
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      module2.exports = arrayFilter;
    }
  });

  // node_modules/lodash/stubArray.js
  var require_stubArray = __commonJS({
    "node_modules/lodash/stubArray.js"(exports2, module2) {
      function stubArray() {
        return [];
      }
      module2.exports = stubArray;
    }
  });

  // node_modules/lodash/_getSymbols.js
  var require_getSymbols = __commonJS({
    "node_modules/lodash/_getSymbols.js"(exports2, module2) {
      var arrayFilter = require_arrayFilter();
      var stubArray = require_stubArray();
      var objectProto = Object.prototype;
      var propertyIsEnumerable = objectProto.propertyIsEnumerable;
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      module2.exports = getSymbols;
    }
  });

  // node_modules/lodash/_baseTimes.js
  var require_baseTimes = __commonJS({
    "node_modules/lodash/_baseTimes.js"(exports2, module2) {
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      module2.exports = baseTimes;
    }
  });

  // node_modules/lodash/_isIndex.js
  var require_isIndex = __commonJS({
    "node_modules/lodash/_isIndex.js"(exports2, module2) {
      var MAX_SAFE_INTEGER = 9007199254740991;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      module2.exports = isIndex;
    }
  });

  // node_modules/lodash/_arrayLikeKeys.js
  var require_arrayLikeKeys = __commonJS({
    "node_modules/lodash/_arrayLikeKeys.js"(exports2, module2) {
      var baseTimes = require_baseTimes();
      var isArguments = require_isArguments();
      var isArray = require_isArray();
      var isBuffer = require_isBuffer();
      var isIndex = require_isIndex();
      var isTypedArray2 = require_isTypedArray();
      var objectProto = Object.prototype;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      module2.exports = arrayLikeKeys;
    }
  });

  // node_modules/lodash/keys.js
  var require_keys = __commonJS({
    "node_modules/lodash/keys.js"(exports2, module2) {
      var arrayLikeKeys = require_arrayLikeKeys();
      var baseKeys = require_baseKeys();
      var isArrayLike = require_isArrayLike();
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      module2.exports = keys;
    }
  });

  // node_modules/lodash/_getAllKeys.js
  var require_getAllKeys = __commonJS({
    "node_modules/lodash/_getAllKeys.js"(exports2, module2) {
      var baseGetAllKeys = require_baseGetAllKeys();
      var getSymbols = require_getSymbols();
      var keys = require_keys();
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }
      module2.exports = getAllKeys;
    }
  });

  // node_modules/lodash/_equalObjects.js
  var require_equalObjects = __commonJS({
    "node_modules/lodash/_equalObjects.js"(exports2, module2) {
      var getAllKeys = require_getAllKeys();
      var COMPARE_PARTIAL_FLAG = 1;
      var objectProto = Object.prototype;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result;
      }
      module2.exports = equalObjects;
    }
  });

  // node_modules/lodash/_baseIsEqualDeep.js
  var require_baseIsEqualDeep = __commonJS({
    "node_modules/lodash/_baseIsEqualDeep.js"(exports2, module2) {
      var Stack = require_Stack();
      var equalArrays = require_equalArrays();
      var equalByTag = require_equalByTag();
      var equalObjects = require_equalObjects();
      var getTag = require_getTag();
      var isArray = require_isArray();
      var isBuffer = require_isBuffer();
      var isTypedArray2 = require_isTypedArray();
      var COMPARE_PARTIAL_FLAG = 1;
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var objectTag = "[object Object]";
      var objectProto = Object.prototype;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray2(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }
      module2.exports = baseIsEqualDeep;
    }
  });

  // node_modules/lodash/_baseIsEqual.js
  var require_baseIsEqual = __commonJS({
    "node_modules/lodash/_baseIsEqual.js"(exports2, module2) {
      var baseIsEqualDeep = require_baseIsEqualDeep();
      var isObjectLike = require_isObjectLike();
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      module2.exports = baseIsEqual;
    }
  });

  // node_modules/lodash/_baseIsMatch.js
  var require_baseIsMatch = __commonJS({
    "node_modules/lodash/_baseIsMatch.js"(exports2, module2) {
      var Stack = require_Stack();
      var baseIsEqual = require_baseIsEqual();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object(object);
        while (index--) {
          var data = matchData[index];
          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }
        while (++index < length) {
          data = matchData[index];
          var key = data[0], objValue = object[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === void 0 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack();
            if (customizer) {
              var result = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
              return false;
            }
          }
        }
        return true;
      }
      module2.exports = baseIsMatch;
    }
  });

  // node_modules/lodash/_isStrictComparable.js
  var require_isStrictComparable = __commonJS({
    "node_modules/lodash/_isStrictComparable.js"(exports2, module2) {
      var isObject2 = require_isObject();
      function isStrictComparable(value) {
        return value === value && !isObject2(value);
      }
      module2.exports = isStrictComparable;
    }
  });

  // node_modules/lodash/_getMatchData.js
  var require_getMatchData = __commonJS({
    "node_modules/lodash/_getMatchData.js"(exports2, module2) {
      var isStrictComparable = require_isStrictComparable();
      var keys = require_keys();
      function getMatchData(object) {
        var result = keys(object), length = result.length;
        while (length--) {
          var key = result[length], value = object[key];
          result[length] = [key, value, isStrictComparable(value)];
        }
        return result;
      }
      module2.exports = getMatchData;
    }
  });

  // node_modules/lodash/_matchesStrictComparable.js
  var require_matchesStrictComparable = __commonJS({
    "node_modules/lodash/_matchesStrictComparable.js"(exports2, module2) {
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
        };
      }
      module2.exports = matchesStrictComparable;
    }
  });

  // node_modules/lodash/_baseMatches.js
  var require_baseMatches = __commonJS({
    "node_modules/lodash/_baseMatches.js"(exports2, module2) {
      var baseIsMatch = require_baseIsMatch();
      var getMatchData = require_getMatchData();
      var matchesStrictComparable = require_matchesStrictComparable();
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      module2.exports = baseMatches;
    }
  });

  // node_modules/lodash/isSymbol.js
  var require_isSymbol = __commonJS({
    "node_modules/lodash/isSymbol.js"(exports2, module2) {
      var baseGetTag = require_baseGetTag();
      var isObjectLike = require_isObjectLike();
      var symbolTag = "[object Symbol]";
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      module2.exports = isSymbol;
    }
  });

  // node_modules/lodash/_isKey.js
  var require_isKey = __commonJS({
    "node_modules/lodash/_isKey.js"(exports2, module2) {
      var isArray = require_isArray();
      var isSymbol = require_isSymbol();
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
      var reIsPlainProp = /^\w*$/;
      function isKey(value, object) {
        if (isArray(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
      }
      module2.exports = isKey;
    }
  });

  // node_modules/lodash/memoize.js
  var require_memoize = __commonJS({
    "node_modules/lodash/memoize.js"(exports2, module2) {
      var MapCache = require_MapCache();
      var FUNC_ERROR_TEXT = "Expected a function";
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache.set(key, result) || cache;
          return result;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      module2.exports = memoize;
    }
  });

  // node_modules/lodash/_memoizeCapped.js
  var require_memoizeCapped = __commonJS({
    "node_modules/lodash/_memoizeCapped.js"(exports2, module2) {
      var memoize = require_memoize();
      var MAX_MEMOIZE_SIZE = 500;
      function memoizeCapped(func) {
        var result = memoize(func, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });
        var cache = result.cache;
        return result;
      }
      module2.exports = memoizeCapped;
    }
  });

  // node_modules/lodash/_stringToPath.js
  var require_stringToPath = __commonJS({
    "node_modules/lodash/_stringToPath.js"(exports2, module2) {
      var memoizeCapped = require_memoizeCapped();
      var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = memoizeCapped(function(string) {
        var result = [];
        if (string.charCodeAt(0) === 46) {
          result.push("");
        }
        string.replace(rePropName, function(match, number, quote, subString) {
          result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
        });
        return result;
      });
      module2.exports = stringToPath;
    }
  });

  // node_modules/lodash/_baseToString.js
  var require_baseToString = __commonJS({
    "node_modules/lodash/_baseToString.js"(exports2, module2) {
      var Symbol2 = require_Symbol();
      var arrayMap = require_arrayMap();
      var isArray = require_isArray();
      var isSymbol = require_isSymbol();
      var INFINITY = 1 / 0;
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
      var symbolToString = symbolProto ? symbolProto.toString : void 0;
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      module2.exports = baseToString;
    }
  });

  // node_modules/lodash/toString.js
  var require_toString = __commonJS({
    "node_modules/lodash/toString.js"(exports2, module2) {
      var baseToString = require_baseToString();
      function toString(value) {
        return value == null ? "" : baseToString(value);
      }
      module2.exports = toString;
    }
  });

  // node_modules/lodash/_castPath.js
  var require_castPath = __commonJS({
    "node_modules/lodash/_castPath.js"(exports2, module2) {
      var isArray = require_isArray();
      var isKey = require_isKey();
      var stringToPath = require_stringToPath();
      var toString = require_toString();
      function castPath(value, object) {
        if (isArray(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath(toString(value));
      }
      module2.exports = castPath;
    }
  });

  // node_modules/lodash/_toKey.js
  var require_toKey = __commonJS({
    "node_modules/lodash/_toKey.js"(exports2, module2) {
      var isSymbol = require_isSymbol();
      var INFINITY = 1 / 0;
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      module2.exports = toKey;
    }
  });

  // node_modules/lodash/_baseGet.js
  var require_baseGet = __commonJS({
    "node_modules/lodash/_baseGet.js"(exports2, module2) {
      var castPath = require_castPath();
      var toKey = require_toKey();
      function baseGet(object, path) {
        path = castPath(path, object);
        var index = 0, length = path.length;
        while (object != null && index < length) {
          object = object[toKey(path[index++])];
        }
        return index && index == length ? object : void 0;
      }
      module2.exports = baseGet;
    }
  });

  // node_modules/lodash/get.js
  var require_get = __commonJS({
    "node_modules/lodash/get.js"(exports2, module2) {
      var baseGet = require_baseGet();
      function get(object, path, defaultValue) {
        var result = object == null ? void 0 : baseGet(object, path);
        return result === void 0 ? defaultValue : result;
      }
      module2.exports = get;
    }
  });

  // node_modules/lodash/_baseHasIn.js
  var require_baseHasIn = __commonJS({
    "node_modules/lodash/_baseHasIn.js"(exports2, module2) {
      function baseHasIn(object, key) {
        return object != null && key in Object(object);
      }
      module2.exports = baseHasIn;
    }
  });

  // node_modules/lodash/_hasPath.js
  var require_hasPath = __commonJS({
    "node_modules/lodash/_hasPath.js"(exports2, module2) {
      var castPath = require_castPath();
      var isArguments = require_isArguments();
      var isArray = require_isArray();
      var isIndex = require_isIndex();
      var isLength = require_isLength();
      var toKey = require_toKey();
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index = -1, length = path.length, result = false;
        while (++index < length) {
          var key = toKey(path[index]);
          if (!(result = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result || ++index != length) {
          return result;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
      }
      module2.exports = hasPath;
    }
  });

  // node_modules/lodash/hasIn.js
  var require_hasIn = __commonJS({
    "node_modules/lodash/hasIn.js"(exports2, module2) {
      var baseHasIn = require_baseHasIn();
      var hasPath = require_hasPath();
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      module2.exports = hasIn;
    }
  });

  // node_modules/lodash/_baseMatchesProperty.js
  var require_baseMatchesProperty = __commonJS({
    "node_modules/lodash/_baseMatchesProperty.js"(exports2, module2) {
      var baseIsEqual = require_baseIsEqual();
      var get = require_get();
      var hasIn = require_hasIn();
      var isKey = require_isKey();
      var isStrictComparable = require_isStrictComparable();
      var matchesStrictComparable = require_matchesStrictComparable();
      var toKey = require_toKey();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get(object, path);
          return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      module2.exports = baseMatchesProperty;
    }
  });

  // node_modules/lodash/identity.js
  var require_identity = __commonJS({
    "node_modules/lodash/identity.js"(exports2, module2) {
      function identity(value) {
        return value;
      }
      module2.exports = identity;
    }
  });

  // node_modules/lodash/_baseProperty.js
  var require_baseProperty = __commonJS({
    "node_modules/lodash/_baseProperty.js"(exports2, module2) {
      function baseProperty(key) {
        return function(object) {
          return object == null ? void 0 : object[key];
        };
      }
      module2.exports = baseProperty;
    }
  });

  // node_modules/lodash/_basePropertyDeep.js
  var require_basePropertyDeep = __commonJS({
    "node_modules/lodash/_basePropertyDeep.js"(exports2, module2) {
      var baseGet = require_baseGet();
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      module2.exports = basePropertyDeep;
    }
  });

  // node_modules/lodash/property.js
  var require_property = __commonJS({
    "node_modules/lodash/property.js"(exports2, module2) {
      var baseProperty = require_baseProperty();
      var basePropertyDeep = require_basePropertyDeep();
      var isKey = require_isKey();
      var toKey = require_toKey();
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      module2.exports = property;
    }
  });

  // node_modules/lodash/_baseIteratee.js
  var require_baseIteratee = __commonJS({
    "node_modules/lodash/_baseIteratee.js"(exports2, module2) {
      var baseMatches = require_baseMatches();
      var baseMatchesProperty = require_baseMatchesProperty();
      var identity = require_identity();
      var isArray = require_isArray();
      var property = require_property();
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      module2.exports = baseIteratee;
    }
  });

  // node_modules/lodash/_createBaseFor.js
  var require_createBaseFor = __commonJS({
    "node_modules/lodash/_createBaseFor.js"(exports2, module2) {
      function createBaseFor(fromRight) {
        return function(object, iteratee, keysFunc) {
          var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      module2.exports = createBaseFor;
    }
  });

  // node_modules/lodash/_baseFor.js
  var require_baseFor = __commonJS({
    "node_modules/lodash/_baseFor.js"(exports2, module2) {
      var createBaseFor = require_createBaseFor();
      var baseFor = createBaseFor();
      module2.exports = baseFor;
    }
  });

  // node_modules/lodash/_baseForOwn.js
  var require_baseForOwn = __commonJS({
    "node_modules/lodash/_baseForOwn.js"(exports2, module2) {
      var baseFor = require_baseFor();
      var keys = require_keys();
      function baseForOwn(object, iteratee) {
        return object && baseFor(object, iteratee, keys);
      }
      module2.exports = baseForOwn;
    }
  });

  // node_modules/lodash/_createBaseEach.js
  var require_createBaseEach = __commonJS({
    "node_modules/lodash/_createBaseEach.js"(exports2, module2) {
      var isArrayLike = require_isArrayLike();
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee);
          }
          var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
          while (fromRight ? index-- : ++index < length) {
            if (iteratee(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      module2.exports = createBaseEach;
    }
  });

  // node_modules/lodash/_baseEach.js
  var require_baseEach = __commonJS({
    "node_modules/lodash/_baseEach.js"(exports2, module2) {
      var baseForOwn = require_baseForOwn();
      var createBaseEach = require_createBaseEach();
      var baseEach = createBaseEach(baseForOwn);
      module2.exports = baseEach;
    }
  });

  // node_modules/lodash/_baseMap.js
  var require_baseMap = __commonJS({
    "node_modules/lodash/_baseMap.js"(exports2, module2) {
      var baseEach = require_baseEach();
      var isArrayLike = require_isArrayLike();
      function baseMap(collection, iteratee) {
        var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result[++index] = iteratee(value, key, collection2);
        });
        return result;
      }
      module2.exports = baseMap;
    }
  });

  // node_modules/lodash/map.js
  var require_map = __commonJS({
    "node_modules/lodash/map.js"(exports2, module2) {
      var arrayMap = require_arrayMap();
      var baseIteratee = require_baseIteratee();
      var baseMap = require_baseMap();
      var isArray = require_isArray();
      function map(collection, iteratee) {
        var func = isArray(collection) ? arrayMap : baseMap;
        return func(collection, baseIteratee(iteratee, 3));
      }
      module2.exports = map;
    }
  });

  // node_modules/lodash/_arrayEach.js
  var require_arrayEach = __commonJS({
    "node_modules/lodash/_arrayEach.js"(exports2, module2) {
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      module2.exports = arrayEach;
    }
  });

  // node_modules/lodash/_castFunction.js
  var require_castFunction = __commonJS({
    "node_modules/lodash/_castFunction.js"(exports2, module2) {
      var identity = require_identity();
      function castFunction(value) {
        return typeof value == "function" ? value : identity;
      }
      module2.exports = castFunction;
    }
  });

  // node_modules/lodash/forEach.js
  var require_forEach = __commonJS({
    "node_modules/lodash/forEach.js"(exports2, module2) {
      var arrayEach = require_arrayEach();
      var baseEach = require_baseEach();
      var castFunction = require_castFunction();
      var isArray = require_isArray();
      function forEach(collection, iteratee) {
        var func = isArray(collection) ? arrayEach : baseEach;
        return func(collection, castFunction(iteratee));
      }
      module2.exports = forEach;
    }
  });

  // node_modules/lodash/_baseValues.js
  var require_baseValues = __commonJS({
    "node_modules/lodash/_baseValues.js"(exports2, module2) {
      var arrayMap = require_arrayMap();
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      module2.exports = baseValues;
    }
  });

  // node_modules/lodash/values.js
  var require_values = __commonJS({
    "node_modules/lodash/values.js"(exports2, module2) {
      var baseValues = require_baseValues();
      var keys = require_keys();
      function values(object) {
        return object == null ? [] : baseValues(object, keys(object));
      }
      module2.exports = values;
    }
  });

  // node_modules/lodash/_baseHas.js
  var require_baseHas = __commonJS({
    "node_modules/lodash/_baseHas.js"(exports2, module2) {
      var objectProto = Object.prototype;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      function baseHas(object, key) {
        return object != null && hasOwnProperty2.call(object, key);
      }
      module2.exports = baseHas;
    }
  });

  // node_modules/lodash/has.js
  var require_has = __commonJS({
    "node_modules/lodash/has.js"(exports2, module2) {
      var baseHas = require_baseHas();
      var hasPath = require_hasPath();
      function has(object, path) {
        return object != null && hasPath(object, path, baseHas);
      }
      module2.exports = has;
    }
  });

  // node_modules/lodash/_defineProperty.js
  var require_defineProperty = __commonJS({
    "node_modules/lodash/_defineProperty.js"(exports2, module2) {
      var getNative = require_getNative();
      var defineProperty = function() {
        try {
          var func = getNative(Object, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      module2.exports = defineProperty;
    }
  });

  // node_modules/lodash/_baseAssignValue.js
  var require_baseAssignValue = __commonJS({
    "node_modules/lodash/_baseAssignValue.js"(exports2, module2) {
      var defineProperty = require_defineProperty();
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object[key] = value;
        }
      }
      module2.exports = baseAssignValue;
    }
  });

  // node_modules/lodash/_assignValue.js
  var require_assignValue = __commonJS({
    "node_modules/lodash/_assignValue.js"(exports2, module2) {
      var baseAssignValue = require_baseAssignValue();
      var eq = require_eq();
      var objectProto = Object.prototype;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      module2.exports = assignValue;
    }
  });

  // node_modules/lodash/_copyObject.js
  var require_copyObject = __commonJS({
    "node_modules/lodash/_copyObject.js"(exports2, module2) {
      var assignValue = require_assignValue();
      var baseAssignValue = require_baseAssignValue();
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
          if (newValue === void 0) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      module2.exports = copyObject;
    }
  });

  // node_modules/lodash/_baseAssign.js
  var require_baseAssign = __commonJS({
    "node_modules/lodash/_baseAssign.js"(exports2, module2) {
      var copyObject = require_copyObject();
      var keys = require_keys();
      function baseAssign(object, source) {
        return object && copyObject(source, keys(source), object);
      }
      module2.exports = baseAssign;
    }
  });

  // node_modules/lodash/_nativeKeysIn.js
  var require_nativeKeysIn = __commonJS({
    "node_modules/lodash/_nativeKeysIn.js"(exports2, module2) {
      function nativeKeysIn(object) {
        var result = [];
        if (object != null) {
          for (var key in Object(object)) {
            result.push(key);
          }
        }
        return result;
      }
      module2.exports = nativeKeysIn;
    }
  });

  // node_modules/lodash/_baseKeysIn.js
  var require_baseKeysIn = __commonJS({
    "node_modules/lodash/_baseKeysIn.js"(exports2, module2) {
      var isObject2 = require_isObject();
      var isPrototype = require_isPrototype();
      var nativeKeysIn = require_nativeKeysIn();
      var objectProto = Object.prototype;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      function baseKeysIn(object) {
        if (!isObject2(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
            result.push(key);
          }
        }
        return result;
      }
      module2.exports = baseKeysIn;
    }
  });

  // node_modules/lodash/keysIn.js
  var require_keysIn = __commonJS({
    "node_modules/lodash/keysIn.js"(exports2, module2) {
      var arrayLikeKeys = require_arrayLikeKeys();
      var baseKeysIn = require_baseKeysIn();
      var isArrayLike = require_isArrayLike();
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      module2.exports = keysIn;
    }
  });

  // node_modules/lodash/_baseAssignIn.js
  var require_baseAssignIn = __commonJS({
    "node_modules/lodash/_baseAssignIn.js"(exports2, module2) {
      var copyObject = require_copyObject();
      var keysIn = require_keysIn();
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      module2.exports = baseAssignIn;
    }
  });

  // node_modules/lodash/_cloneBuffer.js
  var require_cloneBuffer = __commonJS({
    "node_modules/lodash/_cloneBuffer.js"(exports2, module2) {
      var root = require_root();
      var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer2 = moduleExports ? root.Buffer : void 0;
      var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result);
        return result;
      }
      module2.exports = cloneBuffer;
    }
  });

  // node_modules/lodash/_copyArray.js
  var require_copyArray = __commonJS({
    "node_modules/lodash/_copyArray.js"(exports2, module2) {
      function copyArray(source, array) {
        var index = -1, length = source.length;
        array || (array = Array(length));
        while (++index < length) {
          array[index] = source[index];
        }
        return array;
      }
      module2.exports = copyArray;
    }
  });

  // node_modules/lodash/_copySymbols.js
  var require_copySymbols = __commonJS({
    "node_modules/lodash/_copySymbols.js"(exports2, module2) {
      var copyObject = require_copyObject();
      var getSymbols = require_getSymbols();
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      module2.exports = copySymbols;
    }
  });

  // node_modules/lodash/_getPrototype.js
  var require_getPrototype = __commonJS({
    "node_modules/lodash/_getPrototype.js"(exports2, module2) {
      var overArg = require_overArg();
      var getPrototype = overArg(Object.getPrototypeOf, Object);
      module2.exports = getPrototype;
    }
  });

  // node_modules/lodash/_getSymbolsIn.js
  var require_getSymbolsIn = __commonJS({
    "node_modules/lodash/_getSymbolsIn.js"(exports2, module2) {
      var arrayPush = require_arrayPush();
      var getPrototype = require_getPrototype();
      var getSymbols = require_getSymbols();
      var stubArray = require_stubArray();
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result = [];
        while (object) {
          arrayPush(result, getSymbols(object));
          object = getPrototype(object);
        }
        return result;
      };
      module2.exports = getSymbolsIn;
    }
  });

  // node_modules/lodash/_copySymbolsIn.js
  var require_copySymbolsIn = __commonJS({
    "node_modules/lodash/_copySymbolsIn.js"(exports2, module2) {
      var copyObject = require_copyObject();
      var getSymbolsIn = require_getSymbolsIn();
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      module2.exports = copySymbolsIn;
    }
  });

  // node_modules/lodash/_getAllKeysIn.js
  var require_getAllKeysIn = __commonJS({
    "node_modules/lodash/_getAllKeysIn.js"(exports2, module2) {
      var baseGetAllKeys = require_baseGetAllKeys();
      var getSymbolsIn = require_getSymbolsIn();
      var keysIn = require_keysIn();
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      module2.exports = getAllKeysIn;
    }
  });

  // node_modules/lodash/_initCloneArray.js
  var require_initCloneArray = __commonJS({
    "node_modules/lodash/_initCloneArray.js"(exports2, module2) {
      var objectProto = Object.prototype;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      function initCloneArray(array) {
        var length = array.length, result = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
          result.index = array.index;
          result.input = array.input;
        }
        return result;
      }
      module2.exports = initCloneArray;
    }
  });

  // node_modules/lodash/_cloneArrayBuffer.js
  var require_cloneArrayBuffer = __commonJS({
    "node_modules/lodash/_cloneArrayBuffer.js"(exports2, module2) {
      var Uint8Array2 = require_Uint8Array();
      function cloneArrayBuffer(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
        return result;
      }
      module2.exports = cloneArrayBuffer;
    }
  });

  // node_modules/lodash/_cloneDataView.js
  var require_cloneDataView = __commonJS({
    "node_modules/lodash/_cloneDataView.js"(exports2, module2) {
      var cloneArrayBuffer = require_cloneArrayBuffer();
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      module2.exports = cloneDataView;
    }
  });

  // node_modules/lodash/_cloneRegExp.js
  var require_cloneRegExp = __commonJS({
    "node_modules/lodash/_cloneRegExp.js"(exports2, module2) {
      var reFlags = /\w*$/;
      function cloneRegExp(regexp) {
        var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result.lastIndex = regexp.lastIndex;
        return result;
      }
      module2.exports = cloneRegExp;
    }
  });

  // node_modules/lodash/_cloneSymbol.js
  var require_cloneSymbol = __commonJS({
    "node_modules/lodash/_cloneSymbol.js"(exports2, module2) {
      var Symbol2 = require_Symbol();
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
      var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
      }
      module2.exports = cloneSymbol;
    }
  });

  // node_modules/lodash/_cloneTypedArray.js
  var require_cloneTypedArray = __commonJS({
    "node_modules/lodash/_cloneTypedArray.js"(exports2, module2) {
      var cloneArrayBuffer = require_cloneArrayBuffer();
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      module2.exports = cloneTypedArray;
    }
  });

  // node_modules/lodash/_initCloneByTag.js
  var require_initCloneByTag = __commonJS({
    "node_modules/lodash/_initCloneByTag.js"(exports2, module2) {
      var cloneArrayBuffer = require_cloneArrayBuffer();
      var cloneDataView = require_cloneDataView();
      var cloneRegExp = require_cloneRegExp();
      var cloneSymbol = require_cloneSymbol();
      var cloneTypedArray = require_cloneTypedArray();
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var symbolTag = "[object Symbol]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var float32Tag = "[object Float32Array]";
      var float64Tag = "[object Float64Array]";
      var int8Tag = "[object Int8Array]";
      var int16Tag = "[object Int16Array]";
      var int32Tag = "[object Int32Array]";
      var uint8Tag = "[object Uint8Array]";
      var uint8ClampedTag = "[object Uint8ClampedArray]";
      var uint16Tag = "[object Uint16Array]";
      var uint32Tag = "[object Uint32Array]";
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor();
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return new Ctor();
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      module2.exports = initCloneByTag;
    }
  });

  // node_modules/lodash/_baseCreate.js
  var require_baseCreate = __commonJS({
    "node_modules/lodash/_baseCreate.js"(exports2, module2) {
      var isObject2 = require_isObject();
      var objectCreate = Object.create;
      var baseCreate = function() {
        function object() {
        }
        return function(proto) {
          if (!isObject2(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result = new object();
          object.prototype = void 0;
          return result;
        };
      }();
      module2.exports = baseCreate;
    }
  });

  // node_modules/lodash/_initCloneObject.js
  var require_initCloneObject = __commonJS({
    "node_modules/lodash/_initCloneObject.js"(exports2, module2) {
      var baseCreate = require_baseCreate();
      var getPrototype = require_getPrototype();
      var isPrototype = require_isPrototype();
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      module2.exports = initCloneObject;
    }
  });

  // node_modules/lodash/_baseIsMap.js
  var require_baseIsMap = __commonJS({
    "node_modules/lodash/_baseIsMap.js"(exports2, module2) {
      var getTag = require_getTag();
      var isObjectLike = require_isObjectLike();
      var mapTag = "[object Map]";
      function baseIsMap(value) {
        return isObjectLike(value) && getTag(value) == mapTag;
      }
      module2.exports = baseIsMap;
    }
  });

  // node_modules/lodash/isMap.js
  var require_isMap = __commonJS({
    "node_modules/lodash/isMap.js"(exports2, module2) {
      var baseIsMap = require_baseIsMap();
      var baseUnary = require_baseUnary();
      var nodeUtil = require_nodeUtil();
      var nodeIsMap = nodeUtil && nodeUtil.isMap;
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      module2.exports = isMap;
    }
  });

  // node_modules/lodash/_baseIsSet.js
  var require_baseIsSet = __commonJS({
    "node_modules/lodash/_baseIsSet.js"(exports2, module2) {
      var getTag = require_getTag();
      var isObjectLike = require_isObjectLike();
      var setTag = "[object Set]";
      function baseIsSet(value) {
        return isObjectLike(value) && getTag(value) == setTag;
      }
      module2.exports = baseIsSet;
    }
  });

  // node_modules/lodash/isSet.js
  var require_isSet = __commonJS({
    "node_modules/lodash/isSet.js"(exports2, module2) {
      var baseIsSet = require_baseIsSet();
      var baseUnary = require_baseUnary();
      var nodeUtil = require_nodeUtil();
      var nodeIsSet = nodeUtil && nodeUtil.isSet;
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      module2.exports = isSet;
    }
  });

  // node_modules/lodash/_baseClone.js
  var require_baseClone = __commonJS({
    "node_modules/lodash/_baseClone.js"(exports2, module2) {
      var Stack = require_Stack();
      var arrayEach = require_arrayEach();
      var assignValue = require_assignValue();
      var baseAssign = require_baseAssign();
      var baseAssignIn = require_baseAssignIn();
      var cloneBuffer = require_cloneBuffer();
      var copyArray = require_copyArray();
      var copySymbols = require_copySymbols();
      var copySymbolsIn = require_copySymbolsIn();
      var getAllKeys = require_getAllKeys();
      var getAllKeysIn = require_getAllKeysIn();
      var getTag = require_getTag();
      var initCloneArray = require_initCloneArray();
      var initCloneByTag = require_initCloneByTag();
      var initCloneObject = require_initCloneObject();
      var isArray = require_isArray();
      var isBuffer = require_isBuffer();
      var isMap = require_isMap();
      var isObject2 = require_isObject();
      var isSet = require_isSet();
      var keys = require_keys();
      var keysIn = require_keysIn();
      var CLONE_DEEP_FLAG = 1;
      var CLONE_FLAT_FLAG = 2;
      var CLONE_SYMBOLS_FLAG = 4;
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var funcTag = "[object Function]";
      var genTag = "[object GeneratorFunction]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var objectTag = "[object Object]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var symbolTag = "[object Symbol]";
      var weakMapTag = "[object WeakMap]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var float32Tag = "[object Float32Array]";
      var float64Tag = "[object Float64Array]";
      var int8Tag = "[object Int8Array]";
      var int16Tag = "[object Int16Array]";
      var int32Tag = "[object Int32Array]";
      var uint8Tag = "[object Uint8Array]";
      var uint8ClampedTag = "[object Uint8ClampedArray]";
      var uint16Tag = "[object Uint16Array]";
      var uint32Tag = "[object Uint32Array]";
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result !== void 0) {
          return result;
        }
        if (!isObject2(value)) {
          return value;
        }
        var isArr = isArray(value);
        if (isArr) {
          result = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result);
          }
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result);
        if (isSet(value)) {
          value.forEach(function(subValue) {
            result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap(value)) {
          value.forEach(function(subValue, key2) {
            result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props = isArr ? void 0 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result;
      }
      module2.exports = baseClone;
    }
  });

  // node_modules/lodash/clone.js
  var require_clone = __commonJS({
    "node_modules/lodash/clone.js"(exports2, module2) {
      var baseClone = require_baseClone();
      var CLONE_SYMBOLS_FLAG = 4;
      function clone(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      module2.exports = clone;
    }
  });

  // node_modules/@chevrotain/utils/lib/src/print.js
  var require_print = __commonJS({
    "node_modules/@chevrotain/utils/lib/src/print.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.PRINT_WARNING = exports2.PRINT_ERROR = void 0;
      function PRINT_ERROR(msg) {
        if (console && console.error) {
          console.error("Error: ".concat(msg));
        }
      }
      exports2.PRINT_ERROR = PRINT_ERROR;
      function PRINT_WARNING(msg) {
        if (console && console.warn) {
          console.warn("Warning: ".concat(msg));
        }
      }
      exports2.PRINT_WARNING = PRINT_WARNING;
    }
  });

  // node_modules/@chevrotain/utils/lib/src/timer.js
  var require_timer = __commonJS({
    "node_modules/@chevrotain/utils/lib/src/timer.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.timer = void 0;
      function timer(func) {
        var start = new Date().getTime();
        var val = func();
        var end = new Date().getTime();
        var total = end - start;
        return { time: total, value: val };
      }
      exports2.timer = timer;
    }
  });

  // node_modules/@chevrotain/utils/lib/src/to-fast-properties.js
  var require_to_fast_properties = __commonJS({
    "node_modules/@chevrotain/utils/lib/src/to-fast-properties.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toFastProperties = void 0;
      function toFastProperties(toBecomeFast) {
        function FakeConstructor() {
        }
        FakeConstructor.prototype = toBecomeFast;
        var fakeInstance = new FakeConstructor();
        function fakeAccess() {
          return typeof fakeInstance.bar;
        }
        fakeAccess();
        fakeAccess();
        if (1)
          return toBecomeFast;
        eval(toBecomeFast);
      }
      exports.toFastProperties = toFastProperties;
    }
  });

  // node_modules/@chevrotain/utils/lib/src/api.js
  var require_api4 = __commonJS({
    "node_modules/@chevrotain/utils/lib/src/api.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.toFastProperties = exports2.timer = exports2.PRINT_ERROR = exports2.PRINT_WARNING = void 0;
      var print_1 = require_print();
      Object.defineProperty(exports2, "PRINT_WARNING", { enumerable: true, get: function() {
        return print_1.PRINT_WARNING;
      } });
      Object.defineProperty(exports2, "PRINT_ERROR", { enumerable: true, get: function() {
        return print_1.PRINT_ERROR;
      } });
      var timer_1 = require_timer();
      Object.defineProperty(exports2, "timer", { enumerable: true, get: function() {
        return timer_1.timer;
      } });
      var to_fast_properties_1 = require_to_fast_properties();
      Object.defineProperty(exports2, "toFastProperties", { enumerable: true, get: function() {
        return to_fast_properties_1.toFastProperties;
      } });
    }
  });

  // node_modules/lodash/_baseSlice.js
  var require_baseSlice = __commonJS({
    "node_modules/lodash/_baseSlice.js"(exports2, module2) {
      function baseSlice(array, start, end) {
        var index = -1, length = array.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result = Array(length);
        while (++index < length) {
          result[index] = array[index + start];
        }
        return result;
      }
      module2.exports = baseSlice;
    }
  });

  // node_modules/lodash/_trimmedEndIndex.js
  var require_trimmedEndIndex = __commonJS({
    "node_modules/lodash/_trimmedEndIndex.js"(exports2, module2) {
      var reWhitespace = /\s/;
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      module2.exports = trimmedEndIndex;
    }
  });

  // node_modules/lodash/_baseTrim.js
  var require_baseTrim = __commonJS({
    "node_modules/lodash/_baseTrim.js"(exports2, module2) {
      var trimmedEndIndex = require_trimmedEndIndex();
      var reTrimStart = /^\s+/;
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      module2.exports = baseTrim;
    }
  });

  // node_modules/lodash/toNumber.js
  var require_toNumber = __commonJS({
    "node_modules/lodash/toNumber.js"(exports2, module2) {
      var baseTrim = require_baseTrim();
      var isObject2 = require_isObject();
      var isSymbol = require_isSymbol();
      var NAN = 0 / 0;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsOctal = /^0o[0-7]+$/i;
      var freeParseInt = parseInt;
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject2(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject2(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      module2.exports = toNumber;
    }
  });

  // node_modules/lodash/toFinite.js
  var require_toFinite = __commonJS({
    "node_modules/lodash/toFinite.js"(exports2, module2) {
      var toNumber = require_toNumber();
      var INFINITY = 1 / 0;
      var MAX_INTEGER = 17976931348623157e292;
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      module2.exports = toFinite;
    }
  });

  // node_modules/lodash/toInteger.js
  var require_toInteger = __commonJS({
    "node_modules/lodash/toInteger.js"(exports2, module2) {
      var toFinite = require_toFinite();
      function toInteger(value) {
        var result = toFinite(value), remainder = result % 1;
        return result === result ? remainder ? result - remainder : result : 0;
      }
      module2.exports = toInteger;
    }
  });

  // node_modules/lodash/drop.js
  var require_drop = __commonJS({
    "node_modules/lodash/drop.js"(exports2, module2) {
      var baseSlice = require_baseSlice();
      var toInteger = require_toInteger();
      function drop(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === void 0 ? 1 : toInteger(n);
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      module2.exports = drop;
    }
  });

  // node_modules/lodash/isString.js
  var require_isString = __commonJS({
    "node_modules/lodash/isString.js"(exports2, module2) {
      var baseGetTag = require_baseGetTag();
      var isArray = require_isArray();
      var isObjectLike = require_isObjectLike();
      var stringTag = "[object String]";
      function isString2(value) {
        return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
      }
      module2.exports = isString2;
    }
  });

  // node_modules/lodash/_baseIsRegExp.js
  var require_baseIsRegExp = __commonJS({
    "node_modules/lodash/_baseIsRegExp.js"(exports2, module2) {
      var baseGetTag = require_baseGetTag();
      var isObjectLike = require_isObjectLike();
      var regexpTag = "[object RegExp]";
      function baseIsRegExp(value) {
        return isObjectLike(value) && baseGetTag(value) == regexpTag;
      }
      module2.exports = baseIsRegExp;
    }
  });

  // node_modules/lodash/isRegExp.js
  var require_isRegExp = __commonJS({
    "node_modules/lodash/isRegExp.js"(exports2, module2) {
      var baseIsRegExp = require_baseIsRegExp();
      var baseUnary = require_baseUnary();
      var nodeUtil = require_nodeUtil();
      var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;
      var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      module2.exports = isRegExp;
    }
  });

  // node_modules/lodash/_baseSet.js
  var require_baseSet = __commonJS({
    "node_modules/lodash/_baseSet.js"(exports2, module2) {
      var assignValue = require_assignValue();
      var castPath = require_castPath();
      var isIndex = require_isIndex();
      var isObject2 = require_isObject();
      var toKey = require_toKey();
      function baseSet(object, path, value, customizer) {
        if (!isObject2(object)) {
          return object;
        }
        path = castPath(path, object);
        var index = -1, length = path.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index < length) {
          var key = toKey(path[index]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : void 0;
            if (newValue === void 0) {
              newValue = isObject2(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      module2.exports = baseSet;
    }
  });

  // node_modules/lodash/_basePickBy.js
  var require_basePickBy = __commonJS({
    "node_modules/lodash/_basePickBy.js"(exports2, module2) {
      var baseGet = require_baseGet();
      var baseSet = require_baseSet();
      var castPath = require_castPath();
      function basePickBy(object, paths, predicate) {
        var index = -1, length = paths.length, result = {};
        while (++index < length) {
          var path = paths[index], value = baseGet(object, path);
          if (predicate(value, path)) {
            baseSet(result, castPath(path, object), value);
          }
        }
        return result;
      }
      module2.exports = basePickBy;
    }
  });

  // node_modules/lodash/pickBy.js
  var require_pickBy = __commonJS({
    "node_modules/lodash/pickBy.js"(exports2, module2) {
      var arrayMap = require_arrayMap();
      var baseIteratee = require_baseIteratee();
      var basePickBy = require_basePickBy();
      var getAllKeysIn = require_getAllKeysIn();
      function pickBy(object, predicate) {
        if (object == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object), function(prop) {
          return [prop];
        });
        predicate = baseIteratee(predicate);
        return basePickBy(object, props, function(value, path) {
          return predicate(value, path[0]);
        });
      }
      module2.exports = pickBy;
    }
  });

  // node_modules/lodash/_apply.js
  var require_apply = __commonJS({
    "node_modules/lodash/_apply.js"(exports2, module2) {
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      module2.exports = apply;
    }
  });

  // node_modules/lodash/_overRest.js
  var require_overRest = __commonJS({
    "node_modules/lodash/_overRest.js"(exports2, module2) {
      var apply = require_apply();
      var nativeMax = Math.max;
      function overRest(func, start, transform2) {
        start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
          while (++index < length) {
            array[index] = args[start + index];
          }
          index = -1;
          var otherArgs = Array(start + 1);
          while (++index < start) {
            otherArgs[index] = args[index];
          }
          otherArgs[start] = transform2(array);
          return apply(func, this, otherArgs);
        };
      }
      module2.exports = overRest;
    }
  });

  // node_modules/lodash/constant.js
  var require_constant = __commonJS({
    "node_modules/lodash/constant.js"(exports2, module2) {
      function constant(value) {
        return function() {
          return value;
        };
      }
      module2.exports = constant;
    }
  });

  // node_modules/lodash/_baseSetToString.js
  var require_baseSetToString = __commonJS({
    "node_modules/lodash/_baseSetToString.js"(exports2, module2) {
      var constant = require_constant();
      var defineProperty = require_defineProperty();
      var identity = require_identity();
      var baseSetToString = !defineProperty ? identity : function(func, string) {
        return defineProperty(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string),
          "writable": true
        });
      };
      module2.exports = baseSetToString;
    }
  });

  // node_modules/lodash/_shortOut.js
  var require_shortOut = __commonJS({
    "node_modules/lodash/_shortOut.js"(exports2, module2) {
      var HOT_COUNT = 800;
      var HOT_SPAN = 16;
      var nativeNow = Date.now;
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(void 0, arguments);
        };
      }
      module2.exports = shortOut;
    }
  });

  // node_modules/lodash/_setToString.js
  var require_setToString = __commonJS({
    "node_modules/lodash/_setToString.js"(exports2, module2) {
      var baseSetToString = require_baseSetToString();
      var shortOut = require_shortOut();
      var setToString = shortOut(baseSetToString);
      module2.exports = setToString;
    }
  });

  // node_modules/lodash/_baseRest.js
  var require_baseRest = __commonJS({
    "node_modules/lodash/_baseRest.js"(exports2, module2) {
      var identity = require_identity();
      var overRest = require_overRest();
      var setToString = require_setToString();
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + "");
      }
      module2.exports = baseRest;
    }
  });

  // node_modules/lodash/_isIterateeCall.js
  var require_isIterateeCall = __commonJS({
    "node_modules/lodash/_isIterateeCall.js"(exports2, module2) {
      var eq = require_eq();
      var isArrayLike = require_isArrayLike();
      var isIndex = require_isIndex();
      var isObject2 = require_isObject();
      function isIterateeCall(value, index, object) {
        if (!isObject2(object)) {
          return false;
        }
        var type = typeof index;
        if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
          return eq(object[index], value);
        }
        return false;
      }
      module2.exports = isIterateeCall;
    }
  });

  // node_modules/lodash/_createAssigner.js
  var require_createAssigner = __commonJS({
    "node_modules/lodash/_createAssigner.js"(exports2, module2) {
      var baseRest = require_baseRest();
      var isIterateeCall = require_isIterateeCall();
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? void 0 : customizer;
            length = 1;
          }
          object = Object(object);
          while (++index < length) {
            var source = sources[index];
            if (source) {
              assigner(object, source, index, customizer);
            }
          }
          return object;
        });
      }
      module2.exports = createAssigner;
    }
  });

  // node_modules/lodash/assign.js
  var require_assign = __commonJS({
    "node_modules/lodash/assign.js"(exports2, module2) {
      var assignValue = require_assignValue();
      var copyObject = require_copyObject();
      var createAssigner = require_createAssigner();
      var isArrayLike = require_isArrayLike();
      var isPrototype = require_isPrototype();
      var keys = require_keys();
      var objectProto = Object.prototype;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      var assign = createAssigner(function(object, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys(source), object);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty2.call(source, key)) {
            assignValue(object, key, source[key]);
          }
        }
      });
      module2.exports = assign;
    }
  });

  // node_modules/@chevrotain/gast/lib/src/model.js
  var require_model = __commonJS({
    "node_modules/@chevrotain/gast/lib/src/model.js"(exports2) {
      "use strict";
      var __extends = exports2 && exports2.__extends || function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2)
              if (Object.prototype.hasOwnProperty.call(b2, p))
                d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.serializeProduction = exports2.serializeGrammar = exports2.Terminal = exports2.Alternation = exports2.RepetitionWithSeparator = exports2.Repetition = exports2.RepetitionMandatoryWithSeparator = exports2.RepetitionMandatory = exports2.Option = exports2.Alternative = exports2.Rule = exports2.NonTerminal = exports2.AbstractProduction = void 0;
      var map_1 = __importDefault(require_map());
      var forEach_1 = __importDefault(require_forEach());
      var isString_1 = __importDefault(require_isString());
      var isRegExp_1 = __importDefault(require_isRegExp());
      var pickBy_1 = __importDefault(require_pickBy());
      var assign_1 = __importDefault(require_assign());
      function tokenLabel(tokType) {
        if (hasTokenLabel(tokType)) {
          return tokType.LABEL;
        } else {
          return tokType.name;
        }
      }
      function hasTokenLabel(obj) {
        return (0, isString_1.default)(obj.LABEL) && obj.LABEL !== "";
      }
      var AbstractProduction = (
        /** @class */
        function() {
          function AbstractProduction2(_definition) {
            this._definition = _definition;
          }
          Object.defineProperty(AbstractProduction2.prototype, "definition", {
            get: function() {
              return this._definition;
            },
            set: function(value) {
              this._definition = value;
            },
            enumerable: false,
            configurable: true
          });
          AbstractProduction2.prototype.accept = function(visitor) {
            visitor.visit(this);
            (0, forEach_1.default)(this.definition, function(prod) {
              prod.accept(visitor);
            });
          };
          return AbstractProduction2;
        }()
      );
      exports2.AbstractProduction = AbstractProduction;
      var NonTerminal = (
        /** @class */
        function(_super) {
          __extends(NonTerminal2, _super);
          function NonTerminal2(options) {
            var _this = _super.call(this, []) || this;
            _this.idx = 1;
            (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
              return v !== void 0;
            }));
            return _this;
          }
          Object.defineProperty(NonTerminal2.prototype, "definition", {
            get: function() {
              if (this.referencedRule !== void 0) {
                return this.referencedRule.definition;
              }
              return [];
            },
            set: function(definition) {
            },
            enumerable: false,
            configurable: true
          });
          NonTerminal2.prototype.accept = function(visitor) {
            visitor.visit(this);
          };
          return NonTerminal2;
        }(AbstractProduction)
      );
      exports2.NonTerminal = NonTerminal;
      var Rule = (
        /** @class */
        function(_super) {
          __extends(Rule2, _super);
          function Rule2(options) {
            var _this = _super.call(this, options.definition) || this;
            _this.orgText = "";
            (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
              return v !== void 0;
            }));
            return _this;
          }
          return Rule2;
        }(AbstractProduction)
      );
      exports2.Rule = Rule;
      var Alternative = (
        /** @class */
        function(_super) {
          __extends(Alternative2, _super);
          function Alternative2(options) {
            var _this = _super.call(this, options.definition) || this;
            _this.ignoreAmbiguities = false;
            (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
              return v !== void 0;
            }));
            return _this;
          }
          return Alternative2;
        }(AbstractProduction)
      );
      exports2.Alternative = Alternative;
      var Option = (
        /** @class */
        function(_super) {
          __extends(Option2, _super);
          function Option2(options) {
            var _this = _super.call(this, options.definition) || this;
            _this.idx = 1;
            (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
              return v !== void 0;
            }));
            return _this;
          }
          return Option2;
        }(AbstractProduction)
      );
      exports2.Option = Option;
      var RepetitionMandatory = (
        /** @class */
        function(_super) {
          __extends(RepetitionMandatory2, _super);
          function RepetitionMandatory2(options) {
            var _this = _super.call(this, options.definition) || this;
            _this.idx = 1;
            (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
              return v !== void 0;
            }));
            return _this;
          }
          return RepetitionMandatory2;
        }(AbstractProduction)
      );
      exports2.RepetitionMandatory = RepetitionMandatory;
      var RepetitionMandatoryWithSeparator = (
        /** @class */
        function(_super) {
          __extends(RepetitionMandatoryWithSeparator2, _super);
          function RepetitionMandatoryWithSeparator2(options) {
            var _this = _super.call(this, options.definition) || this;
            _this.idx = 1;
            (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
              return v !== void 0;
            }));
            return _this;
          }
          return RepetitionMandatoryWithSeparator2;
        }(AbstractProduction)
      );
      exports2.RepetitionMandatoryWithSeparator = RepetitionMandatoryWithSeparator;
      var Repetition = (
        /** @class */
        function(_super) {
          __extends(Repetition2, _super);
          function Repetition2(options) {
            var _this = _super.call(this, options.definition) || this;
            _this.idx = 1;
            (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
              return v !== void 0;
            }));
            return _this;
          }
          return Repetition2;
        }(AbstractProduction)
      );
      exports2.Repetition = Repetition;
      var RepetitionWithSeparator = (
        /** @class */
        function(_super) {
          __extends(RepetitionWithSeparator2, _super);
          function RepetitionWithSeparator2(options) {
            var _this = _super.call(this, options.definition) || this;
            _this.idx = 1;
            (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
              return v !== void 0;
            }));
            return _this;
          }
          return RepetitionWithSeparator2;
        }(AbstractProduction)
      );
      exports2.RepetitionWithSeparator = RepetitionWithSeparator;
      var Alternation = (
        /** @class */
        function(_super) {
          __extends(Alternation2, _super);
          function Alternation2(options) {
            var _this = _super.call(this, options.definition) || this;
            _this.idx = 1;
            _this.ignoreAmbiguities = false;
            _this.hasPredicates = false;
            (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
              return v !== void 0;
            }));
            return _this;
          }
          Object.defineProperty(Alternation2.prototype, "definition", {
            get: function() {
              return this._definition;
            },
            set: function(value) {
              this._definition = value;
            },
            enumerable: false,
            configurable: true
          });
          return Alternation2;
        }(AbstractProduction)
      );
      exports2.Alternation = Alternation;
      var Terminal = (
        /** @class */
        function() {
          function Terminal2(options) {
            this.idx = 1;
            (0, assign_1.default)(this, (0, pickBy_1.default)(options, function(v) {
              return v !== void 0;
            }));
          }
          Terminal2.prototype.accept = function(visitor) {
            visitor.visit(this);
          };
          return Terminal2;
        }()
      );
      exports2.Terminal = Terminal;
      function serializeGrammar(topRules) {
        return (0, map_1.default)(topRules, serializeProduction);
      }
      exports2.serializeGrammar = serializeGrammar;
      function serializeProduction(node) {
        function convertDefinition(definition) {
          return (0, map_1.default)(definition, serializeProduction);
        }
        if (node instanceof NonTerminal) {
          var serializedNonTerminal = {
            type: "NonTerminal",
            name: node.nonTerminalName,
            idx: node.idx
          };
          if ((0, isString_1.default)(node.label)) {
            serializedNonTerminal.label = node.label;
          }
          return serializedNonTerminal;
        } else if (node instanceof Alternative) {
          return {
            type: "Alternative",
            definition: convertDefinition(node.definition)
          };
        } else if (node instanceof Option) {
          return {
            type: "Option",
            idx: node.idx,
            definition: convertDefinition(node.definition)
          };
        } else if (node instanceof RepetitionMandatory) {
          return {
            type: "RepetitionMandatory",
            idx: node.idx,
            definition: convertDefinition(node.definition)
          };
        } else if (node instanceof RepetitionMandatoryWithSeparator) {
          return {
            type: "RepetitionMandatoryWithSeparator",
            idx: node.idx,
            separator: serializeProduction(new Terminal({ terminalType: node.separator })),
            definition: convertDefinition(node.definition)
          };
        } else if (node instanceof RepetitionWithSeparator) {
          return {
            type: "RepetitionWithSeparator",
            idx: node.idx,
            separator: serializeProduction(new Terminal({ terminalType: node.separator })),
            definition: convertDefinition(node.definition)
          };
        } else if (node instanceof Repetition) {
          return {
            type: "Repetition",
            idx: node.idx,
            definition: convertDefinition(node.definition)
          };
        } else if (node instanceof Alternation) {
          return {
            type: "Alternation",
            idx: node.idx,
            definition: convertDefinition(node.definition)
          };
        } else if (node instanceof Terminal) {
          var serializedTerminal = {
            type: "Terminal",
            name: node.terminalType.name,
            label: tokenLabel(node.terminalType),
            idx: node.idx
          };
          if ((0, isString_1.default)(node.label)) {
            serializedTerminal.terminalLabel = node.label;
          }
          var pattern = node.terminalType.PATTERN;
          if (node.terminalType.PATTERN) {
            serializedTerminal.pattern = (0, isRegExp_1.default)(pattern) ? pattern.source : pattern;
          }
          return serializedTerminal;
        } else if (node instanceof Rule) {
          return {
            type: "Rule",
            name: node.name,
            orgText: node.orgText,
            definition: convertDefinition(node.definition)
          };
        } else {
          throw Error("non exhaustive match");
        }
      }
      exports2.serializeProduction = serializeProduction;
    }
  });

  // node_modules/@chevrotain/gast/lib/src/visitor.js
  var require_visitor = __commonJS({
    "node_modules/@chevrotain/gast/lib/src/visitor.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.GAstVisitor = void 0;
      var model_1 = require_model();
      var GAstVisitor = (
        /** @class */
        function() {
          function GAstVisitor2() {
          }
          GAstVisitor2.prototype.visit = function(node) {
            var nodeAny = node;
            switch (nodeAny.constructor) {
              case model_1.NonTerminal:
                return this.visitNonTerminal(nodeAny);
              case model_1.Alternative:
                return this.visitAlternative(nodeAny);
              case model_1.Option:
                return this.visitOption(nodeAny);
              case model_1.RepetitionMandatory:
                return this.visitRepetitionMandatory(nodeAny);
              case model_1.RepetitionMandatoryWithSeparator:
                return this.visitRepetitionMandatoryWithSeparator(nodeAny);
              case model_1.RepetitionWithSeparator:
                return this.visitRepetitionWithSeparator(nodeAny);
              case model_1.Repetition:
                return this.visitRepetition(nodeAny);
              case model_1.Alternation:
                return this.visitAlternation(nodeAny);
              case model_1.Terminal:
                return this.visitTerminal(nodeAny);
              case model_1.Rule:
                return this.visitRule(nodeAny);
              default:
                throw Error("non exhaustive match");
            }
          };
          GAstVisitor2.prototype.visitNonTerminal = function(node) {
          };
          GAstVisitor2.prototype.visitAlternative = function(node) {
          };
          GAstVisitor2.prototype.visitOption = function(node) {
          };
          GAstVisitor2.prototype.visitRepetition = function(node) {
          };
          GAstVisitor2.prototype.visitRepetitionMandatory = function(node) {
          };
          GAstVisitor2.prototype.visitRepetitionMandatoryWithSeparator = function(node) {
          };
          GAstVisitor2.prototype.visitRepetitionWithSeparator = function(node) {
          };
          GAstVisitor2.prototype.visitAlternation = function(node) {
          };
          GAstVisitor2.prototype.visitTerminal = function(node) {
          };
          GAstVisitor2.prototype.visitRule = function(node) {
          };
          return GAstVisitor2;
        }()
      );
      exports2.GAstVisitor = GAstVisitor;
    }
  });

  // node_modules/lodash/_baseSome.js
  var require_baseSome = __commonJS({
    "node_modules/lodash/_baseSome.js"(exports2, module2) {
      var baseEach = require_baseEach();
      function baseSome(collection, predicate) {
        var result;
        baseEach(collection, function(value, index, collection2) {
          result = predicate(value, index, collection2);
          return !result;
        });
        return !!result;
      }
      module2.exports = baseSome;
    }
  });

  // node_modules/lodash/some.js
  var require_some = __commonJS({
    "node_modules/lodash/some.js"(exports2, module2) {
      var arraySome = require_arraySome();
      var baseIteratee = require_baseIteratee();
      var baseSome = require_baseSome();
      var isArray = require_isArray();
      var isIterateeCall = require_isIterateeCall();
      function some(collection, predicate, guard) {
        var func = isArray(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = void 0;
        }
        return func(collection, baseIteratee(predicate, 3));
      }
      module2.exports = some;
    }
  });

  // node_modules/lodash/_arrayEvery.js
  var require_arrayEvery = __commonJS({
    "node_modules/lodash/_arrayEvery.js"(exports2, module2) {
      function arrayEvery(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      module2.exports = arrayEvery;
    }
  });

  // node_modules/lodash/_baseEvery.js
  var require_baseEvery = __commonJS({
    "node_modules/lodash/_baseEvery.js"(exports2, module2) {
      var baseEach = require_baseEach();
      function baseEvery(collection, predicate) {
        var result = true;
        baseEach(collection, function(value, index, collection2) {
          result = !!predicate(value, index, collection2);
          return result;
        });
        return result;
      }
      module2.exports = baseEvery;
    }
  });

  // node_modules/lodash/every.js
  var require_every = __commonJS({
    "node_modules/lodash/every.js"(exports2, module2) {
      var arrayEvery = require_arrayEvery();
      var baseEvery = require_baseEvery();
      var baseIteratee = require_baseIteratee();
      var isArray = require_isArray();
      var isIterateeCall = require_isIterateeCall();
      function every(collection, predicate, guard) {
        var func = isArray(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = void 0;
        }
        return func(collection, baseIteratee(predicate, 3));
      }
      module2.exports = every;
    }
  });

  // node_modules/lodash/_baseFindIndex.js
  var require_baseFindIndex = __commonJS({
    "node_modules/lodash/_baseFindIndex.js"(exports2, module2) {
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      module2.exports = baseFindIndex;
    }
  });

  // node_modules/lodash/_baseIsNaN.js
  var require_baseIsNaN = __commonJS({
    "node_modules/lodash/_baseIsNaN.js"(exports2, module2) {
      function baseIsNaN(value) {
        return value !== value;
      }
      module2.exports = baseIsNaN;
    }
  });

  // node_modules/lodash/_strictIndexOf.js
  var require_strictIndexOf = __commonJS({
    "node_modules/lodash/_strictIndexOf.js"(exports2, module2) {
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      module2.exports = strictIndexOf;
    }
  });

  // node_modules/lodash/_baseIndexOf.js
  var require_baseIndexOf = __commonJS({
    "node_modules/lodash/_baseIndexOf.js"(exports2, module2) {
      var baseFindIndex = require_baseFindIndex();
      var baseIsNaN = require_baseIsNaN();
      var strictIndexOf = require_strictIndexOf();
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      module2.exports = baseIndexOf;
    }
  });

  // node_modules/lodash/includes.js
  var require_includes = __commonJS({
    "node_modules/lodash/includes.js"(exports2, module2) {
      var baseIndexOf = require_baseIndexOf();
      var isArrayLike = require_isArrayLike();
      var isString2 = require_isString();
      var toInteger = require_toInteger();
      var values = require_values();
      var nativeMax = Math.max;
      function includes(collection, value, fromIndex, guard) {
        collection = isArrayLike(collection) ? collection : values(collection);
        fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }
        return isString2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
      }
      module2.exports = includes;
    }
  });

  // node_modules/@chevrotain/gast/lib/src/helpers.js
  var require_helpers = __commonJS({
    "node_modules/@chevrotain/gast/lib/src/helpers.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getProductionDslName = exports2.isBranchingProd = exports2.isOptionalProd = exports2.isSequenceProd = void 0;
      var some_1 = __importDefault(require_some());
      var every_1 = __importDefault(require_every());
      var includes_1 = __importDefault(require_includes());
      var model_1 = require_model();
      function isSequenceProd(prod) {
        return prod instanceof model_1.Alternative || prod instanceof model_1.Option || prod instanceof model_1.Repetition || prod instanceof model_1.RepetitionMandatory || prod instanceof model_1.RepetitionMandatoryWithSeparator || prod instanceof model_1.RepetitionWithSeparator || prod instanceof model_1.Terminal || prod instanceof model_1.Rule;
      }
      exports2.isSequenceProd = isSequenceProd;
      function isOptionalProd(prod, alreadyVisited) {
        if (alreadyVisited === void 0) {
          alreadyVisited = [];
        }
        var isDirectlyOptional = prod instanceof model_1.Option || prod instanceof model_1.Repetition || prod instanceof model_1.RepetitionWithSeparator;
        if (isDirectlyOptional) {
          return true;
        }
        if (prod instanceof model_1.Alternation) {
          return (0, some_1.default)(prod.definition, function(subProd) {
            return isOptionalProd(subProd, alreadyVisited);
          });
        } else if (prod instanceof model_1.NonTerminal && (0, includes_1.default)(alreadyVisited, prod)) {
          return false;
        } else if (prod instanceof model_1.AbstractProduction) {
          if (prod instanceof model_1.NonTerminal) {
            alreadyVisited.push(prod);
          }
          return (0, every_1.default)(prod.definition, function(subProd) {
            return isOptionalProd(subProd, alreadyVisited);
          });
        } else {
          return false;
        }
      }
      exports2.isOptionalProd = isOptionalProd;
      function isBranchingProd(prod) {
        return prod instanceof model_1.Alternation;
      }
      exports2.isBranchingProd = isBranchingProd;
      function getProductionDslName(prod) {
        if (prod instanceof model_1.NonTerminal) {
          return "SUBRULE";
        } else if (prod instanceof model_1.Option) {
          return "OPTION";
        } else if (prod instanceof model_1.Alternation) {
          return "OR";
        } else if (prod instanceof model_1.RepetitionMandatory) {
          return "AT_LEAST_ONE";
        } else if (prod instanceof model_1.RepetitionMandatoryWithSeparator) {
          return "AT_LEAST_ONE_SEP";
        } else if (prod instanceof model_1.RepetitionWithSeparator) {
          return "MANY_SEP";
        } else if (prod instanceof model_1.Repetition) {
          return "MANY";
        } else if (prod instanceof model_1.Terminal) {
          return "CONSUME";
        } else {
          throw Error("non exhaustive match");
        }
      }
      exports2.getProductionDslName = getProductionDslName;
    }
  });

  // node_modules/@chevrotain/gast/lib/src/api.js
  var require_api5 = __commonJS({
    "node_modules/@chevrotain/gast/lib/src/api.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.isSequenceProd = exports2.isBranchingProd = exports2.isOptionalProd = exports2.getProductionDslName = exports2.GAstVisitor = exports2.serializeProduction = exports2.serializeGrammar = exports2.Alternative = exports2.Alternation = exports2.RepetitionWithSeparator = exports2.RepetitionMandatoryWithSeparator = exports2.RepetitionMandatory = exports2.Repetition = exports2.Option = exports2.NonTerminal = exports2.Terminal = exports2.Rule = void 0;
      var model_1 = require_model();
      Object.defineProperty(exports2, "Rule", { enumerable: true, get: function() {
        return model_1.Rule;
      } });
      Object.defineProperty(exports2, "Terminal", { enumerable: true, get: function() {
        return model_1.Terminal;
      } });
      Object.defineProperty(exports2, "NonTerminal", { enumerable: true, get: function() {
        return model_1.NonTerminal;
      } });
      Object.defineProperty(exports2, "Option", { enumerable: true, get: function() {
        return model_1.Option;
      } });
      Object.defineProperty(exports2, "Repetition", { enumerable: true, get: function() {
        return model_1.Repetition;
      } });
      Object.defineProperty(exports2, "RepetitionMandatory", { enumerable: true, get: function() {
        return model_1.RepetitionMandatory;
      } });
      Object.defineProperty(exports2, "RepetitionMandatoryWithSeparator", { enumerable: true, get: function() {
        return model_1.RepetitionMandatoryWithSeparator;
      } });
      Object.defineProperty(exports2, "RepetitionWithSeparator", { enumerable: true, get: function() {
        return model_1.RepetitionWithSeparator;
      } });
      Object.defineProperty(exports2, "Alternation", { enumerable: true, get: function() {
        return model_1.Alternation;
      } });
      Object.defineProperty(exports2, "Alternative", { enumerable: true, get: function() {
        return model_1.Alternative;
      } });
      Object.defineProperty(exports2, "serializeGrammar", { enumerable: true, get: function() {
        return model_1.serializeGrammar;
      } });
      Object.defineProperty(exports2, "serializeProduction", { enumerable: true, get: function() {
        return model_1.serializeProduction;
      } });
      var visitor_1 = require_visitor();
      Object.defineProperty(exports2, "GAstVisitor", { enumerable: true, get: function() {
        return visitor_1.GAstVisitor;
      } });
      var helpers_1 = require_helpers();
      Object.defineProperty(exports2, "getProductionDslName", { enumerable: true, get: function() {
        return helpers_1.getProductionDslName;
      } });
      Object.defineProperty(exports2, "isOptionalProd", { enumerable: true, get: function() {
        return helpers_1.isOptionalProd;
      } });
      Object.defineProperty(exports2, "isBranchingProd", { enumerable: true, get: function() {
        return helpers_1.isBranchingProd;
      } });
      Object.defineProperty(exports2, "isSequenceProd", { enumerable: true, get: function() {
        return helpers_1.isSequenceProd;
      } });
    }
  });

  // node_modules/chevrotain/lib/src/parse/grammar/rest.js
  var require_rest = __commonJS({
    "node_modules/chevrotain/lib/src/parse/grammar/rest.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.RestWalker = void 0;
      var drop_1 = __importDefault(require_drop());
      var forEach_1 = __importDefault(require_forEach());
      var gast_1 = require_api5();
      var RestWalker = (
        /** @class */
        function() {
          function RestWalker2() {
          }
          RestWalker2.prototype.walk = function(prod, prevRest) {
            var _this = this;
            if (prevRest === void 0) {
              prevRest = [];
            }
            (0, forEach_1.default)(prod.definition, function(subProd, index) {
              var currRest = (0, drop_1.default)(prod.definition, index + 1);
              if (subProd instanceof gast_1.NonTerminal) {
                _this.walkProdRef(subProd, currRest, prevRest);
              } else if (subProd instanceof gast_1.Terminal) {
                _this.walkTerminal(subProd, currRest, prevRest);
              } else if (subProd instanceof gast_1.Alternative) {
                _this.walkFlat(subProd, currRest, prevRest);
              } else if (subProd instanceof gast_1.Option) {
                _this.walkOption(subProd, currRest, prevRest);
              } else if (subProd instanceof gast_1.RepetitionMandatory) {
                _this.walkAtLeastOne(subProd, currRest, prevRest);
              } else if (subProd instanceof gast_1.RepetitionMandatoryWithSeparator) {
                _this.walkAtLeastOneSep(subProd, currRest, prevRest);
              } else if (subProd instanceof gast_1.RepetitionWithSeparator) {
                _this.walkManySep(subProd, currRest, prevRest);
              } else if (subProd instanceof gast_1.Repetition) {
                _this.walkMany(subProd, currRest, prevRest);
              } else if (subProd instanceof gast_1.Alternation) {
                _this.walkOr(subProd, currRest, prevRest);
              } else {
                throw Error("non exhaustive match");
              }
            });
          };
          RestWalker2.prototype.walkTerminal = function(terminal, currRest, prevRest) {
          };
          RestWalker2.prototype.walkProdRef = function(refProd, currRest, prevRest) {
          };
          RestWalker2.prototype.walkFlat = function(flatProd, currRest, prevRest) {
            var fullOrRest = currRest.concat(prevRest);
            this.walk(flatProd, fullOrRest);
          };
          RestWalker2.prototype.walkOption = function(optionProd, currRest, prevRest) {
            var fullOrRest = currRest.concat(prevRest);
            this.walk(optionProd, fullOrRest);
          };
          RestWalker2.prototype.walkAtLeastOne = function(atLeastOneProd, currRest, prevRest) {
            var fullAtLeastOneRest = [
              new gast_1.Option({ definition: atLeastOneProd.definition })
            ].concat(currRest, prevRest);
            this.walk(atLeastOneProd, fullAtLeastOneRest);
          };
          RestWalker2.prototype.walkAtLeastOneSep = function(atLeastOneSepProd, currRest, prevRest) {
            var fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);
            this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);
          };
          RestWalker2.prototype.walkMany = function(manyProd, currRest, prevRest) {
            var fullManyRest = [
              new gast_1.Option({ definition: manyProd.definition })
            ].concat(currRest, prevRest);
            this.walk(manyProd, fullManyRest);
          };
          RestWalker2.prototype.walkManySep = function(manySepProd, currRest, prevRest) {
            var fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);
            this.walk(manySepProd, fullManySepRest);
          };
          RestWalker2.prototype.walkOr = function(orProd, currRest, prevRest) {
            var _this = this;
            var fullOrRest = currRest.concat(prevRest);
            (0, forEach_1.default)(orProd.definition, function(alt) {
              var prodWrapper = new gast_1.Alternative({ definition: [alt] });
              _this.walk(prodWrapper, fullOrRest);
            });
          };
          return RestWalker2;
        }()
      );
      exports2.RestWalker = RestWalker;
      function restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {
        var repSepRest = [
          new gast_1.Option({
            definition: [
              new gast_1.Terminal({ terminalType: repSepProd.separator })
            ].concat(repSepProd.definition)
          })
        ];
        var fullRepSepRest = repSepRest.concat(currRest, prevRest);
        return fullRepSepRest;
      }
    }
  });

  // node_modules/lodash/_isFlattenable.js
  var require_isFlattenable = __commonJS({
    "node_modules/lodash/_isFlattenable.js"(exports2, module2) {
      var Symbol2 = require_Symbol();
      var isArguments = require_isArguments();
      var isArray = require_isArray();
      var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
      function isFlattenable(value) {
        return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      module2.exports = isFlattenable;
    }
  });

  // node_modules/lodash/_baseFlatten.js
  var require_baseFlatten = __commonJS({
    "node_modules/lodash/_baseFlatten.js"(exports2, module2) {
      var arrayPush = require_arrayPush();
      var isFlattenable = require_isFlattenable();
      function baseFlatten(array, depth, predicate, isStrict, result) {
        var index = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result || (result = []);
        while (++index < length) {
          var value = array[index];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result);
            } else {
              arrayPush(result, value);
            }
          } else if (!isStrict) {
            result[result.length] = value;
          }
        }
        return result;
      }
      module2.exports = baseFlatten;
    }
  });

  // node_modules/lodash/flatten.js
  var require_flatten = __commonJS({
    "node_modules/lodash/flatten.js"(exports2, module2) {
      var baseFlatten = require_baseFlatten();
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }
      module2.exports = flatten;
    }
  });

  // node_modules/lodash/_arrayIncludes.js
  var require_arrayIncludes = __commonJS({
    "node_modules/lodash/_arrayIncludes.js"(exports2, module2) {
      var baseIndexOf = require_baseIndexOf();
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      module2.exports = arrayIncludes;
    }
  });

  // node_modules/lodash/_arrayIncludesWith.js
  var require_arrayIncludesWith = __commonJS({
    "node_modules/lodash/_arrayIncludesWith.js"(exports2, module2) {
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      module2.exports = arrayIncludesWith;
    }
  });

  // node_modules/lodash/noop.js
  var require_noop = __commonJS({
    "node_modules/lodash/noop.js"(exports2, module2) {
      function noop() {
      }
      module2.exports = noop;
    }
  });

  // node_modules/lodash/_createSet.js
  var require_createSet = __commonJS({
    "node_modules/lodash/_createSet.js"(exports2, module2) {
      var Set2 = require_Set();
      var noop = require_noop();
      var setToArray = require_setToArray();
      var INFINITY = 1 / 0;
      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
        return new Set2(values);
      };
      module2.exports = createSet;
    }
  });

  // node_modules/lodash/_baseUniq.js
  var require_baseUniq = __commonJS({
    "node_modules/lodash/_baseUniq.js"(exports2, module2) {
      var SetCache = require_SetCache();
      var arrayIncludes = require_arrayIncludes();
      var arrayIncludesWith = require_arrayIncludesWith();
      var cacheHas = require_cacheHas();
      var createSet = require_createSet();
      var setToArray = require_setToArray();
      var LARGE_ARRAY_SIZE = 200;
      function baseUniq(array, iteratee, comparator) {
        var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
        if (comparator) {
          isCommon = false;
          includes = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set = iteratee ? null : createSet(array);
          if (set) {
            return setToArray(set);
          }
          isCommon = false;
          includes = cacheHas;
          seen = new SetCache();
        } else {
          seen = iteratee ? [] : result;
        }
        outer:
          while (++index < length) {
            var value = array[index], computed = iteratee ? iteratee(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee) {
                seen.push(computed);
              }
              result.push(value);
            } else if (!includes(seen, computed, comparator)) {
              if (seen !== result) {
                seen.push(computed);
              }
              result.push(value);
            }
          }
        return result;
      }
      module2.exports = baseUniq;
    }
  });

  // node_modules/lodash/uniq.js
  var require_uniq = __commonJS({
    "node_modules/lodash/uniq.js"(exports2, module2) {
      var baseUniq = require_baseUniq();
      function uniq(array) {
        return array && array.length ? baseUniq(array) : [];
      }
      module2.exports = uniq;
    }
  });

  // node_modules/chevrotain/lib/src/parse/grammar/first.js
  var require_first = __commonJS({
    "node_modules/chevrotain/lib/src/parse/grammar/first.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.firstForTerminal = exports2.firstForBranching = exports2.firstForSequence = exports2.first = void 0;
      var flatten_1 = __importDefault(require_flatten());
      var uniq_1 = __importDefault(require_uniq());
      var map_1 = __importDefault(require_map());
      var gast_1 = require_api5();
      var gast_2 = require_api5();
      function first(prod) {
        if (prod instanceof gast_1.NonTerminal) {
          return first(prod.referencedRule);
        } else if (prod instanceof gast_1.Terminal) {
          return firstForTerminal(prod);
        } else if ((0, gast_2.isSequenceProd)(prod)) {
          return firstForSequence(prod);
        } else if ((0, gast_2.isBranchingProd)(prod)) {
          return firstForBranching(prod);
        } else {
          throw Error("non exhaustive match");
        }
      }
      exports2.first = first;
      function firstForSequence(prod) {
        var firstSet = [];
        var seq = prod.definition;
        var nextSubProdIdx = 0;
        var hasInnerProdsRemaining = seq.length > nextSubProdIdx;
        var currSubProd;
        var isLastInnerProdOptional = true;
        while (hasInnerProdsRemaining && isLastInnerProdOptional) {
          currSubProd = seq[nextSubProdIdx];
          isLastInnerProdOptional = (0, gast_2.isOptionalProd)(currSubProd);
          firstSet = firstSet.concat(first(currSubProd));
          nextSubProdIdx = nextSubProdIdx + 1;
          hasInnerProdsRemaining = seq.length > nextSubProdIdx;
        }
        return (0, uniq_1.default)(firstSet);
      }
      exports2.firstForSequence = firstForSequence;
      function firstForBranching(prod) {
        var allAlternativesFirsts = (0, map_1.default)(prod.definition, function(innerProd) {
          return first(innerProd);
        });
        return (0, uniq_1.default)((0, flatten_1.default)(allAlternativesFirsts));
      }
      exports2.firstForBranching = firstForBranching;
      function firstForTerminal(terminal) {
        return [terminal.terminalType];
      }
      exports2.firstForTerminal = firstForTerminal;
    }
  });

  // node_modules/chevrotain/lib/src/parse/constants.js
  var require_constants = __commonJS({
    "node_modules/chevrotain/lib/src/parse/constants.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.IN = void 0;
      exports2.IN = "_~IN~_";
    }
  });

  // node_modules/chevrotain/lib/src/parse/grammar/follow.js
  var require_follow = __commonJS({
    "node_modules/chevrotain/lib/src/parse/grammar/follow.js"(exports2) {
      "use strict";
      var __extends = exports2 && exports2.__extends || function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2)
              if (Object.prototype.hasOwnProperty.call(b2, p))
                d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.buildInProdFollowPrefix = exports2.buildBetweenProdsFollowPrefix = exports2.computeAllProdsFollows = exports2.ResyncFollowsWalker = void 0;
      var rest_1 = require_rest();
      var first_1 = require_first();
      var forEach_1 = __importDefault(require_forEach());
      var assign_1 = __importDefault(require_assign());
      var constants_1 = require_constants();
      var gast_1 = require_api5();
      var ResyncFollowsWalker = (
        /** @class */
        function(_super) {
          __extends(ResyncFollowsWalker2, _super);
          function ResyncFollowsWalker2(topProd) {
            var _this = _super.call(this) || this;
            _this.topProd = topProd;
            _this.follows = {};
            return _this;
          }
          ResyncFollowsWalker2.prototype.startWalking = function() {
            this.walk(this.topProd);
            return this.follows;
          };
          ResyncFollowsWalker2.prototype.walkTerminal = function(terminal, currRest, prevRest) {
          };
          ResyncFollowsWalker2.prototype.walkProdRef = function(refProd, currRest, prevRest) {
            var followName = buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) + this.topProd.name;
            var fullRest = currRest.concat(prevRest);
            var restProd = new gast_1.Alternative({ definition: fullRest });
            var t_in_topProd_follows = (0, first_1.first)(restProd);
            this.follows[followName] = t_in_topProd_follows;
          };
          return ResyncFollowsWalker2;
        }(rest_1.RestWalker)
      );
      exports2.ResyncFollowsWalker = ResyncFollowsWalker;
      function computeAllProdsFollows(topProductions) {
        var reSyncFollows = {};
        (0, forEach_1.default)(topProductions, function(topProd) {
          var currRefsFollow = new ResyncFollowsWalker(topProd).startWalking();
          (0, assign_1.default)(reSyncFollows, currRefsFollow);
        });
        return reSyncFollows;
      }
      exports2.computeAllProdsFollows = computeAllProdsFollows;
      function buildBetweenProdsFollowPrefix(inner, occurenceInParent) {
        return inner.name + occurenceInParent + constants_1.IN;
      }
      exports2.buildBetweenProdsFollowPrefix = buildBetweenProdsFollowPrefix;
      function buildInProdFollowPrefix(terminal) {
        var terminalName = terminal.terminalType.name;
        return terminalName + terminal.idx + constants_1.IN;
      }
      exports2.buildInProdFollowPrefix = buildInProdFollowPrefix;
    }
  });

  // node_modules/lodash/isUndefined.js
  var require_isUndefined = __commonJS({
    "node_modules/lodash/isUndefined.js"(exports2, module2) {
      function isUndefined(value) {
        return value === void 0;
      }
      module2.exports = isUndefined;
    }
  });

  // node_modules/lodash/head.js
  var require_head = __commonJS({
    "node_modules/lodash/head.js"(exports2, module2) {
      function head(array) {
        return array && array.length ? array[0] : void 0;
      }
      module2.exports = head;
    }
  });

  // node_modules/lodash/first.js
  var require_first2 = __commonJS({
    "node_modules/lodash/first.js"(exports2, module2) {
      module2.exports = require_head();
    }
  });

  // node_modules/lodash/compact.js
  var require_compact = __commonJS({
    "node_modules/lodash/compact.js"(exports2, module2) {
      function compact(array) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (value) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      module2.exports = compact;
    }
  });

  // node_modules/lodash/_baseFilter.js
  var require_baseFilter = __commonJS({
    "node_modules/lodash/_baseFilter.js"(exports2, module2) {
      var baseEach = require_baseEach();
      function baseFilter(collection, predicate) {
        var result = [];
        baseEach(collection, function(value, index, collection2) {
          if (predicate(value, index, collection2)) {
            result.push(value);
          }
        });
        return result;
      }
      module2.exports = baseFilter;
    }
  });

  // node_modules/lodash/negate.js
  var require_negate = __commonJS({
    "node_modules/lodash/negate.js"(exports2, module2) {
      var FUNC_ERROR_TEXT = "Expected a function";
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      module2.exports = negate;
    }
  });

  // node_modules/lodash/reject.js
  var require_reject = __commonJS({
    "node_modules/lodash/reject.js"(exports2, module2) {
      var arrayFilter = require_arrayFilter();
      var baseFilter = require_baseFilter();
      var baseIteratee = require_baseIteratee();
      var isArray = require_isArray();
      var negate = require_negate();
      function reject(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(baseIteratee(predicate, 3)));
      }
      module2.exports = reject;
    }
  });

  // node_modules/lodash/_baseDifference.js
  var require_baseDifference = __commonJS({
    "node_modules/lodash/_baseDifference.js"(exports2, module2) {
      var SetCache = require_SetCache();
      var arrayIncludes = require_arrayIncludes();
      var arrayIncludesWith = require_arrayIncludesWith();
      var arrayMap = require_arrayMap();
      var baseUnary = require_baseUnary();
      var cacheHas = require_cacheHas();
      var LARGE_ARRAY_SIZE = 200;
      function baseDifference(array, values, iteratee, comparator) {
        var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
        if (!length) {
          return result;
        }
        if (iteratee) {
          values = arrayMap(values, baseUnary(iteratee));
        }
        if (comparator) {
          includes = arrayIncludesWith;
          isCommon = false;
        } else if (values.length >= LARGE_ARRAY_SIZE) {
          includes = cacheHas;
          isCommon = false;
          values = new SetCache(values);
        }
        outer:
          while (++index < length) {
            var value = array[index], computed = iteratee == null ? value : iteratee(value);
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result.push(value);
            } else if (!includes(values, computed, comparator)) {
              result.push(value);
            }
          }
        return result;
      }
      module2.exports = baseDifference;
    }
  });

  // node_modules/lodash/isArrayLikeObject.js
  var require_isArrayLikeObject = __commonJS({
    "node_modules/lodash/isArrayLikeObject.js"(exports2, module2) {
      var isArrayLike = require_isArrayLike();
      var isObjectLike = require_isObjectLike();
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      module2.exports = isArrayLikeObject;
    }
  });

  // node_modules/lodash/difference.js
  var require_difference = __commonJS({
    "node_modules/lodash/difference.js"(exports2, module2) {
      var baseDifference = require_baseDifference();
      var baseFlatten = require_baseFlatten();
      var baseRest = require_baseRest();
      var isArrayLikeObject = require_isArrayLikeObject();
      var difference = baseRest(function(array, values) {
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
      });
      module2.exports = difference;
    }
  });

  // node_modules/lodash/indexOf.js
  var require_indexOf = __commonJS({
    "node_modules/lodash/indexOf.js"(exports2, module2) {
      var baseIndexOf = require_baseIndexOf();
      var toInteger = require_toInteger();
      var nativeMax = Math.max;
      function indexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseIndexOf(array, value, index);
      }
      module2.exports = indexOf;
    }
  });

  // node_modules/lodash/_createFind.js
  var require_createFind = __commonJS({
    "node_modules/lodash/_createFind.js"(exports2, module2) {
      var baseIteratee = require_baseIteratee();
      var isArrayLike = require_isArrayLike();
      var keys = require_keys();
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object(collection);
          if (!isArrayLike(collection)) {
            var iteratee = baseIteratee(predicate, 3);
            collection = keys(collection);
            predicate = function(key) {
              return iteratee(iterable[key], key, iterable);
            };
          }
          var index = findIndexFunc(collection, predicate, fromIndex);
          return index > -1 ? iterable[iteratee ? collection[index] : index] : void 0;
        };
      }
      module2.exports = createFind;
    }
  });

  // node_modules/lodash/findIndex.js
  var require_findIndex = __commonJS({
    "node_modules/lodash/findIndex.js"(exports2, module2) {
      var baseFindIndex = require_baseFindIndex();
      var baseIteratee = require_baseIteratee();
      var toInteger = require_toInteger();
      var nativeMax = Math.max;
      function findIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseFindIndex(array, baseIteratee(predicate, 3), index);
      }
      module2.exports = findIndex;
    }
  });

  // node_modules/lodash/find.js
  var require_find = __commonJS({
    "node_modules/lodash/find.js"(exports2, module2) {
      var createFind = require_createFind();
      var findIndex = require_findIndex();
      var find = createFind(findIndex);
      module2.exports = find;
    }
  });

  // node_modules/lodash/filter.js
  var require_filter = __commonJS({
    "node_modules/lodash/filter.js"(exports2, module2) {
      var arrayFilter = require_arrayFilter();
      var baseFilter = require_baseFilter();
      var baseIteratee = require_baseIteratee();
      var isArray = require_isArray();
      function filter(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, baseIteratee(predicate, 3));
      }
      module2.exports = filter;
    }
  });

  // node_modules/lodash/defaults.js
  var require_defaults = __commonJS({
    "node_modules/lodash/defaults.js"(exports2, module2) {
      var baseRest = require_baseRest();
      var eq = require_eq();
      var isIterateeCall = require_isIterateeCall();
      var keysIn = require_keysIn();
      var objectProto = Object.prototype;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      var defaults = baseRest(function(object, sources) {
        object = Object(object);
        var index = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index < length) {
          var source = sources[index];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value = object[key];
            if (value === void 0 || eq(value, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
              object[key] = source[key];
            }
          }
        }
        return object;
      });
      module2.exports = defaults;
    }
  });

  // node_modules/lodash/_arrayReduce.js
  var require_arrayReduce = __commonJS({
    "node_modules/lodash/_arrayReduce.js"(exports2, module2) {
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      module2.exports = arrayReduce;
    }
  });

  // node_modules/lodash/_baseReduce.js
  var require_baseReduce = __commonJS({
    "node_modules/lodash/_baseReduce.js"(exports2, module2) {
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      module2.exports = baseReduce;
    }
  });

  // node_modules/lodash/reduce.js
  var require_reduce = __commonJS({
    "node_modules/lodash/reduce.js"(exports2, module2) {
      var arrayReduce = require_arrayReduce();
      var baseEach = require_baseEach();
      var baseIteratee = require_baseIteratee();
      var baseReduce = require_baseReduce();
      var isArray = require_isArray();
      function reduce(collection, iteratee, accumulator) {
        var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
      }
      module2.exports = reduce;
    }
  });

  // node_modules/chevrotain/lib/src/scan/reg_exp_parser.js
  var require_reg_exp_parser = __commonJS({
    "node_modules/chevrotain/lib/src/scan/reg_exp_parser.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.clearRegExpParserCache = exports2.getRegExpAst = void 0;
      var regexp_to_ast_1 = require_regexp_to_ast();
      var regExpAstCache = {};
      var regExpParser = new regexp_to_ast_1.RegExpParser();
      function getRegExpAst(regExp) {
        var regExpStr = regExp.toString();
        if (regExpAstCache.hasOwnProperty(regExpStr)) {
          return regExpAstCache[regExpStr];
        } else {
          var regExpAst = regExpParser.pattern(regExpStr);
          regExpAstCache[regExpStr] = regExpAst;
          return regExpAst;
        }
      }
      exports2.getRegExpAst = getRegExpAst;
      function clearRegExpParserCache() {
        regExpAstCache = {};
      }
      exports2.clearRegExpParserCache = clearRegExpParserCache;
    }
  });

  // node_modules/chevrotain/lib/src/scan/reg_exp.js
  var require_reg_exp = __commonJS({
    "node_modules/chevrotain/lib/src/scan/reg_exp.js"(exports2) {
      "use strict";
      var __extends = exports2 && exports2.__extends || function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2)
              if (Object.prototype.hasOwnProperty.call(b2, p))
                d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.canMatchCharCode = exports2.firstCharOptimizedIndices = exports2.getOptimizedStartCodesIndices = exports2.failedOptimizationPrefixMsg = void 0;
      var regexp_to_ast_1 = require_regexp_to_ast();
      var isArray_1 = __importDefault(require_isArray());
      var every_1 = __importDefault(require_every());
      var forEach_1 = __importDefault(require_forEach());
      var find_1 = __importDefault(require_find());
      var values_1 = __importDefault(require_values());
      var includes_1 = __importDefault(require_includes());
      var utils_1 = require_api4();
      var reg_exp_parser_1 = require_reg_exp_parser();
      var lexer_1 = require_lexer();
      var complementErrorMessage = "Complement Sets are not supported for first char optimization";
      exports2.failedOptimizationPrefixMsg = 'Unable to use "first char" lexer optimizations:\n';
      function getOptimizedStartCodesIndices(regExp, ensureOptimizations) {
        if (ensureOptimizations === void 0) {
          ensureOptimizations = false;
        }
        try {
          var ast = (0, reg_exp_parser_1.getRegExpAst)(regExp);
          var firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);
          return firstChars;
        } catch (e) {
          if (e.message === complementErrorMessage) {
            if (ensureOptimizations) {
              (0, utils_1.PRINT_WARNING)("".concat(exports2.failedOptimizationPrefixMsg) + "	Unable to optimize: < ".concat(regExp.toString(), " >\n") + "	Complement Sets cannot be automatically optimized.\n	This will disable the lexer's first char optimizations.\n	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.");
            }
          } else {
            var msgSuffix = "";
            if (ensureOptimizations) {
              msgSuffix = "\n	This will disable the lexer's first char optimizations.\n	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.";
            }
            (0, utils_1.PRINT_ERROR)("".concat(exports2.failedOptimizationPrefixMsg, "\n") + "	Failed parsing: < ".concat(regExp.toString(), " >\n") + "	Using the regexp-to-ast library version: ".concat(regexp_to_ast_1.VERSION, "\n") + "	Please open an issue at: https://github.com/bd82/regexp-to-ast/issues" + msgSuffix);
          }
        }
        return [];
      }
      exports2.getOptimizedStartCodesIndices = getOptimizedStartCodesIndices;
      function firstCharOptimizedIndices(ast, result, ignoreCase) {
        switch (ast.type) {
          case "Disjunction":
            for (var i = 0; i < ast.value.length; i++) {
              firstCharOptimizedIndices(ast.value[i], result, ignoreCase);
            }
            break;
          case "Alternative":
            var terms = ast.value;
            for (var i = 0; i < terms.length; i++) {
              var term = terms[i];
              switch (term.type) {
                case "EndAnchor":
                case "GroupBackReference":
                case "Lookahead":
                case "NegativeLookahead":
                case "StartAnchor":
                case "WordBoundary":
                case "NonWordBoundary":
                  continue;
              }
              var atom = term;
              switch (atom.type) {
                case "Character":
                  addOptimizedIdxToResult(atom.value, result, ignoreCase);
                  break;
                case "Set":
                  if (atom.complement === true) {
                    throw Error(complementErrorMessage);
                  }
                  (0, forEach_1.default)(atom.value, function(code) {
                    if (typeof code === "number") {
                      addOptimizedIdxToResult(code, result, ignoreCase);
                    } else {
                      var range = code;
                      if (ignoreCase === true) {
                        for (var rangeCode = range.from; rangeCode <= range.to; rangeCode++) {
                          addOptimizedIdxToResult(rangeCode, result, ignoreCase);
                        }
                      } else {
                        for (var rangeCode = range.from; rangeCode <= range.to && rangeCode < lexer_1.minOptimizationVal; rangeCode++) {
                          addOptimizedIdxToResult(rangeCode, result, ignoreCase);
                        }
                        if (range.to >= lexer_1.minOptimizationVal) {
                          var minUnOptVal = range.from >= lexer_1.minOptimizationVal ? range.from : lexer_1.minOptimizationVal;
                          var maxUnOptVal = range.to;
                          var minOptIdx = (0, lexer_1.charCodeToOptimizedIndex)(minUnOptVal);
                          var maxOptIdx = (0, lexer_1.charCodeToOptimizedIndex)(maxUnOptVal);
                          for (var currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {
                            result[currOptIdx] = currOptIdx;
                          }
                        }
                      }
                    }
                  });
                  break;
                case "Group":
                  firstCharOptimizedIndices(atom.value, result, ignoreCase);
                  break;
                default:
                  throw Error("Non Exhaustive Match");
              }
              var isOptionalQuantifier = atom.quantifier !== void 0 && atom.quantifier.atLeast === 0;
              if (
                // A group may be optional due to empty contents /(?:)/
                // or if everything inside it is optional /((a)?)/
                atom.type === "Group" && isWholeOptional(atom) === false || // If this term is not a group it may only be optional if it has an optional quantifier
                atom.type !== "Group" && isOptionalQuantifier === false
              ) {
                break;
              }
            }
            break;
          default:
            throw Error("non exhaustive match!");
        }
        return (0, values_1.default)(result);
      }
      exports2.firstCharOptimizedIndices = firstCharOptimizedIndices;
      function addOptimizedIdxToResult(code, result, ignoreCase) {
        var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(code);
        result[optimizedCharIdx] = optimizedCharIdx;
        if (ignoreCase === true) {
          handleIgnoreCase(code, result);
        }
      }
      function handleIgnoreCase(code, result) {
        var char = String.fromCharCode(code);
        var upperChar = char.toUpperCase();
        if (upperChar !== char) {
          var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(upperChar.charCodeAt(0));
          result[optimizedCharIdx] = optimizedCharIdx;
        } else {
          var lowerChar = char.toLowerCase();
          if (lowerChar !== char) {
            var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(lowerChar.charCodeAt(0));
            result[optimizedCharIdx] = optimizedCharIdx;
          }
        }
      }
      function findCode(setNode, targetCharCodes) {
        return (0, find_1.default)(setNode.value, function(codeOrRange) {
          if (typeof codeOrRange === "number") {
            return (0, includes_1.default)(targetCharCodes, codeOrRange);
          } else {
            var range_1 = codeOrRange;
            return (0, find_1.default)(targetCharCodes, function(targetCode) {
              return range_1.from <= targetCode && targetCode <= range_1.to;
            }) !== void 0;
          }
        });
      }
      function isWholeOptional(ast) {
        var quantifier = ast.quantifier;
        if (quantifier && quantifier.atLeast === 0) {
          return true;
        }
        if (!ast.value) {
          return false;
        }
        return (0, isArray_1.default)(ast.value) ? (0, every_1.default)(ast.value, isWholeOptional) : isWholeOptional(ast.value);
      }
      var CharCodeFinder = (
        /** @class */
        function(_super) {
          __extends(CharCodeFinder2, _super);
          function CharCodeFinder2(targetCharCodes) {
            var _this = _super.call(this) || this;
            _this.targetCharCodes = targetCharCodes;
            _this.found = false;
            return _this;
          }
          CharCodeFinder2.prototype.visitChildren = function(node) {
            if (this.found === true) {
              return;
            }
            switch (node.type) {
              case "Lookahead":
                this.visitLookahead(node);
                return;
              case "NegativeLookahead":
                this.visitNegativeLookahead(node);
                return;
            }
            _super.prototype.visitChildren.call(this, node);
          };
          CharCodeFinder2.prototype.visitCharacter = function(node) {
            if ((0, includes_1.default)(this.targetCharCodes, node.value)) {
              this.found = true;
            }
          };
          CharCodeFinder2.prototype.visitSet = function(node) {
            if (node.complement) {
              if (findCode(node, this.targetCharCodes) === void 0) {
                this.found = true;
              }
            } else {
              if (findCode(node, this.targetCharCodes) !== void 0) {
                this.found = true;
              }
            }
          };
          return CharCodeFinder2;
        }(regexp_to_ast_1.BaseRegExpVisitor)
      );
      function canMatchCharCode(charCodes, pattern) {
        if (pattern instanceof RegExp) {
          var ast = (0, reg_exp_parser_1.getRegExpAst)(pattern);
          var charCodeFinder = new CharCodeFinder(charCodes);
          charCodeFinder.visit(ast);
          return charCodeFinder.found;
        } else {
          return (0, find_1.default)(pattern, function(char) {
            return (0, includes_1.default)(charCodes, char.charCodeAt(0));
          }) !== void 0;
        }
      }
      exports2.canMatchCharCode = canMatchCharCode;
    }
  });

  // node_modules/chevrotain/lib/src/scan/lexer.js
  var require_lexer = __commonJS({
    "node_modules/chevrotain/lib/src/scan/lexer.js"(exports2) {
      "use strict";
      var __extends = exports2 && exports2.__extends || function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2)
              if (Object.prototype.hasOwnProperty.call(b2, p))
                d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.charCodeToOptimizedIndex = exports2.minOptimizationVal = exports2.buildLineBreakIssueMessage = exports2.LineTerminatorOptimizedTester = exports2.isShortPattern = exports2.isCustomPattern = exports2.cloneEmptyGroups = exports2.performWarningRuntimeChecks = exports2.performRuntimeChecks = exports2.addStickyFlag = exports2.addStartOfInput = exports2.findUnreachablePatterns = exports2.findModesThatDoNotExist = exports2.findInvalidGroupType = exports2.findDuplicatePatterns = exports2.findUnsupportedFlags = exports2.findStartOfInputAnchor = exports2.findEmptyMatchRegExps = exports2.findEndOfInputAnchor = exports2.findInvalidPatterns = exports2.findMissingPatterns = exports2.validatePatterns = exports2.analyzeTokenTypes = exports2.enableSticky = exports2.disableSticky = exports2.SUPPORT_STICKY = exports2.MODES = exports2.DEFAULT_MODE = void 0;
      var regexp_to_ast_1 = require_regexp_to_ast();
      var lexer_public_1 = require_lexer_public();
      var first_1 = __importDefault(require_first2());
      var isEmpty_1 = __importDefault(require_isEmpty());
      var compact_1 = __importDefault(require_compact());
      var isArray_1 = __importDefault(require_isArray());
      var values_1 = __importDefault(require_values());
      var flatten_1 = __importDefault(require_flatten());
      var reject_1 = __importDefault(require_reject());
      var difference_1 = __importDefault(require_difference());
      var indexOf_1 = __importDefault(require_indexOf());
      var map_1 = __importDefault(require_map());
      var forEach_1 = __importDefault(require_forEach());
      var isString_1 = __importDefault(require_isString());
      var isFunction_1 = __importDefault(require_isFunction());
      var isUndefined_1 = __importDefault(require_isUndefined());
      var find_1 = __importDefault(require_find());
      var has_1 = __importDefault(require_has());
      var keys_1 = __importDefault(require_keys());
      var isRegExp_1 = __importDefault(require_isRegExp());
      var filter_1 = __importDefault(require_filter());
      var defaults_1 = __importDefault(require_defaults());
      var reduce_1 = __importDefault(require_reduce());
      var includes_1 = __importDefault(require_includes());
      var utils_1 = require_api4();
      var reg_exp_1 = require_reg_exp();
      var reg_exp_parser_1 = require_reg_exp_parser();
      var PATTERN = "PATTERN";
      exports2.DEFAULT_MODE = "defaultMode";
      exports2.MODES = "modes";
      exports2.SUPPORT_STICKY = typeof new RegExp("(?:)").sticky === "boolean";
      function disableSticky() {
        exports2.SUPPORT_STICKY = false;
      }
      exports2.disableSticky = disableSticky;
      function enableSticky() {
        exports2.SUPPORT_STICKY = true;
      }
      exports2.enableSticky = enableSticky;
      function analyzeTokenTypes(tokenTypes, options) {
        options = (0, defaults_1.default)(options, {
          useSticky: exports2.SUPPORT_STICKY,
          debug: false,
          safeMode: false,
          positionTracking: "full",
          lineTerminatorCharacters: ["\r", "\n"],
          tracer: function(msg, action) {
            return action();
          }
        });
        var tracer = options.tracer;
        tracer("initCharCodeToOptimizedIndexMap", function() {
          initCharCodeToOptimizedIndexMap();
        });
        var onlyRelevantTypes;
        tracer("Reject Lexer.NA", function() {
          onlyRelevantTypes = (0, reject_1.default)(tokenTypes, function(currType) {
            return currType[PATTERN] === lexer_public_1.Lexer.NA;
          });
        });
        var hasCustom = false;
        var allTransformedPatterns;
        tracer("Transform Patterns", function() {
          hasCustom = false;
          allTransformedPatterns = (0, map_1.default)(onlyRelevantTypes, function(currType) {
            var currPattern = currType[PATTERN];
            if ((0, isRegExp_1.default)(currPattern)) {
              var regExpSource = currPattern.source;
              if (regExpSource.length === 1 && // only these regExp meta characters which can appear in a length one regExp
              regExpSource !== "^" && regExpSource !== "$" && regExpSource !== "." && !currPattern.ignoreCase) {
                return regExpSource;
              } else if (regExpSource.length === 2 && regExpSource[0] === "\\" && // not a meta character
              !(0, includes_1.default)([
                "d",
                "D",
                "s",
                "S",
                "t",
                "r",
                "n",
                "t",
                "0",
                "c",
                "b",
                "B",
                "f",
                "v",
                "w",
                "W"
              ], regExpSource[1])) {
                return regExpSource[1];
              } else {
                return options.useSticky ? addStickyFlag(currPattern) : addStartOfInput(currPattern);
              }
            } else if ((0, isFunction_1.default)(currPattern)) {
              hasCustom = true;
              return { exec: currPattern };
            } else if (typeof currPattern === "object") {
              hasCustom = true;
              return currPattern;
            } else if (typeof currPattern === "string") {
              if (currPattern.length === 1) {
                return currPattern;
              } else {
                var escapedRegExpString = currPattern.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&");
                var wrappedRegExp = new RegExp(escapedRegExpString);
                return options.useSticky ? addStickyFlag(wrappedRegExp) : addStartOfInput(wrappedRegExp);
              }
            } else {
              throw Error("non exhaustive match");
            }
          });
        });
        var patternIdxToType;
        var patternIdxToGroup;
        var patternIdxToLongerAltIdxArr;
        var patternIdxToPushMode;
        var patternIdxToPopMode;
        tracer("misc mapping", function() {
          patternIdxToType = (0, map_1.default)(onlyRelevantTypes, function(currType) {
            return currType.tokenTypeIdx;
          });
          patternIdxToGroup = (0, map_1.default)(onlyRelevantTypes, function(clazz) {
            var groupName = clazz.GROUP;
            if (groupName === lexer_public_1.Lexer.SKIPPED) {
              return void 0;
            } else if ((0, isString_1.default)(groupName)) {
              return groupName;
            } else if ((0, isUndefined_1.default)(groupName)) {
              return false;
            } else {
              throw Error("non exhaustive match");
            }
          });
          patternIdxToLongerAltIdxArr = (0, map_1.default)(onlyRelevantTypes, function(clazz) {
            var longerAltType = clazz.LONGER_ALT;
            if (longerAltType) {
              var longerAltIdxArr = (0, isArray_1.default)(longerAltType) ? (0, map_1.default)(longerAltType, function(type) {
                return (0, indexOf_1.default)(onlyRelevantTypes, type);
              }) : [(0, indexOf_1.default)(onlyRelevantTypes, longerAltType)];
              return longerAltIdxArr;
            }
          });
          patternIdxToPushMode = (0, map_1.default)(onlyRelevantTypes, function(clazz) {
            return clazz.PUSH_MODE;
          });
          patternIdxToPopMode = (0, map_1.default)(onlyRelevantTypes, function(clazz) {
            return (0, has_1.default)(clazz, "POP_MODE");
          });
        });
        var patternIdxToCanLineTerminator;
        tracer("Line Terminator Handling", function() {
          var lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters);
          patternIdxToCanLineTerminator = (0, map_1.default)(onlyRelevantTypes, function(tokType) {
            return false;
          });
          if (options.positionTracking !== "onlyOffset") {
            patternIdxToCanLineTerminator = (0, map_1.default)(onlyRelevantTypes, function(tokType) {
              if ((0, has_1.default)(tokType, "LINE_BREAKS")) {
                return !!tokType.LINE_BREAKS;
              } else {
                return checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false && (0, reg_exp_1.canMatchCharCode)(lineTerminatorCharCodes, tokType.PATTERN);
              }
            });
          }
        });
        var patternIdxToIsCustom;
        var patternIdxToShort;
        var emptyGroups;
        var patternIdxToConfig;
        tracer("Misc Mapping #2", function() {
          patternIdxToIsCustom = (0, map_1.default)(onlyRelevantTypes, isCustomPattern);
          patternIdxToShort = (0, map_1.default)(allTransformedPatterns, isShortPattern);
          emptyGroups = (0, reduce_1.default)(onlyRelevantTypes, function(acc, clazz) {
            var groupName = clazz.GROUP;
            if ((0, isString_1.default)(groupName) && !(groupName === lexer_public_1.Lexer.SKIPPED)) {
              acc[groupName] = [];
            }
            return acc;
          }, {});
          patternIdxToConfig = (0, map_1.default)(allTransformedPatterns, function(x, idx) {
            return {
              pattern: allTransformedPatterns[idx],
              longerAlt: patternIdxToLongerAltIdxArr[idx],
              canLineTerminator: patternIdxToCanLineTerminator[idx],
              isCustom: patternIdxToIsCustom[idx],
              short: patternIdxToShort[idx],
              group: patternIdxToGroup[idx],
              push: patternIdxToPushMode[idx],
              pop: patternIdxToPopMode[idx],
              tokenTypeIdx: patternIdxToType[idx],
              tokenType: onlyRelevantTypes[idx]
            };
          });
        });
        var canBeOptimized = true;
        var charCodeToPatternIdxToConfig = [];
        if (!options.safeMode) {
          tracer("First Char Optimization", function() {
            charCodeToPatternIdxToConfig = (0, reduce_1.default)(onlyRelevantTypes, function(result, currTokType, idx) {
              if (typeof currTokType.PATTERN === "string") {
                var charCode = currTokType.PATTERN.charCodeAt(0);
                var optimizedIdx = charCodeToOptimizedIndex(charCode);
                addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);
              } else if ((0, isArray_1.default)(currTokType.START_CHARS_HINT)) {
                var lastOptimizedIdx_1;
                (0, forEach_1.default)(currTokType.START_CHARS_HINT, function(charOrInt) {
                  var charCode2 = typeof charOrInt === "string" ? charOrInt.charCodeAt(0) : charOrInt;
                  var currOptimizedIdx = charCodeToOptimizedIndex(charCode2);
                  if (lastOptimizedIdx_1 !== currOptimizedIdx) {
                    lastOptimizedIdx_1 = currOptimizedIdx;
                    addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx]);
                  }
                });
              } else if ((0, isRegExp_1.default)(currTokType.PATTERN)) {
                if (currTokType.PATTERN.unicode) {
                  canBeOptimized = false;
                  if (options.ensureOptimizations) {
                    (0, utils_1.PRINT_ERROR)("".concat(reg_exp_1.failedOptimizationPrefixMsg) + "	Unable to analyze < ".concat(currTokType.PATTERN.toString(), " > pattern.\n") + "	The regexp unicode flag is not currently supported by the regexp-to-ast library.\n	This will disable the lexer's first char optimizations.\n	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE");
                  }
                } else {
                  var optimizedCodes = (0, reg_exp_1.getOptimizedStartCodesIndices)(currTokType.PATTERN, options.ensureOptimizations);
                  if ((0, isEmpty_1.default)(optimizedCodes)) {
                    canBeOptimized = false;
                  }
                  (0, forEach_1.default)(optimizedCodes, function(code) {
                    addToMapOfArrays(result, code, patternIdxToConfig[idx]);
                  });
                }
              } else {
                if (options.ensureOptimizations) {
                  (0, utils_1.PRINT_ERROR)("".concat(reg_exp_1.failedOptimizationPrefixMsg) + "	TokenType: <".concat(currTokType.name, "> is using a custom token pattern without providing <start_chars_hint> parameter.\n") + "	This will disable the lexer's first char optimizations.\n	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE");
                }
                canBeOptimized = false;
              }
              return result;
            }, []);
          });
        }
        return {
          emptyGroups,
          patternIdxToConfig,
          charCodeToPatternIdxToConfig,
          hasCustom,
          canBeOptimized
        };
      }
      exports2.analyzeTokenTypes = analyzeTokenTypes;
      function validatePatterns(tokenTypes, validModesNames) {
        var errors = [];
        var missingResult = findMissingPatterns(tokenTypes);
        errors = errors.concat(missingResult.errors);
        var invalidResult = findInvalidPatterns(missingResult.valid);
        var validTokenTypes = invalidResult.valid;
        errors = errors.concat(invalidResult.errors);
        errors = errors.concat(validateRegExpPattern(validTokenTypes));
        errors = errors.concat(findInvalidGroupType(validTokenTypes));
        errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames));
        errors = errors.concat(findUnreachablePatterns(validTokenTypes));
        return errors;
      }
      exports2.validatePatterns = validatePatterns;
      function validateRegExpPattern(tokenTypes) {
        var errors = [];
        var withRegExpPatterns = (0, filter_1.default)(tokenTypes, function(currTokType) {
          return (0, isRegExp_1.default)(currTokType[PATTERN]);
        });
        errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));
        errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));
        errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));
        errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));
        errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));
        return errors;
      }
      function findMissingPatterns(tokenTypes) {
        var tokenTypesWithMissingPattern = (0, filter_1.default)(tokenTypes, function(currType) {
          return !(0, has_1.default)(currType, PATTERN);
        });
        var errors = (0, map_1.default)(tokenTypesWithMissingPattern, function(currType) {
          return {
            message: "Token Type: ->" + currType.name + "<- missing static 'PATTERN' property",
            type: lexer_public_1.LexerDefinitionErrorType.MISSING_PATTERN,
            tokenTypes: [currType]
          };
        });
        var valid = (0, difference_1.default)(tokenTypes, tokenTypesWithMissingPattern);
        return { errors, valid };
      }
      exports2.findMissingPatterns = findMissingPatterns;
      function findInvalidPatterns(tokenTypes) {
        var tokenTypesWithInvalidPattern = (0, filter_1.default)(tokenTypes, function(currType) {
          var pattern = currType[PATTERN];
          return !(0, isRegExp_1.default)(pattern) && !(0, isFunction_1.default)(pattern) && !(0, has_1.default)(pattern, "exec") && !(0, isString_1.default)(pattern);
        });
        var errors = (0, map_1.default)(tokenTypesWithInvalidPattern, function(currType) {
          return {
            message: "Token Type: ->" + currType.name + "<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.",
            type: lexer_public_1.LexerDefinitionErrorType.INVALID_PATTERN,
            tokenTypes: [currType]
          };
        });
        var valid = (0, difference_1.default)(tokenTypes, tokenTypesWithInvalidPattern);
        return { errors, valid };
      }
      exports2.findInvalidPatterns = findInvalidPatterns;
      var end_of_input = /[^\\][$]/;
      function findEndOfInputAnchor(tokenTypes) {
        var EndAnchorFinder = (
          /** @class */
          function(_super) {
            __extends(EndAnchorFinder2, _super);
            function EndAnchorFinder2() {
              var _this = _super !== null && _super.apply(this, arguments) || this;
              _this.found = false;
              return _this;
            }
            EndAnchorFinder2.prototype.visitEndAnchor = function(node) {
              this.found = true;
            };
            return EndAnchorFinder2;
          }(regexp_to_ast_1.BaseRegExpVisitor)
        );
        var invalidRegex = (0, filter_1.default)(tokenTypes, function(currType) {
          var pattern = currType.PATTERN;
          try {
            var regexpAst = (0, reg_exp_parser_1.getRegExpAst)(pattern);
            var endAnchorVisitor = new EndAnchorFinder();
            endAnchorVisitor.visit(regexpAst);
            return endAnchorVisitor.found;
          } catch (e) {
            return end_of_input.test(pattern.source);
          }
        });
        var errors = (0, map_1.default)(invalidRegex, function(currType) {
          return {
            message: "Unexpected RegExp Anchor Error:\n	Token Type: ->" + currType.name + "<- static 'PATTERN' cannot contain end of input anchor '$'\n	See chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.",
            type: lexer_public_1.LexerDefinitionErrorType.EOI_ANCHOR_FOUND,
            tokenTypes: [currType]
          };
        });
        return errors;
      }
      exports2.findEndOfInputAnchor = findEndOfInputAnchor;
      function findEmptyMatchRegExps(tokenTypes) {
        var matchesEmptyString = (0, filter_1.default)(tokenTypes, function(currType) {
          var pattern = currType.PATTERN;
          return pattern.test("");
        });
        var errors = (0, map_1.default)(matchesEmptyString, function(currType) {
          return {
            message: "Token Type: ->" + currType.name + "<- static 'PATTERN' must not match an empty string",
            type: lexer_public_1.LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,
            tokenTypes: [currType]
          };
        });
        return errors;
      }
      exports2.findEmptyMatchRegExps = findEmptyMatchRegExps;
      var start_of_input = /[^\\[][\^]|^\^/;
      function findStartOfInputAnchor(tokenTypes) {
        var StartAnchorFinder = (
          /** @class */
          function(_super) {
            __extends(StartAnchorFinder2, _super);
            function StartAnchorFinder2() {
              var _this = _super !== null && _super.apply(this, arguments) || this;
              _this.found = false;
              return _this;
            }
            StartAnchorFinder2.prototype.visitStartAnchor = function(node) {
              this.found = true;
            };
            return StartAnchorFinder2;
          }(regexp_to_ast_1.BaseRegExpVisitor)
        );
        var invalidRegex = (0, filter_1.default)(tokenTypes, function(currType) {
          var pattern = currType.PATTERN;
          try {
            var regexpAst = (0, reg_exp_parser_1.getRegExpAst)(pattern);
            var startAnchorVisitor = new StartAnchorFinder();
            startAnchorVisitor.visit(regexpAst);
            return startAnchorVisitor.found;
          } catch (e) {
            return start_of_input.test(pattern.source);
          }
        });
        var errors = (0, map_1.default)(invalidRegex, function(currType) {
          return {
            message: "Unexpected RegExp Anchor Error:\n	Token Type: ->" + currType.name + "<- static 'PATTERN' cannot contain start of input anchor '^'\n	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.",
            type: lexer_public_1.LexerDefinitionErrorType.SOI_ANCHOR_FOUND,
            tokenTypes: [currType]
          };
        });
        return errors;
      }
      exports2.findStartOfInputAnchor = findStartOfInputAnchor;
      function findUnsupportedFlags(tokenTypes) {
        var invalidFlags = (0, filter_1.default)(tokenTypes, function(currType) {
          var pattern = currType[PATTERN];
          return pattern instanceof RegExp && (pattern.multiline || pattern.global);
        });
        var errors = (0, map_1.default)(invalidFlags, function(currType) {
          return {
            message: "Token Type: ->" + currType.name + "<- static 'PATTERN' may NOT contain global('g') or multiline('m')",
            type: lexer_public_1.LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,
            tokenTypes: [currType]
          };
        });
        return errors;
      }
      exports2.findUnsupportedFlags = findUnsupportedFlags;
      function findDuplicatePatterns(tokenTypes) {
        var found = [];
        var identicalPatterns = (0, map_1.default)(tokenTypes, function(outerType) {
          return (0, reduce_1.default)(tokenTypes, function(result, innerType) {
            if (outerType.PATTERN.source === innerType.PATTERN.source && !(0, includes_1.default)(found, innerType) && innerType.PATTERN !== lexer_public_1.Lexer.NA) {
              found.push(innerType);
              result.push(innerType);
              return result;
            }
            return result;
          }, []);
        });
        identicalPatterns = (0, compact_1.default)(identicalPatterns);
        var duplicatePatterns = (0, filter_1.default)(identicalPatterns, function(currIdenticalSet) {
          return currIdenticalSet.length > 1;
        });
        var errors = (0, map_1.default)(duplicatePatterns, function(setOfIdentical) {
          var tokenTypeNames = (0, map_1.default)(setOfIdentical, function(currType) {
            return currType.name;
          });
          var dupPatternSrc = (0, first_1.default)(setOfIdentical).PATTERN;
          return {
            message: "The same RegExp pattern ->".concat(dupPatternSrc, "<-") + "has been used in all of the following Token Types: ".concat(tokenTypeNames.join(", "), " <-"),
            type: lexer_public_1.LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,
            tokenTypes: setOfIdentical
          };
        });
        return errors;
      }
      exports2.findDuplicatePatterns = findDuplicatePatterns;
      function findInvalidGroupType(tokenTypes) {
        var invalidTypes = (0, filter_1.default)(tokenTypes, function(clazz) {
          if (!(0, has_1.default)(clazz, "GROUP")) {
            return false;
          }
          var group = clazz.GROUP;
          return group !== lexer_public_1.Lexer.SKIPPED && group !== lexer_public_1.Lexer.NA && !(0, isString_1.default)(group);
        });
        var errors = (0, map_1.default)(invalidTypes, function(currType) {
          return {
            message: "Token Type: ->" + currType.name + "<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String",
            type: lexer_public_1.LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,
            tokenTypes: [currType]
          };
        });
        return errors;
      }
      exports2.findInvalidGroupType = findInvalidGroupType;
      function findModesThatDoNotExist(tokenTypes, validModes) {
        var invalidModes = (0, filter_1.default)(tokenTypes, function(clazz) {
          return clazz.PUSH_MODE !== void 0 && !(0, includes_1.default)(validModes, clazz.PUSH_MODE);
        });
        var errors = (0, map_1.default)(invalidModes, function(tokType) {
          var msg = "Token Type: ->".concat(tokType.name, "<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->").concat(tokType.PUSH_MODE, "<-") + "which does not exist";
          return {
            message: msg,
            type: lexer_public_1.LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,
            tokenTypes: [tokType]
          };
        });
        return errors;
      }
      exports2.findModesThatDoNotExist = findModesThatDoNotExist;
      function findUnreachablePatterns(tokenTypes) {
        var errors = [];
        var canBeTested = (0, reduce_1.default)(tokenTypes, function(result, tokType, idx) {
          var pattern = tokType.PATTERN;
          if (pattern === lexer_public_1.Lexer.NA) {
            return result;
          }
          if ((0, isString_1.default)(pattern)) {
            result.push({ str: pattern, idx, tokenType: tokType });
          } else if ((0, isRegExp_1.default)(pattern) && noMetaChar(pattern)) {
            result.push({ str: pattern.source, idx, tokenType: tokType });
          }
          return result;
        }, []);
        (0, forEach_1.default)(tokenTypes, function(tokType, testIdx) {
          (0, forEach_1.default)(canBeTested, function(_a4) {
            var str = _a4.str, idx = _a4.idx, tokenType = _a4.tokenType;
            if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {
              var msg = "Token: ->".concat(tokenType.name, "<- can never be matched.\n") + "Because it appears AFTER the Token Type ->".concat(tokType.name, "<-") + "in the lexer's definition.\nSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE";
              errors.push({
                message: msg,
                type: lexer_public_1.LexerDefinitionErrorType.UNREACHABLE_PATTERN,
                tokenTypes: [tokType, tokenType]
              });
            }
          });
        });
        return errors;
      }
      exports2.findUnreachablePatterns = findUnreachablePatterns;
      function testTokenType(str, pattern) {
        if ((0, isRegExp_1.default)(pattern)) {
          var regExpArray = pattern.exec(str);
          return regExpArray !== null && regExpArray.index === 0;
        } else if ((0, isFunction_1.default)(pattern)) {
          return pattern(str, 0, [], {});
        } else if ((0, has_1.default)(pattern, "exec")) {
          return pattern.exec(str, 0, [], {});
        } else if (typeof pattern === "string") {
          return pattern === str;
        } else {
          throw Error("non exhaustive match");
        }
      }
      function noMetaChar(regExp) {
        var metaChars = [
          ".",
          "\\",
          "[",
          "]",
          "|",
          "^",
          "$",
          "(",
          ")",
          "?",
          "*",
          "+",
          "{"
        ];
        return (0, find_1.default)(metaChars, function(char) {
          return regExp.source.indexOf(char) !== -1;
        }) === void 0;
      }
      function addStartOfInput(pattern) {
        var flags = pattern.ignoreCase ? "i" : "";
        return new RegExp("^(?:".concat(pattern.source, ")"), flags);
      }
      exports2.addStartOfInput = addStartOfInput;
      function addStickyFlag(pattern) {
        var flags = pattern.ignoreCase ? "iy" : "y";
        return new RegExp("".concat(pattern.source), flags);
      }
      exports2.addStickyFlag = addStickyFlag;
      function performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {
        var errors = [];
        if (!(0, has_1.default)(lexerDefinition, exports2.DEFAULT_MODE)) {
          errors.push({
            message: "A MultiMode Lexer cannot be initialized without a <" + exports2.DEFAULT_MODE + "> property in its definition\n",
            type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE
          });
        }
        if (!(0, has_1.default)(lexerDefinition, exports2.MODES)) {
          errors.push({
            message: "A MultiMode Lexer cannot be initialized without a <" + exports2.MODES + "> property in its definition\n",
            type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY
          });
        }
        if ((0, has_1.default)(lexerDefinition, exports2.MODES) && (0, has_1.default)(lexerDefinition, exports2.DEFAULT_MODE) && !(0, has_1.default)(lexerDefinition.modes, lexerDefinition.defaultMode)) {
          errors.push({
            message: "A MultiMode Lexer cannot be initialized with a ".concat(exports2.DEFAULT_MODE, ": <").concat(lexerDefinition.defaultMode, ">") + "which does not exist\n",
            type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST
          });
        }
        if ((0, has_1.default)(lexerDefinition, exports2.MODES)) {
          (0, forEach_1.default)(lexerDefinition.modes, function(currModeValue, currModeName) {
            (0, forEach_1.default)(currModeValue, function(currTokType, currIdx) {
              if ((0, isUndefined_1.default)(currTokType)) {
                errors.push({
                  message: "A Lexer cannot be initialized using an undefined Token Type. Mode:" + "<".concat(currModeName, "> at index: <").concat(currIdx, ">\n"),
                  type: lexer_public_1.LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED
                });
              } else if ((0, has_1.default)(currTokType, "LONGER_ALT")) {
                var longerAlt = (0, isArray_1.default)(currTokType.LONGER_ALT) ? currTokType.LONGER_ALT : [currTokType.LONGER_ALT];
                (0, forEach_1.default)(longerAlt, function(currLongerAlt) {
                  if (!(0, isUndefined_1.default)(currLongerAlt) && !(0, includes_1.default)(currModeValue, currLongerAlt)) {
                    errors.push({
                      message: "A MultiMode Lexer cannot be initialized with a longer_alt <".concat(currLongerAlt.name, "> on token <").concat(currTokType.name, "> outside of mode <").concat(currModeName, ">\n"),
                      type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE
                    });
                  }
                });
              }
            });
          });
        }
        return errors;
      }
      exports2.performRuntimeChecks = performRuntimeChecks;
      function performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {
        var warnings = [];
        var hasAnyLineBreak = false;
        var allTokenTypes = (0, compact_1.default)((0, flatten_1.default)((0, values_1.default)(lexerDefinition.modes)));
        var concreteTokenTypes = (0, reject_1.default)(allTokenTypes, function(currType) {
          return currType[PATTERN] === lexer_public_1.Lexer.NA;
        });
        var terminatorCharCodes = getCharCodes(lineTerminatorCharacters);
        if (trackLines) {
          (0, forEach_1.default)(concreteTokenTypes, function(tokType) {
            var currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);
            if (currIssue !== false) {
              var message = buildLineBreakIssueMessage(tokType, currIssue);
              var warningDescriptor = {
                message,
                type: currIssue.issue,
                tokenType: tokType
              };
              warnings.push(warningDescriptor);
            } else {
              if ((0, has_1.default)(tokType, "LINE_BREAKS")) {
                if (tokType.LINE_BREAKS === true) {
                  hasAnyLineBreak = true;
                }
              } else {
                if ((0, reg_exp_1.canMatchCharCode)(terminatorCharCodes, tokType.PATTERN)) {
                  hasAnyLineBreak = true;
                }
              }
            }
          });
        }
        if (trackLines && !hasAnyLineBreak) {
          warnings.push({
            message: "Warning: No LINE_BREAKS Found.\n	This Lexer has been defined to track line and column information,\n	But none of the Token Types can be identified as matching a line terminator.\n	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \n	for details.",
            type: lexer_public_1.LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS
          });
        }
        return warnings;
      }
      exports2.performWarningRuntimeChecks = performWarningRuntimeChecks;
      function cloneEmptyGroups(emptyGroups) {
        var clonedResult = {};
        var groupKeys = (0, keys_1.default)(emptyGroups);
        (0, forEach_1.default)(groupKeys, function(currKey) {
          var currGroupValue = emptyGroups[currKey];
          if ((0, isArray_1.default)(currGroupValue)) {
            clonedResult[currKey] = [];
          } else {
            throw Error("non exhaustive match");
          }
        });
        return clonedResult;
      }
      exports2.cloneEmptyGroups = cloneEmptyGroups;
      function isCustomPattern(tokenType) {
        var pattern = tokenType.PATTERN;
        if ((0, isRegExp_1.default)(pattern)) {
          return false;
        } else if ((0, isFunction_1.default)(pattern)) {
          return true;
        } else if ((0, has_1.default)(pattern, "exec")) {
          return true;
        } else if ((0, isString_1.default)(pattern)) {
          return false;
        } else {
          throw Error("non exhaustive match");
        }
      }
      exports2.isCustomPattern = isCustomPattern;
      function isShortPattern(pattern) {
        if ((0, isString_1.default)(pattern) && pattern.length === 1) {
          return pattern.charCodeAt(0);
        } else {
          return false;
        }
      }
      exports2.isShortPattern = isShortPattern;
      exports2.LineTerminatorOptimizedTester = {
        // implements /\n|\r\n?/g.test
        test: function(text) {
          var len = text.length;
          for (var i = this.lastIndex; i < len; i++) {
            var c = text.charCodeAt(i);
            if (c === 10) {
              this.lastIndex = i + 1;
              return true;
            } else if (c === 13) {
              if (text.charCodeAt(i + 1) === 10) {
                this.lastIndex = i + 2;
              } else {
                this.lastIndex = i + 1;
              }
              return true;
            }
          }
          return false;
        },
        lastIndex: 0
      };
      function checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {
        if ((0, has_1.default)(tokType, "LINE_BREAKS")) {
          return false;
        } else {
          if ((0, isRegExp_1.default)(tokType.PATTERN)) {
            try {
              (0, reg_exp_1.canMatchCharCode)(lineTerminatorCharCodes, tokType.PATTERN);
            } catch (e) {
              return {
                issue: lexer_public_1.LexerDefinitionErrorType.IDENTIFY_TERMINATOR,
                errMsg: e.message
              };
            }
            return false;
          } else if ((0, isString_1.default)(tokType.PATTERN)) {
            return false;
          } else if (isCustomPattern(tokType)) {
            return { issue: lexer_public_1.LexerDefinitionErrorType.CUSTOM_LINE_BREAK };
          } else {
            throw Error("non exhaustive match");
          }
        }
      }
      function buildLineBreakIssueMessage(tokType, details) {
        if (details.issue === lexer_public_1.LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {
          return "Warning: unable to identify line terminator usage in pattern.\n" + "	The problem is in the <".concat(tokType.name, "> Token Type\n") + "	 Root cause: ".concat(details.errMsg, ".\n") + "	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR";
        } else if (details.issue === lexer_public_1.LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {
          return "Warning: A Custom Token Pattern should specify the <line_breaks> option.\n" + "	The problem is in the <".concat(tokType.name, "> Token Type\n") + "	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK";
        } else {
          throw Error("non exhaustive match");
        }
      }
      exports2.buildLineBreakIssueMessage = buildLineBreakIssueMessage;
      function getCharCodes(charsOrCodes) {
        var charCodes = (0, map_1.default)(charsOrCodes, function(numOrString) {
          if ((0, isString_1.default)(numOrString)) {
            return numOrString.charCodeAt(0);
          } else {
            return numOrString;
          }
        });
        return charCodes;
      }
      function addToMapOfArrays(map, key, value) {
        if (map[key] === void 0) {
          map[key] = [value];
        } else {
          map[key].push(value);
        }
      }
      exports2.minOptimizationVal = 256;
      var charCodeToOptimizedIdxMap = [];
      function charCodeToOptimizedIndex(charCode) {
        return charCode < exports2.minOptimizationVal ? charCode : charCodeToOptimizedIdxMap[charCode];
      }
      exports2.charCodeToOptimizedIndex = charCodeToOptimizedIndex;
      function initCharCodeToOptimizedIndexMap() {
        if ((0, isEmpty_1.default)(charCodeToOptimizedIdxMap)) {
          charCodeToOptimizedIdxMap = new Array(65536);
          for (var i = 0; i < 65536; i++) {
            charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i;
          }
        }
      }
    }
  });

  // node_modules/lodash/last.js
  var require_last = __commonJS({
    "node_modules/lodash/last.js"(exports2, module2) {
      function last(array) {
        var length = array == null ? 0 : array.length;
        return length ? array[length - 1] : void 0;
      }
      module2.exports = last;
    }
  });

  // node_modules/chevrotain/lib/src/scan/tokens.js
  var require_tokens = __commonJS({
    "node_modules/chevrotain/lib/src/scan/tokens.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.isTokenType = exports2.hasExtendingTokensTypesMapProperty = exports2.hasExtendingTokensTypesProperty = exports2.hasCategoriesProperty = exports2.hasShortKeyProperty = exports2.singleAssignCategoriesToksMap = exports2.assignCategoriesMapProp = exports2.assignCategoriesTokensProp = exports2.assignTokenDefaultProps = exports2.expandCategories = exports2.augmentTokenTypes = exports2.tokenIdxToClass = exports2.tokenShortNameIdx = exports2.tokenStructuredMatcherNoCategories = exports2.tokenStructuredMatcher = void 0;
      var isEmpty_1 = __importDefault(require_isEmpty());
      var compact_1 = __importDefault(require_compact());
      var isArray_1 = __importDefault(require_isArray());
      var flatten_1 = __importDefault(require_flatten());
      var difference_1 = __importDefault(require_difference());
      var map_1 = __importDefault(require_map());
      var forEach_1 = __importDefault(require_forEach());
      var has_1 = __importDefault(require_has());
      var includes_1 = __importDefault(require_includes());
      var clone_1 = __importDefault(require_clone());
      function tokenStructuredMatcher(tokInstance, tokConstructor) {
        var instanceType = tokInstance.tokenTypeIdx;
        if (instanceType === tokConstructor.tokenTypeIdx) {
          return true;
        } else {
          return tokConstructor.isParent === true && tokConstructor.categoryMatchesMap[instanceType] === true;
        }
      }
      exports2.tokenStructuredMatcher = tokenStructuredMatcher;
      function tokenStructuredMatcherNoCategories(token, tokType) {
        return token.tokenTypeIdx === tokType.tokenTypeIdx;
      }
      exports2.tokenStructuredMatcherNoCategories = tokenStructuredMatcherNoCategories;
      exports2.tokenShortNameIdx = 1;
      exports2.tokenIdxToClass = {};
      function augmentTokenTypes(tokenTypes) {
        var tokenTypesAndParents = expandCategories(tokenTypes);
        assignTokenDefaultProps(tokenTypesAndParents);
        assignCategoriesMapProp(tokenTypesAndParents);
        assignCategoriesTokensProp(tokenTypesAndParents);
        (0, forEach_1.default)(tokenTypesAndParents, function(tokType) {
          tokType.isParent = tokType.categoryMatches.length > 0;
        });
      }
      exports2.augmentTokenTypes = augmentTokenTypes;
      function expandCategories(tokenTypes) {
        var result = (0, clone_1.default)(tokenTypes);
        var categories = tokenTypes;
        var searching = true;
        while (searching) {
          categories = (0, compact_1.default)((0, flatten_1.default)((0, map_1.default)(categories, function(currTokType) {
            return currTokType.CATEGORIES;
          })));
          var newCategories = (0, difference_1.default)(categories, result);
          result = result.concat(newCategories);
          if ((0, isEmpty_1.default)(newCategories)) {
            searching = false;
          } else {
            categories = newCategories;
          }
        }
        return result;
      }
      exports2.expandCategories = expandCategories;
      function assignTokenDefaultProps(tokenTypes) {
        (0, forEach_1.default)(tokenTypes, function(currTokType) {
          if (!hasShortKeyProperty(currTokType)) {
            exports2.tokenIdxToClass[exports2.tokenShortNameIdx] = currTokType;
            currTokType.tokenTypeIdx = exports2.tokenShortNameIdx++;
          }
          if (hasCategoriesProperty(currTokType) && !(0, isArray_1.default)(currTokType.CATEGORIES)) {
            currTokType.CATEGORIES = [currTokType.CATEGORIES];
          }
          if (!hasCategoriesProperty(currTokType)) {
            currTokType.CATEGORIES = [];
          }
          if (!hasExtendingTokensTypesProperty(currTokType)) {
            currTokType.categoryMatches = [];
          }
          if (!hasExtendingTokensTypesMapProperty(currTokType)) {
            currTokType.categoryMatchesMap = {};
          }
        });
      }
      exports2.assignTokenDefaultProps = assignTokenDefaultProps;
      function assignCategoriesTokensProp(tokenTypes) {
        (0, forEach_1.default)(tokenTypes, function(currTokType) {
          currTokType.categoryMatches = [];
          (0, forEach_1.default)(currTokType.categoryMatchesMap, function(val, key) {
            currTokType.categoryMatches.push(exports2.tokenIdxToClass[key].tokenTypeIdx);
          });
        });
      }
      exports2.assignCategoriesTokensProp = assignCategoriesTokensProp;
      function assignCategoriesMapProp(tokenTypes) {
        (0, forEach_1.default)(tokenTypes, function(currTokType) {
          singleAssignCategoriesToksMap([], currTokType);
        });
      }
      exports2.assignCategoriesMapProp = assignCategoriesMapProp;
      function singleAssignCategoriesToksMap(path, nextNode) {
        (0, forEach_1.default)(path, function(pathNode) {
          nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;
        });
        (0, forEach_1.default)(nextNode.CATEGORIES, function(nextCategory) {
          var newPath = path.concat(nextNode);
          if (!(0, includes_1.default)(newPath, nextCategory)) {
            singleAssignCategoriesToksMap(newPath, nextCategory);
          }
        });
      }
      exports2.singleAssignCategoriesToksMap = singleAssignCategoriesToksMap;
      function hasShortKeyProperty(tokType) {
        return (0, has_1.default)(tokType, "tokenTypeIdx");
      }
      exports2.hasShortKeyProperty = hasShortKeyProperty;
      function hasCategoriesProperty(tokType) {
        return (0, has_1.default)(tokType, "CATEGORIES");
      }
      exports2.hasCategoriesProperty = hasCategoriesProperty;
      function hasExtendingTokensTypesProperty(tokType) {
        return (0, has_1.default)(tokType, "categoryMatches");
      }
      exports2.hasExtendingTokensTypesProperty = hasExtendingTokensTypesProperty;
      function hasExtendingTokensTypesMapProperty(tokType) {
        return (0, has_1.default)(tokType, "categoryMatchesMap");
      }
      exports2.hasExtendingTokensTypesMapProperty = hasExtendingTokensTypesMapProperty;
      function isTokenType(tokType) {
        return (0, has_1.default)(tokType, "tokenTypeIdx");
      }
      exports2.isTokenType = isTokenType;
    }
  });

  // node_modules/chevrotain/lib/src/scan/lexer_errors_public.js
  var require_lexer_errors_public = __commonJS({
    "node_modules/chevrotain/lib/src/scan/lexer_errors_public.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.defaultLexerErrorProvider = void 0;
      exports2.defaultLexerErrorProvider = {
        buildUnableToPopLexerModeMessage: function(token) {
          return "Unable to pop Lexer Mode after encountering Token ->".concat(token.image, "<- The Mode Stack is empty");
        },
        buildUnexpectedCharactersMessage: function(fullText, startOffset, length, line, column) {
          return "unexpected character: ->".concat(fullText.charAt(startOffset), "<- at offset: ").concat(startOffset, ",") + " skipped ".concat(length, " characters.");
        }
      };
    }
  });

  // node_modules/chevrotain/lib/src/scan/lexer_public.js
  var require_lexer_public = __commonJS({
    "node_modules/chevrotain/lib/src/scan/lexer_public.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Lexer = exports2.LexerDefinitionErrorType = void 0;
      var lexer_1 = require_lexer();
      var noop_1 = __importDefault(require_noop());
      var isEmpty_1 = __importDefault(require_isEmpty());
      var isArray_1 = __importDefault(require_isArray());
      var last_1 = __importDefault(require_last());
      var reject_1 = __importDefault(require_reject());
      var map_1 = __importDefault(require_map());
      var forEach_1 = __importDefault(require_forEach());
      var keys_1 = __importDefault(require_keys());
      var isUndefined_1 = __importDefault(require_isUndefined());
      var identity_1 = __importDefault(require_identity());
      var assign_1 = __importDefault(require_assign());
      var reduce_1 = __importDefault(require_reduce());
      var clone_1 = __importDefault(require_clone());
      var utils_1 = require_api4();
      var tokens_1 = require_tokens();
      var lexer_errors_public_1 = require_lexer_errors_public();
      var reg_exp_parser_1 = require_reg_exp_parser();
      var LexerDefinitionErrorType;
      (function(LexerDefinitionErrorType2) {
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["MISSING_PATTERN"] = 0] = "MISSING_PATTERN";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["INVALID_PATTERN"] = 1] = "INVALID_PATTERN";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["EOI_ANCHOR_FOUND"] = 2] = "EOI_ANCHOR_FOUND";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["UNSUPPORTED_FLAGS_FOUND"] = 3] = "UNSUPPORTED_FLAGS_FOUND";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["DUPLICATE_PATTERNS_FOUND"] = 4] = "DUPLICATE_PATTERNS_FOUND";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["INVALID_GROUP_TYPE_FOUND"] = 5] = "INVALID_GROUP_TYPE_FOUND";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["PUSH_MODE_DOES_NOT_EXIST"] = 6] = "PUSH_MODE_DOES_NOT_EXIST";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE"] = 7] = "MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY"] = 8] = "MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST"] = 9] = "MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED"] = 10] = "LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["SOI_ANCHOR_FOUND"] = 11] = "SOI_ANCHOR_FOUND";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["EMPTY_MATCH_PATTERN"] = 12] = "EMPTY_MATCH_PATTERN";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["NO_LINE_BREAKS_FLAGS"] = 13] = "NO_LINE_BREAKS_FLAGS";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["UNREACHABLE_PATTERN"] = 14] = "UNREACHABLE_PATTERN";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["IDENTIFY_TERMINATOR"] = 15] = "IDENTIFY_TERMINATOR";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["CUSTOM_LINE_BREAK"] = 16] = "CUSTOM_LINE_BREAK";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE"] = 17] = "MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE";
      })(LexerDefinitionErrorType = exports2.LexerDefinitionErrorType || (exports2.LexerDefinitionErrorType = {}));
      var DEFAULT_LEXER_CONFIG = {
        deferDefinitionErrorsHandling: false,
        positionTracking: "full",
        lineTerminatorsPattern: /\n|\r\n?/g,
        lineTerminatorCharacters: ["\n", "\r"],
        ensureOptimizations: false,
        safeMode: false,
        errorMessageProvider: lexer_errors_public_1.defaultLexerErrorProvider,
        traceInitPerf: false,
        skipValidations: false,
        recoveryEnabled: true
      };
      Object.freeze(DEFAULT_LEXER_CONFIG);
      var Lexer = (
        /** @class */
        function() {
          function Lexer2(lexerDefinition, config) {
            if (config === void 0) {
              config = DEFAULT_LEXER_CONFIG;
            }
            var _this = this;
            this.lexerDefinition = lexerDefinition;
            this.lexerDefinitionErrors = [];
            this.lexerDefinitionWarning = [];
            this.patternIdxToConfig = {};
            this.charCodeToPatternIdxToConfig = {};
            this.modes = [];
            this.emptyGroups = {};
            this.trackStartLines = true;
            this.trackEndLines = true;
            this.hasCustom = false;
            this.canModeBeOptimized = {};
            this.TRACE_INIT = function(phaseDesc, phaseImpl) {
              if (_this.traceInitPerf === true) {
                _this.traceInitIndent++;
                var indent = new Array(_this.traceInitIndent + 1).join("	");
                if (_this.traceInitIndent < _this.traceInitMaxIdent) {
                  console.log("".concat(indent, "--> <").concat(phaseDesc, ">"));
                }
                var _a4 = (0, utils_1.timer)(phaseImpl), time = _a4.time, value = _a4.value;
                var traceMethod = time > 10 ? console.warn : console.log;
                if (_this.traceInitIndent < _this.traceInitMaxIdent) {
                  traceMethod("".concat(indent, "<-- <").concat(phaseDesc, "> time: ").concat(time, "ms"));
                }
                _this.traceInitIndent--;
                return value;
              } else {
                return phaseImpl();
              }
            };
            if (typeof config === "boolean") {
              throw Error("The second argument to the Lexer constructor is now an ILexerConfig Object.\na boolean 2nd argument is no longer supported");
            }
            this.config = (0, assign_1.default)({}, DEFAULT_LEXER_CONFIG, config);
            var traceInitVal = this.config.traceInitPerf;
            if (traceInitVal === true) {
              this.traceInitMaxIdent = Infinity;
              this.traceInitPerf = true;
            } else if (typeof traceInitVal === "number") {
              this.traceInitMaxIdent = traceInitVal;
              this.traceInitPerf = true;
            }
            this.traceInitIndent = -1;
            this.TRACE_INIT("Lexer Constructor", function() {
              var actualDefinition;
              var hasOnlySingleMode = true;
              _this.TRACE_INIT("Lexer Config handling", function() {
                if (_this.config.lineTerminatorsPattern === DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {
                  _this.config.lineTerminatorsPattern = lexer_1.LineTerminatorOptimizedTester;
                } else {
                  if (_this.config.lineTerminatorCharacters === DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {
                    throw Error("Error: Missing <lineTerminatorCharacters> property on the Lexer config.\n	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS");
                  }
                }
                if (config.safeMode && config.ensureOptimizations) {
                  throw Error('"safeMode" and "ensureOptimizations" flags are mutually exclusive.');
                }
                _this.trackStartLines = /full|onlyStart/i.test(_this.config.positionTracking);
                _this.trackEndLines = /full/i.test(_this.config.positionTracking);
                if ((0, isArray_1.default)(lexerDefinition)) {
                  actualDefinition = {
                    modes: { defaultMode: (0, clone_1.default)(lexerDefinition) },
                    defaultMode: lexer_1.DEFAULT_MODE
                  };
                } else {
                  hasOnlySingleMode = false;
                  actualDefinition = (0, clone_1.default)(lexerDefinition);
                }
              });
              if (_this.config.skipValidations === false) {
                _this.TRACE_INIT("performRuntimeChecks", function() {
                  _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat((0, lexer_1.performRuntimeChecks)(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));
                });
                _this.TRACE_INIT("performWarningRuntimeChecks", function() {
                  _this.lexerDefinitionWarning = _this.lexerDefinitionWarning.concat((0, lexer_1.performWarningRuntimeChecks)(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));
                });
              }
              actualDefinition.modes = actualDefinition.modes ? actualDefinition.modes : {};
              (0, forEach_1.default)(actualDefinition.modes, function(currModeValue, currModeName) {
                actualDefinition.modes[currModeName] = (0, reject_1.default)(currModeValue, function(currTokType) {
                  return (0, isUndefined_1.default)(currTokType);
                });
              });
              var allModeNames = (0, keys_1.default)(actualDefinition.modes);
              (0, forEach_1.default)(actualDefinition.modes, function(currModDef, currModName) {
                _this.TRACE_INIT("Mode: <".concat(currModName, "> processing"), function() {
                  _this.modes.push(currModName);
                  if (_this.config.skipValidations === false) {
                    _this.TRACE_INIT("validatePatterns", function() {
                      _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat((0, lexer_1.validatePatterns)(currModDef, allModeNames));
                    });
                  }
                  if ((0, isEmpty_1.default)(_this.lexerDefinitionErrors)) {
                    (0, tokens_1.augmentTokenTypes)(currModDef);
                    var currAnalyzeResult_1;
                    _this.TRACE_INIT("analyzeTokenTypes", function() {
                      currAnalyzeResult_1 = (0, lexer_1.analyzeTokenTypes)(currModDef, {
                        lineTerminatorCharacters: _this.config.lineTerminatorCharacters,
                        positionTracking: config.positionTracking,
                        ensureOptimizations: config.ensureOptimizations,
                        safeMode: config.safeMode,
                        tracer: _this.TRACE_INIT
                      });
                    });
                    _this.patternIdxToConfig[currModName] = currAnalyzeResult_1.patternIdxToConfig;
                    _this.charCodeToPatternIdxToConfig[currModName] = currAnalyzeResult_1.charCodeToPatternIdxToConfig;
                    _this.emptyGroups = (0, assign_1.default)({}, _this.emptyGroups, currAnalyzeResult_1.emptyGroups);
                    _this.hasCustom = currAnalyzeResult_1.hasCustom || _this.hasCustom;
                    _this.canModeBeOptimized[currModName] = currAnalyzeResult_1.canBeOptimized;
                  }
                });
              });
              _this.defaultMode = actualDefinition.defaultMode;
              if (!(0, isEmpty_1.default)(_this.lexerDefinitionErrors) && !_this.config.deferDefinitionErrorsHandling) {
                var allErrMessages = (0, map_1.default)(_this.lexerDefinitionErrors, function(error) {
                  return error.message;
                });
                var allErrMessagesString = allErrMessages.join("-----------------------\n");
                throw new Error("Errors detected in definition of Lexer:\n" + allErrMessagesString);
              }
              (0, forEach_1.default)(_this.lexerDefinitionWarning, function(warningDescriptor) {
                (0, utils_1.PRINT_WARNING)(warningDescriptor.message);
              });
              _this.TRACE_INIT("Choosing sub-methods implementations", function() {
                if (lexer_1.SUPPORT_STICKY) {
                  _this.chopInput = identity_1.default;
                  _this.match = _this.matchWithTest;
                } else {
                  _this.updateLastIndex = noop_1.default;
                  _this.match = _this.matchWithExec;
                }
                if (hasOnlySingleMode) {
                  _this.handleModes = noop_1.default;
                }
                if (_this.trackStartLines === false) {
                  _this.computeNewColumn = identity_1.default;
                }
                if (_this.trackEndLines === false) {
                  _this.updateTokenEndLineColumnLocation = noop_1.default;
                }
                if (/full/i.test(_this.config.positionTracking)) {
                  _this.createTokenInstance = _this.createFullToken;
                } else if (/onlyStart/i.test(_this.config.positionTracking)) {
                  _this.createTokenInstance = _this.createStartOnlyToken;
                } else if (/onlyOffset/i.test(_this.config.positionTracking)) {
                  _this.createTokenInstance = _this.createOffsetOnlyToken;
                } else {
                  throw Error('Invalid <positionTracking> config option: "'.concat(_this.config.positionTracking, '"'));
                }
                if (_this.hasCustom) {
                  _this.addToken = _this.addTokenUsingPush;
                  _this.handlePayload = _this.handlePayloadWithCustom;
                } else {
                  _this.addToken = _this.addTokenUsingMemberAccess;
                  _this.handlePayload = _this.handlePayloadNoCustom;
                }
              });
              _this.TRACE_INIT("Failed Optimization Warnings", function() {
                var unOptimizedModes = (0, reduce_1.default)(_this.canModeBeOptimized, function(cannotBeOptimized, canBeOptimized, modeName) {
                  if (canBeOptimized === false) {
                    cannotBeOptimized.push(modeName);
                  }
                  return cannotBeOptimized;
                }, []);
                if (config.ensureOptimizations && !(0, isEmpty_1.default)(unOptimizedModes)) {
                  throw Error("Lexer Modes: < ".concat(unOptimizedModes.join(", "), " > cannot be optimized.\n") + '	 Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\n	 Or inspect the console log for details on how to resolve these issues.');
                }
              });
              _this.TRACE_INIT("clearRegExpParserCache", function() {
                (0, reg_exp_parser_1.clearRegExpParserCache)();
              });
              _this.TRACE_INIT("toFastProperties", function() {
                (0, utils_1.toFastProperties)(_this);
              });
            });
          }
          Lexer2.prototype.tokenize = function(text, initialMode) {
            if (initialMode === void 0) {
              initialMode = this.defaultMode;
            }
            if (!(0, isEmpty_1.default)(this.lexerDefinitionErrors)) {
              var allErrMessages = (0, map_1.default)(this.lexerDefinitionErrors, function(error) {
                return error.message;
              });
              var allErrMessagesString = allErrMessages.join("-----------------------\n");
              throw new Error("Unable to Tokenize because Errors detected in definition of Lexer:\n" + allErrMessagesString);
            }
            return this.tokenizeInternal(text, initialMode);
          };
          Lexer2.prototype.tokenizeInternal = function(text, initialMode) {
            var _this = this;
            var i, j, k, matchAltImage, longerAlt, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, droppedChar, msg, match;
            var orgText = text;
            var orgLength = orgText.length;
            var offset = 0;
            var matchedTokensIndex = 0;
            var guessedNumberOfTokens = this.hasCustom ? 0 : Math.floor(text.length / 10);
            var matchedTokens = new Array(guessedNumberOfTokens);
            var errors = [];
            var line = this.trackStartLines ? 1 : void 0;
            var column = this.trackStartLines ? 1 : void 0;
            var groups = (0, lexer_1.cloneEmptyGroups)(this.emptyGroups);
            var trackLines = this.trackStartLines;
            var lineTerminatorPattern = this.config.lineTerminatorsPattern;
            var currModePatternsLength = 0;
            var patternIdxToConfig = [];
            var currCharCodeToPatternIdxToConfig = [];
            var modeStack = [];
            var emptyArray = [];
            Object.freeze(emptyArray);
            var getPossiblePatterns;
            function getPossiblePatternsSlow() {
              return patternIdxToConfig;
            }
            function getPossiblePatternsOptimized(charCode) {
              var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(charCode);
              var possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];
              if (possiblePatterns === void 0) {
                return emptyArray;
              } else {
                return possiblePatterns;
              }
            }
            var pop_mode = function(popToken) {
              if (modeStack.length === 1 && // if we have both a POP_MODE and a PUSH_MODE this is in-fact a "transition"
              // So no error should occur.
              popToken.tokenType.PUSH_MODE === void 0) {
                var msg_1 = _this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);
                errors.push({
                  offset: popToken.startOffset,
                  line: popToken.startLine,
                  column: popToken.startColumn,
                  length: popToken.image.length,
                  message: msg_1
                });
              } else {
                modeStack.pop();
                var newMode = (0, last_1.default)(modeStack);
                patternIdxToConfig = _this.patternIdxToConfig[newMode];
                currCharCodeToPatternIdxToConfig = _this.charCodeToPatternIdxToConfig[newMode];
                currModePatternsLength = patternIdxToConfig.length;
                var modeCanBeOptimized = _this.canModeBeOptimized[newMode] && _this.config.safeMode === false;
                if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {
                  getPossiblePatterns = getPossiblePatternsOptimized;
                } else {
                  getPossiblePatterns = getPossiblePatternsSlow;
                }
              }
            };
            function push_mode(newMode) {
              modeStack.push(newMode);
              currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode];
              patternIdxToConfig = this.patternIdxToConfig[newMode];
              currModePatternsLength = patternIdxToConfig.length;
              currModePatternsLength = patternIdxToConfig.length;
              var modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;
              if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {
                getPossiblePatterns = getPossiblePatternsOptimized;
              } else {
                getPossiblePatterns = getPossiblePatternsSlow;
              }
            }
            push_mode.call(this, initialMode);
            var currConfig;
            var recoveryEnabled = this.config.recoveryEnabled;
            while (offset < orgLength) {
              matchedImage = null;
              var nextCharCode = orgText.charCodeAt(offset);
              var chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);
              var chosenPatternsLength = chosenPatternIdxToConfig.length;
              for (i = 0; i < chosenPatternsLength; i++) {
                currConfig = chosenPatternIdxToConfig[i];
                var currPattern = currConfig.pattern;
                payload = null;
                var singleCharCode = currConfig.short;
                if (singleCharCode !== false) {
                  if (nextCharCode === singleCharCode) {
                    matchedImage = currPattern;
                  }
                } else if (currConfig.isCustom === true) {
                  match = currPattern.exec(orgText, offset, matchedTokens, groups);
                  if (match !== null) {
                    matchedImage = match[0];
                    if (match.payload !== void 0) {
                      payload = match.payload;
                    }
                  } else {
                    matchedImage = null;
                  }
                } else {
                  this.updateLastIndex(currPattern, offset);
                  matchedImage = this.match(currPattern, text, offset);
                }
                if (matchedImage !== null) {
                  longerAlt = currConfig.longerAlt;
                  if (longerAlt !== void 0) {
                    var longerAltLength = longerAlt.length;
                    for (k = 0; k < longerAltLength; k++) {
                      var longerAltConfig = patternIdxToConfig[longerAlt[k]];
                      var longerAltPattern = longerAltConfig.pattern;
                      altPayload = null;
                      if (longerAltConfig.isCustom === true) {
                        match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);
                        if (match !== null) {
                          matchAltImage = match[0];
                          if (match.payload !== void 0) {
                            altPayload = match.payload;
                          }
                        } else {
                          matchAltImage = null;
                        }
                      } else {
                        this.updateLastIndex(longerAltPattern, offset);
                        matchAltImage = this.match(longerAltPattern, text, offset);
                      }
                      if (matchAltImage && matchAltImage.length > matchedImage.length) {
                        matchedImage = matchAltImage;
                        payload = altPayload;
                        currConfig = longerAltConfig;
                        break;
                      }
                    }
                  }
                  break;
                }
              }
              if (matchedImage !== null) {
                imageLength = matchedImage.length;
                group = currConfig.group;
                if (group !== void 0) {
                  tokType = currConfig.tokenTypeIdx;
                  newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);
                  this.handlePayload(newToken, payload);
                  if (group === false) {
                    matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);
                  } else {
                    groups[group].push(newToken);
                  }
                }
                text = this.chopInput(text, imageLength);
                offset = offset + imageLength;
                column = this.computeNewColumn(column, imageLength);
                if (trackLines === true && currConfig.canLineTerminator === true) {
                  var numOfLTsInMatch = 0;
                  var foundTerminator = void 0;
                  var lastLTEndOffset = void 0;
                  lineTerminatorPattern.lastIndex = 0;
                  do {
                    foundTerminator = lineTerminatorPattern.test(matchedImage);
                    if (foundTerminator === true) {
                      lastLTEndOffset = lineTerminatorPattern.lastIndex - 1;
                      numOfLTsInMatch++;
                    }
                  } while (foundTerminator === true);
                  if (numOfLTsInMatch !== 0) {
                    line = line + numOfLTsInMatch;
                    column = imageLength - lastLTEndOffset;
                    this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);
                  }
                }
                this.handleModes(currConfig, pop_mode, push_mode, newToken);
              } else {
                var errorStartOffset = offset;
                var errorLine = line;
                var errorColumn = column;
                var foundResyncPoint = recoveryEnabled === false;
                while (foundResyncPoint === false && offset < orgLength) {
                  text = this.chopInput(text, 1);
                  offset++;
                  for (j = 0; j < currModePatternsLength; j++) {
                    var currConfig_1 = patternIdxToConfig[j];
                    var currPattern = currConfig_1.pattern;
                    var singleCharCode = currConfig_1.short;
                    if (singleCharCode !== false) {
                      if (orgText.charCodeAt(offset) === singleCharCode) {
                        foundResyncPoint = true;
                      }
                    } else if (currConfig_1.isCustom === true) {
                      foundResyncPoint = currPattern.exec(orgText, offset, matchedTokens, groups) !== null;
                    } else {
                      this.updateLastIndex(currPattern, offset);
                      foundResyncPoint = currPattern.exec(text) !== null;
                    }
                    if (foundResyncPoint === true) {
                      break;
                    }
                  }
                }
                errLength = offset - errorStartOffset;
                msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);
                errors.push({
                  offset: errorStartOffset,
                  line: errorLine,
                  column: errorColumn,
                  length: errLength,
                  message: msg
                });
                if (recoveryEnabled === false) {
                  break;
                }
              }
            }
            if (!this.hasCustom) {
              matchedTokens.length = matchedTokensIndex;
            }
            return {
              tokens: matchedTokens,
              groups,
              errors
            };
          };
          Lexer2.prototype.handleModes = function(config, pop_mode, push_mode, newToken) {
            if (config.pop === true) {
              var pushMode = config.push;
              pop_mode(newToken);
              if (pushMode !== void 0) {
                push_mode.call(this, pushMode);
              }
            } else if (config.push !== void 0) {
              push_mode.call(this, config.push);
            }
          };
          Lexer2.prototype.chopInput = function(text, length) {
            return text.substring(length);
          };
          Lexer2.prototype.updateLastIndex = function(regExp, newLastIndex) {
            regExp.lastIndex = newLastIndex;
          };
          Lexer2.prototype.updateTokenEndLineColumnLocation = function(newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {
            var lastCharIsLT, fixForEndingInLT;
            if (group !== void 0) {
              lastCharIsLT = lastLTIdx === imageLength - 1;
              fixForEndingInLT = lastCharIsLT ? -1 : 0;
              if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {
                newToken.endLine = line + fixForEndingInLT;
                newToken.endColumn = column - 1 + -fixForEndingInLT;
              }
            }
          };
          Lexer2.prototype.computeNewColumn = function(oldColumn, imageLength) {
            return oldColumn + imageLength;
          };
          Lexer2.prototype.createOffsetOnlyToken = function(image, startOffset, tokenTypeIdx, tokenType) {
            return {
              image,
              startOffset,
              tokenTypeIdx,
              tokenType
            };
          };
          Lexer2.prototype.createStartOnlyToken = function(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {
            return {
              image,
              startOffset,
              startLine,
              startColumn,
              tokenTypeIdx,
              tokenType
            };
          };
          Lexer2.prototype.createFullToken = function(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {
            return {
              image,
              startOffset,
              endOffset: startOffset + imageLength - 1,
              startLine,
              endLine: startLine,
              startColumn,
              endColumn: startColumn + imageLength - 1,
              tokenTypeIdx,
              tokenType
            };
          };
          Lexer2.prototype.addTokenUsingPush = function(tokenVector, index, tokenToAdd) {
            tokenVector.push(tokenToAdd);
            return index;
          };
          Lexer2.prototype.addTokenUsingMemberAccess = function(tokenVector, index, tokenToAdd) {
            tokenVector[index] = tokenToAdd;
            index++;
            return index;
          };
          Lexer2.prototype.handlePayloadNoCustom = function(token, payload) {
          };
          Lexer2.prototype.handlePayloadWithCustom = function(token, payload) {
            if (payload !== null) {
              token.payload = payload;
            }
          };
          Lexer2.prototype.matchWithTest = function(pattern, text, offset) {
            var found = pattern.test(text);
            if (found === true) {
              return text.substring(offset, pattern.lastIndex);
            }
            return null;
          };
          Lexer2.prototype.matchWithExec = function(pattern, text) {
            var regExpArray = pattern.exec(text);
            return regExpArray !== null ? regExpArray[0] : null;
          };
          Lexer2.SKIPPED = "This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.";
          Lexer2.NA = /NOT_APPLICABLE/;
          return Lexer2;
        }()
      );
      exports2.Lexer = Lexer;
    }
  });

  // node_modules/chevrotain/lib/src/scan/tokens_public.js
  var require_tokens_public = __commonJS({
    "node_modules/chevrotain/lib/src/scan/tokens_public.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.tokenMatcher = exports2.createTokenInstance = exports2.EOF = exports2.createToken = exports2.hasTokenLabel = exports2.tokenName = exports2.tokenLabel = void 0;
      var isString_1 = __importDefault(require_isString());
      var has_1 = __importDefault(require_has());
      var isUndefined_1 = __importDefault(require_isUndefined());
      var lexer_public_1 = require_lexer_public();
      var tokens_1 = require_tokens();
      function tokenLabel(tokType) {
        if (hasTokenLabel(tokType)) {
          return tokType.LABEL;
        } else {
          return tokType.name;
        }
      }
      exports2.tokenLabel = tokenLabel;
      function tokenName(tokType) {
        return tokType.name;
      }
      exports2.tokenName = tokenName;
      function hasTokenLabel(obj) {
        return (0, isString_1.default)(obj.LABEL) && obj.LABEL !== "";
      }
      exports2.hasTokenLabel = hasTokenLabel;
      var PARENT = "parent";
      var CATEGORIES = "categories";
      var LABEL = "label";
      var GROUP = "group";
      var PUSH_MODE = "push_mode";
      var POP_MODE = "pop_mode";
      var LONGER_ALT = "longer_alt";
      var LINE_BREAKS = "line_breaks";
      var START_CHARS_HINT = "start_chars_hint";
      function createToken(config) {
        return createTokenInternal(config);
      }
      exports2.createToken = createToken;
      function createTokenInternal(config) {
        var pattern = config.pattern;
        var tokenType = {};
        tokenType.name = config.name;
        if (!(0, isUndefined_1.default)(pattern)) {
          tokenType.PATTERN = pattern;
        }
        if ((0, has_1.default)(config, PARENT)) {
          throw "The parent property is no longer supported.\nSee: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.";
        }
        if ((0, has_1.default)(config, CATEGORIES)) {
          tokenType.CATEGORIES = config[CATEGORIES];
        }
        (0, tokens_1.augmentTokenTypes)([tokenType]);
        if ((0, has_1.default)(config, LABEL)) {
          tokenType.LABEL = config[LABEL];
        }
        if ((0, has_1.default)(config, GROUP)) {
          tokenType.GROUP = config[GROUP];
        }
        if ((0, has_1.default)(config, POP_MODE)) {
          tokenType.POP_MODE = config[POP_MODE];
        }
        if ((0, has_1.default)(config, PUSH_MODE)) {
          tokenType.PUSH_MODE = config[PUSH_MODE];
        }
        if ((0, has_1.default)(config, LONGER_ALT)) {
          tokenType.LONGER_ALT = config[LONGER_ALT];
        }
        if ((0, has_1.default)(config, LINE_BREAKS)) {
          tokenType.LINE_BREAKS = config[LINE_BREAKS];
        }
        if ((0, has_1.default)(config, START_CHARS_HINT)) {
          tokenType.START_CHARS_HINT = config[START_CHARS_HINT];
        }
        return tokenType;
      }
      exports2.EOF = createToken({ name: "EOF", pattern: lexer_public_1.Lexer.NA });
      (0, tokens_1.augmentTokenTypes)([exports2.EOF]);
      function createTokenInstance(tokType, image, startOffset, endOffset, startLine, endLine, startColumn, endColumn) {
        return {
          image,
          startOffset,
          endOffset,
          startLine,
          endLine,
          startColumn,
          endColumn,
          tokenTypeIdx: tokType.tokenTypeIdx,
          tokenType: tokType
        };
      }
      exports2.createTokenInstance = createTokenInstance;
      function tokenMatcher(token, tokType) {
        return (0, tokens_1.tokenStructuredMatcher)(token, tokType);
      }
      exports2.tokenMatcher = tokenMatcher;
    }
  });

  // node_modules/chevrotain/lib/src/parse/errors_public.js
  var require_errors_public = __commonJS({
    "node_modules/chevrotain/lib/src/parse/errors_public.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.defaultGrammarValidatorErrorProvider = exports2.defaultGrammarResolverErrorProvider = exports2.defaultParserErrorProvider = void 0;
      var tokens_public_1 = require_tokens_public();
      var first_1 = __importDefault(require_first2());
      var map_1 = __importDefault(require_map());
      var reduce_1 = __importDefault(require_reduce());
      var gast_1 = require_api5();
      var gast_2 = require_api5();
      exports2.defaultParserErrorProvider = {
        buildMismatchTokenMessage: function(_a4) {
          var expected = _a4.expected, actual = _a4.actual, previous = _a4.previous, ruleName = _a4.ruleName;
          var hasLabel = (0, tokens_public_1.hasTokenLabel)(expected);
          var expectedMsg = hasLabel ? "--> ".concat((0, tokens_public_1.tokenLabel)(expected), " <--") : "token of type --> ".concat(expected.name, " <--");
          var msg = "Expecting ".concat(expectedMsg, " but found --> '").concat(actual.image, "' <--");
          return msg;
        },
        buildNotAllInputParsedMessage: function(_a4) {
          var firstRedundant = _a4.firstRedundant, ruleName = _a4.ruleName;
          return "Redundant input, expecting EOF but found: " + firstRedundant.image;
        },
        buildNoViableAltMessage: function(_a4) {
          var expectedPathsPerAlt = _a4.expectedPathsPerAlt, actual = _a4.actual, previous = _a4.previous, customUserDescription = _a4.customUserDescription, ruleName = _a4.ruleName;
          var errPrefix = "Expecting: ";
          var actualText = (0, first_1.default)(actual).image;
          var errSuffix = "\nbut found: '" + actualText + "'";
          if (customUserDescription) {
            return errPrefix + customUserDescription + errSuffix;
          } else {
            var allLookAheadPaths = (0, reduce_1.default)(expectedPathsPerAlt, function(result, currAltPaths) {
              return result.concat(currAltPaths);
            }, []);
            var nextValidTokenSequences = (0, map_1.default)(allLookAheadPaths, function(currPath) {
              return "[".concat((0, map_1.default)(currPath, function(currTokenType) {
                return (0, tokens_public_1.tokenLabel)(currTokenType);
              }).join(", "), "]");
            });
            var nextValidSequenceItems = (0, map_1.default)(nextValidTokenSequences, function(itemMsg, idx) {
              return "  ".concat(idx + 1, ". ").concat(itemMsg);
            });
            var calculatedDescription = "one of these possible Token sequences:\n".concat(nextValidSequenceItems.join("\n"));
            return errPrefix + calculatedDescription + errSuffix;
          }
        },
        buildEarlyExitMessage: function(_a4) {
          var expectedIterationPaths = _a4.expectedIterationPaths, actual = _a4.actual, customUserDescription = _a4.customUserDescription, ruleName = _a4.ruleName;
          var errPrefix = "Expecting: ";
          var actualText = (0, first_1.default)(actual).image;
          var errSuffix = "\nbut found: '" + actualText + "'";
          if (customUserDescription) {
            return errPrefix + customUserDescription + errSuffix;
          } else {
            var nextValidTokenSequences = (0, map_1.default)(expectedIterationPaths, function(currPath) {
              return "[".concat((0, map_1.default)(currPath, function(currTokenType) {
                return (0, tokens_public_1.tokenLabel)(currTokenType);
              }).join(","), "]");
            });
            var calculatedDescription = "expecting at least one iteration which starts with one of these possible Token sequences::\n  " + "<".concat(nextValidTokenSequences.join(" ,"), ">");
            return errPrefix + calculatedDescription + errSuffix;
          }
        }
      };
      Object.freeze(exports2.defaultParserErrorProvider);
      exports2.defaultGrammarResolverErrorProvider = {
        buildRuleNotFoundError: function(topLevelRule, undefinedRule) {
          var msg = "Invalid grammar, reference to a rule which is not defined: ->" + undefinedRule.nonTerminalName + "<-\ninside top level rule: ->" + topLevelRule.name + "<-";
          return msg;
        }
      };
      exports2.defaultGrammarValidatorErrorProvider = {
        buildDuplicateFoundError: function(topLevelRule, duplicateProds) {
          function getExtraProductionArgument(prod) {
            if (prod instanceof gast_1.Terminal) {
              return prod.terminalType.name;
            } else if (prod instanceof gast_1.NonTerminal) {
              return prod.nonTerminalName;
            } else {
              return "";
            }
          }
          var topLevelName = topLevelRule.name;
          var duplicateProd = (0, first_1.default)(duplicateProds);
          var index = duplicateProd.idx;
          var dslName = (0, gast_2.getProductionDslName)(duplicateProd);
          var extraArgument = getExtraProductionArgument(duplicateProd);
          var hasExplicitIndex = index > 0;
          var msg = "->".concat(dslName).concat(hasExplicitIndex ? index : "", "<- ").concat(extraArgument ? "with argument: ->".concat(extraArgument, "<-") : "", "\n                  appears more than once (").concat(duplicateProds.length, " times) in the top level rule: ->").concat(topLevelName, "<-.                  \n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  ");
          msg = msg.replace(/[ \t]+/g, " ");
          msg = msg.replace(/\s\s+/g, "\n");
          return msg;
        },
        buildNamespaceConflictError: function(rule) {
          var errMsg = "Namespace conflict found in grammar.\n" + "The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <".concat(rule.name, ">.\n") + "To resolve this make sure each Terminal and Non-Terminal names are unique\nThis is easy to accomplish by using the convention that Terminal names start with an uppercase letter\nand Non-Terminal names start with a lower case letter.";
          return errMsg;
        },
        buildAlternationPrefixAmbiguityError: function(options) {
          var pathMsg = (0, map_1.default)(options.prefixPath, function(currTok) {
            return (0, tokens_public_1.tokenLabel)(currTok);
          }).join(", ");
          var occurrence = options.alternation.idx === 0 ? "" : options.alternation.idx;
          var errMsg = "Ambiguous alternatives: <".concat(options.ambiguityIndices.join(" ,"), "> due to common lookahead prefix\n") + "in <OR".concat(occurrence, "> inside <").concat(options.topLevelRule.name, "> Rule,\n") + "<".concat(pathMsg, "> may appears as a prefix path in all these alternatives.\n") + "See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\nFor Further details.";
          return errMsg;
        },
        buildAlternationAmbiguityError: function(options) {
          var pathMsg = (0, map_1.default)(options.prefixPath, function(currtok) {
            return (0, tokens_public_1.tokenLabel)(currtok);
          }).join(", ");
          var occurrence = options.alternation.idx === 0 ? "" : options.alternation.idx;
          var currMessage = "Ambiguous Alternatives Detected: <".concat(options.ambiguityIndices.join(" ,"), "> in <OR").concat(occurrence, ">") + " inside <".concat(options.topLevelRule.name, "> Rule,\n") + "<".concat(pathMsg, "> may appears as a prefix path in all these alternatives.\n");
          currMessage = currMessage + "See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\nFor Further details.";
          return currMessage;
        },
        buildEmptyRepetitionError: function(options) {
          var dslName = (0, gast_2.getProductionDslName)(options.repetition);
          if (options.repetition.idx !== 0) {
            dslName += options.repetition.idx;
          }
          var errMsg = "The repetition <".concat(dslName, "> within Rule <").concat(options.topLevelRule.name, "> can never consume any tokens.\n") + "This could lead to an infinite loop.";
          return errMsg;
        },
        // TODO: remove - `errors_public` from nyc.config.js exclude
        //       once this method is fully removed from this file
        buildTokenNameError: function(options) {
          return "deprecated";
        },
        buildEmptyAlternationError: function(options) {
          var errMsg = "Ambiguous empty alternative: <".concat(options.emptyChoiceIdx + 1, ">") + " in <OR".concat(options.alternation.idx, "> inside <").concat(options.topLevelRule.name, "> Rule.\n") + "Only the last alternative may be an empty alternative.";
          return errMsg;
        },
        buildTooManyAlternativesError: function(options) {
          var errMsg = "An Alternation cannot have more than 256 alternatives:\n" + "<OR".concat(options.alternation.idx, "> inside <").concat(options.topLevelRule.name, "> Rule.\n has ").concat(options.alternation.definition.length + 1, " alternatives.");
          return errMsg;
        },
        buildLeftRecursionError: function(options) {
          var ruleName = options.topLevelRule.name;
          var pathNames = (0, map_1.default)(options.leftRecursionPath, function(currRule) {
            return currRule.name;
          });
          var leftRecursivePath = "".concat(ruleName, " --> ").concat(pathNames.concat([ruleName]).join(" --> "));
          var errMsg = "Left Recursion found in grammar.\n" + "rule: <".concat(ruleName, "> can be invoked from itself (directly or indirectly)\n") + "without consuming any Tokens. The grammar path that causes this is: \n ".concat(leftRecursivePath, "\n") + " To fix this refactor your grammar to remove the left recursion.\nsee: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.";
          return errMsg;
        },
        // TODO: remove - `errors_public` from nyc.config.js exclude
        //       once this method is fully removed from this file
        buildInvalidRuleNameError: function(options) {
          return "deprecated";
        },
        buildDuplicateRuleNameError: function(options) {
          var ruleName;
          if (options.topLevelRule instanceof gast_1.Rule) {
            ruleName = options.topLevelRule.name;
          } else {
            ruleName = options.topLevelRule;
          }
          var errMsg = "Duplicate definition, rule: ->".concat(ruleName, "<- is already defined in the grammar: ->").concat(options.grammarName, "<-");
          return errMsg;
        }
      };
    }
  });

  // node_modules/chevrotain/lib/src/parse/grammar/resolver.js
  var require_resolver = __commonJS({
    "node_modules/chevrotain/lib/src/parse/grammar/resolver.js"(exports2) {
      "use strict";
      var __extends = exports2 && exports2.__extends || function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2)
              if (Object.prototype.hasOwnProperty.call(b2, p))
                d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.GastRefResolverVisitor = exports2.resolveGrammar = void 0;
      var parser_1 = require_parser();
      var forEach_1 = __importDefault(require_forEach());
      var values_1 = __importDefault(require_values());
      var gast_1 = require_api5();
      function resolveGrammar(topLevels, errMsgProvider) {
        var refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider);
        refResolver.resolveRefs();
        return refResolver.errors;
      }
      exports2.resolveGrammar = resolveGrammar;
      var GastRefResolverVisitor = (
        /** @class */
        function(_super) {
          __extends(GastRefResolverVisitor2, _super);
          function GastRefResolverVisitor2(nameToTopRule, errMsgProvider) {
            var _this = _super.call(this) || this;
            _this.nameToTopRule = nameToTopRule;
            _this.errMsgProvider = errMsgProvider;
            _this.errors = [];
            return _this;
          }
          GastRefResolverVisitor2.prototype.resolveRefs = function() {
            var _this = this;
            (0, forEach_1.default)((0, values_1.default)(this.nameToTopRule), function(prod) {
              _this.currTopLevel = prod;
              prod.accept(_this);
            });
          };
          GastRefResolverVisitor2.prototype.visitNonTerminal = function(node) {
            var ref = this.nameToTopRule[node.nonTerminalName];
            if (!ref) {
              var msg = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, node);
              this.errors.push({
                message: msg,
                type: parser_1.ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,
                ruleName: this.currTopLevel.name,
                unresolvedRefName: node.nonTerminalName
              });
            } else {
              node.referencedRule = ref;
            }
          };
          return GastRefResolverVisitor2;
        }(gast_1.GAstVisitor)
      );
      exports2.GastRefResolverVisitor = GastRefResolverVisitor;
    }
  });

  // node_modules/lodash/_arrayAggregator.js
  var require_arrayAggregator = __commonJS({
    "node_modules/lodash/_arrayAggregator.js"(exports2, module2) {
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      module2.exports = arrayAggregator;
    }
  });

  // node_modules/lodash/_baseAggregator.js
  var require_baseAggregator = __commonJS({
    "node_modules/lodash/_baseAggregator.js"(exports2, module2) {
      var baseEach = require_baseEach();
      function baseAggregator(collection, setter, iteratee, accumulator) {
        baseEach(collection, function(value, key, collection2) {
          setter(accumulator, value, iteratee(value), collection2);
        });
        return accumulator;
      }
      module2.exports = baseAggregator;
    }
  });

  // node_modules/lodash/_createAggregator.js
  var require_createAggregator = __commonJS({
    "node_modules/lodash/_createAggregator.js"(exports2, module2) {
      var arrayAggregator = require_arrayAggregator();
      var baseAggregator = require_baseAggregator();
      var baseIteratee = require_baseIteratee();
      var isArray = require_isArray();
      function createAggregator(setter, initializer) {
        return function(collection, iteratee) {
          var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, baseIteratee(iteratee, 2), accumulator);
        };
      }
      module2.exports = createAggregator;
    }
  });

  // node_modules/lodash/groupBy.js
  var require_groupBy = __commonJS({
    "node_modules/lodash/groupBy.js"(exports2, module2) {
      var baseAssignValue = require_baseAssignValue();
      var createAggregator = require_createAggregator();
      var objectProto = Object.prototype;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      var groupBy = createAggregator(function(result, value, key) {
        if (hasOwnProperty2.call(result, key)) {
          result[key].push(value);
        } else {
          baseAssignValue(result, key, [value]);
        }
      });
      module2.exports = groupBy;
    }
  });

  // node_modules/lodash/flatMap.js
  var require_flatMap = __commonJS({
    "node_modules/lodash/flatMap.js"(exports2, module2) {
      var baseFlatten = require_baseFlatten();
      var map = require_map();
      function flatMap(collection, iteratee) {
        return baseFlatten(map(collection, iteratee), 1);
      }
      module2.exports = flatMap;
    }
  });

  // node_modules/lodash/dropRight.js
  var require_dropRight = __commonJS({
    "node_modules/lodash/dropRight.js"(exports2, module2) {
      var baseSlice = require_baseSlice();
      var toInteger = require_toInteger();
      function dropRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === void 0 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      module2.exports = dropRight;
    }
  });

  // node_modules/chevrotain/lib/src/parse/grammar/interpreter.js
  var require_interpreter = __commonJS({
    "node_modules/chevrotain/lib/src/parse/grammar/interpreter.js"(exports2) {
      "use strict";
      var __extends = exports2 && exports2.__extends || function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2)
              if (Object.prototype.hasOwnProperty.call(b2, p))
                d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.nextPossibleTokensAfter = exports2.possiblePathsFrom = exports2.NextTerminalAfterAtLeastOneSepWalker = exports2.NextTerminalAfterAtLeastOneWalker = exports2.NextTerminalAfterManySepWalker = exports2.NextTerminalAfterManyWalker = exports2.AbstractNextTerminalAfterProductionWalker = exports2.NextAfterTokenWalker = exports2.AbstractNextPossibleTokensWalker = void 0;
      var rest_1 = require_rest();
      var first_1 = __importDefault(require_first2());
      var isEmpty_1 = __importDefault(require_isEmpty());
      var dropRight_1 = __importDefault(require_dropRight());
      var drop_1 = __importDefault(require_drop());
      var last_1 = __importDefault(require_last());
      var forEach_1 = __importDefault(require_forEach());
      var clone_1 = __importDefault(require_clone());
      var first_2 = require_first();
      var gast_1 = require_api5();
      var AbstractNextPossibleTokensWalker = (
        /** @class */
        function(_super) {
          __extends(AbstractNextPossibleTokensWalker2, _super);
          function AbstractNextPossibleTokensWalker2(topProd, path) {
            var _this = _super.call(this) || this;
            _this.topProd = topProd;
            _this.path = path;
            _this.possibleTokTypes = [];
            _this.nextProductionName = "";
            _this.nextProductionOccurrence = 0;
            _this.found = false;
            _this.isAtEndOfPath = false;
            return _this;
          }
          AbstractNextPossibleTokensWalker2.prototype.startWalking = function() {
            this.found = false;
            if (this.path.ruleStack[0] !== this.topProd.name) {
              throw Error("The path does not start with the walker's top Rule!");
            }
            this.ruleStack = (0, clone_1.default)(this.path.ruleStack).reverse();
            this.occurrenceStack = (0, clone_1.default)(this.path.occurrenceStack).reverse();
            this.ruleStack.pop();
            this.occurrenceStack.pop();
            this.updateExpectedNext();
            this.walk(this.topProd);
            return this.possibleTokTypes;
          };
          AbstractNextPossibleTokensWalker2.prototype.walk = function(prod, prevRest) {
            if (prevRest === void 0) {
              prevRest = [];
            }
            if (!this.found) {
              _super.prototype.walk.call(this, prod, prevRest);
            }
          };
          AbstractNextPossibleTokensWalker2.prototype.walkProdRef = function(refProd, currRest, prevRest) {
            if (refProd.referencedRule.name === this.nextProductionName && refProd.idx === this.nextProductionOccurrence) {
              var fullRest = currRest.concat(prevRest);
              this.updateExpectedNext();
              this.walk(refProd.referencedRule, fullRest);
            }
          };
          AbstractNextPossibleTokensWalker2.prototype.updateExpectedNext = function() {
            if ((0, isEmpty_1.default)(this.ruleStack)) {
              this.nextProductionName = "";
              this.nextProductionOccurrence = 0;
              this.isAtEndOfPath = true;
            } else {
              this.nextProductionName = this.ruleStack.pop();
              this.nextProductionOccurrence = this.occurrenceStack.pop();
            }
          };
          return AbstractNextPossibleTokensWalker2;
        }(rest_1.RestWalker)
      );
      exports2.AbstractNextPossibleTokensWalker = AbstractNextPossibleTokensWalker;
      var NextAfterTokenWalker = (
        /** @class */
        function(_super) {
          __extends(NextAfterTokenWalker2, _super);
          function NextAfterTokenWalker2(topProd, path) {
            var _this = _super.call(this, topProd, path) || this;
            _this.path = path;
            _this.nextTerminalName = "";
            _this.nextTerminalOccurrence = 0;
            _this.nextTerminalName = _this.path.lastTok.name;
            _this.nextTerminalOccurrence = _this.path.lastTokOccurrence;
            return _this;
          }
          NextAfterTokenWalker2.prototype.walkTerminal = function(terminal, currRest, prevRest) {
            if (this.isAtEndOfPath && terminal.terminalType.name === this.nextTerminalName && terminal.idx === this.nextTerminalOccurrence && !this.found) {
              var fullRest = currRest.concat(prevRest);
              var restProd = new gast_1.Alternative({ definition: fullRest });
              this.possibleTokTypes = (0, first_2.first)(restProd);
              this.found = true;
            }
          };
          return NextAfterTokenWalker2;
        }(AbstractNextPossibleTokensWalker)
      );
      exports2.NextAfterTokenWalker = NextAfterTokenWalker;
      var AbstractNextTerminalAfterProductionWalker = (
        /** @class */
        function(_super) {
          __extends(AbstractNextTerminalAfterProductionWalker2, _super);
          function AbstractNextTerminalAfterProductionWalker2(topRule, occurrence) {
            var _this = _super.call(this) || this;
            _this.topRule = topRule;
            _this.occurrence = occurrence;
            _this.result = {
              token: void 0,
              occurrence: void 0,
              isEndOfRule: void 0
            };
            return _this;
          }
          AbstractNextTerminalAfterProductionWalker2.prototype.startWalking = function() {
            this.walk(this.topRule);
            return this.result;
          };
          return AbstractNextTerminalAfterProductionWalker2;
        }(rest_1.RestWalker)
      );
      exports2.AbstractNextTerminalAfterProductionWalker = AbstractNextTerminalAfterProductionWalker;
      var NextTerminalAfterManyWalker = (
        /** @class */
        function(_super) {
          __extends(NextTerminalAfterManyWalker2, _super);
          function NextTerminalAfterManyWalker2() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          NextTerminalAfterManyWalker2.prototype.walkMany = function(manyProd, currRest, prevRest) {
            if (manyProd.idx === this.occurrence) {
              var firstAfterMany = (0, first_1.default)(currRest.concat(prevRest));
              this.result.isEndOfRule = firstAfterMany === void 0;
              if (firstAfterMany instanceof gast_1.Terminal) {
                this.result.token = firstAfterMany.terminalType;
                this.result.occurrence = firstAfterMany.idx;
              }
            } else {
              _super.prototype.walkMany.call(this, manyProd, currRest, prevRest);
            }
          };
          return NextTerminalAfterManyWalker2;
        }(AbstractNextTerminalAfterProductionWalker)
      );
      exports2.NextTerminalAfterManyWalker = NextTerminalAfterManyWalker;
      var NextTerminalAfterManySepWalker = (
        /** @class */
        function(_super) {
          __extends(NextTerminalAfterManySepWalker2, _super);
          function NextTerminalAfterManySepWalker2() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          NextTerminalAfterManySepWalker2.prototype.walkManySep = function(manySepProd, currRest, prevRest) {
            if (manySepProd.idx === this.occurrence) {
              var firstAfterManySep = (0, first_1.default)(currRest.concat(prevRest));
              this.result.isEndOfRule = firstAfterManySep === void 0;
              if (firstAfterManySep instanceof gast_1.Terminal) {
                this.result.token = firstAfterManySep.terminalType;
                this.result.occurrence = firstAfterManySep.idx;
              }
            } else {
              _super.prototype.walkManySep.call(this, manySepProd, currRest, prevRest);
            }
          };
          return NextTerminalAfterManySepWalker2;
        }(AbstractNextTerminalAfterProductionWalker)
      );
      exports2.NextTerminalAfterManySepWalker = NextTerminalAfterManySepWalker;
      var NextTerminalAfterAtLeastOneWalker = (
        /** @class */
        function(_super) {
          __extends(NextTerminalAfterAtLeastOneWalker2, _super);
          function NextTerminalAfterAtLeastOneWalker2() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          NextTerminalAfterAtLeastOneWalker2.prototype.walkAtLeastOne = function(atLeastOneProd, currRest, prevRest) {
            if (atLeastOneProd.idx === this.occurrence) {
              var firstAfterAtLeastOne = (0, first_1.default)(currRest.concat(prevRest));
              this.result.isEndOfRule = firstAfterAtLeastOne === void 0;
              if (firstAfterAtLeastOne instanceof gast_1.Terminal) {
                this.result.token = firstAfterAtLeastOne.terminalType;
                this.result.occurrence = firstAfterAtLeastOne.idx;
              }
            } else {
              _super.prototype.walkAtLeastOne.call(this, atLeastOneProd, currRest, prevRest);
            }
          };
          return NextTerminalAfterAtLeastOneWalker2;
        }(AbstractNextTerminalAfterProductionWalker)
      );
      exports2.NextTerminalAfterAtLeastOneWalker = NextTerminalAfterAtLeastOneWalker;
      var NextTerminalAfterAtLeastOneSepWalker = (
        /** @class */
        function(_super) {
          __extends(NextTerminalAfterAtLeastOneSepWalker2, _super);
          function NextTerminalAfterAtLeastOneSepWalker2() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          NextTerminalAfterAtLeastOneSepWalker2.prototype.walkAtLeastOneSep = function(atleastOneSepProd, currRest, prevRest) {
            if (atleastOneSepProd.idx === this.occurrence) {
              var firstAfterfirstAfterAtLeastOneSep = (0, first_1.default)(currRest.concat(prevRest));
              this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === void 0;
              if (firstAfterfirstAfterAtLeastOneSep instanceof gast_1.Terminal) {
                this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;
                this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;
              }
            } else {
              _super.prototype.walkAtLeastOneSep.call(this, atleastOneSepProd, currRest, prevRest);
            }
          };
          return NextTerminalAfterAtLeastOneSepWalker2;
        }(AbstractNextTerminalAfterProductionWalker)
      );
      exports2.NextTerminalAfterAtLeastOneSepWalker = NextTerminalAfterAtLeastOneSepWalker;
      function possiblePathsFrom(targetDef, maxLength, currPath) {
        if (currPath === void 0) {
          currPath = [];
        }
        currPath = (0, clone_1.default)(currPath);
        var result = [];
        var i = 0;
        function remainingPathWith(nextDef) {
          return nextDef.concat((0, drop_1.default)(targetDef, i + 1));
        }
        function getAlternativesForProd(definition) {
          var alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);
          return result.concat(alternatives);
        }
        while (currPath.length < maxLength && i < targetDef.length) {
          var prod = targetDef[i];
          if (prod instanceof gast_1.Alternative) {
            return getAlternativesForProd(prod.definition);
          } else if (prod instanceof gast_1.NonTerminal) {
            return getAlternativesForProd(prod.definition);
          } else if (prod instanceof gast_1.Option) {
            result = getAlternativesForProd(prod.definition);
          } else if (prod instanceof gast_1.RepetitionMandatory) {
            var newDef = prod.definition.concat([
              new gast_1.Repetition({
                definition: prod.definition
              })
            ]);
            return getAlternativesForProd(newDef);
          } else if (prod instanceof gast_1.RepetitionMandatoryWithSeparator) {
            var newDef = [
              new gast_1.Alternative({ definition: prod.definition }),
              new gast_1.Repetition({
                definition: [new gast_1.Terminal({ terminalType: prod.separator })].concat(prod.definition)
              })
            ];
            return getAlternativesForProd(newDef);
          } else if (prod instanceof gast_1.RepetitionWithSeparator) {
            var newDef = prod.definition.concat([
              new gast_1.Repetition({
                definition: [new gast_1.Terminal({ terminalType: prod.separator })].concat(prod.definition)
              })
            ]);
            result = getAlternativesForProd(newDef);
          } else if (prod instanceof gast_1.Repetition) {
            var newDef = prod.definition.concat([
              new gast_1.Repetition({
                definition: prod.definition
              })
            ]);
            result = getAlternativesForProd(newDef);
          } else if (prod instanceof gast_1.Alternation) {
            (0, forEach_1.default)(prod.definition, function(currAlt) {
              if ((0, isEmpty_1.default)(currAlt.definition) === false) {
                result = getAlternativesForProd(currAlt.definition);
              }
            });
            return result;
          } else if (prod instanceof gast_1.Terminal) {
            currPath.push(prod.terminalType);
          } else {
            throw Error("non exhaustive match");
          }
          i++;
        }
        result.push({
          partialPath: currPath,
          suffixDef: (0, drop_1.default)(targetDef, i)
        });
        return result;
      }
      exports2.possiblePathsFrom = possiblePathsFrom;
      function nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {
        var EXIT_NON_TERMINAL = "EXIT_NONE_TERMINAL";
        var EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];
        var EXIT_ALTERNATIVE = "EXIT_ALTERNATIVE";
        var foundCompletePath = false;
        var tokenVectorLength = tokenVector.length;
        var minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;
        var result = [];
        var possiblePaths = [];
        possiblePaths.push({
          idx: -1,
          def: initialDef,
          ruleStack: [],
          occurrenceStack: []
        });
        while (!(0, isEmpty_1.default)(possiblePaths)) {
          var currPath = possiblePaths.pop();
          if (currPath === EXIT_ALTERNATIVE) {
            if (foundCompletePath && (0, last_1.default)(possiblePaths).idx <= minimalAlternativesIndex) {
              possiblePaths.pop();
            }
            continue;
          }
          var currDef = currPath.def;
          var currIdx = currPath.idx;
          var currRuleStack = currPath.ruleStack;
          var currOccurrenceStack = currPath.occurrenceStack;
          if ((0, isEmpty_1.default)(currDef)) {
            continue;
          }
          var prod = currDef[0];
          if (prod === EXIT_NON_TERMINAL) {
            var nextPath = {
              idx: currIdx,
              def: (0, drop_1.default)(currDef),
              ruleStack: (0, dropRight_1.default)(currRuleStack),
              occurrenceStack: (0, dropRight_1.default)(currOccurrenceStack)
            };
            possiblePaths.push(nextPath);
          } else if (prod instanceof gast_1.Terminal) {
            if (currIdx < tokenVectorLength - 1) {
              var nextIdx = currIdx + 1;
              var actualToken = tokenVector[nextIdx];
              if (tokMatcher(actualToken, prod.terminalType)) {
                var nextPath = {
                  idx: nextIdx,
                  def: (0, drop_1.default)(currDef),
                  ruleStack: currRuleStack,
                  occurrenceStack: currOccurrenceStack
                };
                possiblePaths.push(nextPath);
              }
            } else if (currIdx === tokenVectorLength - 1) {
              result.push({
                nextTokenType: prod.terminalType,
                nextTokenOccurrence: prod.idx,
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
              });
              foundCompletePath = true;
            } else {
              throw Error("non exhaustive match");
            }
          } else if (prod instanceof gast_1.NonTerminal) {
            var newRuleStack = (0, clone_1.default)(currRuleStack);
            newRuleStack.push(prod.nonTerminalName);
            var newOccurrenceStack = (0, clone_1.default)(currOccurrenceStack);
            newOccurrenceStack.push(prod.idx);
            var nextPath = {
              idx: currIdx,
              def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, (0, drop_1.default)(currDef)),
              ruleStack: newRuleStack,
              occurrenceStack: newOccurrenceStack
            };
            possiblePaths.push(nextPath);
          } else if (prod instanceof gast_1.Option) {
            var nextPathWithout = {
              idx: currIdx,
              def: (0, drop_1.default)(currDef),
              ruleStack: currRuleStack,
              occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWithout);
            possiblePaths.push(EXIT_ALTERNATIVE);
            var nextPathWith = {
              idx: currIdx,
              def: prod.definition.concat((0, drop_1.default)(currDef)),
              ruleStack: currRuleStack,
              occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWith);
          } else if (prod instanceof gast_1.RepetitionMandatory) {
            var secondIteration = new gast_1.Repetition({
              definition: prod.definition,
              idx: prod.idx
            });
            var nextDef = prod.definition.concat([secondIteration], (0, drop_1.default)(currDef));
            var nextPath = {
              idx: currIdx,
              def: nextDef,
              ruleStack: currRuleStack,
              occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPath);
          } else if (prod instanceof gast_1.RepetitionMandatoryWithSeparator) {
            var separatorGast = new gast_1.Terminal({
              terminalType: prod.separator
            });
            var secondIteration = new gast_1.Repetition({
              definition: [separatorGast].concat(prod.definition),
              idx: prod.idx
            });
            var nextDef = prod.definition.concat([secondIteration], (0, drop_1.default)(currDef));
            var nextPath = {
              idx: currIdx,
              def: nextDef,
              ruleStack: currRuleStack,
              occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPath);
          } else if (prod instanceof gast_1.RepetitionWithSeparator) {
            var nextPathWithout = {
              idx: currIdx,
              def: (0, drop_1.default)(currDef),
              ruleStack: currRuleStack,
              occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWithout);
            possiblePaths.push(EXIT_ALTERNATIVE);
            var separatorGast = new gast_1.Terminal({
              terminalType: prod.separator
            });
            var nthRepetition = new gast_1.Repetition({
              definition: [separatorGast].concat(prod.definition),
              idx: prod.idx
            });
            var nextDef = prod.definition.concat([nthRepetition], (0, drop_1.default)(currDef));
            var nextPathWith = {
              idx: currIdx,
              def: nextDef,
              ruleStack: currRuleStack,
              occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWith);
          } else if (prod instanceof gast_1.Repetition) {
            var nextPathWithout = {
              idx: currIdx,
              def: (0, drop_1.default)(currDef),
              ruleStack: currRuleStack,
              occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWithout);
            possiblePaths.push(EXIT_ALTERNATIVE);
            var nthRepetition = new gast_1.Repetition({
              definition: prod.definition,
              idx: prod.idx
            });
            var nextDef = prod.definition.concat([nthRepetition], (0, drop_1.default)(currDef));
            var nextPathWith = {
              idx: currIdx,
              def: nextDef,
              ruleStack: currRuleStack,
              occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWith);
          } else if (prod instanceof gast_1.Alternation) {
            for (var i = prod.definition.length - 1; i >= 0; i--) {
              var currAlt = prod.definition[i];
              var currAltPath = {
                idx: currIdx,
                def: currAlt.definition.concat((0, drop_1.default)(currDef)),
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
              };
              possiblePaths.push(currAltPath);
              possiblePaths.push(EXIT_ALTERNATIVE);
            }
          } else if (prod instanceof gast_1.Alternative) {
            possiblePaths.push({
              idx: currIdx,
              def: prod.definition.concat((0, drop_1.default)(currDef)),
              ruleStack: currRuleStack,
              occurrenceStack: currOccurrenceStack
            });
          } else if (prod instanceof gast_1.Rule) {
            possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));
          } else {
            throw Error("non exhaustive match");
          }
        }
        return result;
      }
      exports2.nextPossibleTokensAfter = nextPossibleTokensAfter;
      function expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {
        var newRuleStack = (0, clone_1.default)(currRuleStack);
        newRuleStack.push(topRule.name);
        var newCurrOccurrenceStack = (0, clone_1.default)(currOccurrenceStack);
        newCurrOccurrenceStack.push(1);
        return {
          idx: currIdx,
          def: topRule.definition,
          ruleStack: newRuleStack,
          occurrenceStack: newCurrOccurrenceStack
        };
      }
    }
  });

  // node_modules/chevrotain/lib/src/parse/grammar/lookahead.js
  var require_lookahead = __commonJS({
    "node_modules/chevrotain/lib/src/parse/grammar/lookahead.js"(exports2) {
      "use strict";
      var __extends = exports2 && exports2.__extends || function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2)
              if (Object.prototype.hasOwnProperty.call(b2, p))
                d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.areTokenCategoriesNotUsed = exports2.isStrictPrefixOfPath = exports2.containsPath = exports2.getLookaheadPathsForOptionalProd = exports2.getLookaheadPathsForOr = exports2.lookAheadSequenceFromAlternatives = exports2.buildSingleAlternativeLookaheadFunction = exports2.buildAlternativesLookAheadFunc = exports2.buildLookaheadFuncForOptionalProd = exports2.buildLookaheadFuncForOr = exports2.getLookaheadPaths = exports2.getProdType = exports2.PROD_TYPE = void 0;
      var isEmpty_1 = __importDefault(require_isEmpty());
      var flatten_1 = __importDefault(require_flatten());
      var every_1 = __importDefault(require_every());
      var map_1 = __importDefault(require_map());
      var forEach_1 = __importDefault(require_forEach());
      var has_1 = __importDefault(require_has());
      var reduce_1 = __importDefault(require_reduce());
      var interpreter_1 = require_interpreter();
      var rest_1 = require_rest();
      var tokens_1 = require_tokens();
      var gast_1 = require_api5();
      var gast_2 = require_api5();
      var PROD_TYPE;
      (function(PROD_TYPE2) {
        PROD_TYPE2[PROD_TYPE2["OPTION"] = 0] = "OPTION";
        PROD_TYPE2[PROD_TYPE2["REPETITION"] = 1] = "REPETITION";
        PROD_TYPE2[PROD_TYPE2["REPETITION_MANDATORY"] = 2] = "REPETITION_MANDATORY";
        PROD_TYPE2[PROD_TYPE2["REPETITION_MANDATORY_WITH_SEPARATOR"] = 3] = "REPETITION_MANDATORY_WITH_SEPARATOR";
        PROD_TYPE2[PROD_TYPE2["REPETITION_WITH_SEPARATOR"] = 4] = "REPETITION_WITH_SEPARATOR";
        PROD_TYPE2[PROD_TYPE2["ALTERNATION"] = 5] = "ALTERNATION";
      })(PROD_TYPE = exports2.PROD_TYPE || (exports2.PROD_TYPE = {}));
      function getProdType(prod) {
        if (prod instanceof gast_1.Option || prod === "Option") {
          return PROD_TYPE.OPTION;
        } else if (prod instanceof gast_1.Repetition || prod === "Repetition") {
          return PROD_TYPE.REPETITION;
        } else if (prod instanceof gast_1.RepetitionMandatory || prod === "RepetitionMandatory") {
          return PROD_TYPE.REPETITION_MANDATORY;
        } else if (prod instanceof gast_1.RepetitionMandatoryWithSeparator || prod === "RepetitionMandatoryWithSeparator") {
          return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;
        } else if (prod instanceof gast_1.RepetitionWithSeparator || prod === "RepetitionWithSeparator") {
          return PROD_TYPE.REPETITION_WITH_SEPARATOR;
        } else if (prod instanceof gast_1.Alternation || prod === "Alternation") {
          return PROD_TYPE.ALTERNATION;
        } else {
          throw Error("non exhaustive match");
        }
      }
      exports2.getProdType = getProdType;
      function getLookaheadPaths(options) {
        var occurrence = options.occurrence, rule = options.rule, prodType = options.prodType, maxLookahead = options.maxLookahead;
        var type = getProdType(prodType);
        if (type === PROD_TYPE.ALTERNATION) {
          return getLookaheadPathsForOr(occurrence, rule, maxLookahead);
        } else {
          return getLookaheadPathsForOptionalProd(occurrence, rule, type, maxLookahead);
        }
      }
      exports2.getLookaheadPaths = getLookaheadPaths;
      function buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {
        var lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);
        var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths) ? tokens_1.tokenStructuredMatcherNoCategories : tokens_1.tokenStructuredMatcher;
        return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher, dynamicTokensEnabled);
      }
      exports2.buildLookaheadFuncForOr = buildLookaheadFuncForOr;
      function buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {
        var lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);
        var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths) ? tokens_1.tokenStructuredMatcherNoCategories : tokens_1.tokenStructuredMatcher;
        return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled);
      }
      exports2.buildLookaheadFuncForOptionalProd = buildLookaheadFuncForOptionalProd;
      function buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {
        var numOfAlts = alts.length;
        var areAllOneTokenLookahead = (0, every_1.default)(alts, function(currAlt) {
          return (0, every_1.default)(currAlt, function(currPath) {
            return currPath.length === 1;
          });
        });
        if (hasPredicates) {
          return function(orAlts) {
            var predicates = (0, map_1.default)(orAlts, function(currAlt2) {
              return currAlt2.GATE;
            });
            for (var t = 0; t < numOfAlts; t++) {
              var currAlt = alts[t];
              var currNumOfPaths = currAlt.length;
              var currPredicate = predicates[t];
              if (currPredicate !== void 0 && currPredicate.call(this) === false) {
                continue;
              }
              nextPath:
                for (var j = 0; j < currNumOfPaths; j++) {
                  var currPath = currAlt[j];
                  var currPathLength = currPath.length;
                  for (var i = 0; i < currPathLength; i++) {
                    var nextToken = this.LA(i + 1);
                    if (tokenMatcher(nextToken, currPath[i]) === false) {
                      continue nextPath;
                    }
                  }
                  return t;
                }
            }
            return void 0;
          };
        } else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {
          var singleTokenAlts = (0, map_1.default)(alts, function(currAlt) {
            return (0, flatten_1.default)(currAlt);
          });
          var choiceToAlt_1 = (0, reduce_1.default)(singleTokenAlts, function(result, currAlt, idx) {
            (0, forEach_1.default)(currAlt, function(currTokType) {
              if (!(0, has_1.default)(result, currTokType.tokenTypeIdx)) {
                result[currTokType.tokenTypeIdx] = idx;
              }
              (0, forEach_1.default)(currTokType.categoryMatches, function(currExtendingType) {
                if (!(0, has_1.default)(result, currExtendingType)) {
                  result[currExtendingType] = idx;
                }
              });
            });
            return result;
          }, {});
          return function() {
            var nextToken = this.LA(1);
            return choiceToAlt_1[nextToken.tokenTypeIdx];
          };
        } else {
          return function() {
            for (var t = 0; t < numOfAlts; t++) {
              var currAlt = alts[t];
              var currNumOfPaths = currAlt.length;
              nextPath:
                for (var j = 0; j < currNumOfPaths; j++) {
                  var currPath = currAlt[j];
                  var currPathLength = currPath.length;
                  for (var i = 0; i < currPathLength; i++) {
                    var nextToken = this.LA(i + 1);
                    if (tokenMatcher(nextToken, currPath[i]) === false) {
                      continue nextPath;
                    }
                  }
                  return t;
                }
            }
            return void 0;
          };
        }
      }
      exports2.buildAlternativesLookAheadFunc = buildAlternativesLookAheadFunc;
      function buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled) {
        var areAllOneTokenLookahead = (0, every_1.default)(alt, function(currPath) {
          return currPath.length === 1;
        });
        var numOfPaths = alt.length;
        if (areAllOneTokenLookahead && !dynamicTokensEnabled) {
          var singleTokensTypes = (0, flatten_1.default)(alt);
          if (singleTokensTypes.length === 1 && (0, isEmpty_1.default)(singleTokensTypes[0].categoryMatches)) {
            var expectedTokenType = singleTokensTypes[0];
            var expectedTokenUniqueKey_1 = expectedTokenType.tokenTypeIdx;
            return function() {
              return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey_1;
            };
          } else {
            var choiceToAlt_2 = (0, reduce_1.default)(singleTokensTypes, function(result, currTokType, idx) {
              result[currTokType.tokenTypeIdx] = true;
              (0, forEach_1.default)(currTokType.categoryMatches, function(currExtendingType) {
                result[currExtendingType] = true;
              });
              return result;
            }, []);
            return function() {
              var nextToken = this.LA(1);
              return choiceToAlt_2[nextToken.tokenTypeIdx] === true;
            };
          }
        } else {
          return function() {
            nextPath:
              for (var j = 0; j < numOfPaths; j++) {
                var currPath = alt[j];
                var currPathLength = currPath.length;
                for (var i = 0; i < currPathLength; i++) {
                  var nextToken = this.LA(i + 1);
                  if (tokenMatcher(nextToken, currPath[i]) === false) {
                    continue nextPath;
                  }
                }
                return true;
              }
            return false;
          };
        }
      }
      exports2.buildSingleAlternativeLookaheadFunction = buildSingleAlternativeLookaheadFunction;
      var RestDefinitionFinderWalker = (
        /** @class */
        function(_super) {
          __extends(RestDefinitionFinderWalker2, _super);
          function RestDefinitionFinderWalker2(topProd, targetOccurrence, targetProdType) {
            var _this = _super.call(this) || this;
            _this.topProd = topProd;
            _this.targetOccurrence = targetOccurrence;
            _this.targetProdType = targetProdType;
            return _this;
          }
          RestDefinitionFinderWalker2.prototype.startWalking = function() {
            this.walk(this.topProd);
            return this.restDef;
          };
          RestDefinitionFinderWalker2.prototype.checkIsTarget = function(node, expectedProdType, currRest, prevRest) {
            if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdType) {
              this.restDef = currRest.concat(prevRest);
              return true;
            }
            return false;
          };
          RestDefinitionFinderWalker2.prototype.walkOption = function(optionProd, currRest, prevRest) {
            if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {
              _super.prototype.walkOption.call(this, optionProd, currRest, prevRest);
            }
          };
          RestDefinitionFinderWalker2.prototype.walkAtLeastOne = function(atLeastOneProd, currRest, prevRest) {
            if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {
              _super.prototype.walkOption.call(this, atLeastOneProd, currRest, prevRest);
            }
          };
          RestDefinitionFinderWalker2.prototype.walkAtLeastOneSep = function(atLeastOneSepProd, currRest, prevRest) {
            if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {
              _super.prototype.walkOption.call(this, atLeastOneSepProd, currRest, prevRest);
            }
          };
          RestDefinitionFinderWalker2.prototype.walkMany = function(manyProd, currRest, prevRest) {
            if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {
              _super.prototype.walkOption.call(this, manyProd, currRest, prevRest);
            }
          };
          RestDefinitionFinderWalker2.prototype.walkManySep = function(manySepProd, currRest, prevRest) {
            if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {
              _super.prototype.walkOption.call(this, manySepProd, currRest, prevRest);
            }
          };
          return RestDefinitionFinderWalker2;
        }(rest_1.RestWalker)
      );
      var InsideDefinitionFinderVisitor = (
        /** @class */
        function(_super) {
          __extends(InsideDefinitionFinderVisitor2, _super);
          function InsideDefinitionFinderVisitor2(targetOccurrence, targetProdType, targetRef) {
            var _this = _super.call(this) || this;
            _this.targetOccurrence = targetOccurrence;
            _this.targetProdType = targetProdType;
            _this.targetRef = targetRef;
            _this.result = [];
            return _this;
          }
          InsideDefinitionFinderVisitor2.prototype.checkIsTarget = function(node, expectedProdName) {
            if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdName && (this.targetRef === void 0 || node === this.targetRef)) {
              this.result = node.definition;
            }
          };
          InsideDefinitionFinderVisitor2.prototype.visitOption = function(node) {
            this.checkIsTarget(node, PROD_TYPE.OPTION);
          };
          InsideDefinitionFinderVisitor2.prototype.visitRepetition = function(node) {
            this.checkIsTarget(node, PROD_TYPE.REPETITION);
          };
          InsideDefinitionFinderVisitor2.prototype.visitRepetitionMandatory = function(node) {
            this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);
          };
          InsideDefinitionFinderVisitor2.prototype.visitRepetitionMandatoryWithSeparator = function(node) {
            this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);
          };
          InsideDefinitionFinderVisitor2.prototype.visitRepetitionWithSeparator = function(node) {
            this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);
          };
          InsideDefinitionFinderVisitor2.prototype.visitAlternation = function(node) {
            this.checkIsTarget(node, PROD_TYPE.ALTERNATION);
          };
          return InsideDefinitionFinderVisitor2;
        }(gast_2.GAstVisitor)
      );
      function initializeArrayOfArrays(size) {
        var result = new Array(size);
        for (var i = 0; i < size; i++) {
          result[i] = [];
        }
        return result;
      }
      function pathToHashKeys(path) {
        var keys = [""];
        for (var i = 0; i < path.length; i++) {
          var tokType = path[i];
          var longerKeys = [];
          for (var j = 0; j < keys.length; j++) {
            var currShorterKey = keys[j];
            longerKeys.push(currShorterKey + "_" + tokType.tokenTypeIdx);
            for (var t = 0; t < tokType.categoryMatches.length; t++) {
              var categoriesKeySuffix = "_" + tokType.categoryMatches[t];
              longerKeys.push(currShorterKey + categoriesKeySuffix);
            }
          }
          keys = longerKeys;
        }
        return keys;
      }
      function isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {
        for (var currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {
          if (currAltIdx === idx) {
            continue;
          }
          var otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];
          for (var searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {
            var searchKey = searchPathKeys[searchIdx];
            if (otherAltKnownPathsKeys[searchKey] === true) {
              return false;
            }
          }
        }
        return true;
      }
      function lookAheadSequenceFromAlternatives(altsDefs, k) {
        var partialAlts = (0, map_1.default)(altsDefs, function(currAlt) {
          return (0, interpreter_1.possiblePathsFrom)([currAlt], 1);
        });
        var finalResult = initializeArrayOfArrays(partialAlts.length);
        var altsHashes = (0, map_1.default)(partialAlts, function(currAltPaths) {
          var dict = {};
          (0, forEach_1.default)(currAltPaths, function(item) {
            var keys = pathToHashKeys(item.partialPath);
            (0, forEach_1.default)(keys, function(currKey) {
              dict[currKey] = true;
            });
          });
          return dict;
        });
        var newData = partialAlts;
        for (var pathLength = 1; pathLength <= k; pathLength++) {
          var currDataset = newData;
          newData = initializeArrayOfArrays(currDataset.length);
          var _loop_1 = function(altIdx2) {
            var currAltPathsAndSuffixes = currDataset[altIdx2];
            for (var currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {
              var currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;
              var suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;
              var prefixKeys = pathToHashKeys(currPathPrefix);
              var isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx2);
              if (isUnique || (0, isEmpty_1.default)(suffixDef) || currPathPrefix.length === k) {
                var currAltResult = finalResult[altIdx2];
                if (containsPath(currAltResult, currPathPrefix) === false) {
                  currAltResult.push(currPathPrefix);
                  for (var j = 0; j < prefixKeys.length; j++) {
                    var currKey = prefixKeys[j];
                    altsHashes[altIdx2][currKey] = true;
                  }
                }
              } else {
                var newPartialPathsAndSuffixes = (0, interpreter_1.possiblePathsFrom)(suffixDef, pathLength + 1, currPathPrefix);
                newData[altIdx2] = newData[altIdx2].concat(newPartialPathsAndSuffixes);
                (0, forEach_1.default)(newPartialPathsAndSuffixes, function(item) {
                  var prefixKeys2 = pathToHashKeys(item.partialPath);
                  (0, forEach_1.default)(prefixKeys2, function(key) {
                    altsHashes[altIdx2][key] = true;
                  });
                });
              }
            }
          };
          for (var altIdx = 0; altIdx < currDataset.length; altIdx++) {
            _loop_1(altIdx);
          }
        }
        return finalResult;
      }
      exports2.lookAheadSequenceFromAlternatives = lookAheadSequenceFromAlternatives;
      function getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {
        var visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);
        ruleGrammar.accept(visitor);
        return lookAheadSequenceFromAlternatives(visitor.result, k);
      }
      exports2.getLookaheadPathsForOr = getLookaheadPathsForOr;
      function getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {
        var insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);
        ruleGrammar.accept(insideDefVisitor);
        var insideDef = insideDefVisitor.result;
        var afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);
        var afterDef = afterDefWalker.startWalking();
        var insideFlat = new gast_1.Alternative({ definition: insideDef });
        var afterFlat = new gast_1.Alternative({ definition: afterDef });
        return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);
      }
      exports2.getLookaheadPathsForOptionalProd = getLookaheadPathsForOptionalProd;
      function containsPath(alternative, searchPath) {
        compareOtherPath:
          for (var i = 0; i < alternative.length; i++) {
            var otherPath = alternative[i];
            if (otherPath.length !== searchPath.length) {
              continue;
            }
            for (var j = 0; j < otherPath.length; j++) {
              var searchTok = searchPath[j];
              var otherTok = otherPath[j];
              var matchingTokens = searchTok === otherTok || otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== void 0;
              if (matchingTokens === false) {
                continue compareOtherPath;
              }
            }
            return true;
          }
        return false;
      }
      exports2.containsPath = containsPath;
      function isStrictPrefixOfPath(prefix, other) {
        return prefix.length < other.length && (0, every_1.default)(prefix, function(tokType, idx) {
          var otherTokType = other[idx];
          return tokType === otherTokType || otherTokType.categoryMatchesMap[tokType.tokenTypeIdx];
        });
      }
      exports2.isStrictPrefixOfPath = isStrictPrefixOfPath;
      function areTokenCategoriesNotUsed(lookAheadPaths) {
        return (0, every_1.default)(lookAheadPaths, function(singleAltPaths) {
          return (0, every_1.default)(singleAltPaths, function(singlePath) {
            return (0, every_1.default)(singlePath, function(token) {
              return (0, isEmpty_1.default)(token.categoryMatches);
            });
          });
        });
      }
      exports2.areTokenCategoriesNotUsed = areTokenCategoriesNotUsed;
    }
  });

  // node_modules/chevrotain/lib/src/parse/grammar/checks.js
  var require_checks = __commonJS({
    "node_modules/chevrotain/lib/src/parse/grammar/checks.js"(exports2) {
      "use strict";
      var __extends = exports2 && exports2.__extends || function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2)
              if (Object.prototype.hasOwnProperty.call(b2, p))
                d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __assign = exports2 && exports2.__assign || function() {
        __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.checkPrefixAlternativesAmbiguities = exports2.validateSomeNonEmptyLookaheadPath = exports2.validateTooManyAlts = exports2.RepetitionCollector = exports2.validateAmbiguousAlternationAlternatives = exports2.validateEmptyOrAlternative = exports2.getFirstNoneTerminal = exports2.validateNoLeftRecursion = exports2.validateRuleIsOverridden = exports2.validateRuleDoesNotAlreadyExist = exports2.OccurrenceValidationCollector = exports2.identifyProductionForDuplicates = exports2.validateGrammar = exports2.validateLookahead = void 0;
      var first_1 = __importDefault(require_first2());
      var isEmpty_1 = __importDefault(require_isEmpty());
      var drop_1 = __importDefault(require_drop());
      var flatten_1 = __importDefault(require_flatten());
      var filter_1 = __importDefault(require_filter());
      var reject_1 = __importDefault(require_reject());
      var difference_1 = __importDefault(require_difference());
      var map_1 = __importDefault(require_map());
      var forEach_1 = __importDefault(require_forEach());
      var groupBy_1 = __importDefault(require_groupBy());
      var reduce_1 = __importDefault(require_reduce());
      var pickBy_1 = __importDefault(require_pickBy());
      var values_1 = __importDefault(require_values());
      var includes_1 = __importDefault(require_includes());
      var flatMap_1 = __importDefault(require_flatMap());
      var clone_1 = __importDefault(require_clone());
      var parser_1 = require_parser();
      var gast_1 = require_api5();
      var lookahead_1 = require_lookahead();
      var interpreter_1 = require_interpreter();
      var gast_2 = require_api5();
      var gast_3 = require_api5();
      var dropRight_1 = __importDefault(require_dropRight());
      var compact_1 = __importDefault(require_compact());
      var tokens_1 = require_tokens();
      function validateLookahead(options) {
        var lookaheadValidationErrorMessages = options.lookaheadStrategy.validate({
          rules: options.rules,
          tokenTypes: options.tokenTypes,
          grammarName: options.grammarName
        });
        return (0, map_1.default)(lookaheadValidationErrorMessages, function(errorMessage) {
          return __assign({ type: parser_1.ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION }, errorMessage);
        });
      }
      exports2.validateLookahead = validateLookahead;
      function validateGrammar(topLevels, tokenTypes, errMsgProvider, grammarName) {
        var duplicateErrors = (0, flatMap_1.default)(topLevels, function(currTopLevel) {
          return validateDuplicateProductions(currTopLevel, errMsgProvider);
        });
        var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);
        var tooManyAltsErrors = (0, flatMap_1.default)(topLevels, function(curRule) {
          return validateTooManyAlts(curRule, errMsgProvider);
        });
        var duplicateRulesError = (0, flatMap_1.default)(topLevels, function(curRule) {
          return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);
        });
        return duplicateErrors.concat(termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError);
      }
      exports2.validateGrammar = validateGrammar;
      function validateDuplicateProductions(topLevelRule, errMsgProvider) {
        var collectorVisitor = new OccurrenceValidationCollector();
        topLevelRule.accept(collectorVisitor);
        var allRuleProductions = collectorVisitor.allProductions;
        var productionGroups = (0, groupBy_1.default)(allRuleProductions, identifyProductionForDuplicates);
        var duplicates = (0, pickBy_1.default)(productionGroups, function(currGroup) {
          return currGroup.length > 1;
        });
        var errors = (0, map_1.default)((0, values_1.default)(duplicates), function(currDuplicates) {
          var firstProd = (0, first_1.default)(currDuplicates);
          var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);
          var dslName = (0, gast_1.getProductionDslName)(firstProd);
          var defError = {
            message: msg,
            type: parser_1.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,
            ruleName: topLevelRule.name,
            dslName,
            occurrence: firstProd.idx
          };
          var param = getExtraProductionArgument(firstProd);
          if (param) {
            defError.parameter = param;
          }
          return defError;
        });
        return errors;
      }
      function identifyProductionForDuplicates(prod) {
        return "".concat((0, gast_1.getProductionDslName)(prod), "_#_").concat(prod.idx, "_#_").concat(getExtraProductionArgument(prod));
      }
      exports2.identifyProductionForDuplicates = identifyProductionForDuplicates;
      function getExtraProductionArgument(prod) {
        if (prod instanceof gast_2.Terminal) {
          return prod.terminalType.name;
        } else if (prod instanceof gast_2.NonTerminal) {
          return prod.nonTerminalName;
        } else {
          return "";
        }
      }
      var OccurrenceValidationCollector = (
        /** @class */
        function(_super) {
          __extends(OccurrenceValidationCollector2, _super);
          function OccurrenceValidationCollector2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.allProductions = [];
            return _this;
          }
          OccurrenceValidationCollector2.prototype.visitNonTerminal = function(subrule) {
            this.allProductions.push(subrule);
          };
          OccurrenceValidationCollector2.prototype.visitOption = function(option) {
            this.allProductions.push(option);
          };
          OccurrenceValidationCollector2.prototype.visitRepetitionWithSeparator = function(manySep) {
            this.allProductions.push(manySep);
          };
          OccurrenceValidationCollector2.prototype.visitRepetitionMandatory = function(atLeastOne) {
            this.allProductions.push(atLeastOne);
          };
          OccurrenceValidationCollector2.prototype.visitRepetitionMandatoryWithSeparator = function(atLeastOneSep) {
            this.allProductions.push(atLeastOneSep);
          };
          OccurrenceValidationCollector2.prototype.visitRepetition = function(many) {
            this.allProductions.push(many);
          };
          OccurrenceValidationCollector2.prototype.visitAlternation = function(or2) {
            this.allProductions.push(or2);
          };
          OccurrenceValidationCollector2.prototype.visitTerminal = function(terminal) {
            this.allProductions.push(terminal);
          };
          return OccurrenceValidationCollector2;
        }(gast_3.GAstVisitor)
      );
      exports2.OccurrenceValidationCollector = OccurrenceValidationCollector;
      function validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {
        var errors = [];
        var occurrences = (0, reduce_1.default)(allRules, function(result, curRule) {
          if (curRule.name === rule.name) {
            return result + 1;
          }
          return result;
        }, 0);
        if (occurrences > 1) {
          var errMsg = errMsgProvider.buildDuplicateRuleNameError({
            topLevelRule: rule,
            grammarName: className
          });
          errors.push({
            message: errMsg,
            type: parser_1.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,
            ruleName: rule.name
          });
        }
        return errors;
      }
      exports2.validateRuleDoesNotAlreadyExist = validateRuleDoesNotAlreadyExist;
      function validateRuleIsOverridden(ruleName, definedRulesNames, className) {
        var errors = [];
        var errMsg;
        if (!(0, includes_1.default)(definedRulesNames, ruleName)) {
          errMsg = "Invalid rule override, rule: ->".concat(ruleName, "<- cannot be overridden in the grammar: ->").concat(className, "<-") + "as it is not defined in any of the super grammars ";
          errors.push({
            message: errMsg,
            type: parser_1.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,
            ruleName
          });
        }
        return errors;
      }
      exports2.validateRuleIsOverridden = validateRuleIsOverridden;
      function validateNoLeftRecursion(topRule, currRule, errMsgProvider, path) {
        if (path === void 0) {
          path = [];
        }
        var errors = [];
        var nextNonTerminals = getFirstNoneTerminal(currRule.definition);
        if ((0, isEmpty_1.default)(nextNonTerminals)) {
          return [];
        } else {
          var ruleName = topRule.name;
          var foundLeftRecursion = (0, includes_1.default)(nextNonTerminals, topRule);
          if (foundLeftRecursion) {
            errors.push({
              message: errMsgProvider.buildLeftRecursionError({
                topLevelRule: topRule,
                leftRecursionPath: path
              }),
              type: parser_1.ParserDefinitionErrorType.LEFT_RECURSION,
              ruleName
            });
          }
          var validNextSteps = (0, difference_1.default)(nextNonTerminals, path.concat([topRule]));
          var errorsFromNextSteps = (0, flatMap_1.default)(validNextSteps, function(currRefRule) {
            var newPath = (0, clone_1.default)(path);
            newPath.push(currRefRule);
            return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);
          });
          return errors.concat(errorsFromNextSteps);
        }
      }
      exports2.validateNoLeftRecursion = validateNoLeftRecursion;
      function getFirstNoneTerminal(definition) {
        var result = [];
        if ((0, isEmpty_1.default)(definition)) {
          return result;
        }
        var firstProd = (0, first_1.default)(definition);
        if (firstProd instanceof gast_2.NonTerminal) {
          result.push(firstProd.referencedRule);
        } else if (firstProd instanceof gast_2.Alternative || firstProd instanceof gast_2.Option || firstProd instanceof gast_2.RepetitionMandatory || firstProd instanceof gast_2.RepetitionMandatoryWithSeparator || firstProd instanceof gast_2.RepetitionWithSeparator || firstProd instanceof gast_2.Repetition) {
          result = result.concat(getFirstNoneTerminal(firstProd.definition));
        } else if (firstProd instanceof gast_2.Alternation) {
          result = (0, flatten_1.default)((0, map_1.default)(firstProd.definition, function(currSubDef) {
            return getFirstNoneTerminal(currSubDef.definition);
          }));
        } else if (firstProd instanceof gast_2.Terminal) {
        } else {
          throw Error("non exhaustive match");
        }
        var isFirstOptional = (0, gast_1.isOptionalProd)(firstProd);
        var hasMore = definition.length > 1;
        if (isFirstOptional && hasMore) {
          var rest = (0, drop_1.default)(definition);
          return result.concat(getFirstNoneTerminal(rest));
        } else {
          return result;
        }
      }
      exports2.getFirstNoneTerminal = getFirstNoneTerminal;
      var OrCollector = (
        /** @class */
        function(_super) {
          __extends(OrCollector2, _super);
          function OrCollector2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.alternations = [];
            return _this;
          }
          OrCollector2.prototype.visitAlternation = function(node) {
            this.alternations.push(node);
          };
          return OrCollector2;
        }(gast_3.GAstVisitor)
      );
      function validateEmptyOrAlternative(topLevelRule, errMsgProvider) {
        var orCollector = new OrCollector();
        topLevelRule.accept(orCollector);
        var ors = orCollector.alternations;
        var errors = (0, flatMap_1.default)(ors, function(currOr) {
          var exceptLast = (0, dropRight_1.default)(currOr.definition);
          return (0, flatMap_1.default)(exceptLast, function(currAlternative, currAltIdx) {
            var possibleFirstInAlt = (0, interpreter_1.nextPossibleTokensAfter)([currAlternative], [], tokens_1.tokenStructuredMatcher, 1);
            if ((0, isEmpty_1.default)(possibleFirstInAlt)) {
              return [
                {
                  message: errMsgProvider.buildEmptyAlternationError({
                    topLevelRule,
                    alternation: currOr,
                    emptyChoiceIdx: currAltIdx
                  }),
                  type: parser_1.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,
                  ruleName: topLevelRule.name,
                  occurrence: currOr.idx,
                  alternative: currAltIdx + 1
                }
              ];
            } else {
              return [];
            }
          });
        });
        return errors;
      }
      exports2.validateEmptyOrAlternative = validateEmptyOrAlternative;
      function validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {
        var orCollector = new OrCollector();
        topLevelRule.accept(orCollector);
        var ors = orCollector.alternations;
        ors = (0, reject_1.default)(ors, function(currOr) {
          return currOr.ignoreAmbiguities === true;
        });
        var errors = (0, flatMap_1.default)(ors, function(currOr) {
          var currOccurrence = currOr.idx;
          var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;
          var alternatives = (0, lookahead_1.getLookaheadPathsForOr)(currOccurrence, topLevelRule, actualMaxLookahead, currOr);
          var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);
          var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);
          return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors);
        });
        return errors;
      }
      exports2.validateAmbiguousAlternationAlternatives = validateAmbiguousAlternationAlternatives;
      var RepetitionCollector = (
        /** @class */
        function(_super) {
          __extends(RepetitionCollector2, _super);
          function RepetitionCollector2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.allProductions = [];
            return _this;
          }
          RepetitionCollector2.prototype.visitRepetitionWithSeparator = function(manySep) {
            this.allProductions.push(manySep);
          };
          RepetitionCollector2.prototype.visitRepetitionMandatory = function(atLeastOne) {
            this.allProductions.push(atLeastOne);
          };
          RepetitionCollector2.prototype.visitRepetitionMandatoryWithSeparator = function(atLeastOneSep) {
            this.allProductions.push(atLeastOneSep);
          };
          RepetitionCollector2.prototype.visitRepetition = function(many) {
            this.allProductions.push(many);
          };
          return RepetitionCollector2;
        }(gast_3.GAstVisitor)
      );
      exports2.RepetitionCollector = RepetitionCollector;
      function validateTooManyAlts(topLevelRule, errMsgProvider) {
        var orCollector = new OrCollector();
        topLevelRule.accept(orCollector);
        var ors = orCollector.alternations;
        var errors = (0, flatMap_1.default)(ors, function(currOr) {
          if (currOr.definition.length > 255) {
            return [
              {
                message: errMsgProvider.buildTooManyAlternativesError({
                  topLevelRule,
                  alternation: currOr
                }),
                type: parser_1.ParserDefinitionErrorType.TOO_MANY_ALTS,
                ruleName: topLevelRule.name,
                occurrence: currOr.idx
              }
            ];
          } else {
            return [];
          }
        });
        return errors;
      }
      exports2.validateTooManyAlts = validateTooManyAlts;
      function validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {
        var errors = [];
        (0, forEach_1.default)(topLevelRules, function(currTopRule) {
          var collectorVisitor = new RepetitionCollector();
          currTopRule.accept(collectorVisitor);
          var allRuleProductions = collectorVisitor.allProductions;
          (0, forEach_1.default)(allRuleProductions, function(currProd) {
            var prodType = (0, lookahead_1.getProdType)(currProd);
            var actualMaxLookahead = currProd.maxLookahead || maxLookahead;
            var currOccurrence = currProd.idx;
            var paths = (0, lookahead_1.getLookaheadPathsForOptionalProd)(currOccurrence, currTopRule, prodType, actualMaxLookahead);
            var pathsInsideProduction = paths[0];
            if ((0, isEmpty_1.default)((0, flatten_1.default)(pathsInsideProduction))) {
              var errMsg = errMsgProvider.buildEmptyRepetitionError({
                topLevelRule: currTopRule,
                repetition: currProd
              });
              errors.push({
                message: errMsg,
                type: parser_1.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,
                ruleName: currTopRule.name
              });
            }
          });
        });
        return errors;
      }
      exports2.validateSomeNonEmptyLookaheadPath = validateSomeNonEmptyLookaheadPath;
      function checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {
        var foundAmbiguousPaths = [];
        var identicalAmbiguities = (0, reduce_1.default)(alternatives, function(result, currAlt, currAltIdx) {
          if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {
            return result;
          }
          (0, forEach_1.default)(currAlt, function(currPath) {
            var altsCurrPathAppearsIn = [currAltIdx];
            (0, forEach_1.default)(alternatives, function(currOtherAlt, currOtherAltIdx) {
              if (currAltIdx !== currOtherAltIdx && (0, lookahead_1.containsPath)(currOtherAlt, currPath) && // ignore (skip) ambiguities with this "other" alternative
              alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {
                altsCurrPathAppearsIn.push(currOtherAltIdx);
              }
            });
            if (altsCurrPathAppearsIn.length > 1 && !(0, lookahead_1.containsPath)(foundAmbiguousPaths, currPath)) {
              foundAmbiguousPaths.push(currPath);
              result.push({
                alts: altsCurrPathAppearsIn,
                path: currPath
              });
            }
          });
          return result;
        }, []);
        var currErrors = (0, map_1.default)(identicalAmbiguities, function(currAmbDescriptor) {
          var ambgIndices = (0, map_1.default)(currAmbDescriptor.alts, function(currAltIdx) {
            return currAltIdx + 1;
          });
          var currMessage = errMsgProvider.buildAlternationAmbiguityError({
            topLevelRule: rule,
            alternation,
            ambiguityIndices: ambgIndices,
            prefixPath: currAmbDescriptor.path
          });
          return {
            message: currMessage,
            type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_ALTS,
            ruleName: rule.name,
            occurrence: alternation.idx,
            alternatives: currAmbDescriptor.alts
          };
        });
        return currErrors;
      }
      function checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {
        var pathsAndIndices = (0, reduce_1.default)(alternatives, function(result, currAlt, idx) {
          var currPathsAndIdx = (0, map_1.default)(currAlt, function(currPath) {
            return { idx, path: currPath };
          });
          return result.concat(currPathsAndIdx);
        }, []);
        var errors = (0, compact_1.default)((0, flatMap_1.default)(pathsAndIndices, function(currPathAndIdx) {
          var alternativeGast = alternation.definition[currPathAndIdx.idx];
          if (alternativeGast.ignoreAmbiguities === true) {
            return [];
          }
          var targetIdx = currPathAndIdx.idx;
          var targetPath = currPathAndIdx.path;
          var prefixAmbiguitiesPathsAndIndices = (0, filter_1.default)(pathsAndIndices, function(searchPathAndIdx) {
            return (
              // ignore (skip) ambiguities with this "other" alternative
              alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !== true && searchPathAndIdx.idx < targetIdx && // checking for strict prefix because identical lookaheads
              // will be be detected using a different validation.
              (0, lookahead_1.isStrictPrefixOfPath)(searchPathAndIdx.path, targetPath)
            );
          });
          var currPathPrefixErrors = (0, map_1.default)(prefixAmbiguitiesPathsAndIndices, function(currAmbPathAndIdx) {
            var ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];
            var occurrence = alternation.idx === 0 ? "" : alternation.idx;
            var message = errMsgProvider.buildAlternationPrefixAmbiguityError({
              topLevelRule: rule,
              alternation,
              ambiguityIndices: ambgIndices,
              prefixPath: currAmbPathAndIdx.path
            });
            return {
              message,
              type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,
              ruleName: rule.name,
              occurrence,
              alternatives: ambgIndices
            };
          });
          return currPathPrefixErrors;
        }));
        return errors;
      }
      exports2.checkPrefixAlternativesAmbiguities = checkPrefixAlternativesAmbiguities;
      function checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {
        var errors = [];
        var tokenNames = (0, map_1.default)(tokenTypes, function(currToken) {
          return currToken.name;
        });
        (0, forEach_1.default)(topLevels, function(currRule) {
          var currRuleName = currRule.name;
          if ((0, includes_1.default)(tokenNames, currRuleName)) {
            var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);
            errors.push({
              message: errMsg,
              type: parser_1.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,
              ruleName: currRuleName
            });
          }
        });
        return errors;
      }
    }
  });

  // node_modules/chevrotain/lib/src/parse/grammar/gast/gast_resolver_public.js
  var require_gast_resolver_public = __commonJS({
    "node_modules/chevrotain/lib/src/parse/grammar/gast/gast_resolver_public.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.validateGrammar = exports2.resolveGrammar = void 0;
      var forEach_1 = __importDefault(require_forEach());
      var defaults_1 = __importDefault(require_defaults());
      var resolver_1 = require_resolver();
      var checks_1 = require_checks();
      var errors_public_1 = require_errors_public();
      function resolveGrammar(options) {
        var actualOptions = (0, defaults_1.default)(options, {
          errMsgProvider: errors_public_1.defaultGrammarResolverErrorProvider
        });
        var topRulesTable = {};
        (0, forEach_1.default)(options.rules, function(rule) {
          topRulesTable[rule.name] = rule;
        });
        return (0, resolver_1.resolveGrammar)(topRulesTable, actualOptions.errMsgProvider);
      }
      exports2.resolveGrammar = resolveGrammar;
      function validateGrammar(options) {
        options = (0, defaults_1.default)(options, {
          errMsgProvider: errors_public_1.defaultGrammarValidatorErrorProvider
        });
        return (0, checks_1.validateGrammar)(options.rules, options.tokenTypes, options.errMsgProvider, options.grammarName);
      }
      exports2.validateGrammar = validateGrammar;
    }
  });

  // node_modules/chevrotain/lib/src/parse/exceptions_public.js
  var require_exceptions_public = __commonJS({
    "node_modules/chevrotain/lib/src/parse/exceptions_public.js"(exports2) {
      "use strict";
      var __extends = exports2 && exports2.__extends || function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2)
              if (Object.prototype.hasOwnProperty.call(b2, p))
                d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.EarlyExitException = exports2.NotAllInputParsedException = exports2.NoViableAltException = exports2.MismatchedTokenException = exports2.isRecognitionException = void 0;
      var includes_1 = __importDefault(require_includes());
      var MISMATCHED_TOKEN_EXCEPTION = "MismatchedTokenException";
      var NO_VIABLE_ALT_EXCEPTION = "NoViableAltException";
      var EARLY_EXIT_EXCEPTION = "EarlyExitException";
      var NOT_ALL_INPUT_PARSED_EXCEPTION = "NotAllInputParsedException";
      var RECOGNITION_EXCEPTION_NAMES = [
        MISMATCHED_TOKEN_EXCEPTION,
        NO_VIABLE_ALT_EXCEPTION,
        EARLY_EXIT_EXCEPTION,
        NOT_ALL_INPUT_PARSED_EXCEPTION
      ];
      Object.freeze(RECOGNITION_EXCEPTION_NAMES);
      function isRecognitionException(error) {
        return (0, includes_1.default)(RECOGNITION_EXCEPTION_NAMES, error.name);
      }
      exports2.isRecognitionException = isRecognitionException;
      var RecognitionException = (
        /** @class */
        function(_super) {
          __extends(RecognitionException2, _super);
          function RecognitionException2(message, token) {
            var _newTarget = this.constructor;
            var _this = _super.call(this, message) || this;
            _this.token = token;
            _this.resyncedTokens = [];
            Object.setPrototypeOf(_this, _newTarget.prototype);
            if (Error.captureStackTrace) {
              Error.captureStackTrace(_this, _this.constructor);
            }
            return _this;
          }
          return RecognitionException2;
        }(Error)
      );
      var MismatchedTokenException = (
        /** @class */
        function(_super) {
          __extends(MismatchedTokenException2, _super);
          function MismatchedTokenException2(message, token, previousToken) {
            var _this = _super.call(this, message, token) || this;
            _this.previousToken = previousToken;
            _this.name = MISMATCHED_TOKEN_EXCEPTION;
            return _this;
          }
          return MismatchedTokenException2;
        }(RecognitionException)
      );
      exports2.MismatchedTokenException = MismatchedTokenException;
      var NoViableAltException = (
        /** @class */
        function(_super) {
          __extends(NoViableAltException2, _super);
          function NoViableAltException2(message, token, previousToken) {
            var _this = _super.call(this, message, token) || this;
            _this.previousToken = previousToken;
            _this.name = NO_VIABLE_ALT_EXCEPTION;
            return _this;
          }
          return NoViableAltException2;
        }(RecognitionException)
      );
      exports2.NoViableAltException = NoViableAltException;
      var NotAllInputParsedException = (
        /** @class */
        function(_super) {
          __extends(NotAllInputParsedException2, _super);
          function NotAllInputParsedException2(message, token) {
            var _this = _super.call(this, message, token) || this;
            _this.name = NOT_ALL_INPUT_PARSED_EXCEPTION;
            return _this;
          }
          return NotAllInputParsedException2;
        }(RecognitionException)
      );
      exports2.NotAllInputParsedException = NotAllInputParsedException;
      var EarlyExitException = (
        /** @class */
        function(_super) {
          __extends(EarlyExitException2, _super);
          function EarlyExitException2(message, token, previousToken) {
            var _this = _super.call(this, message, token) || this;
            _this.previousToken = previousToken;
            _this.name = EARLY_EXIT_EXCEPTION;
            return _this;
          }
          return EarlyExitException2;
        }(RecognitionException)
      );
      exports2.EarlyExitException = EarlyExitException;
    }
  });

  // node_modules/chevrotain/lib/src/parse/parser/traits/recoverable.js
  var require_recoverable = __commonJS({
    "node_modules/chevrotain/lib/src/parse/parser/traits/recoverable.js"(exports2) {
      "use strict";
      var __extends = exports2 && exports2.__extends || function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2)
              if (Object.prototype.hasOwnProperty.call(b2, p))
                d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.attemptInRepetitionRecovery = exports2.Recoverable = exports2.InRuleRecoveryException = exports2.IN_RULE_RECOVERY_EXCEPTION = exports2.EOF_FOLLOW_KEY = void 0;
      var tokens_public_1 = require_tokens_public();
      var isEmpty_1 = __importDefault(require_isEmpty());
      var dropRight_1 = __importDefault(require_dropRight());
      var flatten_1 = __importDefault(require_flatten());
      var map_1 = __importDefault(require_map());
      var find_1 = __importDefault(require_find());
      var has_1 = __importDefault(require_has());
      var includes_1 = __importDefault(require_includes());
      var clone_1 = __importDefault(require_clone());
      var exceptions_public_1 = require_exceptions_public();
      var constants_1 = require_constants();
      var parser_1 = require_parser();
      exports2.EOF_FOLLOW_KEY = {};
      exports2.IN_RULE_RECOVERY_EXCEPTION = "InRuleRecoveryException";
      var InRuleRecoveryException = (
        /** @class */
        function(_super) {
          __extends(InRuleRecoveryException2, _super);
          function InRuleRecoveryException2(message) {
            var _this = _super.call(this, message) || this;
            _this.name = exports2.IN_RULE_RECOVERY_EXCEPTION;
            return _this;
          }
          return InRuleRecoveryException2;
        }(Error)
      );
      exports2.InRuleRecoveryException = InRuleRecoveryException;
      var Recoverable = (
        /** @class */
        function() {
          function Recoverable2() {
          }
          Recoverable2.prototype.initRecoverable = function(config) {
            this.firstAfterRepMap = {};
            this.resyncFollows = {};
            this.recoveryEnabled = (0, has_1.default)(config, "recoveryEnabled") ? config.recoveryEnabled : parser_1.DEFAULT_PARSER_CONFIG.recoveryEnabled;
            if (this.recoveryEnabled) {
              this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;
            }
          };
          Recoverable2.prototype.getTokenToInsert = function(tokType) {
            var tokToInsert = (0, tokens_public_1.createTokenInstance)(tokType, "", NaN, NaN, NaN, NaN, NaN, NaN);
            tokToInsert.isInsertedInRecovery = true;
            return tokToInsert;
          };
          Recoverable2.prototype.canTokenTypeBeInsertedInRecovery = function(tokType) {
            return true;
          };
          Recoverable2.prototype.canTokenTypeBeDeletedInRecovery = function(tokType) {
            return true;
          };
          Recoverable2.prototype.tryInRepetitionRecovery = function(grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {
            var _this = this;
            var reSyncTokType = this.findReSyncTokenType();
            var savedLexerState = this.exportLexerState();
            var resyncedTokens = [];
            var passedResyncPoint = false;
            var nextTokenWithoutResync = this.LA(1);
            var currToken = this.LA(1);
            var generateErrorMessage = function() {
              var previousToken = _this.LA(0);
              var msg = _this.errorMessageProvider.buildMismatchTokenMessage({
                expected: expectedTokType,
                actual: nextTokenWithoutResync,
                previous: previousToken,
                ruleName: _this.getCurrRuleFullName()
              });
              var error = new exceptions_public_1.MismatchedTokenException(msg, nextTokenWithoutResync, _this.LA(0));
              error.resyncedTokens = (0, dropRight_1.default)(resyncedTokens);
              _this.SAVE_ERROR(error);
            };
            while (!passedResyncPoint) {
              if (this.tokenMatcher(currToken, expectedTokType)) {
                generateErrorMessage();
                return;
              } else if (lookAheadFunc.call(this)) {
                generateErrorMessage();
                grammarRule.apply(this, grammarRuleArgs);
                return;
              } else if (this.tokenMatcher(currToken, reSyncTokType)) {
                passedResyncPoint = true;
              } else {
                currToken = this.SKIP_TOKEN();
                this.addToResyncTokens(currToken, resyncedTokens);
              }
            }
            this.importLexerState(savedLexerState);
          };
          Recoverable2.prototype.shouldInRepetitionRecoveryBeTried = function(expectTokAfterLastMatch, nextTokIdx, notStuck) {
            if (notStuck === false) {
              return false;
            }
            if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {
              return false;
            }
            if (this.isBackTracking()) {
              return false;
            }
            if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {
              return false;
            }
            return true;
          };
          Recoverable2.prototype.getFollowsForInRuleRecovery = function(tokType, tokIdxInRule) {
            var grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);
            var follows = this.getNextPossibleTokenTypes(grammarPath);
            return follows;
          };
          Recoverable2.prototype.tryInRuleRecovery = function(expectedTokType, follows) {
            if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {
              var tokToInsert = this.getTokenToInsert(expectedTokType);
              return tokToInsert;
            }
            if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {
              var nextTok = this.SKIP_TOKEN();
              this.consumeToken();
              return nextTok;
            }
            throw new InRuleRecoveryException("sad sad panda");
          };
          Recoverable2.prototype.canPerformInRuleRecovery = function(expectedToken, follows) {
            return this.canRecoverWithSingleTokenInsertion(expectedToken, follows) || this.canRecoverWithSingleTokenDeletion(expectedToken);
          };
          Recoverable2.prototype.canRecoverWithSingleTokenInsertion = function(expectedTokType, follows) {
            var _this = this;
            if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {
              return false;
            }
            if ((0, isEmpty_1.default)(follows)) {
              return false;
            }
            var mismatchedTok = this.LA(1);
            var isMisMatchedTokInFollows = (0, find_1.default)(follows, function(possibleFollowsTokType) {
              return _this.tokenMatcher(mismatchedTok, possibleFollowsTokType);
            }) !== void 0;
            return isMisMatchedTokInFollows;
          };
          Recoverable2.prototype.canRecoverWithSingleTokenDeletion = function(expectedTokType) {
            if (!this.canTokenTypeBeDeletedInRecovery(expectedTokType)) {
              return false;
            }
            var isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);
            return isNextTokenWhatIsExpected;
          };
          Recoverable2.prototype.isInCurrentRuleReSyncSet = function(tokenTypeIdx) {
            var followKey = this.getCurrFollowKey();
            var currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);
            return (0, includes_1.default)(currentRuleReSyncSet, tokenTypeIdx);
          };
          Recoverable2.prototype.findReSyncTokenType = function() {
            var allPossibleReSyncTokTypes = this.flattenFollowSet();
            var nextToken = this.LA(1);
            var k = 2;
            while (true) {
              var foundMatch = (0, find_1.default)(allPossibleReSyncTokTypes, function(resyncTokType) {
                var canMatch = (0, tokens_public_1.tokenMatcher)(nextToken, resyncTokType);
                return canMatch;
              });
              if (foundMatch !== void 0) {
                return foundMatch;
              }
              nextToken = this.LA(k);
              k++;
            }
          };
          Recoverable2.prototype.getCurrFollowKey = function() {
            if (this.RULE_STACK.length === 1) {
              return exports2.EOF_FOLLOW_KEY;
            }
            var currRuleShortName = this.getLastExplicitRuleShortName();
            var currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();
            var prevRuleShortName = this.getPreviousExplicitRuleShortName();
            return {
              ruleName: this.shortRuleNameToFullName(currRuleShortName),
              idxInCallingRule: currRuleIdx,
              inRule: this.shortRuleNameToFullName(prevRuleShortName)
            };
          };
          Recoverable2.prototype.buildFullFollowKeyStack = function() {
            var _this = this;
            var explicitRuleStack = this.RULE_STACK;
            var explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;
            return (0, map_1.default)(explicitRuleStack, function(ruleName, idx) {
              if (idx === 0) {
                return exports2.EOF_FOLLOW_KEY;
              }
              return {
                ruleName: _this.shortRuleNameToFullName(ruleName),
                idxInCallingRule: explicitOccurrenceStack[idx],
                inRule: _this.shortRuleNameToFullName(explicitRuleStack[idx - 1])
              };
            });
          };
          Recoverable2.prototype.flattenFollowSet = function() {
            var _this = this;
            var followStack = (0, map_1.default)(this.buildFullFollowKeyStack(), function(currKey) {
              return _this.getFollowSetFromFollowKey(currKey);
            });
            return (0, flatten_1.default)(followStack);
          };
          Recoverable2.prototype.getFollowSetFromFollowKey = function(followKey) {
            if (followKey === exports2.EOF_FOLLOW_KEY) {
              return [tokens_public_1.EOF];
            }
            var followName = followKey.ruleName + followKey.idxInCallingRule + constants_1.IN + followKey.inRule;
            return this.resyncFollows[followName];
          };
          Recoverable2.prototype.addToResyncTokens = function(token, resyncTokens) {
            if (!this.tokenMatcher(token, tokens_public_1.EOF)) {
              resyncTokens.push(token);
            }
            return resyncTokens;
          };
          Recoverable2.prototype.reSyncTo = function(tokType) {
            var resyncedTokens = [];
            var nextTok = this.LA(1);
            while (this.tokenMatcher(nextTok, tokType) === false) {
              nextTok = this.SKIP_TOKEN();
              this.addToResyncTokens(nextTok, resyncedTokens);
            }
            return (0, dropRight_1.default)(resyncedTokens);
          };
          Recoverable2.prototype.attemptInRepetitionRecovery = function(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {
          };
          Recoverable2.prototype.getCurrentGrammarPath = function(tokType, tokIdxInRule) {
            var pathRuleStack = this.getHumanReadableRuleStack();
            var pathOccurrenceStack = (0, clone_1.default)(this.RULE_OCCURRENCE_STACK);
            var grammarPath = {
              ruleStack: pathRuleStack,
              occurrenceStack: pathOccurrenceStack,
              lastTok: tokType,
              lastTokOccurrence: tokIdxInRule
            };
            return grammarPath;
          };
          Recoverable2.prototype.getHumanReadableRuleStack = function() {
            var _this = this;
            return (0, map_1.default)(this.RULE_STACK, function(currShortName) {
              return _this.shortRuleNameToFullName(currShortName);
            });
          };
          return Recoverable2;
        }()
      );
      exports2.Recoverable = Recoverable;
      function attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {
        var key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);
        var firstAfterRepInfo = this.firstAfterRepMap[key];
        if (firstAfterRepInfo === void 0) {
          var currRuleName = this.getCurrRuleFullName();
          var ruleGrammar = this.getGAstProductions()[currRuleName];
          var walker = new nextToksWalker(ruleGrammar, prodOccurrence);
          firstAfterRepInfo = walker.startWalking();
          this.firstAfterRepMap[key] = firstAfterRepInfo;
        }
        var expectTokAfterLastMatch = firstAfterRepInfo.token;
        var nextTokIdx = firstAfterRepInfo.occurrence;
        var isEndOfRule = firstAfterRepInfo.isEndOfRule;
        if (this.RULE_STACK.length === 1 && isEndOfRule && expectTokAfterLastMatch === void 0) {
          expectTokAfterLastMatch = tokens_public_1.EOF;
          nextTokIdx = 1;
        }
        if (expectTokAfterLastMatch === void 0 || nextTokIdx === void 0) {
          return;
        }
        if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {
          this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);
        }
      }
      exports2.attemptInRepetitionRecovery = attemptInRepetitionRecovery;
    }
  });

  // node_modules/chevrotain/lib/src/parse/grammar/keys.js
  var require_keys2 = __commonJS({
    "node_modules/chevrotain/lib/src/parse/grammar/keys.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getKeyForAutomaticLookahead = exports2.AT_LEAST_ONE_SEP_IDX = exports2.MANY_SEP_IDX = exports2.AT_LEAST_ONE_IDX = exports2.MANY_IDX = exports2.OPTION_IDX = exports2.OR_IDX = exports2.BITS_FOR_ALT_IDX = exports2.BITS_FOR_RULE_IDX = exports2.BITS_FOR_OCCURRENCE_IDX = exports2.BITS_FOR_METHOD_TYPE = void 0;
      exports2.BITS_FOR_METHOD_TYPE = 4;
      exports2.BITS_FOR_OCCURRENCE_IDX = 8;
      exports2.BITS_FOR_RULE_IDX = 12;
      exports2.BITS_FOR_ALT_IDX = 8;
      exports2.OR_IDX = 1 << exports2.BITS_FOR_OCCURRENCE_IDX;
      exports2.OPTION_IDX = 2 << exports2.BITS_FOR_OCCURRENCE_IDX;
      exports2.MANY_IDX = 3 << exports2.BITS_FOR_OCCURRENCE_IDX;
      exports2.AT_LEAST_ONE_IDX = 4 << exports2.BITS_FOR_OCCURRENCE_IDX;
      exports2.MANY_SEP_IDX = 5 << exports2.BITS_FOR_OCCURRENCE_IDX;
      exports2.AT_LEAST_ONE_SEP_IDX = 6 << exports2.BITS_FOR_OCCURRENCE_IDX;
      function getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) {
        return occurrence | dslMethodIdx | ruleIdx;
      }
      exports2.getKeyForAutomaticLookahead = getKeyForAutomaticLookahead;
      var BITS_START_FOR_ALT_IDX = 32 - exports2.BITS_FOR_ALT_IDX;
    }
  });

  // node_modules/chevrotain/lib/src/parse/grammar/llk_lookahead.js
  var require_llk_lookahead = __commonJS({
    "node_modules/chevrotain/lib/src/parse/grammar/llk_lookahead.js"(exports2) {
      "use strict";
      var __spreadArray = exports2 && exports2.__spreadArray || function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LLkLookaheadStrategy = void 0;
      var flatMap_1 = __importDefault(require_flatMap());
      var isEmpty_1 = __importDefault(require_isEmpty());
      var errors_public_1 = require_errors_public();
      var parser_1 = require_parser();
      var checks_1 = require_checks();
      var lookahead_1 = require_lookahead();
      var LLkLookaheadStrategy = (
        /** @class */
        function() {
          function LLkLookaheadStrategy2(options) {
            var _a4;
            this.maxLookahead = (_a4 = options === null || options === void 0 ? void 0 : options.maxLookahead) !== null && _a4 !== void 0 ? _a4 : parser_1.DEFAULT_PARSER_CONFIG.maxLookahead;
          }
          LLkLookaheadStrategy2.prototype.validate = function(options) {
            var leftRecursionErrors = this.validateNoLeftRecursion(options.rules);
            if ((0, isEmpty_1.default)(leftRecursionErrors)) {
              var emptyAltErrors = this.validateEmptyOrAlternatives(options.rules);
              var ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(options.rules, this.maxLookahead);
              var emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(options.rules, this.maxLookahead);
              var allErrors = __spreadArray(__spreadArray(__spreadArray(__spreadArray([], leftRecursionErrors, true), emptyAltErrors, true), ambiguousAltsErrors, true), emptyRepetitionErrors, true);
              return allErrors;
            }
            return leftRecursionErrors;
          };
          LLkLookaheadStrategy2.prototype.validateNoLeftRecursion = function(rules) {
            return (0, flatMap_1.default)(rules, function(currTopRule) {
              return (0, checks_1.validateNoLeftRecursion)(currTopRule, currTopRule, errors_public_1.defaultGrammarValidatorErrorProvider);
            });
          };
          LLkLookaheadStrategy2.prototype.validateEmptyOrAlternatives = function(rules) {
            return (0, flatMap_1.default)(rules, function(currTopRule) {
              return (0, checks_1.validateEmptyOrAlternative)(currTopRule, errors_public_1.defaultGrammarValidatorErrorProvider);
            });
          };
          LLkLookaheadStrategy2.prototype.validateAmbiguousAlternationAlternatives = function(rules, maxLookahead) {
            return (0, flatMap_1.default)(rules, function(currTopRule) {
              return (0, checks_1.validateAmbiguousAlternationAlternatives)(currTopRule, maxLookahead, errors_public_1.defaultGrammarValidatorErrorProvider);
            });
          };
          LLkLookaheadStrategy2.prototype.validateSomeNonEmptyLookaheadPath = function(rules, maxLookahead) {
            return (0, checks_1.validateSomeNonEmptyLookaheadPath)(rules, maxLookahead, errors_public_1.defaultGrammarValidatorErrorProvider);
          };
          LLkLookaheadStrategy2.prototype.buildLookaheadForAlternation = function(options) {
            return (0, lookahead_1.buildLookaheadFuncForOr)(options.prodOccurrence, options.rule, options.maxLookahead, options.hasPredicates, options.dynamicTokensEnabled, lookahead_1.buildAlternativesLookAheadFunc);
          };
          LLkLookaheadStrategy2.prototype.buildLookaheadForOptional = function(options) {
            return (0, lookahead_1.buildLookaheadFuncForOptionalProd)(options.prodOccurrence, options.rule, options.maxLookahead, options.dynamicTokensEnabled, (0, lookahead_1.getProdType)(options.prodType), lookahead_1.buildSingleAlternativeLookaheadFunction);
          };
          return LLkLookaheadStrategy2;
        }()
      );
      exports2.LLkLookaheadStrategy = LLkLookaheadStrategy;
    }
  });

  // node_modules/chevrotain/lib/src/parse/parser/traits/looksahead.js
  var require_looksahead = __commonJS({
    "node_modules/chevrotain/lib/src/parse/parser/traits/looksahead.js"(exports2) {
      "use strict";
      var __extends = exports2 && exports2.__extends || function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2)
              if (Object.prototype.hasOwnProperty.call(b2, p))
                d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.collectMethods = exports2.LooksAhead = void 0;
      var forEach_1 = __importDefault(require_forEach());
      var has_1 = __importDefault(require_has());
      var parser_1 = require_parser();
      var keys_1 = require_keys2();
      var gast_1 = require_api5();
      var gast_2 = require_api5();
      var llk_lookahead_1 = require_llk_lookahead();
      var LooksAhead = (
        /** @class */
        function() {
          function LooksAhead2() {
          }
          LooksAhead2.prototype.initLooksAhead = function(config) {
            this.dynamicTokensEnabled = (0, has_1.default)(config, "dynamicTokensEnabled") ? config.dynamicTokensEnabled : parser_1.DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;
            this.maxLookahead = (0, has_1.default)(config, "maxLookahead") ? config.maxLookahead : parser_1.DEFAULT_PARSER_CONFIG.maxLookahead;
            this.lookaheadStrategy = (0, has_1.default)(config, "lookaheadStrategy") ? config.lookaheadStrategy : new llk_lookahead_1.LLkLookaheadStrategy({ maxLookahead: this.maxLookahead });
            this.lookAheadFuncsCache = /* @__PURE__ */ new Map();
          };
          LooksAhead2.prototype.preComputeLookaheadFunctions = function(rules) {
            var _this = this;
            (0, forEach_1.default)(rules, function(currRule) {
              _this.TRACE_INIT("".concat(currRule.name, " Rule Lookahead"), function() {
                var _a4 = collectMethods(currRule), alternation = _a4.alternation, repetition = _a4.repetition, option = _a4.option, repetitionMandatory = _a4.repetitionMandatory, repetitionMandatoryWithSeparator = _a4.repetitionMandatoryWithSeparator, repetitionWithSeparator = _a4.repetitionWithSeparator;
                (0, forEach_1.default)(alternation, function(currProd) {
                  var prodIdx = currProd.idx === 0 ? "" : currProd.idx;
                  _this.TRACE_INIT("".concat((0, gast_2.getProductionDslName)(currProd)).concat(prodIdx), function() {
                    var laFunc = _this.lookaheadStrategy.buildLookaheadForAlternation({
                      prodOccurrence: currProd.idx,
                      rule: currRule,
                      maxLookahead: currProd.maxLookahead || _this.maxLookahead,
                      hasPredicates: currProd.hasPredicates,
                      dynamicTokensEnabled: _this.dynamicTokensEnabled
                    });
                    var key = (0, keys_1.getKeyForAutomaticLookahead)(_this.fullRuleNameToShort[currRule.name], keys_1.OR_IDX, currProd.idx);
                    _this.setLaFuncCache(key, laFunc);
                  });
                });
                (0, forEach_1.default)(repetition, function(currProd) {
                  _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.MANY_IDX, "Repetition", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
                });
                (0, forEach_1.default)(option, function(currProd) {
                  _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.OPTION_IDX, "Option", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
                });
                (0, forEach_1.default)(repetitionMandatory, function(currProd) {
                  _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.AT_LEAST_ONE_IDX, "RepetitionMandatory", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
                });
                (0, forEach_1.default)(repetitionMandatoryWithSeparator, function(currProd) {
                  _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.AT_LEAST_ONE_SEP_IDX, "RepetitionMandatoryWithSeparator", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
                });
                (0, forEach_1.default)(repetitionWithSeparator, function(currProd) {
                  _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.MANY_SEP_IDX, "RepetitionWithSeparator", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
                });
              });
            });
          };
          LooksAhead2.prototype.computeLookaheadFunc = function(rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {
            var _this = this;
            this.TRACE_INIT("".concat(dslMethodName).concat(prodOccurrence === 0 ? "" : prodOccurrence), function() {
              var laFunc = _this.lookaheadStrategy.buildLookaheadForOptional({
                prodOccurrence,
                rule,
                maxLookahead: prodMaxLookahead || _this.maxLookahead,
                dynamicTokensEnabled: _this.dynamicTokensEnabled,
                prodType
              });
              var key = (0, keys_1.getKeyForAutomaticLookahead)(_this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);
              _this.setLaFuncCache(key, laFunc);
            });
          };
          LooksAhead2.prototype.getKeyForAutomaticLookahead = function(dslMethodIdx, occurrence) {
            var currRuleShortName = this.getLastExplicitRuleShortName();
            return (0, keys_1.getKeyForAutomaticLookahead)(currRuleShortName, dslMethodIdx, occurrence);
          };
          LooksAhead2.prototype.getLaFuncFromCache = function(key) {
            return this.lookAheadFuncsCache.get(key);
          };
          LooksAhead2.prototype.setLaFuncCache = function(key, value) {
            this.lookAheadFuncsCache.set(key, value);
          };
          return LooksAhead2;
        }()
      );
      exports2.LooksAhead = LooksAhead;
      var DslMethodsCollectorVisitor = (
        /** @class */
        function(_super) {
          __extends(DslMethodsCollectorVisitor2, _super);
          function DslMethodsCollectorVisitor2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.dslMethods = {
              option: [],
              alternation: [],
              repetition: [],
              repetitionWithSeparator: [],
              repetitionMandatory: [],
              repetitionMandatoryWithSeparator: []
            };
            return _this;
          }
          DslMethodsCollectorVisitor2.prototype.reset = function() {
            this.dslMethods = {
              option: [],
              alternation: [],
              repetition: [],
              repetitionWithSeparator: [],
              repetitionMandatory: [],
              repetitionMandatoryWithSeparator: []
            };
          };
          DslMethodsCollectorVisitor2.prototype.visitOption = function(option) {
            this.dslMethods.option.push(option);
          };
          DslMethodsCollectorVisitor2.prototype.visitRepetitionWithSeparator = function(manySep) {
            this.dslMethods.repetitionWithSeparator.push(manySep);
          };
          DslMethodsCollectorVisitor2.prototype.visitRepetitionMandatory = function(atLeastOne) {
            this.dslMethods.repetitionMandatory.push(atLeastOne);
          };
          DslMethodsCollectorVisitor2.prototype.visitRepetitionMandatoryWithSeparator = function(atLeastOneSep) {
            this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);
          };
          DslMethodsCollectorVisitor2.prototype.visitRepetition = function(many) {
            this.dslMethods.repetition.push(many);
          };
          DslMethodsCollectorVisitor2.prototype.visitAlternation = function(or2) {
            this.dslMethods.alternation.push(or2);
          };
          return DslMethodsCollectorVisitor2;
        }(gast_1.GAstVisitor)
      );
      var collectorVisitor = new DslMethodsCollectorVisitor();
      function collectMethods(rule) {
        collectorVisitor.reset();
        rule.accept(collectorVisitor);
        var dslMethods = collectorVisitor.dslMethods;
        collectorVisitor.reset();
        return dslMethods;
      }
      exports2.collectMethods = collectMethods;
    }
  });

  // node_modules/chevrotain/lib/src/parse/cst/cst.js
  var require_cst = __commonJS({
    "node_modules/chevrotain/lib/src/parse/cst/cst.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.addNoneTerminalToCst = exports2.addTerminalToCst = exports2.setNodeLocationFull = exports2.setNodeLocationOnlyOffset = void 0;
      function setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {
        if (isNaN(currNodeLocation.startOffset) === true) {
          currNodeLocation.startOffset = newLocationInfo.startOffset;
          currNodeLocation.endOffset = newLocationInfo.endOffset;
        } else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {
          currNodeLocation.endOffset = newLocationInfo.endOffset;
        }
      }
      exports2.setNodeLocationOnlyOffset = setNodeLocationOnlyOffset;
      function setNodeLocationFull(currNodeLocation, newLocationInfo) {
        if (isNaN(currNodeLocation.startOffset) === true) {
          currNodeLocation.startOffset = newLocationInfo.startOffset;
          currNodeLocation.startColumn = newLocationInfo.startColumn;
          currNodeLocation.startLine = newLocationInfo.startLine;
          currNodeLocation.endOffset = newLocationInfo.endOffset;
          currNodeLocation.endColumn = newLocationInfo.endColumn;
          currNodeLocation.endLine = newLocationInfo.endLine;
        } else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {
          currNodeLocation.endOffset = newLocationInfo.endOffset;
          currNodeLocation.endColumn = newLocationInfo.endColumn;
          currNodeLocation.endLine = newLocationInfo.endLine;
        }
      }
      exports2.setNodeLocationFull = setNodeLocationFull;
      function addTerminalToCst(node, token, tokenTypeName) {
        if (node.children[tokenTypeName] === void 0) {
          node.children[tokenTypeName] = [token];
        } else {
          node.children[tokenTypeName].push(token);
        }
      }
      exports2.addTerminalToCst = addTerminalToCst;
      function addNoneTerminalToCst(node, ruleName, ruleResult) {
        if (node.children[ruleName] === void 0) {
          node.children[ruleName] = [ruleResult];
        } else {
          node.children[ruleName].push(ruleResult);
        }
      }
      exports2.addNoneTerminalToCst = addNoneTerminalToCst;
    }
  });

  // node_modules/chevrotain/lib/src/lang/lang_extensions.js
  var require_lang_extensions = __commonJS({
    "node_modules/chevrotain/lib/src/lang/lang_extensions.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.defineNameProp = void 0;
      var NAME = "name";
      function defineNameProp(obj, nameValue) {
        Object.defineProperty(obj, NAME, {
          enumerable: false,
          configurable: true,
          writable: false,
          value: nameValue
        });
      }
      exports2.defineNameProp = defineNameProp;
    }
  });

  // node_modules/chevrotain/lib/src/parse/cst/cst_visitor.js
  var require_cst_visitor = __commonJS({
    "node_modules/chevrotain/lib/src/parse/cst/cst_visitor.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.validateMissingCstMethods = exports2.validateVisitor = exports2.CstVisitorDefinitionError = exports2.createBaseVisitorConstructorWithDefaults = exports2.createBaseSemanticVisitorConstructor = exports2.defaultVisit = void 0;
      var isEmpty_1 = __importDefault(require_isEmpty());
      var compact_1 = __importDefault(require_compact());
      var isArray_1 = __importDefault(require_isArray());
      var map_1 = __importDefault(require_map());
      var forEach_1 = __importDefault(require_forEach());
      var filter_1 = __importDefault(require_filter());
      var keys_1 = __importDefault(require_keys());
      var isFunction_1 = __importDefault(require_isFunction());
      var isUndefined_1 = __importDefault(require_isUndefined());
      var lang_extensions_1 = require_lang_extensions();
      function defaultVisit(ctx, param) {
        var childrenNames = (0, keys_1.default)(ctx);
        var childrenNamesLength = childrenNames.length;
        for (var i = 0; i < childrenNamesLength; i++) {
          var currChildName = childrenNames[i];
          var currChildArray = ctx[currChildName];
          var currChildArrayLength = currChildArray.length;
          for (var j = 0; j < currChildArrayLength; j++) {
            var currChild = currChildArray[j];
            if (currChild.tokenTypeIdx === void 0) {
              this[currChild.name](currChild.children, param);
            }
          }
        }
      }
      exports2.defaultVisit = defaultVisit;
      function createBaseSemanticVisitorConstructor(grammarName, ruleNames) {
        var derivedConstructor = function() {
        };
        (0, lang_extensions_1.defineNameProp)(derivedConstructor, grammarName + "BaseSemantics");
        var semanticProto = {
          visit: function(cstNode, param) {
            if ((0, isArray_1.default)(cstNode)) {
              cstNode = cstNode[0];
            }
            if ((0, isUndefined_1.default)(cstNode)) {
              return void 0;
            }
            return this[cstNode.name](cstNode.children, param);
          },
          validateVisitor: function() {
            var semanticDefinitionErrors = validateVisitor(this, ruleNames);
            if (!(0, isEmpty_1.default)(semanticDefinitionErrors)) {
              var errorMessages = (0, map_1.default)(semanticDefinitionErrors, function(currDefError) {
                return currDefError.msg;
              });
              throw Error("Errors Detected in CST Visitor <".concat(this.constructor.name, ">:\n	") + "".concat(errorMessages.join("\n\n").replace(/\n/g, "\n	")));
            }
          }
        };
        derivedConstructor.prototype = semanticProto;
        derivedConstructor.prototype.constructor = derivedConstructor;
        derivedConstructor._RULE_NAMES = ruleNames;
        return derivedConstructor;
      }
      exports2.createBaseSemanticVisitorConstructor = createBaseSemanticVisitorConstructor;
      function createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {
        var derivedConstructor = function() {
        };
        (0, lang_extensions_1.defineNameProp)(derivedConstructor, grammarName + "BaseSemanticsWithDefaults");
        var withDefaultsProto = Object.create(baseConstructor.prototype);
        (0, forEach_1.default)(ruleNames, function(ruleName) {
          withDefaultsProto[ruleName] = defaultVisit;
        });
        derivedConstructor.prototype = withDefaultsProto;
        derivedConstructor.prototype.constructor = derivedConstructor;
        return derivedConstructor;
      }
      exports2.createBaseVisitorConstructorWithDefaults = createBaseVisitorConstructorWithDefaults;
      var CstVisitorDefinitionError;
      (function(CstVisitorDefinitionError2) {
        CstVisitorDefinitionError2[CstVisitorDefinitionError2["REDUNDANT_METHOD"] = 0] = "REDUNDANT_METHOD";
        CstVisitorDefinitionError2[CstVisitorDefinitionError2["MISSING_METHOD"] = 1] = "MISSING_METHOD";
      })(CstVisitorDefinitionError = exports2.CstVisitorDefinitionError || (exports2.CstVisitorDefinitionError = {}));
      function validateVisitor(visitorInstance, ruleNames) {
        var missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);
        return missingErrors;
      }
      exports2.validateVisitor = validateVisitor;
      function validateMissingCstMethods(visitorInstance, ruleNames) {
        var missingRuleNames = (0, filter_1.default)(ruleNames, function(currRuleName) {
          return (0, isFunction_1.default)(visitorInstance[currRuleName]) === false;
        });
        var errors = (0, map_1.default)(missingRuleNames, function(currRuleName) {
          return {
            msg: "Missing visitor method: <".concat(currRuleName, "> on ").concat(visitorInstance.constructor.name, " CST Visitor."),
            type: CstVisitorDefinitionError.MISSING_METHOD,
            methodName: currRuleName
          };
        });
        return (0, compact_1.default)(errors);
      }
      exports2.validateMissingCstMethods = validateMissingCstMethods;
    }
  });

  // node_modules/chevrotain/lib/src/parse/parser/traits/tree_builder.js
  var require_tree_builder = __commonJS({
    "node_modules/chevrotain/lib/src/parse/parser/traits/tree_builder.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TreeBuilder = void 0;
      var cst_1 = require_cst();
      var noop_1 = __importDefault(require_noop());
      var has_1 = __importDefault(require_has());
      var keys_1 = __importDefault(require_keys());
      var isUndefined_1 = __importDefault(require_isUndefined());
      var cst_visitor_1 = require_cst_visitor();
      var parser_1 = require_parser();
      var TreeBuilder = (
        /** @class */
        function() {
          function TreeBuilder2() {
          }
          TreeBuilder2.prototype.initTreeBuilder = function(config) {
            this.CST_STACK = [];
            this.outputCst = config.outputCst;
            this.nodeLocationTracking = (0, has_1.default)(config, "nodeLocationTracking") ? config.nodeLocationTracking : parser_1.DEFAULT_PARSER_CONFIG.nodeLocationTracking;
            if (!this.outputCst) {
              this.cstInvocationStateUpdate = noop_1.default;
              this.cstFinallyStateUpdate = noop_1.default;
              this.cstPostTerminal = noop_1.default;
              this.cstPostNonTerminal = noop_1.default;
              this.cstPostRule = noop_1.default;
            } else {
              if (/full/i.test(this.nodeLocationTracking)) {
                if (this.recoveryEnabled) {
                  this.setNodeLocationFromToken = cst_1.setNodeLocationFull;
                  this.setNodeLocationFromNode = cst_1.setNodeLocationFull;
                  this.cstPostRule = noop_1.default;
                  this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;
                } else {
                  this.setNodeLocationFromToken = noop_1.default;
                  this.setNodeLocationFromNode = noop_1.default;
                  this.cstPostRule = this.cstPostRuleFull;
                  this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;
                }
              } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {
                if (this.recoveryEnabled) {
                  this.setNodeLocationFromToken = cst_1.setNodeLocationOnlyOffset;
                  this.setNodeLocationFromNode = cst_1.setNodeLocationOnlyOffset;
                  this.cstPostRule = noop_1.default;
                  this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;
                } else {
                  this.setNodeLocationFromToken = noop_1.default;
                  this.setNodeLocationFromNode = noop_1.default;
                  this.cstPostRule = this.cstPostRuleOnlyOffset;
                  this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;
                }
              } else if (/none/i.test(this.nodeLocationTracking)) {
                this.setNodeLocationFromToken = noop_1.default;
                this.setNodeLocationFromNode = noop_1.default;
                this.cstPostRule = noop_1.default;
                this.setInitialNodeLocation = noop_1.default;
              } else {
                throw Error('Invalid <nodeLocationTracking> config option: "'.concat(config.nodeLocationTracking, '"'));
              }
            }
          };
          TreeBuilder2.prototype.setInitialNodeLocationOnlyOffsetRecovery = function(cstNode) {
            cstNode.location = {
              startOffset: NaN,
              endOffset: NaN
            };
          };
          TreeBuilder2.prototype.setInitialNodeLocationOnlyOffsetRegular = function(cstNode) {
            cstNode.location = {
              // without error recovery the starting Location of a new CstNode is guaranteed
              // To be the next Token's startOffset (for valid inputs).
              // For invalid inputs there won't be any CSTOutput so this potential
              // inaccuracy does not matter
              startOffset: this.LA(1).startOffset,
              endOffset: NaN
            };
          };
          TreeBuilder2.prototype.setInitialNodeLocationFullRecovery = function(cstNode) {
            cstNode.location = {
              startOffset: NaN,
              startLine: NaN,
              startColumn: NaN,
              endOffset: NaN,
              endLine: NaN,
              endColumn: NaN
            };
          };
          TreeBuilder2.prototype.setInitialNodeLocationFullRegular = function(cstNode) {
            var nextToken = this.LA(1);
            cstNode.location = {
              startOffset: nextToken.startOffset,
              startLine: nextToken.startLine,
              startColumn: nextToken.startColumn,
              endOffset: NaN,
              endLine: NaN,
              endColumn: NaN
            };
          };
          TreeBuilder2.prototype.cstInvocationStateUpdate = function(fullRuleName) {
            var cstNode = {
              name: fullRuleName,
              children: /* @__PURE__ */ Object.create(null)
            };
            this.setInitialNodeLocation(cstNode);
            this.CST_STACK.push(cstNode);
          };
          TreeBuilder2.prototype.cstFinallyStateUpdate = function() {
            this.CST_STACK.pop();
          };
          TreeBuilder2.prototype.cstPostRuleFull = function(ruleCstNode) {
            var prevToken = this.LA(0);
            var loc = ruleCstNode.location;
            if (loc.startOffset <= prevToken.startOffset === true) {
              loc.endOffset = prevToken.endOffset;
              loc.endLine = prevToken.endLine;
              loc.endColumn = prevToken.endColumn;
            } else {
              loc.startOffset = NaN;
              loc.startLine = NaN;
              loc.startColumn = NaN;
            }
          };
          TreeBuilder2.prototype.cstPostRuleOnlyOffset = function(ruleCstNode) {
            var prevToken = this.LA(0);
            var loc = ruleCstNode.location;
            if (loc.startOffset <= prevToken.startOffset === true) {
              loc.endOffset = prevToken.endOffset;
            } else {
              loc.startOffset = NaN;
            }
          };
          TreeBuilder2.prototype.cstPostTerminal = function(key, consumedToken) {
            var rootCst = this.CST_STACK[this.CST_STACK.length - 1];
            (0, cst_1.addTerminalToCst)(rootCst, consumedToken, key);
            this.setNodeLocationFromToken(rootCst.location, consumedToken);
          };
          TreeBuilder2.prototype.cstPostNonTerminal = function(ruleCstResult, ruleName) {
            var preCstNode = this.CST_STACK[this.CST_STACK.length - 1];
            (0, cst_1.addNoneTerminalToCst)(preCstNode, ruleName, ruleCstResult);
            this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);
          };
          TreeBuilder2.prototype.getBaseCstVisitorConstructor = function() {
            if ((0, isUndefined_1.default)(this.baseCstVisitorConstructor)) {
              var newBaseCstVisitorConstructor = (0, cst_visitor_1.createBaseSemanticVisitorConstructor)(this.className, (0, keys_1.default)(this.gastProductionsCache));
              this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;
              return newBaseCstVisitorConstructor;
            }
            return this.baseCstVisitorConstructor;
          };
          TreeBuilder2.prototype.getBaseCstVisitorConstructorWithDefaults = function() {
            if ((0, isUndefined_1.default)(this.baseCstVisitorWithDefaultsConstructor)) {
              var newConstructor = (0, cst_visitor_1.createBaseVisitorConstructorWithDefaults)(this.className, (0, keys_1.default)(this.gastProductionsCache), this.getBaseCstVisitorConstructor());
              this.baseCstVisitorWithDefaultsConstructor = newConstructor;
              return newConstructor;
            }
            return this.baseCstVisitorWithDefaultsConstructor;
          };
          TreeBuilder2.prototype.getLastExplicitRuleShortName = function() {
            var ruleStack = this.RULE_STACK;
            return ruleStack[ruleStack.length - 1];
          };
          TreeBuilder2.prototype.getPreviousExplicitRuleShortName = function() {
            var ruleStack = this.RULE_STACK;
            return ruleStack[ruleStack.length - 2];
          };
          TreeBuilder2.prototype.getLastExplicitRuleOccurrenceIndex = function() {
            var occurrenceStack = this.RULE_OCCURRENCE_STACK;
            return occurrenceStack[occurrenceStack.length - 1];
          };
          return TreeBuilder2;
        }()
      );
      exports2.TreeBuilder = TreeBuilder;
    }
  });

  // node_modules/chevrotain/lib/src/parse/parser/traits/lexer_adapter.js
  var require_lexer_adapter = __commonJS({
    "node_modules/chevrotain/lib/src/parse/parser/traits/lexer_adapter.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LexerAdapter = void 0;
      var parser_1 = require_parser();
      var LexerAdapter = (
        /** @class */
        function() {
          function LexerAdapter2() {
          }
          LexerAdapter2.prototype.initLexerAdapter = function() {
            this.tokVector = [];
            this.tokVectorLength = 0;
            this.currIdx = -1;
          };
          Object.defineProperty(LexerAdapter2.prototype, "input", {
            get: function() {
              return this.tokVector;
            },
            set: function(newInput) {
              if (this.selfAnalysisDone !== true) {
                throw Error("Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.");
              }
              this.reset();
              this.tokVector = newInput;
              this.tokVectorLength = newInput.length;
            },
            enumerable: false,
            configurable: true
          });
          LexerAdapter2.prototype.SKIP_TOKEN = function() {
            if (this.currIdx <= this.tokVector.length - 2) {
              this.consumeToken();
              return this.LA(1);
            } else {
              return parser_1.END_OF_FILE;
            }
          };
          LexerAdapter2.prototype.LA = function(howMuch) {
            var soughtIdx = this.currIdx + howMuch;
            if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {
              return parser_1.END_OF_FILE;
            } else {
              return this.tokVector[soughtIdx];
            }
          };
          LexerAdapter2.prototype.consumeToken = function() {
            this.currIdx++;
          };
          LexerAdapter2.prototype.exportLexerState = function() {
            return this.currIdx;
          };
          LexerAdapter2.prototype.importLexerState = function(newState) {
            this.currIdx = newState;
          };
          LexerAdapter2.prototype.resetLexerState = function() {
            this.currIdx = -1;
          };
          LexerAdapter2.prototype.moveToTerminatedState = function() {
            this.currIdx = this.tokVector.length - 1;
          };
          LexerAdapter2.prototype.getLexerPosition = function() {
            return this.exportLexerState();
          };
          return LexerAdapter2;
        }()
      );
      exports2.LexerAdapter = LexerAdapter;
    }
  });

  // node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_api.js
  var require_recognizer_api = __commonJS({
    "node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_api.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.RecognizerApi = void 0;
      var values_1 = __importDefault(require_values());
      var includes_1 = __importDefault(require_includes());
      var exceptions_public_1 = require_exceptions_public();
      var parser_1 = require_parser();
      var errors_public_1 = require_errors_public();
      var checks_1 = require_checks();
      var gast_1 = require_api5();
      var RecognizerApi = (
        /** @class */
        function() {
          function RecognizerApi2() {
          }
          RecognizerApi2.prototype.ACTION = function(impl) {
            return impl.call(this);
          };
          RecognizerApi2.prototype.consume = function(idx, tokType, options) {
            return this.consumeInternal(tokType, idx, options);
          };
          RecognizerApi2.prototype.subrule = function(idx, ruleToCall, options) {
            return this.subruleInternal(ruleToCall, idx, options);
          };
          RecognizerApi2.prototype.option = function(idx, actionORMethodDef) {
            return this.optionInternal(actionORMethodDef, idx);
          };
          RecognizerApi2.prototype.or = function(idx, altsOrOpts) {
            return this.orInternal(altsOrOpts, idx);
          };
          RecognizerApi2.prototype.many = function(idx, actionORMethodDef) {
            return this.manyInternal(idx, actionORMethodDef);
          };
          RecognizerApi2.prototype.atLeastOne = function(idx, actionORMethodDef) {
            return this.atLeastOneInternal(idx, actionORMethodDef);
          };
          RecognizerApi2.prototype.CONSUME = function(tokType, options) {
            return this.consumeInternal(tokType, 0, options);
          };
          RecognizerApi2.prototype.CONSUME1 = function(tokType, options) {
            return this.consumeInternal(tokType, 1, options);
          };
          RecognizerApi2.prototype.CONSUME2 = function(tokType, options) {
            return this.consumeInternal(tokType, 2, options);
          };
          RecognizerApi2.prototype.CONSUME3 = function(tokType, options) {
            return this.consumeInternal(tokType, 3, options);
          };
          RecognizerApi2.prototype.CONSUME4 = function(tokType, options) {
            return this.consumeInternal(tokType, 4, options);
          };
          RecognizerApi2.prototype.CONSUME5 = function(tokType, options) {
            return this.consumeInternal(tokType, 5, options);
          };
          RecognizerApi2.prototype.CONSUME6 = function(tokType, options) {
            return this.consumeInternal(tokType, 6, options);
          };
          RecognizerApi2.prototype.CONSUME7 = function(tokType, options) {
            return this.consumeInternal(tokType, 7, options);
          };
          RecognizerApi2.prototype.CONSUME8 = function(tokType, options) {
            return this.consumeInternal(tokType, 8, options);
          };
          RecognizerApi2.prototype.CONSUME9 = function(tokType, options) {
            return this.consumeInternal(tokType, 9, options);
          };
          RecognizerApi2.prototype.SUBRULE = function(ruleToCall, options) {
            return this.subruleInternal(ruleToCall, 0, options);
          };
          RecognizerApi2.prototype.SUBRULE1 = function(ruleToCall, options) {
            return this.subruleInternal(ruleToCall, 1, options);
          };
          RecognizerApi2.prototype.SUBRULE2 = function(ruleToCall, options) {
            return this.subruleInternal(ruleToCall, 2, options);
          };
          RecognizerApi2.prototype.SUBRULE3 = function(ruleToCall, options) {
            return this.subruleInternal(ruleToCall, 3, options);
          };
          RecognizerApi2.prototype.SUBRULE4 = function(ruleToCall, options) {
            return this.subruleInternal(ruleToCall, 4, options);
          };
          RecognizerApi2.prototype.SUBRULE5 = function(ruleToCall, options) {
            return this.subruleInternal(ruleToCall, 5, options);
          };
          RecognizerApi2.prototype.SUBRULE6 = function(ruleToCall, options) {
            return this.subruleInternal(ruleToCall, 6, options);
          };
          RecognizerApi2.prototype.SUBRULE7 = function(ruleToCall, options) {
            return this.subruleInternal(ruleToCall, 7, options);
          };
          RecognizerApi2.prototype.SUBRULE8 = function(ruleToCall, options) {
            return this.subruleInternal(ruleToCall, 8, options);
          };
          RecognizerApi2.prototype.SUBRULE9 = function(ruleToCall, options) {
            return this.subruleInternal(ruleToCall, 9, options);
          };
          RecognizerApi2.prototype.OPTION = function(actionORMethodDef) {
            return this.optionInternal(actionORMethodDef, 0);
          };
          RecognizerApi2.prototype.OPTION1 = function(actionORMethodDef) {
            return this.optionInternal(actionORMethodDef, 1);
          };
          RecognizerApi2.prototype.OPTION2 = function(actionORMethodDef) {
            return this.optionInternal(actionORMethodDef, 2);
          };
          RecognizerApi2.prototype.OPTION3 = function(actionORMethodDef) {
            return this.optionInternal(actionORMethodDef, 3);
          };
          RecognizerApi2.prototype.OPTION4 = function(actionORMethodDef) {
            return this.optionInternal(actionORMethodDef, 4);
          };
          RecognizerApi2.prototype.OPTION5 = function(actionORMethodDef) {
            return this.optionInternal(actionORMethodDef, 5);
          };
          RecognizerApi2.prototype.OPTION6 = function(actionORMethodDef) {
            return this.optionInternal(actionORMethodDef, 6);
          };
          RecognizerApi2.prototype.OPTION7 = function(actionORMethodDef) {
            return this.optionInternal(actionORMethodDef, 7);
          };
          RecognizerApi2.prototype.OPTION8 = function(actionORMethodDef) {
            return this.optionInternal(actionORMethodDef, 8);
          };
          RecognizerApi2.prototype.OPTION9 = function(actionORMethodDef) {
            return this.optionInternal(actionORMethodDef, 9);
          };
          RecognizerApi2.prototype.OR = function(altsOrOpts) {
            return this.orInternal(altsOrOpts, 0);
          };
          RecognizerApi2.prototype.OR1 = function(altsOrOpts) {
            return this.orInternal(altsOrOpts, 1);
          };
          RecognizerApi2.prototype.OR2 = function(altsOrOpts) {
            return this.orInternal(altsOrOpts, 2);
          };
          RecognizerApi2.prototype.OR3 = function(altsOrOpts) {
            return this.orInternal(altsOrOpts, 3);
          };
          RecognizerApi2.prototype.OR4 = function(altsOrOpts) {
            return this.orInternal(altsOrOpts, 4);
          };
          RecognizerApi2.prototype.OR5 = function(altsOrOpts) {
            return this.orInternal(altsOrOpts, 5);
          };
          RecognizerApi2.prototype.OR6 = function(altsOrOpts) {
            return this.orInternal(altsOrOpts, 6);
          };
          RecognizerApi2.prototype.OR7 = function(altsOrOpts) {
            return this.orInternal(altsOrOpts, 7);
          };
          RecognizerApi2.prototype.OR8 = function(altsOrOpts) {
            return this.orInternal(altsOrOpts, 8);
          };
          RecognizerApi2.prototype.OR9 = function(altsOrOpts) {
            return this.orInternal(altsOrOpts, 9);
          };
          RecognizerApi2.prototype.MANY = function(actionORMethodDef) {
            this.manyInternal(0, actionORMethodDef);
          };
          RecognizerApi2.prototype.MANY1 = function(actionORMethodDef) {
            this.manyInternal(1, actionORMethodDef);
          };
          RecognizerApi2.prototype.MANY2 = function(actionORMethodDef) {
            this.manyInternal(2, actionORMethodDef);
          };
          RecognizerApi2.prototype.MANY3 = function(actionORMethodDef) {
            this.manyInternal(3, actionORMethodDef);
          };
          RecognizerApi2.prototype.MANY4 = function(actionORMethodDef) {
            this.manyInternal(4, actionORMethodDef);
          };
          RecognizerApi2.prototype.MANY5 = function(actionORMethodDef) {
            this.manyInternal(5, actionORMethodDef);
          };
          RecognizerApi2.prototype.MANY6 = function(actionORMethodDef) {
            this.manyInternal(6, actionORMethodDef);
          };
          RecognizerApi2.prototype.MANY7 = function(actionORMethodDef) {
            this.manyInternal(7, actionORMethodDef);
          };
          RecognizerApi2.prototype.MANY8 = function(actionORMethodDef) {
            this.manyInternal(8, actionORMethodDef);
          };
          RecognizerApi2.prototype.MANY9 = function(actionORMethodDef) {
            this.manyInternal(9, actionORMethodDef);
          };
          RecognizerApi2.prototype.MANY_SEP = function(options) {
            this.manySepFirstInternal(0, options);
          };
          RecognizerApi2.prototype.MANY_SEP1 = function(options) {
            this.manySepFirstInternal(1, options);
          };
          RecognizerApi2.prototype.MANY_SEP2 = function(options) {
            this.manySepFirstInternal(2, options);
          };
          RecognizerApi2.prototype.MANY_SEP3 = function(options) {
            this.manySepFirstInternal(3, options);
          };
          RecognizerApi2.prototype.MANY_SEP4 = function(options) {
            this.manySepFirstInternal(4, options);
          };
          RecognizerApi2.prototype.MANY_SEP5 = function(options) {
            this.manySepFirstInternal(5, options);
          };
          RecognizerApi2.prototype.MANY_SEP6 = function(options) {
            this.manySepFirstInternal(6, options);
          };
          RecognizerApi2.prototype.MANY_SEP7 = function(options) {
            this.manySepFirstInternal(7, options);
          };
          RecognizerApi2.prototype.MANY_SEP8 = function(options) {
            this.manySepFirstInternal(8, options);
          };
          RecognizerApi2.prototype.MANY_SEP9 = function(options) {
            this.manySepFirstInternal(9, options);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE = function(actionORMethodDef) {
            this.atLeastOneInternal(0, actionORMethodDef);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE1 = function(actionORMethodDef) {
            return this.atLeastOneInternal(1, actionORMethodDef);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE2 = function(actionORMethodDef) {
            this.atLeastOneInternal(2, actionORMethodDef);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE3 = function(actionORMethodDef) {
            this.atLeastOneInternal(3, actionORMethodDef);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE4 = function(actionORMethodDef) {
            this.atLeastOneInternal(4, actionORMethodDef);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE5 = function(actionORMethodDef) {
            this.atLeastOneInternal(5, actionORMethodDef);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE6 = function(actionORMethodDef) {
            this.atLeastOneInternal(6, actionORMethodDef);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE7 = function(actionORMethodDef) {
            this.atLeastOneInternal(7, actionORMethodDef);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE8 = function(actionORMethodDef) {
            this.atLeastOneInternal(8, actionORMethodDef);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE9 = function(actionORMethodDef) {
            this.atLeastOneInternal(9, actionORMethodDef);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE_SEP = function(options) {
            this.atLeastOneSepFirstInternal(0, options);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE_SEP1 = function(options) {
            this.atLeastOneSepFirstInternal(1, options);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE_SEP2 = function(options) {
            this.atLeastOneSepFirstInternal(2, options);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE_SEP3 = function(options) {
            this.atLeastOneSepFirstInternal(3, options);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE_SEP4 = function(options) {
            this.atLeastOneSepFirstInternal(4, options);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE_SEP5 = function(options) {
            this.atLeastOneSepFirstInternal(5, options);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE_SEP6 = function(options) {
            this.atLeastOneSepFirstInternal(6, options);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE_SEP7 = function(options) {
            this.atLeastOneSepFirstInternal(7, options);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE_SEP8 = function(options) {
            this.atLeastOneSepFirstInternal(8, options);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE_SEP9 = function(options) {
            this.atLeastOneSepFirstInternal(9, options);
          };
          RecognizerApi2.prototype.RULE = function(name, implementation, config) {
            if (config === void 0) {
              config = parser_1.DEFAULT_RULE_CONFIG;
            }
            if ((0, includes_1.default)(this.definedRulesNames, name)) {
              var errMsg = errors_public_1.defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({
                topLevelRule: name,
                grammarName: this.className
              });
              var error = {
                message: errMsg,
                type: parser_1.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,
                ruleName: name
              };
              this.definitionErrors.push(error);
            }
            this.definedRulesNames.push(name);
            var ruleImplementation = this.defineRule(name, implementation, config);
            this[name] = ruleImplementation;
            return ruleImplementation;
          };
          RecognizerApi2.prototype.OVERRIDE_RULE = function(name, impl, config) {
            if (config === void 0) {
              config = parser_1.DEFAULT_RULE_CONFIG;
            }
            var ruleErrors = (0, checks_1.validateRuleIsOverridden)(name, this.definedRulesNames, this.className);
            this.definitionErrors = this.definitionErrors.concat(ruleErrors);
            var ruleImplementation = this.defineRule(name, impl, config);
            this[name] = ruleImplementation;
            return ruleImplementation;
          };
          RecognizerApi2.prototype.BACKTRACK = function(grammarRule, args) {
            return function() {
              this.isBackTrackingStack.push(1);
              var orgState = this.saveRecogState();
              try {
                grammarRule.apply(this, args);
                return true;
              } catch (e) {
                if ((0, exceptions_public_1.isRecognitionException)(e)) {
                  return false;
                } else {
                  throw e;
                }
              } finally {
                this.reloadRecogState(orgState);
                this.isBackTrackingStack.pop();
              }
            };
          };
          RecognizerApi2.prototype.getGAstProductions = function() {
            return this.gastProductionsCache;
          };
          RecognizerApi2.prototype.getSerializedGastProductions = function() {
            return (0, gast_1.serializeGrammar)((0, values_1.default)(this.gastProductionsCache));
          };
          return RecognizerApi2;
        }()
      );
      exports2.RecognizerApi = RecognizerApi;
    }
  });

  // node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_engine.js
  var require_recognizer_engine = __commonJS({
    "node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_engine.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.RecognizerEngine = void 0;
      var isEmpty_1 = __importDefault(require_isEmpty());
      var isArray_1 = __importDefault(require_isArray());
      var flatten_1 = __importDefault(require_flatten());
      var every_1 = __importDefault(require_every());
      var uniq_1 = __importDefault(require_uniq());
      var isObject_1 = __importDefault(require_isObject());
      var has_1 = __importDefault(require_has());
      var values_1 = __importDefault(require_values());
      var reduce_1 = __importDefault(require_reduce());
      var clone_1 = __importDefault(require_clone());
      var keys_1 = require_keys2();
      var exceptions_public_1 = require_exceptions_public();
      var lookahead_1 = require_lookahead();
      var interpreter_1 = require_interpreter();
      var parser_1 = require_parser();
      var recoverable_1 = require_recoverable();
      var tokens_public_1 = require_tokens_public();
      var tokens_1 = require_tokens();
      var RecognizerEngine = (
        /** @class */
        function() {
          function RecognizerEngine2() {
          }
          RecognizerEngine2.prototype.initRecognizerEngine = function(tokenVocabulary, config) {
            this.className = this.constructor.name;
            this.shortRuleNameToFull = {};
            this.fullRuleNameToShort = {};
            this.ruleShortNameIdx = 256;
            this.tokenMatcher = tokens_1.tokenStructuredMatcherNoCategories;
            this.subruleIdx = 0;
            this.definedRulesNames = [];
            this.tokensMap = {};
            this.isBackTrackingStack = [];
            this.RULE_STACK = [];
            this.RULE_OCCURRENCE_STACK = [];
            this.gastProductionsCache = {};
            if ((0, has_1.default)(config, "serializedGrammar")) {
              throw Error("The Parser's configuration can no longer contain a <serializedGrammar> property.\n	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\n	For Further details.");
            }
            if ((0, isArray_1.default)(tokenVocabulary)) {
              if ((0, isEmpty_1.default)(tokenVocabulary)) {
                throw Error("A Token Vocabulary cannot be empty.\n	Note that the first argument for the parser constructor\n	is no longer a Token vector (since v4.0).");
              }
              if (typeof tokenVocabulary[0].startOffset === "number") {
                throw Error("The Parser constructor no longer accepts a token vector as the first argument.\n	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\n	For Further details.");
              }
            }
            if ((0, isArray_1.default)(tokenVocabulary)) {
              this.tokensMap = (0, reduce_1.default)(tokenVocabulary, function(acc, tokType) {
                acc[tokType.name] = tokType;
                return acc;
              }, {});
            } else if ((0, has_1.default)(tokenVocabulary, "modes") && (0, every_1.default)((0, flatten_1.default)((0, values_1.default)(tokenVocabulary.modes)), tokens_1.isTokenType)) {
              var allTokenTypes_1 = (0, flatten_1.default)((0, values_1.default)(tokenVocabulary.modes));
              var uniqueTokens = (0, uniq_1.default)(allTokenTypes_1);
              this.tokensMap = (0, reduce_1.default)(uniqueTokens, function(acc, tokType) {
                acc[tokType.name] = tokType;
                return acc;
              }, {});
            } else if ((0, isObject_1.default)(tokenVocabulary)) {
              this.tokensMap = (0, clone_1.default)(tokenVocabulary);
            } else {
              throw new Error("<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition");
            }
            this.tokensMap["EOF"] = tokens_public_1.EOF;
            var allTokenTypes = (0, has_1.default)(tokenVocabulary, "modes") ? (0, flatten_1.default)((0, values_1.default)(tokenVocabulary.modes)) : (0, values_1.default)(tokenVocabulary);
            var noTokenCategoriesUsed = (0, every_1.default)(allTokenTypes, function(tokenConstructor) {
              return (0, isEmpty_1.default)(tokenConstructor.categoryMatches);
            });
            this.tokenMatcher = noTokenCategoriesUsed ? tokens_1.tokenStructuredMatcherNoCategories : tokens_1.tokenStructuredMatcher;
            (0, tokens_1.augmentTokenTypes)((0, values_1.default)(this.tokensMap));
          };
          RecognizerEngine2.prototype.defineRule = function(ruleName, impl, config) {
            if (this.selfAnalysisDone) {
              throw Error("Grammar rule <".concat(ruleName, "> may not be defined after the 'performSelfAnalysis' method has been called'\n") + "Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.");
            }
            var resyncEnabled = (0, has_1.default)(config, "resyncEnabled") ? config.resyncEnabled : parser_1.DEFAULT_RULE_CONFIG.resyncEnabled;
            var recoveryValueFunc = (0, has_1.default)(config, "recoveryValueFunc") ? config.recoveryValueFunc : parser_1.DEFAULT_RULE_CONFIG.recoveryValueFunc;
            var shortName = this.ruleShortNameIdx << keys_1.BITS_FOR_METHOD_TYPE + keys_1.BITS_FOR_OCCURRENCE_IDX;
            this.ruleShortNameIdx++;
            this.shortRuleNameToFull[shortName] = ruleName;
            this.fullRuleNameToShort[ruleName] = shortName;
            var invokeRuleWithTry;
            if (this.outputCst === true) {
              invokeRuleWithTry = function invokeRuleWithTry2() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i] = arguments[_i];
                }
                try {
                  this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);
                  impl.apply(this, args);
                  var cst = this.CST_STACK[this.CST_STACK.length - 1];
                  this.cstPostRule(cst);
                  return cst;
                } catch (e) {
                  return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);
                } finally {
                  this.ruleFinallyStateUpdate();
                }
              };
            } else {
              invokeRuleWithTry = function invokeRuleWithTryCst() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i] = arguments[_i];
                }
                try {
                  this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);
                  return impl.apply(this, args);
                } catch (e) {
                  return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);
                } finally {
                  this.ruleFinallyStateUpdate();
                }
              };
            }
            var wrappedGrammarRule = Object.assign(invokeRuleWithTry, { ruleName, originalGrammarAction: impl });
            return wrappedGrammarRule;
          };
          RecognizerEngine2.prototype.invokeRuleCatch = function(e, resyncEnabledConfig, recoveryValueFunc) {
            var isFirstInvokedRule = this.RULE_STACK.length === 1;
            var reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;
            if ((0, exceptions_public_1.isRecognitionException)(e)) {
              var recogError = e;
              if (reSyncEnabled) {
                var reSyncTokType = this.findReSyncTokenType();
                if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {
                  recogError.resyncedTokens = this.reSyncTo(reSyncTokType);
                  if (this.outputCst) {
                    var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];
                    partialCstResult.recoveredNode = true;
                    return partialCstResult;
                  } else {
                    return recoveryValueFunc();
                  }
                } else {
                  if (this.outputCst) {
                    var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];
                    partialCstResult.recoveredNode = true;
                    recogError.partialCstResult = partialCstResult;
                  }
                  throw recogError;
                }
              } else if (isFirstInvokedRule) {
                this.moveToTerminatedState();
                return recoveryValueFunc();
              } else {
                throw recogError;
              }
            } else {
              throw e;
            }
          };
          RecognizerEngine2.prototype.optionInternal = function(actionORMethodDef, occurrence) {
            var key = this.getKeyForAutomaticLookahead(keys_1.OPTION_IDX, occurrence);
            return this.optionInternalLogic(actionORMethodDef, occurrence, key);
          };
          RecognizerEngine2.prototype.optionInternalLogic = function(actionORMethodDef, occurrence, key) {
            var _this = this;
            var lookAheadFunc = this.getLaFuncFromCache(key);
            var action;
            if (typeof actionORMethodDef !== "function") {
              action = actionORMethodDef.DEF;
              var predicate_1 = actionORMethodDef.GATE;
              if (predicate_1 !== void 0) {
                var orgLookaheadFunction_1 = lookAheadFunc;
                lookAheadFunc = function() {
                  return predicate_1.call(_this) && orgLookaheadFunction_1.call(_this);
                };
              }
            } else {
              action = actionORMethodDef;
            }
            if (lookAheadFunc.call(this) === true) {
              return action.call(this);
            }
            return void 0;
          };
          RecognizerEngine2.prototype.atLeastOneInternal = function(prodOccurrence, actionORMethodDef) {
            var laKey = this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_IDX, prodOccurrence);
            return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);
          };
          RecognizerEngine2.prototype.atLeastOneInternalLogic = function(prodOccurrence, actionORMethodDef, key) {
            var _this = this;
            var lookAheadFunc = this.getLaFuncFromCache(key);
            var action;
            if (typeof actionORMethodDef !== "function") {
              action = actionORMethodDef.DEF;
              var predicate_2 = actionORMethodDef.GATE;
              if (predicate_2 !== void 0) {
                var orgLookaheadFunction_2 = lookAheadFunc;
                lookAheadFunc = function() {
                  return predicate_2.call(_this) && orgLookaheadFunction_2.call(_this);
                };
              }
            } else {
              action = actionORMethodDef;
            }
            if (lookAheadFunc.call(this) === true) {
              var notStuck = this.doSingleRepetition(action);
              while (lookAheadFunc.call(this) === true && notStuck === true) {
                notStuck = this.doSingleRepetition(action);
              }
            } else {
              throw this.raiseEarlyExitException(prodOccurrence, lookahead_1.PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);
            }
            this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, keys_1.AT_LEAST_ONE_IDX, prodOccurrence, interpreter_1.NextTerminalAfterAtLeastOneWalker);
          };
          RecognizerEngine2.prototype.atLeastOneSepFirstInternal = function(prodOccurrence, options) {
            var laKey = this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence);
            this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);
          };
          RecognizerEngine2.prototype.atLeastOneSepFirstInternalLogic = function(prodOccurrence, options, key) {
            var _this = this;
            var action = options.DEF;
            var separator = options.SEP;
            var firstIterationLookaheadFunc = this.getLaFuncFromCache(key);
            if (firstIterationLookaheadFunc.call(this) === true) {
              ;
              action.call(this);
              var separatorLookAheadFunc = function() {
                return _this.tokenMatcher(_this.LA(1), separator);
              };
              while (this.tokenMatcher(this.LA(1), separator) === true) {
                this.CONSUME(separator);
                action.call(this);
              }
              this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
                prodOccurrence,
                separator,
                separatorLookAheadFunc,
                action,
                interpreter_1.NextTerminalAfterAtLeastOneSepWalker
              ], separatorLookAheadFunc, keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence, interpreter_1.NextTerminalAfterAtLeastOneSepWalker);
            } else {
              throw this.raiseEarlyExitException(prodOccurrence, lookahead_1.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);
            }
          };
          RecognizerEngine2.prototype.manyInternal = function(prodOccurrence, actionORMethodDef) {
            var laKey = this.getKeyForAutomaticLookahead(keys_1.MANY_IDX, prodOccurrence);
            return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);
          };
          RecognizerEngine2.prototype.manyInternalLogic = function(prodOccurrence, actionORMethodDef, key) {
            var _this = this;
            var lookaheadFunction = this.getLaFuncFromCache(key);
            var action;
            if (typeof actionORMethodDef !== "function") {
              action = actionORMethodDef.DEF;
              var predicate_3 = actionORMethodDef.GATE;
              if (predicate_3 !== void 0) {
                var orgLookaheadFunction_3 = lookaheadFunction;
                lookaheadFunction = function() {
                  return predicate_3.call(_this) && orgLookaheadFunction_3.call(_this);
                };
              }
            } else {
              action = actionORMethodDef;
            }
            var notStuck = true;
            while (lookaheadFunction.call(this) === true && notStuck === true) {
              notStuck = this.doSingleRepetition(action);
            }
            this.attemptInRepetitionRecovery(
              this.manyInternal,
              [prodOccurrence, actionORMethodDef],
              lookaheadFunction,
              keys_1.MANY_IDX,
              prodOccurrence,
              interpreter_1.NextTerminalAfterManyWalker,
              // The notStuck parameter is only relevant when "attemptInRepetitionRecovery"
              // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]
              // An infinite loop cannot occur as:
              // - Either the lookahead is guaranteed to consume something (Single Token Separator)
              // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).
              notStuck
            );
          };
          RecognizerEngine2.prototype.manySepFirstInternal = function(prodOccurrence, options) {
            var laKey = this.getKeyForAutomaticLookahead(keys_1.MANY_SEP_IDX, prodOccurrence);
            this.manySepFirstInternalLogic(prodOccurrence, options, laKey);
          };
          RecognizerEngine2.prototype.manySepFirstInternalLogic = function(prodOccurrence, options, key) {
            var _this = this;
            var action = options.DEF;
            var separator = options.SEP;
            var firstIterationLaFunc = this.getLaFuncFromCache(key);
            if (firstIterationLaFunc.call(this) === true) {
              action.call(this);
              var separatorLookAheadFunc = function() {
                return _this.tokenMatcher(_this.LA(1), separator);
              };
              while (this.tokenMatcher(this.LA(1), separator) === true) {
                this.CONSUME(separator);
                action.call(this);
              }
              this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
                prodOccurrence,
                separator,
                separatorLookAheadFunc,
                action,
                interpreter_1.NextTerminalAfterManySepWalker
              ], separatorLookAheadFunc, keys_1.MANY_SEP_IDX, prodOccurrence, interpreter_1.NextTerminalAfterManySepWalker);
            }
          };
          RecognizerEngine2.prototype.repetitionSepSecondInternal = function(prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {
            while (separatorLookAheadFunc()) {
              this.CONSUME(separator);
              action.call(this);
            }
            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
              prodOccurrence,
              separator,
              separatorLookAheadFunc,
              action,
              nextTerminalAfterWalker
            ], separatorLookAheadFunc, keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);
          };
          RecognizerEngine2.prototype.doSingleRepetition = function(action) {
            var beforeIteration = this.getLexerPosition();
            action.call(this);
            var afterIteration = this.getLexerPosition();
            return afterIteration > beforeIteration;
          };
          RecognizerEngine2.prototype.orInternal = function(altsOrOpts, occurrence) {
            var laKey = this.getKeyForAutomaticLookahead(keys_1.OR_IDX, occurrence);
            var alts = (0, isArray_1.default)(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;
            var laFunc = this.getLaFuncFromCache(laKey);
            var altIdxToTake = laFunc.call(this, alts);
            if (altIdxToTake !== void 0) {
              var chosenAlternative = alts[altIdxToTake];
              return chosenAlternative.ALT.call(this);
            }
            this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);
          };
          RecognizerEngine2.prototype.ruleFinallyStateUpdate = function() {
            this.RULE_STACK.pop();
            this.RULE_OCCURRENCE_STACK.pop();
            this.cstFinallyStateUpdate();
            if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {
              var firstRedundantTok = this.LA(1);
              var errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({
                firstRedundant: firstRedundantTok,
                ruleName: this.getCurrRuleFullName()
              });
              this.SAVE_ERROR(new exceptions_public_1.NotAllInputParsedException(errMsg, firstRedundantTok));
            }
          };
          RecognizerEngine2.prototype.subruleInternal = function(ruleToCall, idx, options) {
            var ruleResult;
            try {
              var args = options !== void 0 ? options.ARGS : void 0;
              this.subruleIdx = idx;
              ruleResult = ruleToCall.apply(this, args);
              this.cstPostNonTerminal(ruleResult, options !== void 0 && options.LABEL !== void 0 ? options.LABEL : ruleToCall.ruleName);
              return ruleResult;
            } catch (e) {
              throw this.subruleInternalError(e, options, ruleToCall.ruleName);
            }
          };
          RecognizerEngine2.prototype.subruleInternalError = function(e, options, ruleName) {
            if ((0, exceptions_public_1.isRecognitionException)(e) && e.partialCstResult !== void 0) {
              this.cstPostNonTerminal(e.partialCstResult, options !== void 0 && options.LABEL !== void 0 ? options.LABEL : ruleName);
              delete e.partialCstResult;
            }
            throw e;
          };
          RecognizerEngine2.prototype.consumeInternal = function(tokType, idx, options) {
            var consumedToken;
            try {
              var nextToken = this.LA(1);
              if (this.tokenMatcher(nextToken, tokType) === true) {
                this.consumeToken();
                consumedToken = nextToken;
              } else {
                this.consumeInternalError(tokType, nextToken, options);
              }
            } catch (eFromConsumption) {
              consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);
            }
            this.cstPostTerminal(options !== void 0 && options.LABEL !== void 0 ? options.LABEL : tokType.name, consumedToken);
            return consumedToken;
          };
          RecognizerEngine2.prototype.consumeInternalError = function(tokType, nextToken, options) {
            var msg;
            var previousToken = this.LA(0);
            if (options !== void 0 && options.ERR_MSG) {
              msg = options.ERR_MSG;
            } else {
              msg = this.errorMessageProvider.buildMismatchTokenMessage({
                expected: tokType,
                actual: nextToken,
                previous: previousToken,
                ruleName: this.getCurrRuleFullName()
              });
            }
            throw this.SAVE_ERROR(new exceptions_public_1.MismatchedTokenException(msg, nextToken, previousToken));
          };
          RecognizerEngine2.prototype.consumeInternalRecovery = function(tokType, idx, eFromConsumption) {
            if (this.recoveryEnabled && // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?
            eFromConsumption.name === "MismatchedTokenException" && !this.isBackTracking()) {
              var follows = this.getFollowsForInRuleRecovery(tokType, idx);
              try {
                return this.tryInRuleRecovery(tokType, follows);
              } catch (eFromInRuleRecovery) {
                if (eFromInRuleRecovery.name === recoverable_1.IN_RULE_RECOVERY_EXCEPTION) {
                  throw eFromConsumption;
                } else {
                  throw eFromInRuleRecovery;
                }
              }
            } else {
              throw eFromConsumption;
            }
          };
          RecognizerEngine2.prototype.saveRecogState = function() {
            var savedErrors = this.errors;
            var savedRuleStack = (0, clone_1.default)(this.RULE_STACK);
            return {
              errors: savedErrors,
              lexerState: this.exportLexerState(),
              RULE_STACK: savedRuleStack,
              CST_STACK: this.CST_STACK
            };
          };
          RecognizerEngine2.prototype.reloadRecogState = function(newState) {
            this.errors = newState.errors;
            this.importLexerState(newState.lexerState);
            this.RULE_STACK = newState.RULE_STACK;
          };
          RecognizerEngine2.prototype.ruleInvocationStateUpdate = function(shortName, fullName, idxInCallingRule) {
            this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);
            this.RULE_STACK.push(shortName);
            this.cstInvocationStateUpdate(fullName);
          };
          RecognizerEngine2.prototype.isBackTracking = function() {
            return this.isBackTrackingStack.length !== 0;
          };
          RecognizerEngine2.prototype.getCurrRuleFullName = function() {
            var shortName = this.getLastExplicitRuleShortName();
            return this.shortRuleNameToFull[shortName];
          };
          RecognizerEngine2.prototype.shortRuleNameToFullName = function(shortName) {
            return this.shortRuleNameToFull[shortName];
          };
          RecognizerEngine2.prototype.isAtEndOfInput = function() {
            return this.tokenMatcher(this.LA(1), tokens_public_1.EOF);
          };
          RecognizerEngine2.prototype.reset = function() {
            this.resetLexerState();
            this.subruleIdx = 0;
            this.isBackTrackingStack = [];
            this.errors = [];
            this.RULE_STACK = [];
            this.CST_STACK = [];
            this.RULE_OCCURRENCE_STACK = [];
          };
          return RecognizerEngine2;
        }()
      );
      exports2.RecognizerEngine = RecognizerEngine;
    }
  });

  // node_modules/chevrotain/lib/src/parse/parser/traits/error_handler.js
  var require_error_handler = __commonJS({
    "node_modules/chevrotain/lib/src/parse/parser/traits/error_handler.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ErrorHandler = void 0;
      var exceptions_public_1 = require_exceptions_public();
      var has_1 = __importDefault(require_has());
      var clone_1 = __importDefault(require_clone());
      var lookahead_1 = require_lookahead();
      var parser_1 = require_parser();
      var ErrorHandler2 = (
        /** @class */
        function() {
          function ErrorHandler3() {
          }
          ErrorHandler3.prototype.initErrorHandler = function(config) {
            this._errors = [];
            this.errorMessageProvider = (0, has_1.default)(config, "errorMessageProvider") ? config.errorMessageProvider : parser_1.DEFAULT_PARSER_CONFIG.errorMessageProvider;
          };
          ErrorHandler3.prototype.SAVE_ERROR = function(error) {
            if ((0, exceptions_public_1.isRecognitionException)(error)) {
              error.context = {
                ruleStack: this.getHumanReadableRuleStack(),
                ruleOccurrenceStack: (0, clone_1.default)(this.RULE_OCCURRENCE_STACK)
              };
              this._errors.push(error);
              return error;
            } else {
              throw Error("Trying to save an Error which is not a RecognitionException");
            }
          };
          Object.defineProperty(ErrorHandler3.prototype, "errors", {
            get: function() {
              return (0, clone_1.default)(this._errors);
            },
            set: function(newErrors) {
              this._errors = newErrors;
            },
            enumerable: false,
            configurable: true
          });
          ErrorHandler3.prototype.raiseEarlyExitException = function(occurrence, prodType, userDefinedErrMsg) {
            var ruleName = this.getCurrRuleFullName();
            var ruleGrammar = this.getGAstProductions()[ruleName];
            var lookAheadPathsPerAlternative = (0, lookahead_1.getLookaheadPathsForOptionalProd)(occurrence, ruleGrammar, prodType, this.maxLookahead);
            var insideProdPaths = lookAheadPathsPerAlternative[0];
            var actualTokens = [];
            for (var i = 1; i <= this.maxLookahead; i++) {
              actualTokens.push(this.LA(i));
            }
            var msg = this.errorMessageProvider.buildEarlyExitMessage({
              expectedIterationPaths: insideProdPaths,
              actual: actualTokens,
              previous: this.LA(0),
              customUserDescription: userDefinedErrMsg,
              ruleName
            });
            throw this.SAVE_ERROR(new exceptions_public_1.EarlyExitException(msg, this.LA(1), this.LA(0)));
          };
          ErrorHandler3.prototype.raiseNoAltException = function(occurrence, errMsgTypes) {
            var ruleName = this.getCurrRuleFullName();
            var ruleGrammar = this.getGAstProductions()[ruleName];
            var lookAheadPathsPerAlternative = (0, lookahead_1.getLookaheadPathsForOr)(occurrence, ruleGrammar, this.maxLookahead);
            var actualTokens = [];
            for (var i = 1; i <= this.maxLookahead; i++) {
              actualTokens.push(this.LA(i));
            }
            var previousToken = this.LA(0);
            var errMsg = this.errorMessageProvider.buildNoViableAltMessage({
              expectedPathsPerAlt: lookAheadPathsPerAlternative,
              actual: actualTokens,
              previous: previousToken,
              customUserDescription: errMsgTypes,
              ruleName: this.getCurrRuleFullName()
            });
            throw this.SAVE_ERROR(new exceptions_public_1.NoViableAltException(errMsg, this.LA(1), previousToken));
          };
          return ErrorHandler3;
        }()
      );
      exports2.ErrorHandler = ErrorHandler2;
    }
  });

  // node_modules/chevrotain/lib/src/parse/parser/traits/context_assist.js
  var require_context_assist = __commonJS({
    "node_modules/chevrotain/lib/src/parse/parser/traits/context_assist.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ContentAssist = void 0;
      var interpreter_1 = require_interpreter();
      var first_1 = __importDefault(require_first2());
      var isUndefined_1 = __importDefault(require_isUndefined());
      var ContentAssist = (
        /** @class */
        function() {
          function ContentAssist2() {
          }
          ContentAssist2.prototype.initContentAssist = function() {
          };
          ContentAssist2.prototype.computeContentAssist = function(startRuleName, precedingInput) {
            var startRuleGast = this.gastProductionsCache[startRuleName];
            if ((0, isUndefined_1.default)(startRuleGast)) {
              throw Error("Rule ->".concat(startRuleName, "<- does not exist in this grammar."));
            }
            return (0, interpreter_1.nextPossibleTokensAfter)([startRuleGast], precedingInput, this.tokenMatcher, this.maxLookahead);
          };
          ContentAssist2.prototype.getNextPossibleTokenTypes = function(grammarPath) {
            var topRuleName = (0, first_1.default)(grammarPath.ruleStack);
            var gastProductions = this.getGAstProductions();
            var topProduction = gastProductions[topRuleName];
            var nextPossibleTokenTypes = new interpreter_1.NextAfterTokenWalker(topProduction, grammarPath).startWalking();
            return nextPossibleTokenTypes;
          };
          return ContentAssist2;
        }()
      );
      exports2.ContentAssist = ContentAssist;
    }
  });

  // node_modules/chevrotain/lib/src/parse/parser/traits/gast_recorder.js
  var require_gast_recorder = __commonJS({
    "node_modules/chevrotain/lib/src/parse/parser/traits/gast_recorder.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.GastRecorder = void 0;
      var last_1 = __importDefault(require_last());
      var isArray_1 = __importDefault(require_isArray());
      var some_1 = __importDefault(require_some());
      var forEach_1 = __importDefault(require_forEach());
      var isFunction_1 = __importDefault(require_isFunction());
      var has_1 = __importDefault(require_has());
      var gast_1 = require_api5();
      var lexer_public_1 = require_lexer_public();
      var tokens_1 = require_tokens();
      var tokens_public_1 = require_tokens_public();
      var parser_1 = require_parser();
      var keys_1 = require_keys2();
      var RECORDING_NULL_OBJECT = {
        description: "This Object indicates the Parser is during Recording Phase"
      };
      Object.freeze(RECORDING_NULL_OBJECT);
      var HANDLE_SEPARATOR = true;
      var MAX_METHOD_IDX = Math.pow(2, keys_1.BITS_FOR_OCCURRENCE_IDX) - 1;
      var RFT = (0, tokens_public_1.createToken)({ name: "RECORDING_PHASE_TOKEN", pattern: lexer_public_1.Lexer.NA });
      (0, tokens_1.augmentTokenTypes)([RFT]);
      var RECORDING_PHASE_TOKEN = (0, tokens_public_1.createTokenInstance)(
        RFT,
        "This IToken indicates the Parser is in Recording Phase\n	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details",
        // Using "-1" instead of NaN (as in EOF) because an actual number is less likely to
        // cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.
        -1,
        -1,
        -1,
        -1,
        -1,
        -1
      );
      Object.freeze(RECORDING_PHASE_TOKEN);
      var RECORDING_PHASE_CSTNODE = {
        name: "This CSTNode indicates the Parser is in Recording Phase\n	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details",
        children: {}
      };
      var GastRecorder = (
        /** @class */
        function() {
          function GastRecorder2() {
          }
          GastRecorder2.prototype.initGastRecorder = function(config) {
            this.recordingProdStack = [];
            this.RECORDING_PHASE = false;
          };
          GastRecorder2.prototype.enableRecording = function() {
            var _this = this;
            this.RECORDING_PHASE = true;
            this.TRACE_INIT("Enable Recording", function() {
              var _loop_1 = function(i2) {
                var idx = i2 > 0 ? i2 : "";
                _this["CONSUME".concat(idx)] = function(arg1, arg2) {
                  return this.consumeInternalRecord(arg1, i2, arg2);
                };
                _this["SUBRULE".concat(idx)] = function(arg1, arg2) {
                  return this.subruleInternalRecord(arg1, i2, arg2);
                };
                _this["OPTION".concat(idx)] = function(arg1) {
                  return this.optionInternalRecord(arg1, i2);
                };
                _this["OR".concat(idx)] = function(arg1) {
                  return this.orInternalRecord(arg1, i2);
                };
                _this["MANY".concat(idx)] = function(arg1) {
                  this.manyInternalRecord(i2, arg1);
                };
                _this["MANY_SEP".concat(idx)] = function(arg1) {
                  this.manySepFirstInternalRecord(i2, arg1);
                };
                _this["AT_LEAST_ONE".concat(idx)] = function(arg1) {
                  this.atLeastOneInternalRecord(i2, arg1);
                };
                _this["AT_LEAST_ONE_SEP".concat(idx)] = function(arg1) {
                  this.atLeastOneSepFirstInternalRecord(i2, arg1);
                };
              };
              for (var i = 0; i < 10; i++) {
                _loop_1(i);
              }
              _this["consume"] = function(idx, arg1, arg2) {
                return this.consumeInternalRecord(arg1, idx, arg2);
              };
              _this["subrule"] = function(idx, arg1, arg2) {
                return this.subruleInternalRecord(arg1, idx, arg2);
              };
              _this["option"] = function(idx, arg1) {
                return this.optionInternalRecord(arg1, idx);
              };
              _this["or"] = function(idx, arg1) {
                return this.orInternalRecord(arg1, idx);
              };
              _this["many"] = function(idx, arg1) {
                this.manyInternalRecord(idx, arg1);
              };
              _this["atLeastOne"] = function(idx, arg1) {
                this.atLeastOneInternalRecord(idx, arg1);
              };
              _this.ACTION = _this.ACTION_RECORD;
              _this.BACKTRACK = _this.BACKTRACK_RECORD;
              _this.LA = _this.LA_RECORD;
            });
          };
          GastRecorder2.prototype.disableRecording = function() {
            var _this = this;
            this.RECORDING_PHASE = false;
            this.TRACE_INIT("Deleting Recording methods", function() {
              var that = _this;
              for (var i = 0; i < 10; i++) {
                var idx = i > 0 ? i : "";
                delete that["CONSUME".concat(idx)];
                delete that["SUBRULE".concat(idx)];
                delete that["OPTION".concat(idx)];
                delete that["OR".concat(idx)];
                delete that["MANY".concat(idx)];
                delete that["MANY_SEP".concat(idx)];
                delete that["AT_LEAST_ONE".concat(idx)];
                delete that["AT_LEAST_ONE_SEP".concat(idx)];
              }
              delete that["consume"];
              delete that["subrule"];
              delete that["option"];
              delete that["or"];
              delete that["many"];
              delete that["atLeastOne"];
              delete that.ACTION;
              delete that.BACKTRACK;
              delete that.LA;
            });
          };
          GastRecorder2.prototype.ACTION_RECORD = function(impl) {
          };
          GastRecorder2.prototype.BACKTRACK_RECORD = function(grammarRule, args) {
            return function() {
              return true;
            };
          };
          GastRecorder2.prototype.LA_RECORD = function(howMuch) {
            return parser_1.END_OF_FILE;
          };
          GastRecorder2.prototype.topLevelRuleRecord = function(name, def) {
            try {
              var newTopLevelRule = new gast_1.Rule({ definition: [], name });
              newTopLevelRule.name = name;
              this.recordingProdStack.push(newTopLevelRule);
              def.call(this);
              this.recordingProdStack.pop();
              return newTopLevelRule;
            } catch (originalError) {
              if (originalError.KNOWN_RECORDER_ERROR !== true) {
                try {
                  originalError.message = originalError.message + '\n	 This error was thrown during the "grammar recording phase" For more info see:\n	https://chevrotain.io/docs/guide/internals.html#grammar-recording';
                } catch (mutabilityError) {
                  throw originalError;
                }
              }
              throw originalError;
            }
          };
          GastRecorder2.prototype.optionInternalRecord = function(actionORMethodDef, occurrence) {
            return recordProd.call(this, gast_1.Option, actionORMethodDef, occurrence);
          };
          GastRecorder2.prototype.atLeastOneInternalRecord = function(occurrence, actionORMethodDef) {
            recordProd.call(this, gast_1.RepetitionMandatory, actionORMethodDef, occurrence);
          };
          GastRecorder2.prototype.atLeastOneSepFirstInternalRecord = function(occurrence, options) {
            recordProd.call(this, gast_1.RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);
          };
          GastRecorder2.prototype.manyInternalRecord = function(occurrence, actionORMethodDef) {
            recordProd.call(this, gast_1.Repetition, actionORMethodDef, occurrence);
          };
          GastRecorder2.prototype.manySepFirstInternalRecord = function(occurrence, options) {
            recordProd.call(this, gast_1.RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);
          };
          GastRecorder2.prototype.orInternalRecord = function(altsOrOpts, occurrence) {
            return recordOrProd.call(this, altsOrOpts, occurrence);
          };
          GastRecorder2.prototype.subruleInternalRecord = function(ruleToCall, occurrence, options) {
            assertMethodIdxIsValid(occurrence);
            if (!ruleToCall || (0, has_1.default)(ruleToCall, "ruleName") === false) {
              var error = new Error("<SUBRULE".concat(getIdxSuffix(occurrence), "> argument is invalid") + " expecting a Parser method reference but got: <".concat(JSON.stringify(ruleToCall), ">") + "\n inside top level rule: <".concat(this.recordingProdStack[0].name, ">"));
              error.KNOWN_RECORDER_ERROR = true;
              throw error;
            }
            var prevProd = (0, last_1.default)(this.recordingProdStack);
            var ruleName = ruleToCall.ruleName;
            var newNoneTerminal = new gast_1.NonTerminal({
              idx: occurrence,
              nonTerminalName: ruleName,
              label: options === null || options === void 0 ? void 0 : options.LABEL,
              // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created
              referencedRule: void 0
            });
            prevProd.definition.push(newNoneTerminal);
            return this.outputCst ? RECORDING_PHASE_CSTNODE : RECORDING_NULL_OBJECT;
          };
          GastRecorder2.prototype.consumeInternalRecord = function(tokType, occurrence, options) {
            assertMethodIdxIsValid(occurrence);
            if (!(0, tokens_1.hasShortKeyProperty)(tokType)) {
              var error = new Error("<CONSUME".concat(getIdxSuffix(occurrence), "> argument is invalid") + " expecting a TokenType reference but got: <".concat(JSON.stringify(tokType), ">") + "\n inside top level rule: <".concat(this.recordingProdStack[0].name, ">"));
              error.KNOWN_RECORDER_ERROR = true;
              throw error;
            }
            var prevProd = (0, last_1.default)(this.recordingProdStack);
            var newNoneTerminal = new gast_1.Terminal({
              idx: occurrence,
              terminalType: tokType,
              label: options === null || options === void 0 ? void 0 : options.LABEL
            });
            prevProd.definition.push(newNoneTerminal);
            return RECORDING_PHASE_TOKEN;
          };
          return GastRecorder2;
        }()
      );
      exports2.GastRecorder = GastRecorder;
      function recordProd(prodConstructor, mainProdArg, occurrence, handleSep) {
        if (handleSep === void 0) {
          handleSep = false;
        }
        assertMethodIdxIsValid(occurrence);
        var prevProd = (0, last_1.default)(this.recordingProdStack);
        var grammarAction = (0, isFunction_1.default)(mainProdArg) ? mainProdArg : mainProdArg.DEF;
        var newProd = new prodConstructor({ definition: [], idx: occurrence });
        if (handleSep) {
          newProd.separator = mainProdArg.SEP;
        }
        if ((0, has_1.default)(mainProdArg, "MAX_LOOKAHEAD")) {
          newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;
        }
        this.recordingProdStack.push(newProd);
        grammarAction.call(this);
        prevProd.definition.push(newProd);
        this.recordingProdStack.pop();
        return RECORDING_NULL_OBJECT;
      }
      function recordOrProd(mainProdArg, occurrence) {
        var _this = this;
        assertMethodIdxIsValid(occurrence);
        var prevProd = (0, last_1.default)(this.recordingProdStack);
        var hasOptions = (0, isArray_1.default)(mainProdArg) === false;
        var alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;
        var newOrProd = new gast_1.Alternation({
          definition: [],
          idx: occurrence,
          ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true
        });
        if ((0, has_1.default)(mainProdArg, "MAX_LOOKAHEAD")) {
          newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;
        }
        var hasPredicates = (0, some_1.default)(alts, function(currAlt) {
          return (0, isFunction_1.default)(currAlt.GATE);
        });
        newOrProd.hasPredicates = hasPredicates;
        prevProd.definition.push(newOrProd);
        (0, forEach_1.default)(alts, function(currAlt) {
          var currAltFlat = new gast_1.Alternative({ definition: [] });
          newOrProd.definition.push(currAltFlat);
          if ((0, has_1.default)(currAlt, "IGNORE_AMBIGUITIES")) {
            currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES;
          } else if ((0, has_1.default)(currAlt, "GATE")) {
            currAltFlat.ignoreAmbiguities = true;
          }
          _this.recordingProdStack.push(currAltFlat);
          currAlt.ALT.call(_this);
          _this.recordingProdStack.pop();
        });
        return RECORDING_NULL_OBJECT;
      }
      function getIdxSuffix(idx) {
        return idx === 0 ? "" : "".concat(idx);
      }
      function assertMethodIdxIsValid(idx) {
        if (idx < 0 || idx > MAX_METHOD_IDX) {
          var error = new Error(
            // The stack trace will contain all the needed details
            "Invalid DSL Method idx value: <".concat(idx, ">\n	") + "Idx value must be a none negative value smaller than ".concat(MAX_METHOD_IDX + 1)
          );
          error.KNOWN_RECORDER_ERROR = true;
          throw error;
        }
      }
    }
  });

  // node_modules/chevrotain/lib/src/parse/parser/traits/perf_tracer.js
  var require_perf_tracer = __commonJS({
    "node_modules/chevrotain/lib/src/parse/parser/traits/perf_tracer.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.PerformanceTracer = void 0;
      var has_1 = __importDefault(require_has());
      var utils_1 = require_api4();
      var parser_1 = require_parser();
      var PerformanceTracer = (
        /** @class */
        function() {
          function PerformanceTracer2() {
          }
          PerformanceTracer2.prototype.initPerformanceTracer = function(config) {
            if ((0, has_1.default)(config, "traceInitPerf")) {
              var userTraceInitPerf = config.traceInitPerf;
              var traceIsNumber = typeof userTraceInitPerf === "number";
              this.traceInitMaxIdent = traceIsNumber ? userTraceInitPerf : Infinity;
              this.traceInitPerf = traceIsNumber ? userTraceInitPerf > 0 : userTraceInitPerf;
            } else {
              this.traceInitMaxIdent = 0;
              this.traceInitPerf = parser_1.DEFAULT_PARSER_CONFIG.traceInitPerf;
            }
            this.traceInitIndent = -1;
          };
          PerformanceTracer2.prototype.TRACE_INIT = function(phaseDesc, phaseImpl) {
            if (this.traceInitPerf === true) {
              this.traceInitIndent++;
              var indent = new Array(this.traceInitIndent + 1).join("	");
              if (this.traceInitIndent < this.traceInitMaxIdent) {
                console.log("".concat(indent, "--> <").concat(phaseDesc, ">"));
              }
              var _a4 = (0, utils_1.timer)(phaseImpl), time = _a4.time, value = _a4.value;
              var traceMethod = time > 10 ? console.warn : console.log;
              if (this.traceInitIndent < this.traceInitMaxIdent) {
                traceMethod("".concat(indent, "<-- <").concat(phaseDesc, "> time: ").concat(time, "ms"));
              }
              this.traceInitIndent--;
              return value;
            } else {
              return phaseImpl();
            }
          };
          return PerformanceTracer2;
        }()
      );
      exports2.PerformanceTracer = PerformanceTracer;
    }
  });

  // node_modules/chevrotain/lib/src/parse/parser/utils/apply_mixins.js
  var require_apply_mixins = __commonJS({
    "node_modules/chevrotain/lib/src/parse/parser/utils/apply_mixins.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.applyMixins = void 0;
      function applyMixins(derivedCtor, baseCtors) {
        baseCtors.forEach(function(baseCtor) {
          var baseProto = baseCtor.prototype;
          Object.getOwnPropertyNames(baseProto).forEach(function(propName) {
            if (propName === "constructor") {
              return;
            }
            var basePropDescriptor = Object.getOwnPropertyDescriptor(baseProto, propName);
            if (basePropDescriptor && (basePropDescriptor.get || basePropDescriptor.set)) {
              Object.defineProperty(derivedCtor.prototype, propName, basePropDescriptor);
            } else {
              derivedCtor.prototype[propName] = baseCtor.prototype[propName];
            }
          });
        });
      }
      exports2.applyMixins = applyMixins;
    }
  });

  // node_modules/chevrotain/lib/src/parse/parser/parser.js
  var require_parser = __commonJS({
    "node_modules/chevrotain/lib/src/parse/parser/parser.js"(exports2) {
      "use strict";
      var __extends = exports2 && exports2.__extends || function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2)
              if (Object.prototype.hasOwnProperty.call(b2, p))
                d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.EmbeddedActionsParser = exports2.CstParser = exports2.Parser = exports2.EMPTY_ALT = exports2.ParserDefinitionErrorType = exports2.DEFAULT_RULE_CONFIG = exports2.DEFAULT_PARSER_CONFIG = exports2.END_OF_FILE = void 0;
      var isEmpty_1 = __importDefault(require_isEmpty());
      var map_1 = __importDefault(require_map());
      var forEach_1 = __importDefault(require_forEach());
      var values_1 = __importDefault(require_values());
      var has_1 = __importDefault(require_has());
      var clone_1 = __importDefault(require_clone());
      var utils_1 = require_api4();
      var follow_1 = require_follow();
      var tokens_public_1 = require_tokens_public();
      var errors_public_1 = require_errors_public();
      var gast_resolver_public_1 = require_gast_resolver_public();
      var recoverable_1 = require_recoverable();
      var looksahead_1 = require_looksahead();
      var tree_builder_1 = require_tree_builder();
      var lexer_adapter_1 = require_lexer_adapter();
      var recognizer_api_1 = require_recognizer_api();
      var recognizer_engine_1 = require_recognizer_engine();
      var error_handler_1 = require_error_handler();
      var context_assist_1 = require_context_assist();
      var gast_recorder_1 = require_gast_recorder();
      var perf_tracer_1 = require_perf_tracer();
      var apply_mixins_1 = require_apply_mixins();
      var checks_1 = require_checks();
      exports2.END_OF_FILE = (0, tokens_public_1.createTokenInstance)(tokens_public_1.EOF, "", NaN, NaN, NaN, NaN, NaN, NaN);
      Object.freeze(exports2.END_OF_FILE);
      exports2.DEFAULT_PARSER_CONFIG = Object.freeze({
        recoveryEnabled: false,
        maxLookahead: 3,
        dynamicTokensEnabled: false,
        outputCst: true,
        errorMessageProvider: errors_public_1.defaultParserErrorProvider,
        nodeLocationTracking: "none",
        traceInitPerf: false,
        skipValidations: false
      });
      exports2.DEFAULT_RULE_CONFIG = Object.freeze({
        recoveryValueFunc: function() {
          return void 0;
        },
        resyncEnabled: true
      });
      var ParserDefinitionErrorType;
      (function(ParserDefinitionErrorType2) {
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["INVALID_RULE_NAME"] = 0] = "INVALID_RULE_NAME";
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["DUPLICATE_RULE_NAME"] = 1] = "DUPLICATE_RULE_NAME";
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["INVALID_RULE_OVERRIDE"] = 2] = "INVALID_RULE_OVERRIDE";
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["DUPLICATE_PRODUCTIONS"] = 3] = "DUPLICATE_PRODUCTIONS";
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["UNRESOLVED_SUBRULE_REF"] = 4] = "UNRESOLVED_SUBRULE_REF";
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["LEFT_RECURSION"] = 5] = "LEFT_RECURSION";
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["NONE_LAST_EMPTY_ALT"] = 6] = "NONE_LAST_EMPTY_ALT";
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["AMBIGUOUS_ALTS"] = 7] = "AMBIGUOUS_ALTS";
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["CONFLICT_TOKENS_RULES_NAMESPACE"] = 8] = "CONFLICT_TOKENS_RULES_NAMESPACE";
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["INVALID_TOKEN_NAME"] = 9] = "INVALID_TOKEN_NAME";
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["NO_NON_EMPTY_LOOKAHEAD"] = 10] = "NO_NON_EMPTY_LOOKAHEAD";
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["AMBIGUOUS_PREFIX_ALTS"] = 11] = "AMBIGUOUS_PREFIX_ALTS";
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["TOO_MANY_ALTS"] = 12] = "TOO_MANY_ALTS";
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["CUSTOM_LOOKAHEAD_VALIDATION"] = 13] = "CUSTOM_LOOKAHEAD_VALIDATION";
      })(ParserDefinitionErrorType = exports2.ParserDefinitionErrorType || (exports2.ParserDefinitionErrorType = {}));
      function EMPTY_ALT(value) {
        if (value === void 0) {
          value = void 0;
        }
        return function() {
          return value;
        };
      }
      exports2.EMPTY_ALT = EMPTY_ALT;
      var Parser2 = (
        /** @class */
        function() {
          function Parser3(tokenVocabulary, config) {
            this.definitionErrors = [];
            this.selfAnalysisDone = false;
            var that = this;
            that.initErrorHandler(config);
            that.initLexerAdapter();
            that.initLooksAhead(config);
            that.initRecognizerEngine(tokenVocabulary, config);
            that.initRecoverable(config);
            that.initTreeBuilder(config);
            that.initContentAssist();
            that.initGastRecorder(config);
            that.initPerformanceTracer(config);
            if ((0, has_1.default)(config, "ignoredIssues")) {
              throw new Error("The <ignoredIssues> IParserConfig property has been deprecated.\n	Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\n	See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\n	For further details.");
            }
            this.skipValidations = (0, has_1.default)(config, "skipValidations") ? config.skipValidations : exports2.DEFAULT_PARSER_CONFIG.skipValidations;
          }
          Parser3.performSelfAnalysis = function(parserInstance) {
            throw Error("The **static** `performSelfAnalysis` method has been deprecated.	\nUse the **instance** method with the same name instead.");
          };
          Parser3.prototype.performSelfAnalysis = function() {
            var _this = this;
            this.TRACE_INIT("performSelfAnalysis", function() {
              var defErrorsMsgs;
              _this.selfAnalysisDone = true;
              var className = _this.className;
              _this.TRACE_INIT("toFastProps", function() {
                (0, utils_1.toFastProperties)(_this);
              });
              _this.TRACE_INIT("Grammar Recording", function() {
                try {
                  _this.enableRecording();
                  (0, forEach_1.default)(_this.definedRulesNames, function(currRuleName) {
                    var wrappedRule = _this[currRuleName];
                    var originalGrammarAction = wrappedRule["originalGrammarAction"];
                    var recordedRuleGast;
                    _this.TRACE_INIT("".concat(currRuleName, " Rule"), function() {
                      recordedRuleGast = _this.topLevelRuleRecord(currRuleName, originalGrammarAction);
                    });
                    _this.gastProductionsCache[currRuleName] = recordedRuleGast;
                  });
                } finally {
                  _this.disableRecording();
                }
              });
              var resolverErrors = [];
              _this.TRACE_INIT("Grammar Resolving", function() {
                resolverErrors = (0, gast_resolver_public_1.resolveGrammar)({
                  rules: (0, values_1.default)(_this.gastProductionsCache)
                });
                _this.definitionErrors = _this.definitionErrors.concat(resolverErrors);
              });
              _this.TRACE_INIT("Grammar Validations", function() {
                if ((0, isEmpty_1.default)(resolverErrors) && _this.skipValidations === false) {
                  var validationErrors = (0, gast_resolver_public_1.validateGrammar)({
                    rules: (0, values_1.default)(_this.gastProductionsCache),
                    tokenTypes: (0, values_1.default)(_this.tokensMap),
                    errMsgProvider: errors_public_1.defaultGrammarValidatorErrorProvider,
                    grammarName: className
                  });
                  var lookaheadValidationErrors = (0, checks_1.validateLookahead)({
                    lookaheadStrategy: _this.lookaheadStrategy,
                    rules: (0, values_1.default)(_this.gastProductionsCache),
                    tokenTypes: (0, values_1.default)(_this.tokensMap),
                    grammarName: className
                  });
                  _this.definitionErrors = _this.definitionErrors.concat(validationErrors, lookaheadValidationErrors);
                }
              });
              if ((0, isEmpty_1.default)(_this.definitionErrors)) {
                if (_this.recoveryEnabled) {
                  _this.TRACE_INIT("computeAllProdsFollows", function() {
                    var allFollows = (0, follow_1.computeAllProdsFollows)((0, values_1.default)(_this.gastProductionsCache));
                    _this.resyncFollows = allFollows;
                  });
                }
                _this.TRACE_INIT("ComputeLookaheadFunctions", function() {
                  var _a4, _b2;
                  (_b2 = (_a4 = _this.lookaheadStrategy).initialize) === null || _b2 === void 0 ? void 0 : _b2.call(_a4, {
                    rules: (0, values_1.default)(_this.gastProductionsCache)
                  });
                  _this.preComputeLookaheadFunctions((0, values_1.default)(_this.gastProductionsCache));
                });
              }
              if (!Parser3.DEFER_DEFINITION_ERRORS_HANDLING && !(0, isEmpty_1.default)(_this.definitionErrors)) {
                defErrorsMsgs = (0, map_1.default)(_this.definitionErrors, function(defError) {
                  return defError.message;
                });
                throw new Error("Parser Definition Errors detected:\n ".concat(defErrorsMsgs.join("\n-------------------------------\n")));
              }
            });
          };
          Parser3.DEFER_DEFINITION_ERRORS_HANDLING = false;
          return Parser3;
        }()
      );
      exports2.Parser = Parser2;
      (0, apply_mixins_1.applyMixins)(Parser2, [
        recoverable_1.Recoverable,
        looksahead_1.LooksAhead,
        tree_builder_1.TreeBuilder,
        lexer_adapter_1.LexerAdapter,
        recognizer_engine_1.RecognizerEngine,
        recognizer_api_1.RecognizerApi,
        error_handler_1.ErrorHandler,
        context_assist_1.ContentAssist,
        gast_recorder_1.GastRecorder,
        perf_tracer_1.PerformanceTracer
      ]);
      var CstParser = (
        /** @class */
        function(_super) {
          __extends(CstParser2, _super);
          function CstParser2(tokenVocabulary, config) {
            if (config === void 0) {
              config = exports2.DEFAULT_PARSER_CONFIG;
            }
            var configClone = (0, clone_1.default)(config);
            configClone.outputCst = true;
            return _super.call(this, tokenVocabulary, configClone) || this;
          }
          return CstParser2;
        }(Parser2)
      );
      exports2.CstParser = CstParser;
      var EmbeddedActionsParser = (
        /** @class */
        function(_super) {
          __extends(EmbeddedActionsParser2, _super);
          function EmbeddedActionsParser2(tokenVocabulary, config) {
            if (config === void 0) {
              config = exports2.DEFAULT_PARSER_CONFIG;
            }
            var configClone = (0, clone_1.default)(config);
            configClone.outputCst = false;
            return _super.call(this, tokenVocabulary, configClone) || this;
          }
          return EmbeddedActionsParser2;
        }(Parser2)
      );
      exports2.EmbeddedActionsParser = EmbeddedActionsParser;
    }
  });

  // node_modules/@chevrotain/cst-dts-gen/lib/src/model.js
  var require_model2 = __commonJS({
    "node_modules/@chevrotain/cst-dts-gen/lib/src/model.js"(exports2) {
      "use strict";
      var __extends = exports2 && exports2.__extends || function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2)
              if (Object.prototype.hasOwnProperty.call(b2, p))
                d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.buildModel = void 0;
      var gast_1 = require_api5();
      var map_1 = __importDefault(require_map());
      var flatten_1 = __importDefault(require_flatten());
      var values_1 = __importDefault(require_values());
      var some_1 = __importDefault(require_some());
      var groupBy_1 = __importDefault(require_groupBy());
      var assign_1 = __importDefault(require_assign());
      function buildModel(productions) {
        var generator = new CstNodeDefinitionGenerator();
        var allRules = (0, values_1.default)(productions);
        return (0, map_1.default)(allRules, function(rule) {
          return generator.visitRule(rule);
        });
      }
      exports2.buildModel = buildModel;
      var CstNodeDefinitionGenerator = (
        /** @class */
        function(_super) {
          __extends(CstNodeDefinitionGenerator2, _super);
          function CstNodeDefinitionGenerator2() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          CstNodeDefinitionGenerator2.prototype.visitRule = function(node) {
            var rawElements = this.visitEach(node.definition);
            var grouped = (0, groupBy_1.default)(rawElements, function(el) {
              return el.propertyName;
            });
            var properties = (0, map_1.default)(grouped, function(group, propertyName) {
              var allNullable = !(0, some_1.default)(group, function(el) {
                return !el.canBeNull;
              });
              var propertyType = group[0].type;
              if (group.length > 1) {
                propertyType = (0, map_1.default)(group, function(g) {
                  return g.type;
                });
              }
              return {
                name: propertyName,
                type: propertyType,
                optional: allNullable
              };
            });
            return {
              name: node.name,
              properties
            };
          };
          CstNodeDefinitionGenerator2.prototype.visitAlternative = function(node) {
            return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });
          };
          CstNodeDefinitionGenerator2.prototype.visitOption = function(node) {
            return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });
          };
          CstNodeDefinitionGenerator2.prototype.visitRepetition = function(node) {
            return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });
          };
          CstNodeDefinitionGenerator2.prototype.visitRepetitionMandatory = function(node) {
            return this.visitEach(node.definition);
          };
          CstNodeDefinitionGenerator2.prototype.visitRepetitionMandatoryWithSeparator = function(node) {
            return this.visitEach(node.definition).concat({
              propertyName: node.separator.name,
              canBeNull: true,
              type: getType(node.separator)
            });
          };
          CstNodeDefinitionGenerator2.prototype.visitRepetitionWithSeparator = function(node) {
            return this.visitEachAndOverrideWith(node.definition, {
              canBeNull: true
            }).concat({
              propertyName: node.separator.name,
              canBeNull: true,
              type: getType(node.separator)
            });
          };
          CstNodeDefinitionGenerator2.prototype.visitAlternation = function(node) {
            return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });
          };
          CstNodeDefinitionGenerator2.prototype.visitTerminal = function(node) {
            return [
              {
                propertyName: node.label || node.terminalType.name,
                canBeNull: false,
                type: getType(node)
              }
            ];
          };
          CstNodeDefinitionGenerator2.prototype.visitNonTerminal = function(node) {
            return [
              {
                propertyName: node.label || node.nonTerminalName,
                canBeNull: false,
                type: getType(node)
              }
            ];
          };
          CstNodeDefinitionGenerator2.prototype.visitEachAndOverrideWith = function(definition, override) {
            return (0, map_1.default)(this.visitEach(definition), function(definition2) {
              return (0, assign_1.default)({}, definition2, override);
            });
          };
          CstNodeDefinitionGenerator2.prototype.visitEach = function(definition) {
            var _this = this;
            return (0, flatten_1.default)((0, map_1.default)(definition, function(definition2) {
              return _this.visit(definition2);
            }));
          };
          return CstNodeDefinitionGenerator2;
        }(gast_1.GAstVisitor)
      );
      function getType(production) {
        if (production instanceof gast_1.NonTerminal) {
          return {
            kind: "rule",
            name: production.referencedRule.name
          };
        }
        return { kind: "token" };
      }
    }
  });

  // node_modules/lodash/_castSlice.js
  var require_castSlice = __commonJS({
    "node_modules/lodash/_castSlice.js"(exports2, module2) {
      var baseSlice = require_baseSlice();
      function castSlice(array, start, end) {
        var length = array.length;
        end = end === void 0 ? length : end;
        return !start && end >= length ? array : baseSlice(array, start, end);
      }
      module2.exports = castSlice;
    }
  });

  // node_modules/lodash/_hasUnicode.js
  var require_hasUnicode = __commonJS({
    "node_modules/lodash/_hasUnicode.js"(exports2, module2) {
      var rsAstralRange = "\\ud800-\\udfff";
      var rsComboMarksRange = "\\u0300-\\u036f";
      var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
      var rsComboSymbolsRange = "\\u20d0-\\u20ff";
      var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
      var rsVarRange = "\\ufe0e\\ufe0f";
      var rsZWJ = "\\u200d";
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      module2.exports = hasUnicode;
    }
  });

  // node_modules/lodash/_asciiToArray.js
  var require_asciiToArray = __commonJS({
    "node_modules/lodash/_asciiToArray.js"(exports2, module2) {
      function asciiToArray(string) {
        return string.split("");
      }
      module2.exports = asciiToArray;
    }
  });

  // node_modules/lodash/_unicodeToArray.js
  var require_unicodeToArray = __commonJS({
    "node_modules/lodash/_unicodeToArray.js"(exports2, module2) {
      var rsAstralRange = "\\ud800-\\udfff";
      var rsComboMarksRange = "\\u0300-\\u036f";
      var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
      var rsComboSymbolsRange = "\\u20d0-\\u20ff";
      var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
      var rsVarRange = "\\ufe0e\\ufe0f";
      var rsAstral = "[" + rsAstralRange + "]";
      var rsCombo = "[" + rsComboRange + "]";
      var rsFitz = "\\ud83c[\\udffb-\\udfff]";
      var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
      var rsNonAstral = "[^" + rsAstralRange + "]";
      var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
      var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
      var rsZWJ = "\\u200d";
      var reOptMod = rsModifier + "?";
      var rsOptVar = "[" + rsVarRange + "]?";
      var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
      var rsSeq = rsOptVar + reOptMod + rsOptJoin;
      var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      module2.exports = unicodeToArray;
    }
  });

  // node_modules/lodash/_stringToArray.js
  var require_stringToArray = __commonJS({
    "node_modules/lodash/_stringToArray.js"(exports2, module2) {
      var asciiToArray = require_asciiToArray();
      var hasUnicode = require_hasUnicode();
      var unicodeToArray = require_unicodeToArray();
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      module2.exports = stringToArray;
    }
  });

  // node_modules/lodash/_createCaseFirst.js
  var require_createCaseFirst = __commonJS({
    "node_modules/lodash/_createCaseFirst.js"(exports2, module2) {
      var castSlice = require_castSlice();
      var hasUnicode = require_hasUnicode();
      var stringToArray = require_stringToArray();
      var toString = require_toString();
      function createCaseFirst(methodName) {
        return function(string) {
          string = toString(string);
          var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
          var chr = strSymbols ? strSymbols[0] : string.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      module2.exports = createCaseFirst;
    }
  });

  // node_modules/lodash/upperFirst.js
  var require_upperFirst = __commonJS({
    "node_modules/lodash/upperFirst.js"(exports2, module2) {
      var createCaseFirst = require_createCaseFirst();
      var upperFirst = createCaseFirst("toUpperCase");
      module2.exports = upperFirst;
    }
  });

  // node_modules/@chevrotain/cst-dts-gen/lib/src/generate.js
  var require_generate = __commonJS({
    "node_modules/@chevrotain/cst-dts-gen/lib/src/generate.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.genDts = void 0;
      var flatten_1 = __importDefault(require_flatten());
      var isArray_1 = __importDefault(require_isArray());
      var map_1 = __importDefault(require_map());
      var reduce_1 = __importDefault(require_reduce());
      var uniq_1 = __importDefault(require_uniq());
      var upperFirst_1 = __importDefault(require_upperFirst());
      function genDts(model, options) {
        var contentParts = [];
        contentParts = contentParts.concat('import type { CstNode, ICstVisitor, IToken } from "chevrotain";');
        contentParts = contentParts.concat((0, flatten_1.default)((0, map_1.default)(model, function(node) {
          return genCstNodeTypes(node);
        })));
        if (options.includeVisitorInterface) {
          contentParts = contentParts.concat(genVisitor(options.visitorInterfaceName, model));
        }
        return contentParts.join("\n\n") + "\n";
      }
      exports2.genDts = genDts;
      function genCstNodeTypes(node) {
        var nodeCstInterface = genNodeInterface(node);
        var nodeChildrenInterface = genNodeChildrenType(node);
        return [nodeCstInterface, nodeChildrenInterface];
      }
      function genNodeInterface(node) {
        var nodeInterfaceName = getNodeInterfaceName(node.name);
        var childrenTypeName = getNodeChildrenTypeName(node.name);
        return "export interface ".concat(nodeInterfaceName, ' extends CstNode {\n  name: "').concat(node.name, '";\n  children: ').concat(childrenTypeName, ";\n}");
      }
      function genNodeChildrenType(node) {
        var typeName = getNodeChildrenTypeName(node.name);
        return "export type ".concat(typeName, " = {\n  ").concat((0, map_1.default)(node.properties, function(property) {
          return genChildProperty(property);
        }).join("\n  "), "\n};");
      }
      function genChildProperty(prop) {
        var typeName = buildTypeString(prop.type);
        return "".concat(prop.name).concat(prop.optional ? "?" : "", ": ").concat(typeName, "[];");
      }
      function genVisitor(name, nodes) {
        return "export interface ".concat(name, "<IN, OUT> extends ICstVisitor<IN, OUT> {\n  ").concat((0, map_1.default)(nodes, function(node) {
          return genVisitorFunction(node);
        }).join("\n  "), "\n}");
      }
      function genVisitorFunction(node) {
        var childrenTypeName = getNodeChildrenTypeName(node.name);
        return "".concat(node.name, "(children: ").concat(childrenTypeName, ", param?: IN): OUT;");
      }
      function buildTypeString(type) {
        if ((0, isArray_1.default)(type)) {
          var typeNames = (0, uniq_1.default)((0, map_1.default)(type, function(t) {
            return getTypeString(t);
          }));
          var typeString = (0, reduce_1.default)(typeNames, function(sum, t) {
            return sum + " | " + t;
          });
          return "(" + typeString + ")";
        } else {
          return getTypeString(type);
        }
      }
      function getTypeString(type) {
        if (type.kind === "token") {
          return "IToken";
        }
        return getNodeInterfaceName(type.name);
      }
      function getNodeInterfaceName(ruleName) {
        return (0, upperFirst_1.default)(ruleName) + "CstNode";
      }
      function getNodeChildrenTypeName(ruleName) {
        return (0, upperFirst_1.default)(ruleName) + "CstChildren";
      }
    }
  });

  // node_modules/@chevrotain/cst-dts-gen/lib/src/api.js
  var require_api6 = __commonJS({
    "node_modules/@chevrotain/cst-dts-gen/lib/src/api.js"(exports2) {
      "use strict";
      var __assign = exports2 && exports2.__assign || function() {
        __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.generateCstDts = void 0;
      var model_1 = require_model2();
      var generate_1 = require_generate();
      var defaultOptions = {
        includeVisitorInterface: true,
        visitorInterfaceName: "ICstNodeVisitor"
      };
      function generateCstDts(productions, options) {
        var effectiveOptions = __assign(__assign({}, defaultOptions), options);
        var model = (0, model_1.buildModel)(productions);
        return (0, generate_1.genDts)(model, effectiveOptions);
      }
      exports2.generateCstDts = generateCstDts;
    }
  });

  // node_modules/chevrotain/lib/src/diagrams/render_public.js
  var require_render_public = __commonJS({
    "node_modules/chevrotain/lib/src/diagrams/render_public.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createSyntaxDiagramsCode = void 0;
      var version_1 = require_version();
      function createSyntaxDiagramsCode(grammar, _a4) {
        var _b2 = _a4 === void 0 ? {} : _a4, _c2 = _b2.resourceBase, resourceBase = _c2 === void 0 ? "https://unpkg.com/chevrotain@".concat(version_1.VERSION, "/diagrams/") : _c2, _d = _b2.css, css = _d === void 0 ? "https://unpkg.com/chevrotain@".concat(version_1.VERSION, "/diagrams/diagrams.css") : _d;
        var header = '\n<!-- This is a generated file -->\n<!DOCTYPE html>\n<meta charset="utf-8">\n<style>\n  body {\n    background-color: hsl(30, 20%, 95%)\n  }\n</style>\n\n';
        var cssHtml = "\n<link rel='stylesheet' href='".concat(css, "'>\n");
        var scripts = "\n<script src='".concat(resourceBase, "vendor/railroad-diagrams.js'><\/script>\n<script src='").concat(resourceBase, "src/diagrams_builder.js'><\/script>\n<script src='").concat(resourceBase, "src/diagrams_behavior.js'><\/script>\n<script src='").concat(resourceBase, "src/main.js'><\/script>\n");
        var diagramsDiv = '\n<div id="diagrams" align="center"></div>    \n';
        var serializedGrammar = "\n<script>\n    window.serializedGrammar = ".concat(JSON.stringify(grammar, null, "  "), ";\n<\/script>\n");
        var initLogic = '\n<script>\n    var diagramsDiv = document.getElementById("diagrams");\n    main.drawDiagramsFromSerializedGrammar(serializedGrammar, diagramsDiv);\n<\/script>\n';
        return header + cssHtml + scripts + diagramsDiv + serializedGrammar + initLogic;
      }
      exports2.createSyntaxDiagramsCode = createSyntaxDiagramsCode;
    }
  });

  // node_modules/chevrotain/lib/src/api.js
  var require_api7 = __commonJS({
    "node_modules/chevrotain/lib/src/api.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Parser = exports2.createSyntaxDiagramsCode = exports2.clearCache = exports2.generateCstDts = exports2.GAstVisitor = exports2.serializeProduction = exports2.serializeGrammar = exports2.Terminal = exports2.Rule = exports2.RepetitionWithSeparator = exports2.RepetitionMandatoryWithSeparator = exports2.RepetitionMandatory = exports2.Repetition = exports2.Option = exports2.NonTerminal = exports2.Alternative = exports2.Alternation = exports2.defaultLexerErrorProvider = exports2.NoViableAltException = exports2.NotAllInputParsedException = exports2.MismatchedTokenException = exports2.isRecognitionException = exports2.EarlyExitException = exports2.defaultParserErrorProvider = exports2.LLkLookaheadStrategy = exports2.getLookaheadPaths = exports2.tokenName = exports2.tokenMatcher = exports2.tokenLabel = exports2.EOF = exports2.createTokenInstance = exports2.createToken = exports2.LexerDefinitionErrorType = exports2.Lexer = exports2.EMPTY_ALT = exports2.ParserDefinitionErrorType = exports2.EmbeddedActionsParser = exports2.CstParser = exports2.VERSION = void 0;
      var version_1 = require_version();
      Object.defineProperty(exports2, "VERSION", { enumerable: true, get: function() {
        return version_1.VERSION;
      } });
      var parser_1 = require_parser();
      Object.defineProperty(exports2, "CstParser", { enumerable: true, get: function() {
        return parser_1.CstParser;
      } });
      Object.defineProperty(exports2, "EmbeddedActionsParser", { enumerable: true, get: function() {
        return parser_1.EmbeddedActionsParser;
      } });
      Object.defineProperty(exports2, "ParserDefinitionErrorType", { enumerable: true, get: function() {
        return parser_1.ParserDefinitionErrorType;
      } });
      Object.defineProperty(exports2, "EMPTY_ALT", { enumerable: true, get: function() {
        return parser_1.EMPTY_ALT;
      } });
      var lexer_public_1 = require_lexer_public();
      Object.defineProperty(exports2, "Lexer", { enumerable: true, get: function() {
        return lexer_public_1.Lexer;
      } });
      Object.defineProperty(exports2, "LexerDefinitionErrorType", { enumerable: true, get: function() {
        return lexer_public_1.LexerDefinitionErrorType;
      } });
      var tokens_public_1 = require_tokens_public();
      Object.defineProperty(exports2, "createToken", { enumerable: true, get: function() {
        return tokens_public_1.createToken;
      } });
      Object.defineProperty(exports2, "createTokenInstance", { enumerable: true, get: function() {
        return tokens_public_1.createTokenInstance;
      } });
      Object.defineProperty(exports2, "EOF", { enumerable: true, get: function() {
        return tokens_public_1.EOF;
      } });
      Object.defineProperty(exports2, "tokenLabel", { enumerable: true, get: function() {
        return tokens_public_1.tokenLabel;
      } });
      Object.defineProperty(exports2, "tokenMatcher", { enumerable: true, get: function() {
        return tokens_public_1.tokenMatcher;
      } });
      Object.defineProperty(exports2, "tokenName", { enumerable: true, get: function() {
        return tokens_public_1.tokenName;
      } });
      var lookahead_1 = require_lookahead();
      Object.defineProperty(exports2, "getLookaheadPaths", { enumerable: true, get: function() {
        return lookahead_1.getLookaheadPaths;
      } });
      var llk_lookahead_1 = require_llk_lookahead();
      Object.defineProperty(exports2, "LLkLookaheadStrategy", { enumerable: true, get: function() {
        return llk_lookahead_1.LLkLookaheadStrategy;
      } });
      var errors_public_1 = require_errors_public();
      Object.defineProperty(exports2, "defaultParserErrorProvider", { enumerable: true, get: function() {
        return errors_public_1.defaultParserErrorProvider;
      } });
      var exceptions_public_1 = require_exceptions_public();
      Object.defineProperty(exports2, "EarlyExitException", { enumerable: true, get: function() {
        return exceptions_public_1.EarlyExitException;
      } });
      Object.defineProperty(exports2, "isRecognitionException", { enumerable: true, get: function() {
        return exceptions_public_1.isRecognitionException;
      } });
      Object.defineProperty(exports2, "MismatchedTokenException", { enumerable: true, get: function() {
        return exceptions_public_1.MismatchedTokenException;
      } });
      Object.defineProperty(exports2, "NotAllInputParsedException", { enumerable: true, get: function() {
        return exceptions_public_1.NotAllInputParsedException;
      } });
      Object.defineProperty(exports2, "NoViableAltException", { enumerable: true, get: function() {
        return exceptions_public_1.NoViableAltException;
      } });
      var lexer_errors_public_1 = require_lexer_errors_public();
      Object.defineProperty(exports2, "defaultLexerErrorProvider", { enumerable: true, get: function() {
        return lexer_errors_public_1.defaultLexerErrorProvider;
      } });
      var gast_1 = require_api5();
      Object.defineProperty(exports2, "Alternation", { enumerable: true, get: function() {
        return gast_1.Alternation;
      } });
      Object.defineProperty(exports2, "Alternative", { enumerable: true, get: function() {
        return gast_1.Alternative;
      } });
      Object.defineProperty(exports2, "NonTerminal", { enumerable: true, get: function() {
        return gast_1.NonTerminal;
      } });
      Object.defineProperty(exports2, "Option", { enumerable: true, get: function() {
        return gast_1.Option;
      } });
      Object.defineProperty(exports2, "Repetition", { enumerable: true, get: function() {
        return gast_1.Repetition;
      } });
      Object.defineProperty(exports2, "RepetitionMandatory", { enumerable: true, get: function() {
        return gast_1.RepetitionMandatory;
      } });
      Object.defineProperty(exports2, "RepetitionMandatoryWithSeparator", { enumerable: true, get: function() {
        return gast_1.RepetitionMandatoryWithSeparator;
      } });
      Object.defineProperty(exports2, "RepetitionWithSeparator", { enumerable: true, get: function() {
        return gast_1.RepetitionWithSeparator;
      } });
      Object.defineProperty(exports2, "Rule", { enumerable: true, get: function() {
        return gast_1.Rule;
      } });
      Object.defineProperty(exports2, "Terminal", { enumerable: true, get: function() {
        return gast_1.Terminal;
      } });
      var gast_2 = require_api5();
      Object.defineProperty(exports2, "serializeGrammar", { enumerable: true, get: function() {
        return gast_2.serializeGrammar;
      } });
      Object.defineProperty(exports2, "serializeProduction", { enumerable: true, get: function() {
        return gast_2.serializeProduction;
      } });
      Object.defineProperty(exports2, "GAstVisitor", { enumerable: true, get: function() {
        return gast_2.GAstVisitor;
      } });
      var cst_dts_gen_1 = require_api6();
      Object.defineProperty(exports2, "generateCstDts", { enumerable: true, get: function() {
        return cst_dts_gen_1.generateCstDts;
      } });
      function clearCache() {
        console.warn("The clearCache function was 'soft' removed from the Chevrotain API.\n	 It performs no action other than printing this message.\n	 Please avoid using it as it will be completely removed in the future");
      }
      exports2.clearCache = clearCache;
      var render_public_1 = require_render_public();
      Object.defineProperty(exports2, "createSyntaxDiagramsCode", { enumerable: true, get: function() {
        return render_public_1.createSyntaxDiagramsCode;
      } });
      var Parser2 = (
        /** @class */
        function() {
          function Parser3() {
            throw new Error("The Parser class has been deprecated, use CstParser or EmbeddedActionsParser instead.	\nSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_7-0-0");
          }
          return Parser3;
        }()
      );
      exports2.Parser = Parser2;
    }
  });

  // node_modules/chevrotain-allstar/lib/atn.js
  var require_atn = __commonJS({
    "node_modules/chevrotain-allstar/lib/atn.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createATN = exports2.RuleTransition = exports2.EpsilonTransition = exports2.AtomTransition = exports2.AbstractTransition = exports2.ATN_LOOP_END = exports2.ATN_PLUS_LOOP_BACK = exports2.ATN_STAR_LOOP_ENTRY = exports2.ATN_STAR_LOOP_BACK = exports2.ATN_BLOCK_END = exports2.ATN_RULE_STOP = exports2.ATN_TOKEN_START = exports2.ATN_STAR_BLOCK_START = exports2.ATN_PLUS_BLOCK_START = exports2.ATN_RULE_START = exports2.ATN_BASIC = exports2.ATN_INVALID_TYPE = exports2.buildATNKey = void 0;
      var map_1 = __importDefault(require_map());
      var filter_1 = __importDefault(require_filter());
      var chevrotain_1 = require_api7();
      function buildATNKey(rule, type, occurrence) {
        return `${rule.name}_${type}_${occurrence}`;
      }
      exports2.buildATNKey = buildATNKey;
      exports2.ATN_INVALID_TYPE = 0;
      exports2.ATN_BASIC = 1;
      exports2.ATN_RULE_START = 2;
      exports2.ATN_PLUS_BLOCK_START = 4;
      exports2.ATN_STAR_BLOCK_START = 5;
      exports2.ATN_TOKEN_START = 6;
      exports2.ATN_RULE_STOP = 7;
      exports2.ATN_BLOCK_END = 8;
      exports2.ATN_STAR_LOOP_BACK = 9;
      exports2.ATN_STAR_LOOP_ENTRY = 10;
      exports2.ATN_PLUS_LOOP_BACK = 11;
      exports2.ATN_LOOP_END = 12;
      var AbstractTransition = class {
        constructor(target) {
          this.target = target;
        }
        isEpsilon() {
          return false;
        }
      };
      exports2.AbstractTransition = AbstractTransition;
      var AtomTransition = class extends AbstractTransition {
        constructor(target, tokenType) {
          super(target);
          this.tokenType = tokenType;
        }
      };
      exports2.AtomTransition = AtomTransition;
      var EpsilonTransition = class extends AbstractTransition {
        constructor(target) {
          super(target);
        }
        isEpsilon() {
          return true;
        }
      };
      exports2.EpsilonTransition = EpsilonTransition;
      var RuleTransition = class extends AbstractTransition {
        constructor(ruleStart, rule, followState) {
          super(ruleStart);
          this.rule = rule;
          this.followState = followState;
        }
        isEpsilon() {
          return true;
        }
      };
      exports2.RuleTransition = RuleTransition;
      function createATN(rules) {
        const atn = {
          decisionMap: {},
          decisionStates: [],
          ruleToStartState: /* @__PURE__ */ new Map(),
          ruleToStopState: /* @__PURE__ */ new Map(),
          states: []
        };
        createRuleStartAndStopATNStates(atn, rules);
        const ruleLength = rules.length;
        for (let i = 0; i < ruleLength; i++) {
          const rule = rules[i];
          const ruleBlock = block(atn, rule, rule);
          if (ruleBlock === void 0) {
            continue;
          }
          buildRuleHandle(atn, rule, ruleBlock);
        }
        return atn;
      }
      exports2.createATN = createATN;
      function createRuleStartAndStopATNStates(atn, rules) {
        const ruleLength = rules.length;
        for (let i = 0; i < ruleLength; i++) {
          const rule = rules[i];
          const start = newState(atn, rule, void 0, {
            type: exports2.ATN_RULE_START
          });
          const stop = newState(atn, rule, void 0, {
            type: exports2.ATN_RULE_STOP
          });
          start.stop = stop;
          atn.ruleToStartState.set(rule, start);
          atn.ruleToStopState.set(rule, stop);
        }
      }
      function atom(atn, rule, production) {
        if (production instanceof chevrotain_1.Terminal) {
          return tokenRef(atn, rule, production.terminalType, production);
        } else if (production instanceof chevrotain_1.NonTerminal) {
          return ruleRef(atn, rule, production);
        } else if (production instanceof chevrotain_1.Alternation) {
          return alternation(atn, rule, production);
        } else if (production instanceof chevrotain_1.Option) {
          return option(atn, rule, production);
        } else if (production instanceof chevrotain_1.Repetition) {
          return repetition(atn, rule, production);
        } else if (production instanceof chevrotain_1.RepetitionWithSeparator) {
          return repetitionSep(atn, rule, production);
        } else if (production instanceof chevrotain_1.RepetitionMandatory) {
          return repetitionMandatory(atn, rule, production);
        } else if (production instanceof chevrotain_1.RepetitionMandatoryWithSeparator) {
          return repetitionMandatorySep(atn, rule, production);
        } else {
          return block(atn, rule, production);
        }
      }
      function repetition(atn, rule, repetition2) {
        const starState = newState(atn, rule, repetition2, {
          type: exports2.ATN_STAR_BLOCK_START
        });
        defineDecisionState(atn, starState);
        const handle = makeAlts(atn, rule, starState, repetition2, block(atn, rule, repetition2));
        return star(atn, rule, repetition2, handle);
      }
      function repetitionSep(atn, rule, repetition2) {
        const starState = newState(atn, rule, repetition2, {
          type: exports2.ATN_STAR_BLOCK_START
        });
        defineDecisionState(atn, starState);
        const handle = makeAlts(atn, rule, starState, repetition2, block(atn, rule, repetition2));
        const sep2 = tokenRef(atn, rule, repetition2.separator, repetition2);
        return star(atn, rule, repetition2, handle, sep2);
      }
      function repetitionMandatory(atn, rule, repetition2) {
        const plusState = newState(atn, rule, repetition2, {
          type: exports2.ATN_PLUS_BLOCK_START
        });
        defineDecisionState(atn, plusState);
        const handle = makeAlts(atn, rule, plusState, repetition2, block(atn, rule, repetition2));
        return plus(atn, rule, repetition2, handle);
      }
      function repetitionMandatorySep(atn, rule, repetition2) {
        const plusState = newState(atn, rule, repetition2, {
          type: exports2.ATN_PLUS_BLOCK_START
        });
        defineDecisionState(atn, plusState);
        const handle = makeAlts(atn, rule, plusState, repetition2, block(atn, rule, repetition2));
        const sep2 = tokenRef(atn, rule, repetition2.separator, repetition2);
        return plus(atn, rule, repetition2, handle, sep2);
      }
      function alternation(atn, rule, alternation2) {
        const start = newState(atn, rule, alternation2, {
          type: exports2.ATN_BASIC
        });
        defineDecisionState(atn, start);
        const alts = (0, map_1.default)(alternation2.definition, (e) => atom(atn, rule, e));
        const handle = makeAlts(atn, rule, start, alternation2, ...alts);
        return handle;
      }
      function option(atn, rule, option2) {
        const start = newState(atn, rule, option2, {
          type: exports2.ATN_BASIC
        });
        defineDecisionState(atn, start);
        const handle = makeAlts(atn, rule, start, option2, block(atn, rule, option2));
        return optional(atn, rule, option2, handle);
      }
      function block(atn, rule, block2) {
        const handles = (0, filter_1.default)((0, map_1.default)(block2.definition, (e) => atom(atn, rule, e)), (e) => e !== void 0);
        if (handles.length === 1) {
          return handles[0];
        } else if (handles.length === 0) {
          return void 0;
        } else {
          return makeBlock(atn, handles);
        }
      }
      function plus(atn, rule, plus2, handle, sep2) {
        const blkStart = handle.left;
        const blkEnd = handle.right;
        const loop = newState(atn, rule, plus2, {
          type: exports2.ATN_PLUS_LOOP_BACK
        });
        defineDecisionState(atn, loop);
        const end = newState(atn, rule, plus2, {
          type: exports2.ATN_LOOP_END
        });
        blkStart.loopback = loop;
        end.loopback = loop;
        atn.decisionMap[buildATNKey(rule, sep2 ? "RepetitionMandatoryWithSeparator" : "RepetitionMandatory", plus2.idx)] = loop;
        epsilon(blkEnd, loop);
        if (sep2 === void 0) {
          epsilon(loop, blkStart);
          epsilon(loop, end);
        } else {
          epsilon(loop, end);
          epsilon(loop, sep2.left);
          epsilon(sep2.right, blkStart);
        }
        return {
          left: blkStart,
          right: end
        };
      }
      function star(atn, rule, star2, handle, sep2) {
        const start = handle.left;
        const end = handle.right;
        const entry = newState(atn, rule, star2, {
          type: exports2.ATN_STAR_LOOP_ENTRY
        });
        defineDecisionState(atn, entry);
        const loopEnd = newState(atn, rule, star2, {
          type: exports2.ATN_LOOP_END
        });
        const loop = newState(atn, rule, star2, {
          type: exports2.ATN_STAR_LOOP_BACK
        });
        entry.loopback = loop;
        loopEnd.loopback = loop;
        epsilon(entry, start);
        epsilon(entry, loopEnd);
        epsilon(end, loop);
        if (sep2 !== void 0) {
          epsilon(loop, loopEnd);
          epsilon(loop, sep2.left);
          epsilon(sep2.right, start);
        } else {
          epsilon(loop, entry);
        }
        atn.decisionMap[buildATNKey(rule, sep2 ? "RepetitionWithSeparator" : "Repetition", star2.idx)] = entry;
        return {
          left: entry,
          right: loopEnd
        };
      }
      function optional(atn, rule, optional2, handle) {
        const start = handle.left;
        const end = handle.right;
        epsilon(start, end);
        atn.decisionMap[buildATNKey(rule, "Option", optional2.idx)] = start;
        return handle;
      }
      function defineDecisionState(atn, state) {
        atn.decisionStates.push(state);
        state.decision = atn.decisionStates.length - 1;
        return state.decision;
      }
      function makeAlts(atn, rule, start, production, ...alts) {
        const end = newState(atn, rule, production, {
          type: exports2.ATN_BLOCK_END,
          start
        });
        start.end = end;
        for (const alt of alts) {
          if (alt !== void 0) {
            epsilon(start, alt.left);
            epsilon(alt.right, end);
          } else {
            epsilon(start, end);
          }
        }
        const handle = {
          left: start,
          right: end
        };
        atn.decisionMap[buildATNKey(rule, getProdType(production), production.idx)] = start;
        return handle;
      }
      function getProdType(production) {
        if (production instanceof chevrotain_1.Alternation) {
          return "Alternation";
        } else if (production instanceof chevrotain_1.Option) {
          return "Option";
        } else if (production instanceof chevrotain_1.Repetition) {
          return "Repetition";
        } else if (production instanceof chevrotain_1.RepetitionWithSeparator) {
          return "RepetitionWithSeparator";
        } else if (production instanceof chevrotain_1.RepetitionMandatory) {
          return "RepetitionMandatory";
        } else if (production instanceof chevrotain_1.RepetitionMandatoryWithSeparator) {
          return "RepetitionMandatoryWithSeparator";
        } else {
          throw new Error("Invalid production type encountered");
        }
      }
      function makeBlock(atn, alts) {
        const altsLength = alts.length;
        for (let i = 0; i < altsLength - 1; i++) {
          const handle = alts[i];
          let transition;
          if (handle.left.transitions.length === 1) {
            transition = handle.left.transitions[0];
          }
          const isRuleTransition = transition instanceof RuleTransition;
          const ruleTransition = transition;
          const next = alts[i + 1].left;
          if (handle.left.type === exports2.ATN_BASIC && handle.right.type === exports2.ATN_BASIC && transition !== void 0 && (isRuleTransition && ruleTransition.followState === handle.right || transition.target === handle.right)) {
            if (isRuleTransition) {
              ruleTransition.followState = next;
            } else {
              transition.target = next;
            }
            removeState(atn, handle.right);
          } else {
            epsilon(handle.right, next);
          }
        }
        const first = alts[0];
        const last = alts[altsLength - 1];
        return {
          left: first.left,
          right: last.right
        };
      }
      function tokenRef(atn, rule, tokenType, production) {
        const left = newState(atn, rule, production, {
          type: exports2.ATN_BASIC
        });
        const right = newState(atn, rule, production, {
          type: exports2.ATN_BASIC
        });
        addTransition(left, new AtomTransition(right, tokenType));
        return {
          left,
          right
        };
      }
      function ruleRef(atn, currentRule, nonTerminal) {
        const rule = nonTerminal.referencedRule;
        const start = atn.ruleToStartState.get(rule);
        const left = newState(atn, currentRule, nonTerminal, {
          type: exports2.ATN_BASIC
        });
        const right = newState(atn, currentRule, nonTerminal, {
          type: exports2.ATN_BASIC
        });
        const call = new RuleTransition(start, rule, right);
        addTransition(left, call);
        return {
          left,
          right
        };
      }
      function buildRuleHandle(atn, rule, block2) {
        const start = atn.ruleToStartState.get(rule);
        epsilon(start, block2.left);
        const stop = atn.ruleToStopState.get(rule);
        epsilon(block2.right, stop);
        const handle = {
          left: start,
          right: stop
        };
        return handle;
      }
      function epsilon(a, b) {
        const transition = new EpsilonTransition(b);
        addTransition(a, transition);
      }
      function newState(atn, rule, production, partial) {
        const t = Object.assign({
          atn,
          production,
          epsilonOnlyTransitions: false,
          rule,
          transitions: [],
          nextTokenWithinRule: [],
          stateNumber: atn.states.length
        }, partial);
        atn.states.push(t);
        return t;
      }
      function addTransition(state, transition) {
        if (state.transitions.length === 0) {
          state.epsilonOnlyTransitions = transition.isEpsilon();
        }
        state.transitions.push(transition);
      }
      function removeState(atn, state) {
        atn.states.splice(atn.states.indexOf(state), 1);
      }
    }
  });

  // node_modules/chevrotain-allstar/lib/dfa.js
  var require_dfa = __commonJS({
    "node_modules/chevrotain-allstar/lib/dfa.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getATNConfigKey = exports2.ATNConfigSet = exports2.DFA_ERROR = void 0;
      var map_1 = __importDefault(require_map());
      exports2.DFA_ERROR = {};
      var ATNConfigSet = class {
        constructor() {
          this.map = {};
          this.configs = [];
        }
        get size() {
          return this.configs.length;
        }
        finalize() {
          this.map = {};
        }
        add(config) {
          const key = getATNConfigKey(config);
          if (!(key in this.map)) {
            this.map[key] = this.configs.length;
            this.configs.push(config);
          }
        }
        get elements() {
          return this.configs;
        }
        get alts() {
          return (0, map_1.default)(this.configs, (e) => e.alt);
        }
        get key() {
          let value = "";
          for (const k in this.map) {
            value += k + ":";
          }
          return value;
        }
      };
      exports2.ATNConfigSet = ATNConfigSet;
      function getATNConfigKey(config, alt = true) {
        return `${alt ? `a${config.alt}` : ""}s${config.state.stateNumber}:${config.stack.map((e) => e.stateNumber.toString()).join("_")}`;
      }
      exports2.getATNConfigKey = getATNConfigKey;
    }
  });

  // node_modules/lodash/_baseExtremum.js
  var require_baseExtremum = __commonJS({
    "node_modules/lodash/_baseExtremum.js"(exports2, module2) {
      var isSymbol = require_isSymbol();
      function baseExtremum(array, iteratee, comparator) {
        var index = -1, length = array.length;
        while (++index < length) {
          var value = array[index], current = iteratee(value);
          if (current != null && (computed === void 0 ? current === current && !isSymbol(current) : comparator(current, computed))) {
            var computed = current, result = value;
          }
        }
        return result;
      }
      module2.exports = baseExtremum;
    }
  });

  // node_modules/lodash/_baseLt.js
  var require_baseLt = __commonJS({
    "node_modules/lodash/_baseLt.js"(exports2, module2) {
      function baseLt(value, other) {
        return value < other;
      }
      module2.exports = baseLt;
    }
  });

  // node_modules/lodash/min.js
  var require_min = __commonJS({
    "node_modules/lodash/min.js"(exports2, module2) {
      var baseExtremum = require_baseExtremum();
      var baseLt = require_baseLt();
      var identity = require_identity();
      function min(array) {
        return array && array.length ? baseExtremum(array, identity, baseLt) : void 0;
      }
      module2.exports = min;
    }
  });

  // node_modules/lodash/uniqBy.js
  var require_uniqBy = __commonJS({
    "node_modules/lodash/uniqBy.js"(exports2, module2) {
      var baseIteratee = require_baseIteratee();
      var baseUniq = require_baseUniq();
      function uniqBy(array, iteratee) {
        return array && array.length ? baseUniq(array, baseIteratee(iteratee, 2)) : [];
      }
      module2.exports = uniqBy;
    }
  });

  // node_modules/chevrotain-allstar/lib/all-star-lookahead.js
  var require_all_star_lookahead = __commonJS({
    "node_modules/chevrotain-allstar/lib/all-star-lookahead.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LLStarLookaheadStrategy = void 0;
      var chevrotain_1 = require_api7();
      var atn_1 = require_atn();
      var dfa_1 = require_dfa();
      var min_1 = __importDefault(require_min());
      var flatMap_1 = __importDefault(require_flatMap());
      var uniqBy_1 = __importDefault(require_uniqBy());
      var map_1 = __importDefault(require_map());
      var flatten_1 = __importDefault(require_flatten());
      var forEach_1 = __importDefault(require_forEach());
      var isEmpty_1 = __importDefault(require_isEmpty());
      var reduce_1 = __importDefault(require_reduce());
      function createDFACache(startState, decision) {
        const map = {};
        return (predicateSet) => {
          const key = predicateSet.toString();
          let existing = map[key];
          if (existing !== void 0) {
            return existing;
          } else {
            existing = {
              atnStartState: startState,
              decision,
              states: {}
            };
            map[key] = existing;
            return existing;
          }
        };
      }
      var PredicateSet = class {
        constructor() {
          this.predicates = [];
        }
        is(index) {
          return index >= this.predicates.length || this.predicates[index];
        }
        set(index, value) {
          this.predicates[index] = value;
        }
        toString() {
          let value = "";
          const size = this.predicates.length;
          for (let i = 0; i < size; i++) {
            value += this.predicates[i] === true ? "1" : "0";
          }
          return value;
        }
      };
      var EMPTY_PREDICATES = new PredicateSet();
      var LLStarLookaheadStrategy = class extends chevrotain_1.LLkLookaheadStrategy {
        constructor(options) {
          var _a4;
          super();
          this.logging = (_a4 = options === null || options === void 0 ? void 0 : options.logging) !== null && _a4 !== void 0 ? _a4 : (message) => console.log(message);
        }
        initialize(options) {
          this.atn = (0, atn_1.createATN)(options.rules);
          this.dfas = initATNSimulator(this.atn);
        }
        validateAmbiguousAlternationAlternatives() {
          return [];
        }
        validateEmptyOrAlternatives() {
          return [];
        }
        buildLookaheadForAlternation(options) {
          const { prodOccurrence, rule, hasPredicates, dynamicTokensEnabled } = options;
          const dfas = this.dfas;
          const logging = this.logging;
          const key = (0, atn_1.buildATNKey)(rule, "Alternation", prodOccurrence);
          const decisionState = this.atn.decisionMap[key];
          const decisionIndex = decisionState.decision;
          const partialAlts = (0, map_1.default)((0, chevrotain_1.getLookaheadPaths)({
            maxLookahead: 1,
            occurrence: prodOccurrence,
            prodType: "Alternation",
            rule
          }), (currAlt) => (0, map_1.default)(currAlt, (path) => path[0]));
          if (isLL1Sequence(partialAlts, false) && !dynamicTokensEnabled) {
            const choiceToAlt = (0, reduce_1.default)(partialAlts, (result, currAlt, idx) => {
              (0, forEach_1.default)(currAlt, (currTokType) => {
                if (currTokType) {
                  result[currTokType.tokenTypeIdx] = idx;
                  (0, forEach_1.default)(currTokType.categoryMatches, (currExtendingType) => {
                    result[currExtendingType] = idx;
                  });
                }
              });
              return result;
            }, {});
            if (hasPredicates) {
              return function(orAlts) {
                var _a4;
                const nextToken = this.LA(1);
                const prediction = choiceToAlt[nextToken.tokenTypeIdx];
                if (orAlts !== void 0 && prediction !== void 0) {
                  const gate = (_a4 = orAlts[prediction]) === null || _a4 === void 0 ? void 0 : _a4.GATE;
                  if (gate !== void 0 && gate.call(this) === false) {
                    return void 0;
                  }
                }
                return prediction;
              };
            } else {
              return function() {
                const nextToken = this.LA(1);
                return choiceToAlt[nextToken.tokenTypeIdx];
              };
            }
          } else if (hasPredicates) {
            return function(orAlts) {
              const predicates = new PredicateSet();
              const length = orAlts === void 0 ? 0 : orAlts.length;
              for (let i = 0; i < length; i++) {
                const gate = orAlts === null || orAlts === void 0 ? void 0 : orAlts[i].GATE;
                predicates.set(i, gate === void 0 || gate.call(this));
              }
              const result = adaptivePredict.call(this, dfas, decisionIndex, predicates, logging);
              return typeof result === "number" ? result : void 0;
            };
          } else {
            return function() {
              const result = adaptivePredict.call(this, dfas, decisionIndex, EMPTY_PREDICATES, logging);
              return typeof result === "number" ? result : void 0;
            };
          }
        }
        buildLookaheadForOptional(options) {
          const { prodOccurrence, rule, prodType, dynamicTokensEnabled } = options;
          const dfas = this.dfas;
          const logging = this.logging;
          const key = (0, atn_1.buildATNKey)(rule, prodType, prodOccurrence);
          const decisionState = this.atn.decisionMap[key];
          const decisionIndex = decisionState.decision;
          const alts = (0, map_1.default)((0, chevrotain_1.getLookaheadPaths)({
            maxLookahead: 1,
            occurrence: prodOccurrence,
            prodType,
            rule
          }), (e) => {
            return (0, map_1.default)(e, (g) => g[0]);
          });
          if (isLL1Sequence(alts) && alts[0][0] && !dynamicTokensEnabled) {
            const alt = alts[0];
            const singleTokensTypes = (0, flatten_1.default)(alt);
            if (singleTokensTypes.length === 1 && (0, isEmpty_1.default)(singleTokensTypes[0].categoryMatches)) {
              const expectedTokenType = singleTokensTypes[0];
              const expectedTokenUniqueKey = expectedTokenType.tokenTypeIdx;
              return function() {
                return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey;
              };
            } else {
              const choiceToAlt = (0, reduce_1.default)(singleTokensTypes, (result, currTokType) => {
                if (currTokType !== void 0) {
                  result[currTokType.tokenTypeIdx] = true;
                  (0, forEach_1.default)(currTokType.categoryMatches, (currExtendingType) => {
                    result[currExtendingType] = true;
                  });
                }
                return result;
              }, {});
              return function() {
                const nextToken = this.LA(1);
                return choiceToAlt[nextToken.tokenTypeIdx] === true;
              };
            }
          }
          return function() {
            const result = adaptivePredict.call(this, dfas, decisionIndex, EMPTY_PREDICATES, logging);
            return typeof result === "object" ? false : result === 0;
          };
        }
      };
      exports2.LLStarLookaheadStrategy = LLStarLookaheadStrategy;
      function isLL1Sequence(sequences, allowEmpty = true) {
        const fullSet = /* @__PURE__ */ new Set();
        for (const alt of sequences) {
          const altSet = /* @__PURE__ */ new Set();
          for (const tokType of alt) {
            if (tokType === void 0) {
              if (allowEmpty) {
                break;
              } else {
                return false;
              }
            }
            const indices = [tokType.tokenTypeIdx].concat(tokType.categoryMatches);
            for (const index of indices) {
              if (fullSet.has(index)) {
                if (!altSet.has(index)) {
                  return false;
                }
              } else {
                fullSet.add(index);
                altSet.add(index);
              }
            }
          }
        }
        return true;
      }
      function initATNSimulator(atn) {
        const decisionLength = atn.decisionStates.length;
        const decisionToDFA = Array(decisionLength);
        for (let i = 0; i < decisionLength; i++) {
          decisionToDFA[i] = createDFACache(atn.decisionStates[i], i);
        }
        return decisionToDFA;
      }
      function adaptivePredict(dfaCaches, decision, predicateSet, logging) {
        const dfa = dfaCaches[decision](predicateSet);
        let start = dfa.start;
        if (start === void 0) {
          const closure2 = computeStartState(dfa.atnStartState);
          start = addDFAState(dfa, newDFAState(closure2));
          dfa.start = start;
        }
        const alt = performLookahead.apply(this, [dfa, start, predicateSet, logging]);
        return alt;
      }
      function performLookahead(dfa, s0, predicateSet, logging) {
        let previousD = s0;
        let i = 1;
        const path = [];
        let t = this.LA(i++);
        while (true) {
          let d = getExistingTargetState(previousD, t);
          if (d === void 0) {
            d = computeLookaheadTarget.apply(this, [dfa, previousD, t, i, predicateSet, logging]);
          }
          if (d === dfa_1.DFA_ERROR) {
            return buildAdaptivePredictError(path, previousD, t);
          }
          if (d.isAcceptState === true) {
            return d.prediction;
          }
          previousD = d;
          path.push(t);
          t = this.LA(i++);
        }
      }
      function computeLookaheadTarget(dfa, previousD, token, lookahead, predicateSet, logging) {
        const reach = computeReachSet(previousD.configs, token, predicateSet);
        if (reach.size === 0) {
          addDFAEdge(dfa, previousD, token, dfa_1.DFA_ERROR);
          return dfa_1.DFA_ERROR;
        }
        let newState = newDFAState(reach);
        const predictedAlt = getUniqueAlt(reach, predicateSet);
        if (predictedAlt !== void 0) {
          newState.isAcceptState = true;
          newState.prediction = predictedAlt;
          newState.configs.uniqueAlt = predictedAlt;
        } else if (hasConflictTerminatingPrediction(reach)) {
          const prediction = (0, min_1.default)(reach.alts);
          newState.isAcceptState = true;
          newState.prediction = prediction;
          newState.configs.uniqueAlt = prediction;
          reportLookaheadAmbiguity.apply(this, [dfa, lookahead, reach.alts, logging]);
        }
        newState = addDFAEdge(dfa, previousD, token, newState);
        return newState;
      }
      function reportLookaheadAmbiguity(dfa, lookahead, ambiguityIndices, logging) {
        const prefixPath = [];
        for (let i = 1; i <= lookahead; i++) {
          prefixPath.push(this.LA(i).tokenType);
        }
        const atnState = dfa.atnStartState;
        const topLevelRule = atnState.rule;
        const production = atnState.production;
        const message = buildAmbiguityError({
          topLevelRule,
          ambiguityIndices,
          production,
          prefixPath
        });
        logging(message);
      }
      function buildAmbiguityError(options) {
        const pathMsg = (0, map_1.default)(options.prefixPath, (currtok) => (0, chevrotain_1.tokenLabel)(currtok)).join(", ");
        const occurrence = options.production.idx === 0 ? "" : options.production.idx;
        let currMessage = `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(", ")}> in <${getProductionDslName(options.production)}${occurrence}> inside <${options.topLevelRule.name}> Rule,
<${pathMsg}> may appears as a prefix path in all these alternatives.
`;
        currMessage = currMessage + `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES
For Further details.`;
        return currMessage;
      }
      function getProductionDslName(prod) {
        if (prod instanceof chevrotain_1.NonTerminal) {
          return "SUBRULE";
        } else if (prod instanceof chevrotain_1.Option) {
          return "OPTION";
        } else if (prod instanceof chevrotain_1.Alternation) {
          return "OR";
        } else if (prod instanceof chevrotain_1.RepetitionMandatory) {
          return "AT_LEAST_ONE";
        } else if (prod instanceof chevrotain_1.RepetitionMandatoryWithSeparator) {
          return "AT_LEAST_ONE_SEP";
        } else if (prod instanceof chevrotain_1.RepetitionWithSeparator) {
          return "MANY_SEP";
        } else if (prod instanceof chevrotain_1.Repetition) {
          return "MANY";
        } else if (prod instanceof chevrotain_1.Terminal) {
          return "CONSUME";
        } else {
          throw Error("non exhaustive match");
        }
      }
      function buildAdaptivePredictError(path, previous, current) {
        const nextTransitions = (0, flatMap_1.default)(previous.configs.elements, (e) => e.state.transitions);
        const nextTokenTypes = (0, uniqBy_1.default)(nextTransitions.filter((e) => e instanceof atn_1.AtomTransition).map((e) => e.tokenType), (e) => e.tokenTypeIdx);
        return {
          actualToken: current,
          possibleTokenTypes: nextTokenTypes,
          tokenPath: path
        };
      }
      function getExistingTargetState(state, token) {
        return state.edges[token.tokenTypeIdx];
      }
      function computeReachSet(configs, token, predicateSet) {
        const intermediate = new dfa_1.ATNConfigSet();
        const skippedStopStates = [];
        for (const c of configs.elements) {
          if (predicateSet.is(c.alt) === false) {
            continue;
          }
          if (c.state.type === atn_1.ATN_RULE_STOP) {
            skippedStopStates.push(c);
            continue;
          }
          const transitionLength = c.state.transitions.length;
          for (let i = 0; i < transitionLength; i++) {
            const transition = c.state.transitions[i];
            const target = getReachableTarget(transition, token);
            if (target !== void 0) {
              intermediate.add({
                state: target,
                alt: c.alt,
                stack: c.stack
              });
            }
          }
        }
        let reach;
        if (skippedStopStates.length === 0 && intermediate.size === 1) {
          reach = intermediate;
        }
        if (reach === void 0) {
          reach = new dfa_1.ATNConfigSet();
          for (const c of intermediate.elements) {
            closure(c, reach);
          }
        }
        if (skippedStopStates.length > 0 && !hasConfigInRuleStopState(reach)) {
          for (const c of skippedStopStates) {
            reach.add(c);
          }
        }
        return reach;
      }
      function getReachableTarget(transition, token) {
        if (transition instanceof atn_1.AtomTransition && (0, chevrotain_1.tokenMatcher)(token, transition.tokenType)) {
          return transition.target;
        }
        return void 0;
      }
      function getUniqueAlt(configs, predicateSet) {
        let alt;
        for (const c of configs.elements) {
          if (predicateSet.is(c.alt) === true) {
            if (alt === void 0) {
              alt = c.alt;
            } else if (alt !== c.alt) {
              return void 0;
            }
          }
        }
        return alt;
      }
      function newDFAState(closure2) {
        return {
          configs: closure2,
          edges: {},
          isAcceptState: false,
          prediction: -1
        };
      }
      function addDFAEdge(dfa, from, token, to) {
        to = addDFAState(dfa, to);
        from.edges[token.tokenTypeIdx] = to;
        return to;
      }
      function addDFAState(dfa, state) {
        if (state === dfa_1.DFA_ERROR) {
          return state;
        }
        const mapKey = state.configs.key;
        const existing = dfa.states[mapKey];
        if (existing !== void 0) {
          return existing;
        }
        state.configs.finalize();
        dfa.states[mapKey] = state;
        return state;
      }
      function computeStartState(atnState) {
        const configs = new dfa_1.ATNConfigSet();
        const numberOfTransitions = atnState.transitions.length;
        for (let i = 0; i < numberOfTransitions; i++) {
          const target = atnState.transitions[i].target;
          const config = {
            state: target,
            alt: i,
            stack: []
          };
          closure(config, configs);
        }
        return configs;
      }
      function closure(config, configs) {
        const p = config.state;
        if (p.type === atn_1.ATN_RULE_STOP) {
          if (config.stack.length > 0) {
            const atnStack = [...config.stack];
            const followState = atnStack.pop();
            const followConfig = {
              state: followState,
              alt: config.alt,
              stack: atnStack
            };
            closure(followConfig, configs);
          } else {
            configs.add(config);
          }
          return;
        }
        if (!p.epsilonOnlyTransitions) {
          configs.add(config);
        }
        const transitionLength = p.transitions.length;
        for (let i = 0; i < transitionLength; i++) {
          const transition = p.transitions[i];
          const c = getEpsilonTarget(config, transition);
          if (c !== void 0) {
            closure(c, configs);
          }
        }
      }
      function getEpsilonTarget(config, transition) {
        if (transition instanceof atn_1.EpsilonTransition) {
          return {
            state: transition.target,
            alt: config.alt,
            stack: config.stack
          };
        } else if (transition instanceof atn_1.RuleTransition) {
          const stack = [...config.stack, transition.followState];
          return {
            state: transition.target,
            alt: config.alt,
            stack
          };
        }
        return void 0;
      }
      function hasConfigInRuleStopState(configs) {
        for (const c of configs.elements) {
          if (c.state.type === atn_1.ATN_RULE_STOP) {
            return true;
          }
        }
        return false;
      }
      function allConfigsInRuleStopStates(configs) {
        for (const c of configs.elements) {
          if (c.state.type !== atn_1.ATN_RULE_STOP) {
            return false;
          }
        }
        return true;
      }
      function hasConflictTerminatingPrediction(configs) {
        if (allConfigsInRuleStopStates(configs)) {
          return true;
        }
        const altSets = getConflictingAltSets(configs.elements);
        const heuristic = hasConflictingAltSet(altSets) && !hasStateAssociatedWithOneAlt(altSets);
        return heuristic;
      }
      function getConflictingAltSets(configs) {
        const configToAlts = /* @__PURE__ */ new Map();
        for (const c of configs) {
          const key = (0, dfa_1.getATNConfigKey)(c, false);
          let alts = configToAlts.get(key);
          if (alts === void 0) {
            alts = {};
            configToAlts.set(key, alts);
          }
          alts[c.alt] = true;
        }
        return configToAlts;
      }
      function hasConflictingAltSet(altSets) {
        for (const value of Array.from(altSets.values())) {
          if (Object.keys(value).length > 1) {
            return true;
          }
        }
        return false;
      }
      function hasStateAssociatedWithOneAlt(altSets) {
        for (const value of Array.from(altSets.values())) {
          if (Object.keys(value).length === 1) {
            return true;
          }
        }
        return false;
      }
    }
  });

  // node_modules/chevrotain-allstar/lib/index.js
  var require_lib = __commonJS({
    "node_modules/chevrotain-allstar/lib/index.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LLStarLookaheadStrategy = void 0;
      var all_star_lookahead_1 = require_all_star_lookahead();
      Object.defineProperty(exports2, "LLStarLookaheadStrategy", { enumerable: true, get: function() {
        return all_star_lookahead_1.LLStarLookaheadStrategy;
      } });
    }
  });

  // node_modules/langium/lib/parser/cst-node-builder.js
  var require_cst_node_builder = __commonJS({
    "node_modules/langium/lib/parser/cst-node-builder.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.RootCstNodeImpl = exports2.CompositeCstNodeImpl = exports2.LeafCstNodeImpl = exports2.AbstractCstNode = exports2.CstNodeBuilder = void 0;
      var vscode_languageserver_types_1 = require_main2();
      var syntax_tree_1 = require_syntax_tree();
      var cst_util_1 = require_cst_util();
      var CstNodeBuilder = class {
        constructor() {
          this.nodeStack = [];
        }
        get current() {
          return this.nodeStack[this.nodeStack.length - 1];
        }
        buildRootNode(input) {
          this.rootNode = new RootCstNodeImpl(input);
          this.nodeStack = [this.rootNode];
          return this.rootNode;
        }
        buildCompositeNode(feature) {
          const compositeNode = new CompositeCstNodeImpl();
          compositeNode.feature = feature;
          compositeNode.root = this.rootNode;
          this.current.children.push(compositeNode);
          this.nodeStack.push(compositeNode);
          return compositeNode;
        }
        buildLeafNode(token, feature) {
          const leafNode = new LeafCstNodeImpl(token.startOffset, token.image.length, (0, cst_util_1.tokenToRange)(token), token.tokenType, false);
          leafNode.feature = feature;
          leafNode.root = this.rootNode;
          this.current.children.push(leafNode);
          return leafNode;
        }
        removeNode(node) {
          const parent = node.parent;
          if (parent) {
            const index = parent.children.indexOf(node);
            if (index >= 0) {
              parent.children.splice(index, 1);
            }
          }
        }
        construct(item) {
          const current = this.current;
          if (typeof item.$type === "string") {
            this.current.element = item;
          }
          item.$cstNode = current;
          const node = this.nodeStack.pop();
          if ((node === null || node === void 0 ? void 0 : node.children.length) === 0) {
            this.removeNode(node);
          }
        }
        addHiddenTokens(hiddenTokens) {
          for (const token of hiddenTokens) {
            const hiddenNode = new LeafCstNodeImpl(token.startOffset, token.image.length, (0, cst_util_1.tokenToRange)(token), token.tokenType, true);
            hiddenNode.root = this.rootNode;
            this.addHiddenToken(this.rootNode, hiddenNode);
          }
        }
        addHiddenToken(node, token) {
          const { offset: tokenStart, end: tokenEnd } = token;
          for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i];
            const { offset: childStart, end: childEnd } = child;
            if ((0, syntax_tree_1.isCompositeCstNode)(child) && tokenStart > childStart && tokenEnd < childEnd) {
              this.addHiddenToken(child, token);
              return;
            } else if (tokenEnd <= childStart) {
              node.children.splice(i, 0, token);
              return;
            }
          }
          node.children.push(token);
        }
      };
      exports2.CstNodeBuilder = CstNodeBuilder;
      var AbstractCstNode = class {
        get hidden() {
          return false;
        }
        get element() {
          var _a4, _b2;
          const node = typeof ((_a4 = this._element) === null || _a4 === void 0 ? void 0 : _a4.$type) === "string" ? this._element : (_b2 = this.parent) === null || _b2 === void 0 ? void 0 : _b2.element;
          if (!node) {
            throw new Error("This node has no associated AST element");
          }
          return node;
        }
        set element(value) {
          this._element = value;
        }
        get text() {
          return this.root.fullText.substring(this.offset, this.end);
        }
      };
      exports2.AbstractCstNode = AbstractCstNode;
      var LeafCstNodeImpl = class extends AbstractCstNode {
        get offset() {
          return this._offset;
        }
        get length() {
          return this._length;
        }
        get end() {
          return this._offset + this._length;
        }
        get hidden() {
          return this._hidden;
        }
        get tokenType() {
          return this._tokenType;
        }
        get range() {
          return this._range;
        }
        constructor(offset, length, range, tokenType, hidden = false) {
          super();
          this._hidden = hidden;
          this._offset = offset;
          this._tokenType = tokenType;
          this._length = length;
          this._range = range;
        }
      };
      exports2.LeafCstNodeImpl = LeafCstNodeImpl;
      var CompositeCstNodeImpl = class extends AbstractCstNode {
        constructor() {
          super(...arguments);
          this.children = new CstNodeContainer(this);
        }
        get offset() {
          var _a4, _b2;
          return (_b2 = (_a4 = this.firstNonHiddenNode) === null || _a4 === void 0 ? void 0 : _a4.offset) !== null && _b2 !== void 0 ? _b2 : 0;
        }
        get length() {
          return this.end - this.offset;
        }
        get end() {
          var _a4, _b2;
          return (_b2 = (_a4 = this.lastNonHiddenNode) === null || _a4 === void 0 ? void 0 : _a4.end) !== null && _b2 !== void 0 ? _b2 : 0;
        }
        get range() {
          const firstNode = this.firstNonHiddenNode;
          const lastNode = this.lastNonHiddenNode;
          if (firstNode && lastNode) {
            if (this._rangeCache === void 0) {
              const { range: firstRange } = firstNode;
              const { range: lastRange } = lastNode;
              this._rangeCache = { start: firstRange.start, end: lastRange.end.line < firstRange.start.line ? firstRange.start : lastRange.end };
            }
            return this._rangeCache;
          } else {
            return { start: vscode_languageserver_types_1.Position.create(0, 0), end: vscode_languageserver_types_1.Position.create(0, 0) };
          }
        }
        get firstNonHiddenNode() {
          for (const child of this.children) {
            if (!child.hidden) {
              return child;
            }
          }
          return this.children[0];
        }
        get lastNonHiddenNode() {
          for (let i = this.children.length - 1; i >= 0; i--) {
            const child = this.children[i];
            if (!child.hidden) {
              return child;
            }
          }
          return this.children[this.children.length - 1];
        }
      };
      exports2.CompositeCstNodeImpl = CompositeCstNodeImpl;
      var CstNodeContainer = class extends Array {
        constructor(parent) {
          super();
          this.parent = parent;
          Object.setPrototypeOf(this, CstNodeContainer.prototype);
        }
        push(...items) {
          this.addParents(items);
          return super.push(...items);
        }
        unshift(...items) {
          this.addParents(items);
          return super.unshift(...items);
        }
        splice(start, count, ...items) {
          this.addParents(items);
          return super.splice(start, count, ...items);
        }
        addParents(items) {
          for (const item of items) {
            item.parent = this.parent;
          }
        }
      };
      var RootCstNodeImpl = class extends CompositeCstNodeImpl {
        get text() {
          return this._text.substring(this.offset, this.end);
        }
        get fullText() {
          return this._text;
        }
        constructor(input) {
          super();
          this._text = "";
          this._text = input !== null && input !== void 0 ? input : "";
        }
      };
      exports2.RootCstNodeImpl = RootCstNodeImpl;
    }
  });

  // node_modules/langium/lib/parser/langium-parser.js
  var require_langium_parser = __commonJS({
    "node_modules/langium/lib/parser/langium-parser.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LangiumCompletionParser = exports2.LangiumParserErrorMessageProvider = exports2.LangiumParser = exports2.AbstractLangiumParser = exports2.DatatypeSymbol = void 0;
      var chevrotain_1 = require_api7();
      var chevrotain_allstar_1 = require_lib();
      var ast_1 = require_ast();
      var internal_grammar_util_1 = require_internal_grammar_util();
      var ast_util_1 = require_ast_util();
      var cst_node_builder_1 = require_cst_node_builder();
      exports2.DatatypeSymbol = Symbol("Datatype");
      function isDataTypeNode(node) {
        return node.$type === exports2.DatatypeSymbol;
      }
      var ruleSuffix = "\u200B";
      var withRuleSuffix = (name) => name.endsWith(ruleSuffix) ? name : name + ruleSuffix;
      var AbstractLangiumParser = class {
        constructor(services) {
          this._unorderedGroups = /* @__PURE__ */ new Map();
          this.lexer = services.parser.Lexer;
          const tokens = this.lexer.definition;
          this.wrapper = new ChevrotainWrapper(tokens, services.parser.ParserConfig);
        }
        alternatives(idx, choices) {
          this.wrapper.wrapOr(idx, choices);
        }
        optional(idx, callback) {
          this.wrapper.wrapOption(idx, callback);
        }
        many(idx, callback) {
          this.wrapper.wrapMany(idx, callback);
        }
        atLeastOne(idx, callback) {
          this.wrapper.wrapAtLeastOne(idx, callback);
        }
        isRecording() {
          return this.wrapper.IS_RECORDING;
        }
        get unorderedGroups() {
          return this._unorderedGroups;
        }
        getRuleStack() {
          return this.wrapper.RULE_STACK;
        }
        finalize() {
          this.wrapper.wrapSelfAnalysis();
        }
      };
      exports2.AbstractLangiumParser = AbstractLangiumParser;
      var LangiumParser = class extends AbstractLangiumParser {
        get current() {
          return this.stack[this.stack.length - 1];
        }
        constructor(services) {
          super(services);
          this.nodeBuilder = new cst_node_builder_1.CstNodeBuilder();
          this.stack = [];
          this.assignmentMap = /* @__PURE__ */ new Map();
          this.linker = services.references.Linker;
          this.converter = services.parser.ValueConverter;
          this.astReflection = services.shared.AstReflection;
        }
        rule(rule, impl) {
          const type = rule.fragment ? void 0 : (0, internal_grammar_util_1.isDataTypeRule)(rule) ? exports2.DatatypeSymbol : (0, internal_grammar_util_1.getTypeName)(rule);
          const ruleMethod = this.wrapper.DEFINE_RULE(withRuleSuffix(rule.name), this.startImplementation(type, impl).bind(this));
          if (rule.entry) {
            this.mainRule = ruleMethod;
          }
          return ruleMethod;
        }
        parse(input) {
          this.nodeBuilder.buildRootNode(input);
          const lexerResult = this.lexer.tokenize(input);
          this.wrapper.input = lexerResult.tokens;
          const result = this.mainRule.call(this.wrapper, {});
          this.nodeBuilder.addHiddenTokens(lexerResult.hidden);
          this.unorderedGroups.clear();
          return {
            value: result,
            lexerErrors: lexerResult.errors,
            parserErrors: this.wrapper.errors
          };
        }
        startImplementation($type, implementation) {
          return (args) => {
            if (!this.isRecording()) {
              const node = { $type };
              this.stack.push(node);
              if ($type === exports2.DatatypeSymbol) {
                node.value = "";
              }
            }
            let result;
            try {
              result = implementation(args);
            } catch (err) {
              result = void 0;
            }
            if (!this.isRecording() && result === void 0) {
              result = this.construct();
            }
            return result;
          };
        }
        consume(idx, tokenType, feature) {
          const token = this.wrapper.wrapConsume(idx, tokenType);
          if (!this.isRecording() && !token.isInsertedInRecovery) {
            const leafNode = this.nodeBuilder.buildLeafNode(token, feature);
            const { assignment, isCrossRef } = this.getAssignment(feature);
            const current = this.current;
            if (assignment) {
              const convertedValue = (0, ast_1.isKeyword)(feature) ? token.image : this.converter.convert(token.image, leafNode);
              this.assign(assignment.operator, assignment.feature, convertedValue, leafNode, isCrossRef);
            } else if (isDataTypeNode(current)) {
              let text = token.image;
              if (!(0, ast_1.isKeyword)(feature)) {
                text = this.converter.convert(text, leafNode).toString();
              }
              current.value += text;
            }
          }
        }
        subrule(idx, rule, feature, args) {
          let cstNode;
          if (!this.isRecording()) {
            cstNode = this.nodeBuilder.buildCompositeNode(feature);
          }
          const subruleResult = this.wrapper.wrapSubrule(idx, rule, args);
          if (!this.isRecording() && cstNode && cstNode.length > 0) {
            this.performSubruleAssignment(subruleResult, feature, cstNode);
          }
        }
        performSubruleAssignment(result, feature, cstNode) {
          const { assignment, isCrossRef } = this.getAssignment(feature);
          if (assignment) {
            this.assign(assignment.operator, assignment.feature, result, cstNode, isCrossRef);
          } else if (!assignment) {
            const current = this.current;
            if (isDataTypeNode(current)) {
              current.value += result.toString();
            } else {
              const resultKind = result.$type;
              const object = this.assignWithoutOverride(result, current);
              if (resultKind) {
                object.$type = resultKind;
              }
              const newItem = object;
              this.stack.pop();
              this.stack.push(newItem);
            }
          }
        }
        action($type, action) {
          if (!this.isRecording()) {
            let last = this.current;
            if (!last.$cstNode && action.feature && action.operator) {
              last = this.construct(false);
              const feature = last.$cstNode.feature;
              this.nodeBuilder.buildCompositeNode(feature);
            }
            const newItem = { $type };
            this.stack.pop();
            this.stack.push(newItem);
            if (action.feature && action.operator) {
              this.assign(action.operator, action.feature, last, last.$cstNode, false);
            }
          }
        }
        construct(pop = true) {
          if (this.isRecording()) {
            return void 0;
          }
          const obj = this.current;
          (0, ast_util_1.linkContentToContainer)(obj);
          this.nodeBuilder.construct(obj);
          if (pop) {
            this.stack.pop();
          }
          if (isDataTypeNode(obj)) {
            return this.converter.convert(obj.value, obj.$cstNode);
          } else {
            this.assignMandatoryProperties(obj);
          }
          return obj;
        }
        assignMandatoryProperties(obj) {
          const typeMetaData = this.astReflection.getTypeMetaData(obj.$type);
          for (const mandatoryProperty of typeMetaData.mandatory) {
            const value = obj[mandatoryProperty.name];
            if (mandatoryProperty.type === "array" && !Array.isArray(value)) {
              obj[mandatoryProperty.name] = [];
            } else if (mandatoryProperty.type === "boolean" && value === void 0) {
              obj[mandatoryProperty.name] = false;
            }
          }
        }
        getAssignment(feature) {
          if (!this.assignmentMap.has(feature)) {
            const assignment = (0, ast_util_1.getContainerOfType)(feature, ast_1.isAssignment);
            this.assignmentMap.set(feature, {
              assignment,
              isCrossRef: assignment ? (0, ast_1.isCrossReference)(assignment.terminal) : false
            });
          }
          return this.assignmentMap.get(feature);
        }
        assign(operator, feature, value, cstNode, isCrossRef) {
          const obj = this.current;
          let item;
          if (isCrossRef && typeof value === "string") {
            item = this.linker.buildReference(obj, feature, cstNode, value);
          } else {
            item = value;
          }
          switch (operator) {
            case "=": {
              obj[feature] = item;
              break;
            }
            case "?=": {
              obj[feature] = true;
              break;
            }
            case "+=": {
              if (!Array.isArray(obj[feature])) {
                obj[feature] = [];
              }
              obj[feature].push(item);
            }
          }
        }
        assignWithoutOverride(target, source) {
          for (const [name, existingValue] of Object.entries(source)) {
            const newValue = target[name];
            if (newValue === void 0) {
              target[name] = existingValue;
            } else if (Array.isArray(newValue) && Array.isArray(existingValue)) {
              existingValue.push(...newValue);
              target[name] = existingValue;
            }
          }
          return target;
        }
        get definitionErrors() {
          return this.wrapper.definitionErrors;
        }
      };
      exports2.LangiumParser = LangiumParser;
      var LangiumParserErrorMessageProvider = class {
        buildMismatchTokenMessage({ expected, actual }) {
          const expectedMsg = expected.LABEL ? "`" + expected.LABEL + "`" : expected.name.endsWith(":KW") ? `keyword '${expected.name.substring(0, expected.name.length - 3)}'` : `token of type '${expected.name}'`;
          return `Expecting ${expectedMsg} but found \`${actual.image}\`.`;
        }
        buildNotAllInputParsedMessage({ firstRedundant }) {
          return `Expecting end of file but found \`${firstRedundant.image}\`.`;
        }
        buildNoViableAltMessage(options) {
          return chevrotain_1.defaultParserErrorProvider.buildNoViableAltMessage(options);
        }
        buildEarlyExitMessage(options) {
          return chevrotain_1.defaultParserErrorProvider.buildEarlyExitMessage(options);
        }
      };
      exports2.LangiumParserErrorMessageProvider = LangiumParserErrorMessageProvider;
      var LangiumCompletionParser = class extends AbstractLangiumParser {
        constructor() {
          super(...arguments);
          this.tokens = [];
          this.elementStack = [];
          this.lastElementStack = [];
          this.nextTokenIndex = 0;
          this.stackSize = 0;
        }
        action() {
        }
        construct() {
          return void 0;
        }
        parse(input) {
          this.resetState();
          const tokens = this.lexer.tokenize(input);
          this.tokens = tokens.tokens;
          this.wrapper.input = [...this.tokens];
          this.mainRule.call(this.wrapper, {});
          this.unorderedGroups.clear();
          return {
            tokens: this.tokens,
            elementStack: [...this.lastElementStack],
            tokenIndex: this.nextTokenIndex
          };
        }
        rule(rule, impl) {
          const ruleMethod = this.wrapper.DEFINE_RULE(withRuleSuffix(rule.name), this.startImplementation(impl).bind(this));
          if (rule.entry) {
            this.mainRule = ruleMethod;
          }
          return ruleMethod;
        }
        resetState() {
          this.elementStack = [];
          this.lastElementStack = [];
          this.nextTokenIndex = 0;
          this.stackSize = 0;
        }
        startImplementation(implementation) {
          return (args) => {
            const size = this.keepStackSize();
            try {
              implementation(args);
            } finally {
              this.resetStackSize(size);
            }
          };
        }
        removeUnexpectedElements() {
          this.elementStack.splice(this.stackSize);
        }
        keepStackSize() {
          const size = this.elementStack.length;
          this.stackSize = size;
          return size;
        }
        resetStackSize(size) {
          this.removeUnexpectedElements();
          this.stackSize = size;
        }
        consume(idx, tokenType, feature) {
          this.wrapper.wrapConsume(idx, tokenType);
          if (!this.isRecording()) {
            this.lastElementStack = [...this.elementStack, feature];
            this.nextTokenIndex = this.currIdx + 1;
          }
        }
        subrule(idx, rule, feature, args) {
          this.before(feature);
          this.wrapper.wrapSubrule(idx, rule, args);
          this.after(feature);
        }
        before(element) {
          if (!this.isRecording()) {
            this.elementStack.push(element);
          }
        }
        after(element) {
          if (!this.isRecording()) {
            const index = this.elementStack.lastIndexOf(element);
            if (index >= 0) {
              this.elementStack.splice(index);
            }
          }
        }
        get currIdx() {
          return this.wrapper.currIdx;
        }
      };
      exports2.LangiumCompletionParser = LangiumCompletionParser;
      var defaultConfig2 = {
        recoveryEnabled: true,
        nodeLocationTracking: "full",
        skipValidations: true,
        errorMessageProvider: new LangiumParserErrorMessageProvider()
      };
      var ChevrotainWrapper = class extends chevrotain_1.EmbeddedActionsParser {
        constructor(tokens, config) {
          const useDefaultLookahead = config && "maxLookahead" in config;
          super(tokens, Object.assign(Object.assign(Object.assign({}, defaultConfig2), { lookaheadStrategy: useDefaultLookahead ? new chevrotain_1.LLkLookaheadStrategy({ maxLookahead: config.maxLookahead }) : new chevrotain_allstar_1.LLStarLookaheadStrategy() }), config));
        }
        get IS_RECORDING() {
          return this.RECORDING_PHASE;
        }
        DEFINE_RULE(name, impl) {
          return this.RULE(name, impl);
        }
        wrapSelfAnalysis() {
          this.performSelfAnalysis();
        }
        wrapConsume(idx, tokenType) {
          return this.consume(idx, tokenType);
        }
        wrapSubrule(idx, rule, args) {
          return this.subrule(idx, rule, {
            ARGS: [args]
          });
        }
        wrapOr(idx, choices) {
          this.or(idx, choices);
        }
        wrapOption(idx, callback) {
          this.option(idx, callback);
        }
        wrapMany(idx, callback) {
          this.many(idx, callback);
        }
        wrapAtLeastOne(idx, callback) {
          this.atLeastOne(idx, callback);
        }
      };
    }
  });

  // node_modules/langium/lib/utils/errors.js
  var require_errors = __commonJS({
    "node_modules/langium/lib/utils/errors.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.assertUnreachable = exports2.ErrorWithLocation = void 0;
      var ErrorWithLocation = class extends Error {
        constructor(node, message) {
          super(node ? `${message} at ${node.range.start.line}:${node.range.start.character}` : message);
        }
      };
      exports2.ErrorWithLocation = ErrorWithLocation;
      function assertUnreachable(_) {
        throw new Error("Error! The input value was not handled.");
      }
      exports2.assertUnreachable = assertUnreachable;
    }
  });

  // node_modules/langium/lib/parser/parser-builder-base.js
  var require_parser_builder_base = __commonJS({
    "node_modules/langium/lib/parser/parser-builder-base.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createParser = void 0;
      var chevrotain_1 = require_api7();
      var ast_1 = require_ast();
      var errors_1 = require_errors();
      var stream_1 = require_stream();
      var internal_grammar_util_1 = require_internal_grammar_util();
      var grammar_util_1 = require_grammar_util();
      function createParser(grammar, parser, tokens) {
        const rules = /* @__PURE__ */ new Map();
        const parserContext = {
          parser,
          tokens,
          rules,
          ruleNames: /* @__PURE__ */ new Map()
        };
        buildRules(parserContext, grammar);
        return parser;
      }
      exports2.createParser = createParser;
      function buildRules(parserContext, grammar) {
        const reachable = (0, grammar_util_1.getAllReachableRules)(grammar, false);
        const parserRules = (0, stream_1.stream)(grammar.rules).filter(ast_1.isParserRule).filter((rule) => reachable.has(rule));
        for (const rule of parserRules) {
          const ctx = Object.assign(Object.assign({}, parserContext), { consume: 1, optional: 1, subrule: 1, many: 1, or: 1 });
          ctx.rules.set(rule.name, parserContext.parser.rule(rule, buildElement(ctx, rule.definition)));
        }
      }
      function buildElement(ctx, element, ignoreGuard = false) {
        let method;
        if ((0, ast_1.isKeyword)(element)) {
          method = buildKeyword(ctx, element);
        } else if ((0, ast_1.isAction)(element)) {
          method = buildAction(ctx, element);
        } else if ((0, ast_1.isAssignment)(element)) {
          method = buildElement(ctx, element.terminal);
        } else if ((0, ast_1.isCrossReference)(element)) {
          method = buildCrossReference(ctx, element);
        } else if ((0, ast_1.isRuleCall)(element)) {
          method = buildRuleCall(ctx, element);
        } else if ((0, ast_1.isAlternatives)(element)) {
          method = buildAlternatives(ctx, element);
        } else if ((0, ast_1.isUnorderedGroup)(element)) {
          method = buildUnorderedGroup(ctx, element);
        } else if ((0, ast_1.isGroup)(element)) {
          method = buildGroup(ctx, element);
        } else {
          throw new errors_1.ErrorWithLocation(element.$cstNode, `Unexpected element type: ${element.$type}`);
        }
        return wrap(ctx, ignoreGuard ? void 0 : getGuardCondition(element), method, element.cardinality);
      }
      function buildAction(ctx, action) {
        const actionType = (0, internal_grammar_util_1.getTypeName)(action);
        return () => ctx.parser.action(actionType, action);
      }
      function buildRuleCall(ctx, ruleCall) {
        const rule = ruleCall.rule.ref;
        if ((0, ast_1.isParserRule)(rule)) {
          const idx = ctx.subrule++;
          const predicate = ruleCall.arguments.length > 0 ? buildRuleCallPredicate(rule, ruleCall.arguments) : () => ({});
          return (args) => ctx.parser.subrule(idx, getRule(ctx, rule), ruleCall, predicate(args));
        } else if ((0, ast_1.isTerminalRule)(rule)) {
          const idx = ctx.consume++;
          const method = getToken(ctx, rule.name);
          return () => ctx.parser.consume(idx, method, ruleCall);
        } else if (!rule) {
          throw new errors_1.ErrorWithLocation(ruleCall.$cstNode, `Undefined rule type: ${ruleCall.$type}`);
        } else {
          (0, errors_1.assertUnreachable)(rule);
        }
      }
      function buildRuleCallPredicate(rule, namedArgs) {
        const predicates = namedArgs.map((e) => buildPredicate(e.value));
        return (args) => {
          const ruleArgs = {};
          for (let i = 0; i < predicates.length; i++) {
            const ruleTarget = rule.parameters[i];
            const predicate = predicates[i];
            ruleArgs[ruleTarget.name] = predicate(args);
          }
          return ruleArgs;
        };
      }
      function buildPredicate(condition) {
        if ((0, ast_1.isDisjunction)(condition)) {
          const left = buildPredicate(condition.left);
          const right = buildPredicate(condition.right);
          return (args) => left(args) || right(args);
        } else if ((0, ast_1.isConjunction)(condition)) {
          const left = buildPredicate(condition.left);
          const right = buildPredicate(condition.right);
          return (args) => left(args) && right(args);
        } else if ((0, ast_1.isNegation)(condition)) {
          const value = buildPredicate(condition.value);
          return (args) => !value(args);
        } else if ((0, ast_1.isParameterReference)(condition)) {
          const name = condition.parameter.ref.name;
          return (args) => args !== void 0 && args[name] === true;
        } else if ((0, ast_1.isLiteralCondition)(condition)) {
          const value = Boolean(condition.true);
          return () => value;
        }
        (0, errors_1.assertUnreachable)(condition);
      }
      function buildAlternatives(ctx, alternatives) {
        if (alternatives.elements.length === 1) {
          return buildElement(ctx, alternatives.elements[0]);
        } else {
          const methods = [];
          for (const element of alternatives.elements) {
            const predicatedMethod = {
              // Since we handle the guard condition in the alternative already
              // We can ignore the group guard condition inside
              ALT: buildElement(ctx, element, true)
            };
            const guard = getGuardCondition(element);
            if (guard) {
              predicatedMethod.GATE = buildPredicate(guard);
            }
            methods.push(predicatedMethod);
          }
          const idx = ctx.or++;
          return (args) => ctx.parser.alternatives(idx, methods.map((method) => {
            const alt = {
              ALT: () => method.ALT(args)
            };
            const gate = method.GATE;
            if (gate) {
              alt.GATE = () => gate(args);
            }
            return alt;
          }));
        }
      }
      function buildUnorderedGroup(ctx, group) {
        if (group.elements.length === 1) {
          return buildElement(ctx, group.elements[0]);
        }
        const methods = [];
        for (const element of group.elements) {
          const predicatedMethod = {
            // Since we handle the guard condition in the alternative already
            // We can ignore the group guard condition inside
            ALT: buildElement(ctx, element, true)
          };
          const guard = getGuardCondition(element);
          if (guard) {
            predicatedMethod.GATE = buildPredicate(guard);
          }
          methods.push(predicatedMethod);
        }
        const orIdx = ctx.or++;
        const idFunc = (groupIdx, lParser) => {
          const stackId = lParser.getRuleStack().join("-");
          return `uGroup_${groupIdx}_${stackId}`;
        };
        const alternatives = (args) => ctx.parser.alternatives(orIdx, methods.map((method, idx) => {
          const alt = { ALT: () => true };
          const parser = ctx.parser;
          alt.ALT = () => {
            method.ALT(args);
            if (!parser.isRecording()) {
              const key = idFunc(orIdx, parser);
              if (!parser.unorderedGroups.get(key)) {
                parser.unorderedGroups.set(key, []);
              }
              const groupState = parser.unorderedGroups.get(key);
              if (typeof (groupState === null || groupState === void 0 ? void 0 : groupState[idx]) === "undefined") {
                groupState[idx] = true;
              }
            }
          };
          const gate = method.GATE;
          if (gate) {
            alt.GATE = () => gate(args);
          } else {
            alt.GATE = () => {
              const trackedAlternatives = parser.unorderedGroups.get(idFunc(orIdx, parser));
              const allow = !(trackedAlternatives === null || trackedAlternatives === void 0 ? void 0 : trackedAlternatives[idx]);
              return allow;
            };
          }
          return alt;
        }));
        const wrapped = wrap(ctx, getGuardCondition(group), alternatives, "*");
        return (args) => {
          wrapped(args);
          if (!ctx.parser.isRecording()) {
            ctx.parser.unorderedGroups.delete(idFunc(orIdx, ctx.parser));
          }
        };
      }
      function buildGroup(ctx, group) {
        const methods = group.elements.map((e) => buildElement(ctx, e));
        return (args) => methods.forEach((method) => method(args));
      }
      function getGuardCondition(element) {
        if ((0, ast_1.isGroup)(element)) {
          return element.guardCondition;
        }
        return void 0;
      }
      function buildCrossReference(ctx, crossRef, terminal = crossRef.terminal) {
        if (!terminal) {
          if (!crossRef.type.ref) {
            throw new Error("Could not resolve reference to type: " + crossRef.type.$refText);
          }
          const assignment = (0, grammar_util_1.findNameAssignment)(crossRef.type.ref);
          const assignTerminal = assignment === null || assignment === void 0 ? void 0 : assignment.terminal;
          if (!assignTerminal) {
            throw new Error("Could not find name assignment for type: " + (0, internal_grammar_util_1.getTypeName)(crossRef.type.ref));
          }
          return buildCrossReference(ctx, crossRef, assignTerminal);
        } else if ((0, ast_1.isRuleCall)(terminal) && (0, ast_1.isParserRule)(terminal.rule.ref)) {
          const idx = ctx.subrule++;
          return (args) => ctx.parser.subrule(idx, getRule(ctx, terminal.rule.ref), crossRef, args);
        } else if ((0, ast_1.isRuleCall)(terminal) && (0, ast_1.isTerminalRule)(terminal.rule.ref)) {
          const idx = ctx.consume++;
          const terminalRule = getToken(ctx, terminal.rule.ref.name);
          return () => ctx.parser.consume(idx, terminalRule, crossRef);
        } else if ((0, ast_1.isKeyword)(terminal)) {
          const idx = ctx.consume++;
          const keyword = getToken(ctx, terminal.value);
          return () => ctx.parser.consume(idx, keyword, crossRef);
        } else {
          throw new Error("Could not build cross reference parser");
        }
      }
      function buildKeyword(ctx, keyword) {
        const idx = ctx.consume++;
        const token = ctx.tokens[keyword.value];
        if (!token) {
          throw new Error("Could not find token for keyword: " + keyword.value);
        }
        return () => ctx.parser.consume(idx, token, keyword);
      }
      function wrap(ctx, guard, method, cardinality) {
        const gate = guard && buildPredicate(guard);
        if (!cardinality) {
          if (gate) {
            const idx = ctx.or++;
            return (args) => ctx.parser.alternatives(idx, [
              {
                ALT: () => method(args),
                GATE: () => gate(args)
              },
              {
                ALT: (0, chevrotain_1.EMPTY_ALT)(),
                GATE: () => !gate(args)
              }
            ]);
          } else {
            return method;
          }
        }
        if (cardinality === "*") {
          const idx = ctx.many++;
          return (args) => ctx.parser.many(idx, {
            DEF: () => method(args),
            GATE: gate ? () => gate(args) : void 0
          });
        } else if (cardinality === "+") {
          const idx = ctx.many++;
          if (gate) {
            const orIdx = ctx.or++;
            return (args) => ctx.parser.alternatives(orIdx, [
              {
                ALT: () => ctx.parser.atLeastOne(idx, {
                  DEF: () => method(args)
                }),
                GATE: () => gate(args)
              },
              {
                ALT: (0, chevrotain_1.EMPTY_ALT)(),
                GATE: () => !gate(args)
              }
            ]);
          } else {
            return (args) => ctx.parser.atLeastOne(idx, {
              DEF: () => method(args)
            });
          }
        } else if (cardinality === "?") {
          const idx = ctx.optional++;
          return (args) => ctx.parser.optional(idx, {
            DEF: () => method(args),
            GATE: gate ? () => gate(args) : void 0
          });
        } else {
          (0, errors_1.assertUnreachable)(cardinality);
        }
      }
      function getRule(ctx, element) {
        const name = getRuleName(ctx, element);
        const rule = ctx.rules.get(name);
        if (!rule)
          throw new Error(`Rule "${name}" not found."`);
        return rule;
      }
      function getRuleName(ctx, element) {
        if ((0, ast_1.isParserRule)(element)) {
          return element.name;
        } else if (ctx.ruleNames.has(element)) {
          return ctx.ruleNames.get(element);
        } else {
          let item = element;
          let parent = item.$container;
          let ruleName = element.$type;
          while (!(0, ast_1.isParserRule)(parent)) {
            if ((0, ast_1.isGroup)(parent) || (0, ast_1.isAlternatives)(parent) || (0, ast_1.isUnorderedGroup)(parent)) {
              const index = parent.elements.indexOf(item);
              ruleName = index.toString() + ":" + ruleName;
            }
            item = parent;
            parent = parent.$container;
          }
          const rule = parent;
          ruleName = rule.name + ":" + ruleName;
          ctx.ruleNames.set(element, ruleName);
          return ruleName;
        }
      }
      function getToken(ctx, name) {
        const token = ctx.tokens[name];
        if (!token)
          throw new Error(`Token "${name}" not found."`);
        return token;
      }
    }
  });

  // node_modules/langium/lib/parser/completion-parser-builder.js
  var require_completion_parser_builder = __commonJS({
    "node_modules/langium/lib/parser/completion-parser-builder.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createCompletionParser = void 0;
      var langium_parser_1 = require_langium_parser();
      var parser_builder_base_1 = require_parser_builder_base();
      function createCompletionParser(services) {
        const grammar = services.Grammar;
        const lexer = services.parser.Lexer;
        const parser = new langium_parser_1.LangiumCompletionParser(services);
        (0, parser_builder_base_1.createParser)(grammar, parser, lexer.definition);
        parser.finalize();
        return parser;
      }
      exports2.createCompletionParser = createCompletionParser;
    }
  });

  // node_modules/langium/lib/parser/langium-parser-builder.js
  var require_langium_parser_builder = __commonJS({
    "node_modules/langium/lib/parser/langium-parser-builder.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.prepareLangiumParser = exports2.createLangiumParser = void 0;
      var langium_parser_1 = require_langium_parser();
      var parser_builder_base_1 = require_parser_builder_base();
      function createLangiumParser(services) {
        const parser = prepareLangiumParser(services);
        parser.finalize();
        return parser;
      }
      exports2.createLangiumParser = createLangiumParser;
      function prepareLangiumParser(services) {
        const grammar = services.Grammar;
        const lexer = services.parser.Lexer;
        const parser = new langium_parser_1.LangiumParser(services);
        return (0, parser_builder_base_1.createParser)(grammar, parser, lexer.definition);
      }
      exports2.prepareLangiumParser = prepareLangiumParser;
    }
  });

  // node_modules/langium/lib/parser/token-builder.js
  var require_token_builder = __commonJS({
    "node_modules/langium/lib/parser/token-builder.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DefaultTokenBuilder = void 0;
      var chevrotain_1 = require_api7();
      var ast_1 = require_ast();
      var internal_grammar_util_1 = require_internal_grammar_util();
      var ast_util_1 = require_ast_util();
      var grammar_util_1 = require_grammar_util();
      var regex_util_1 = require_regex_util();
      var stream_1 = require_stream();
      var DefaultTokenBuilder = class {
        buildTokens(grammar, options) {
          const reachableRules = (0, stream_1.stream)((0, grammar_util_1.getAllReachableRules)(grammar, false));
          const terminalTokens = this.buildTerminalTokens(reachableRules);
          const tokens = this.buildKeywordTokens(reachableRules, terminalTokens, options);
          terminalTokens.forEach((terminalToken) => {
            const pattern = terminalToken.PATTERN;
            if (typeof pattern === "object" && pattern && "test" in pattern && (0, regex_util_1.isWhitespaceRegExp)(pattern)) {
              tokens.unshift(terminalToken);
            } else {
              tokens.push(terminalToken);
            }
          });
          return tokens;
        }
        buildTerminalTokens(rules) {
          return rules.filter(ast_1.isTerminalRule).filter((e) => !e.fragment).map((terminal) => this.buildTerminalToken(terminal)).toArray();
        }
        buildTerminalToken(terminal) {
          const regex = (0, internal_grammar_util_1.terminalRegex)(terminal);
          const token = { name: terminal.name, PATTERN: new RegExp(regex) };
          if (terminal.hidden) {
            token.GROUP = (0, regex_util_1.isWhitespaceRegExp)(regex) ? chevrotain_1.Lexer.SKIPPED : "hidden";
          }
          return token;
        }
        buildKeywordTokens(rules, terminalTokens, options) {
          return rules.filter(ast_1.isParserRule).flatMap((rule) => (0, ast_util_1.streamAllContents)(rule).filter(ast_1.isKeyword)).distinct((e) => e.value).toArray().sort((a, b) => b.value.length - a.value.length).map((keyword) => this.buildKeywordToken(keyword, terminalTokens, Boolean(options === null || options === void 0 ? void 0 : options.caseInsensitive)));
        }
        buildKeywordToken(keyword, terminalTokens, caseInsensitive) {
          return {
            name: keyword.value,
            PATTERN: this.buildKeywordPattern(keyword, caseInsensitive),
            LONGER_ALT: this.findLongerAlt(keyword, terminalTokens)
          };
        }
        buildKeywordPattern(keyword, caseInsensitive) {
          return caseInsensitive ? new RegExp((0, regex_util_1.getCaseInsensitivePattern)(keyword.value)) : keyword.value;
        }
        findLongerAlt(keyword, terminalTokens) {
          return terminalTokens.reduce((longerAlts, token) => {
            const pattern = token === null || token === void 0 ? void 0 : token.PATTERN;
            if ((pattern === null || pattern === void 0 ? void 0 : pattern.source) && (0, regex_util_1.partialMatches)("^" + pattern.source + "$", keyword.value)) {
              longerAlts.push(token);
            }
            return longerAlts;
          }, []);
        }
      };
      exports2.DefaultTokenBuilder = DefaultTokenBuilder;
    }
  });

  // node_modules/langium/lib/parser/value-converter.js
  var require_value_converter = __commonJS({
    "node_modules/langium/lib/parser/value-converter.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.convertBoolean = exports2.convertNumber = exports2.convertDate = exports2.convertBigint = exports2.convertInt = exports2.convertID = exports2.convertRegexLiteral = exports2.convertString = exports2.DefaultValueConverter = void 0;
      var ast_1 = require_ast();
      var internal_grammar_util_1 = require_internal_grammar_util();
      var grammar_util_1 = require_grammar_util();
      var DefaultValueConverter = class {
        convert(input, cstNode) {
          let feature = cstNode.feature;
          if ((0, ast_1.isCrossReference)(feature)) {
            feature = (0, grammar_util_1.getCrossReferenceTerminal)(feature);
          }
          if ((0, ast_1.isRuleCall)(feature)) {
            const rule = feature.rule.ref;
            if (!rule) {
              throw new Error("This cst node was not parsed by a rule.");
            }
            return this.runConverter(rule, input, cstNode);
          }
          return input;
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        runConverter(rule, input, cstNode) {
          var _a4;
          switch (rule.name.toUpperCase()) {
            case "INT":
              return convertInt(input);
            case "STRING":
              return convertString(input);
            case "ID":
              return convertID(input);
            case "REGEXLITERAL":
              return convertRegexLiteral(input);
          }
          switch ((_a4 = (0, internal_grammar_util_1.getRuleType)(rule)) === null || _a4 === void 0 ? void 0 : _a4.toLowerCase()) {
            case "number":
              return convertNumber(input);
            case "boolean":
              return convertBoolean(input);
            case "bigint":
              return convertBigint(input);
            case "date":
              return convertDate(input);
            default:
              return input;
          }
        }
      };
      exports2.DefaultValueConverter = DefaultValueConverter;
      function convertString(input) {
        let result = "";
        for (let i = 1; i < input.length - 1; i++) {
          const c = input.charAt(i);
          if (c === "\\") {
            const c1 = input.charAt(++i);
            result += convertEscapeCharacter(c1);
          } else {
            result += c;
          }
        }
        return result;
      }
      exports2.convertString = convertString;
      function convertEscapeCharacter(char) {
        switch (char) {
          case "b":
            return "\b";
          case "f":
            return "\f";
          case "n":
            return "\n";
          case "r":
            return "\r";
          case "t":
            return "	";
          case "v":
            return "\v";
          case "0":
            return "\0";
          default:
            return char;
        }
      }
      function convertRegexLiteral(input) {
        return input.substring(1, input.length - 1);
      }
      exports2.convertRegexLiteral = convertRegexLiteral;
      function convertID(input) {
        if (input.charAt(0) === "^") {
          return input.substring(1);
        } else {
          return input;
        }
      }
      exports2.convertID = convertID;
      function convertInt(input) {
        return parseInt(input);
      }
      exports2.convertInt = convertInt;
      function convertBigint(input) {
        return BigInt(input);
      }
      exports2.convertBigint = convertBigint;
      function convertDate(input) {
        return new Date(input);
      }
      exports2.convertDate = convertDate;
      function convertNumber(input) {
        return Number(input);
      }
      exports2.convertNumber = convertNumber;
      function convertBoolean(input) {
        return input.toLowerCase() === "true";
      }
      exports2.convertBoolean = convertBoolean;
    }
  });

  // node_modules/langium/lib/references/linker.js
  var require_linker = __commonJS({
    "node_modules/langium/lib/references/linker.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DefaultLinker = void 0;
      var vscode_languageserver_1 = require_main4();
      var syntax_tree_1 = require_syntax_tree();
      var ast_util_1 = require_ast_util();
      var promise_util_1 = require_promise_util();
      var documents_1 = require_documents();
      var DefaultLinker = class {
        constructor(services) {
          this.reflection = services.shared.AstReflection;
          this.langiumDocuments = () => services.shared.workspace.LangiumDocuments;
          this.scopeProvider = services.references.ScopeProvider;
          this.astNodeLocator = services.workspace.AstNodeLocator;
        }
        async link(document2, cancelToken = vscode_languageserver_1.CancellationToken.None) {
          for (const node of (0, ast_util_1.streamAst)(document2.parseResult.value)) {
            await (0, promise_util_1.interruptAndCheck)(cancelToken);
            (0, ast_util_1.streamReferences)(node).forEach((ref) => this.doLink(ref, document2));
          }
          document2.state = documents_1.DocumentState.Linked;
        }
        doLink(refInfo, document2) {
          const ref = refInfo.reference;
          if (ref._ref === void 0) {
            try {
              const description = this.getCandidate(refInfo);
              if ((0, syntax_tree_1.isLinkingError)(description)) {
                ref._ref = description;
              } else {
                ref._nodeDescription = description;
                if (this.langiumDocuments().hasDocument(description.documentUri)) {
                  const linkedNode = this.loadAstNode(description);
                  ref._ref = linkedNode !== null && linkedNode !== void 0 ? linkedNode : this.createLinkingError(refInfo, description);
                }
              }
            } catch (err) {
              ref._ref = Object.assign(Object.assign({}, refInfo), { message: `An error occurred while resolving reference to '${ref.$refText}': ${err}` });
            }
          }
          document2.references.push(ref);
        }
        unlink(document2) {
          for (const ref of document2.references) {
            delete ref._ref;
            delete ref._nodeDescription;
          }
          document2.references = [];
        }
        getCandidate(refInfo) {
          const scope = this.scopeProvider.getScope(refInfo);
          const description = scope.getElement(refInfo.reference.$refText);
          return description !== null && description !== void 0 ? description : this.createLinkingError(refInfo);
        }
        buildReference(node, property, refNode, refText) {
          const linker = this;
          const reference = {
            $refNode: refNode,
            $refText: refText,
            get ref() {
              var _a4;
              if ((0, syntax_tree_1.isAstNode)(this._ref)) {
                return this._ref;
              } else if ((0, syntax_tree_1.isAstNodeDescription)(this._nodeDescription)) {
                const linkedNode = linker.loadAstNode(this._nodeDescription);
                this._ref = linkedNode !== null && linkedNode !== void 0 ? linkedNode : linker.createLinkingError({ reference, container: node, property }, this._nodeDescription);
              } else if (this._ref === void 0) {
                const refData = linker.getLinkedNode({ reference, container: node, property });
                if (refData.error && (0, ast_util_1.getDocument)(node).state < documents_1.DocumentState.ComputedScopes) {
                  return void 0;
                }
                this._ref = (_a4 = refData.node) !== null && _a4 !== void 0 ? _a4 : refData.error;
                this._nodeDescription = refData.descr;
              }
              return (0, syntax_tree_1.isAstNode)(this._ref) ? this._ref : void 0;
            },
            get $nodeDescription() {
              return this._nodeDescription;
            },
            get error() {
              return (0, syntax_tree_1.isLinkingError)(this._ref) ? this._ref : void 0;
            }
          };
          return reference;
        }
        getLinkedNode(refInfo) {
          try {
            const description = this.getCandidate(refInfo);
            if ((0, syntax_tree_1.isLinkingError)(description)) {
              return { error: description };
            }
            const linkedNode = this.loadAstNode(description);
            if (linkedNode) {
              return { node: linkedNode, descr: description };
            } else {
              return {
                descr: description,
                error: this.createLinkingError(refInfo, description)
              };
            }
          } catch (err) {
            return {
              error: Object.assign(Object.assign({}, refInfo), { message: `An error occurred while resolving reference to '${refInfo.reference.$refText}': ${err}` })
            };
          }
        }
        loadAstNode(nodeDescription) {
          if (nodeDescription.node) {
            return nodeDescription.node;
          }
          const doc = this.langiumDocuments().getOrCreateDocument(nodeDescription.documentUri);
          return this.astNodeLocator.getAstNode(doc.parseResult.value, nodeDescription.path);
        }
        createLinkingError(refInfo, targetDescription) {
          const document2 = (0, ast_util_1.getDocument)(refInfo.container);
          if (document2.state < documents_1.DocumentState.ComputedScopes) {
            console.warn(`Attempted reference resolution before document reached ComputedScopes state (${document2.uri}).`);
          }
          const referenceType = this.reflection.getReferenceType(refInfo);
          return Object.assign(Object.assign({}, refInfo), { message: `Could not resolve reference to ${referenceType} named '${refInfo.reference.$refText}'.`, targetDescription });
        }
      };
      exports2.DefaultLinker = DefaultLinker;
    }
  });

  // node_modules/langium/lib/serializer/json-serializer.js
  var require_json_serializer = __commonJS({
    "node_modules/langium/lib/serializer/json-serializer.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DefaultJsonSerializer = void 0;
      var syntax_tree_1 = require_syntax_tree();
      var ast_util_1 = require_ast_util();
      var grammar_util_1 = require_grammar_util();
      function isIntermediateReference(obj) {
        return typeof obj === "object" && !!obj && ("$ref" in obj || "$error" in obj);
      }
      var DefaultJsonSerializer = class {
        constructor(services) {
          this.ignoreProperties = /* @__PURE__ */ new Set(["$container", "$containerProperty", "$containerIndex", "$document", "$cstNode"]);
          this.astNodeLocator = services.workspace.AstNodeLocator;
          this.nameProvider = services.references.NameProvider;
        }
        serialize(node, options) {
          const specificReplacer = options === null || options === void 0 ? void 0 : options.replacer;
          const defaultReplacer = (key, value) => this.replacer(key, value, options);
          const replacer = specificReplacer ? (key, value) => specificReplacer(key, value, defaultReplacer) : defaultReplacer;
          return JSON.stringify(node, replacer, options === null || options === void 0 ? void 0 : options.space);
        }
        deserialize(content) {
          const root = JSON.parse(content);
          this.linkNode(root, root);
          return root;
        }
        replacer(key, value, { refText, sourceText, textRegions } = {}) {
          var _a4, _b2, _c2;
          if (this.ignoreProperties.has(key)) {
            return void 0;
          } else if ((0, syntax_tree_1.isReference)(value)) {
            const refValue = value.ref;
            const $refText = refText ? value.$refText : void 0;
            if (refValue) {
              return {
                $refText,
                $ref: "#" + (refValue && this.astNodeLocator.getAstNodePath(refValue))
              };
            } else {
              return {
                $refText,
                $error: (_b2 = (_a4 = value.error) === null || _a4 === void 0 ? void 0 : _a4.message) !== null && _b2 !== void 0 ? _b2 : "Could not resolve reference"
              };
            }
          } else {
            let astNode = void 0;
            if (textRegions && (0, syntax_tree_1.isAstNode)(value)) {
              astNode = this.addAstNodeRegionWithAssignmentsTo(Object.assign({}, value));
              if ((!key || value.$document) && (astNode === null || astNode === void 0 ? void 0 : astNode.$textRegion)) {
                try {
                  astNode.$textRegion.documentURI = (0, ast_util_1.getDocument)(value).uri.toString();
                } catch (e) {
                }
              }
            }
            if (sourceText && !key && (0, syntax_tree_1.isAstNode)(value)) {
              astNode !== null && astNode !== void 0 ? astNode : astNode = Object.assign({}, value);
              astNode.$sourceText = (_c2 = value.$cstNode) === null || _c2 === void 0 ? void 0 : _c2.text;
            }
            return astNode !== null && astNode !== void 0 ? astNode : value;
          }
        }
        addAstNodeRegionWithAssignmentsTo(node) {
          const createDocumentSegment = (cstNode) => ({
            offset: cstNode.offset,
            end: cstNode.end,
            length: cstNode.length,
            range: cstNode.range
          });
          if (node.$cstNode) {
            const textRegion = node.$textRegion = createDocumentSegment(node.$cstNode);
            const assignments = textRegion.assignments = {};
            Object.keys(node).filter((key) => !key.startsWith("$")).forEach((key) => {
              const propertyAssignments = (0, grammar_util_1.findNodesForProperty)(node.$cstNode, key).map(createDocumentSegment);
              if (propertyAssignments.length !== 0) {
                assignments[key] = propertyAssignments;
              }
            });
            return node;
          }
          return void 0;
        }
        linkNode(node, root, container, containerProperty, containerIndex) {
          for (const [propertyName, item] of Object.entries(node)) {
            if (Array.isArray(item)) {
              for (let index = 0; index < item.length; index++) {
                const element = item[index];
                if (isIntermediateReference(element)) {
                  item[index] = this.reviveReference(node, propertyName, root, element);
                } else if ((0, syntax_tree_1.isAstNode)(element)) {
                  this.linkNode(element, root, node, propertyName, index);
                }
              }
            } else if (isIntermediateReference(item)) {
              node[propertyName] = this.reviveReference(node, propertyName, root, item);
            } else if ((0, syntax_tree_1.isAstNode)(item)) {
              this.linkNode(item, root, node, propertyName);
            }
          }
          const mutable = node;
          mutable.$container = container;
          mutable.$containerProperty = containerProperty;
          mutable.$containerIndex = containerIndex;
        }
        reviveReference(container, property, root, reference) {
          let refText = reference.$refText;
          if (reference.$ref) {
            const ref = this.getRefNode(root, reference.$ref);
            if (!refText) {
              refText = this.nameProvider.getName(ref);
            }
            return {
              $refText: refText !== null && refText !== void 0 ? refText : "",
              ref
            };
          } else if (reference.$error) {
            const ref = {
              $refText: refText !== null && refText !== void 0 ? refText : ""
            };
            ref.error = {
              container,
              property,
              message: reference.$error,
              reference: ref
            };
            return ref;
          } else {
            return void 0;
          }
        }
        getRefNode(root, path) {
          return this.astNodeLocator.getAstNode(root, path.substring(1));
        }
      };
      exports2.DefaultJsonSerializer = DefaultJsonSerializer;
    }
  });

  // node_modules/langium/lib/service-registry.js
  var require_service_registry = __commonJS({
    "node_modules/langium/lib/service-registry.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DefaultServiceRegistry = void 0;
      var vscode_uri_1 = require_umd();
      var DefaultServiceRegistry = class {
        register(language2) {
          if (!this.singleton && !this.map) {
            this.singleton = language2;
            return;
          }
          if (!this.map) {
            this.map = {};
            if (this.singleton) {
              for (const ext of this.singleton.LanguageMetaData.fileExtensions) {
                this.map[ext] = this.singleton;
              }
              this.singleton = void 0;
            }
          }
          for (const ext of language2.LanguageMetaData.fileExtensions) {
            if (this.map[ext] !== void 0 && this.map[ext] !== language2) {
              console.warn(`The file extension ${ext} is used by multiple languages. It is now assigned to '${language2.LanguageMetaData.languageId}'.`);
            }
            this.map[ext] = language2;
          }
        }
        getServices(uri) {
          if (this.singleton !== void 0) {
            return this.singleton;
          }
          if (this.map === void 0) {
            throw new Error("The service registry is empty. Use `register` to register the services of a language.");
          }
          const ext = vscode_uri_1.Utils.extname(uri);
          const services = this.map[ext];
          if (!services) {
            throw new Error(`The service registry contains no services for the extension '${ext}'.`);
          }
          return services;
        }
        get all() {
          if (this.singleton !== void 0) {
            return [this.singleton];
          }
          if (this.map !== void 0) {
            return Object.values(this.map);
          }
          return [];
        }
      };
      exports2.DefaultServiceRegistry = DefaultServiceRegistry;
    }
  });

  // node_modules/langium/lib/validation/validation-registry.js
  var require_validation_registry = __commonJS({
    "node_modules/langium/lib/validation/validation-registry.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ValidationRegistry = void 0;
      var collections_1 = require_collections();
      var promise_util_1 = require_promise_util();
      var ValidationRegistry = class {
        constructor(services) {
          this.validationChecks = new collections_1.MultiMap();
          this.reflection = services.shared.AstReflection;
        }
        register(checksRecord, thisObj = this) {
          for (const [type, ch] of Object.entries(checksRecord)) {
            const callbacks = ch;
            if (Array.isArray(callbacks)) {
              for (const check of callbacks) {
                this.doRegister(type, this.wrapValidationException(check, thisObj));
              }
            } else if (typeof callbacks === "function") {
              this.doRegister(type, this.wrapValidationException(callbacks, thisObj));
            }
          }
        }
        wrapValidationException(check, thisObj) {
          return async (node, accept, cancelToken) => {
            try {
              await check.call(thisObj, node, accept, cancelToken);
            } catch (err) {
              if ((0, promise_util_1.isOperationCancelled)(err)) {
                throw err;
              }
              console.error("An error occurred during validation:", err);
              const message = err instanceof Error ? err.message : String(err);
              if (err instanceof Error && err.stack) {
                console.error(err.stack);
              }
              accept("error", "An error occurred during validation: " + message, { node });
            }
          };
        }
        doRegister(type, check) {
          if (type === "AstNode") {
            this.validationChecks.add("AstNode", check);
            return;
          }
          for (const subtype of this.reflection.getAllSubTypes(type)) {
            this.validationChecks.add(subtype, check);
          }
        }
        getChecks(type) {
          return this.validationChecks.get(type).concat(this.validationChecks.get("AstNode"));
        }
      };
      exports2.ValidationRegistry = ValidationRegistry;
    }
  });

  // node_modules/langium/lib/workspace/ast-descriptions.js
  var require_ast_descriptions = __commonJS({
    "node_modules/langium/lib/workspace/ast-descriptions.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DefaultReferenceDescriptionProvider = exports2.DefaultAstNodeDescriptionProvider = void 0;
      var vscode_languageserver_1 = require_main4();
      var syntax_tree_1 = require_syntax_tree();
      var ast_util_1 = require_ast_util();
      var cst_util_1 = require_cst_util();
      var promise_util_1 = require_promise_util();
      var uri_util_1 = require_uri_util();
      var DefaultAstNodeDescriptionProvider = class {
        constructor(services) {
          this.astNodeLocator = services.workspace.AstNodeLocator;
          this.nameProvider = services.references.NameProvider;
        }
        createDescription(node, name, document2 = (0, ast_util_1.getDocument)(node)) {
          var _a4;
          name !== null && name !== void 0 ? name : name = this.nameProvider.getName(node);
          const path = this.astNodeLocator.getAstNodePath(node);
          if (!name) {
            throw new Error(`Node at path ${path} has no name.`);
          }
          const nameNode = (_a4 = this.nameProvider.getNameNode(node)) !== null && _a4 !== void 0 ? _a4 : node.$cstNode;
          return {
            node,
            name,
            nameSegment: (0, cst_util_1.toDocumentSegment)(nameNode),
            selectionSegment: (0, cst_util_1.toDocumentSegment)(node.$cstNode),
            type: node.$type,
            documentUri: document2.uri,
            path
          };
        }
      };
      exports2.DefaultAstNodeDescriptionProvider = DefaultAstNodeDescriptionProvider;
      var DefaultReferenceDescriptionProvider = class {
        constructor(services) {
          this.nodeLocator = services.workspace.AstNodeLocator;
        }
        async createDescriptions(document2, cancelToken = vscode_languageserver_1.CancellationToken.None) {
          const descr = [];
          const rootNode = document2.parseResult.value;
          for (const astNode of (0, ast_util_1.streamAst)(rootNode)) {
            await (0, promise_util_1.interruptAndCheck)(cancelToken);
            (0, ast_util_1.streamReferences)(astNode).filter((refInfo) => !(0, syntax_tree_1.isLinkingError)(refInfo)).forEach((refInfo) => {
              const description = this.createDescription(refInfo);
              if (description) {
                descr.push(description);
              }
            });
          }
          return descr;
        }
        createDescription(refInfo) {
          const targetNodeDescr = refInfo.reference.$nodeDescription;
          const refCstNode = refInfo.reference.$refNode;
          if (!targetNodeDescr || !refCstNode) {
            return void 0;
          }
          const docUri = (0, ast_util_1.getDocument)(refInfo.container).uri;
          return {
            sourceUri: docUri,
            sourcePath: this.nodeLocator.getAstNodePath(refInfo.container),
            targetUri: targetNodeDescr.documentUri,
            targetPath: targetNodeDescr.path,
            segment: (0, cst_util_1.toDocumentSegment)(refCstNode),
            local: (0, uri_util_1.equalURI)(targetNodeDescr.documentUri, docUri)
          };
        }
      };
      exports2.DefaultReferenceDescriptionProvider = DefaultReferenceDescriptionProvider;
    }
  });

  // node_modules/langium/lib/workspace/ast-node-locator.js
  var require_ast_node_locator = __commonJS({
    "node_modules/langium/lib/workspace/ast-node-locator.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DefaultAstNodeLocator = void 0;
      var DefaultAstNodeLocator = class {
        constructor() {
          this.segmentSeparator = "/";
          this.indexSeparator = "@";
        }
        getAstNodePath(node) {
          if (node.$container) {
            const containerPath = this.getAstNodePath(node.$container);
            const newSegment = this.getPathSegment(node);
            const nodePath = containerPath + this.segmentSeparator + newSegment;
            return nodePath;
          }
          return "";
        }
        getPathSegment({ $containerProperty, $containerIndex }) {
          if (!$containerProperty) {
            throw new Error("Missing '$containerProperty' in AST node.");
          }
          if ($containerIndex !== void 0) {
            return $containerProperty + this.indexSeparator + $containerIndex;
          }
          return $containerProperty;
        }
        getAstNode(node, path) {
          const segments = path.split(this.segmentSeparator);
          return segments.reduce((previousValue, currentValue) => {
            if (!previousValue || currentValue.length === 0) {
              return previousValue;
            }
            const propertyIndex = currentValue.indexOf(this.indexSeparator);
            if (propertyIndex > 0) {
              const property = currentValue.substring(0, propertyIndex);
              const arrayIndex = parseInt(currentValue.substring(propertyIndex + 1));
              const array = previousValue[property];
              return array === null || array === void 0 ? void 0 : array[arrayIndex];
            }
            return previousValue[currentValue];
          }, node);
        }
      };
      exports2.DefaultAstNodeLocator = DefaultAstNodeLocator;
    }
  });

  // node_modules/langium/lib/workspace/configuration.js
  var require_configuration2 = __commonJS({
    "node_modules/langium/lib/workspace/configuration.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DefaultConfigurationProvider = void 0;
      var vscode_languageserver_protocol_1 = require_main3();
      var DefaultConfigurationProvider = class {
        constructor(services) {
          this.settings = {};
          this.workspaceConfig = false;
          this.initialized = false;
          this.serviceRegistry = services.ServiceRegistry;
          this.connection = services.lsp.Connection;
          services.lsp.LanguageServer.onInitialize((params) => {
            var _a4, _b2;
            this.workspaceConfig = (_b2 = (_a4 = params.capabilities.workspace) === null || _a4 === void 0 ? void 0 : _a4.configuration) !== null && _b2 !== void 0 ? _b2 : false;
          });
          services.lsp.LanguageServer.onInitialized((_params) => {
            var _a4;
            const languages2 = this.serviceRegistry.all;
            (_a4 = services.lsp.Connection) === null || _a4 === void 0 ? void 0 : _a4.client.register(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, {
              // Listen to configuration changes for all languages
              section: languages2.map((lang) => this.toSectionName(lang.LanguageMetaData.languageId))
            });
          });
        }
        async initialize() {
          if (this.workspaceConfig && this.connection) {
            const languages2 = this.serviceRegistry.all;
            const configToUpdate = languages2.map((lang) => {
              return { section: this.toSectionName(lang.LanguageMetaData.languageId) };
            });
            const configs = await this.connection.workspace.getConfiguration(configToUpdate);
            configToUpdate.forEach((conf, idx) => {
              this.updateSectionConfiguration(conf.section, configs[idx]);
            });
          }
          this.initialized = true;
        }
        updateConfiguration(change) {
          if (!change.settings) {
            return;
          }
          Object.keys(change.settings).forEach((section) => {
            this.updateSectionConfiguration(section, change.settings[section]);
          });
        }
        updateSectionConfiguration(section, configuration) {
          this.settings[section] = configuration;
        }
        async getConfiguration(language2, configuration) {
          if (!this.initialized) {
            await this.initialize();
          }
          const sectionName = this.toSectionName(language2);
          if (this.settings[sectionName]) {
            return this.settings[sectionName][configuration];
          }
        }
        toSectionName(languageId) {
          return `${languageId}`;
        }
      };
      exports2.DefaultConfigurationProvider = DefaultConfigurationProvider;
    }
  });

  // node_modules/langium/lib/workspace/document-builder.js
  var require_document_builder = __commonJS({
    "node_modules/langium/lib/workspace/document-builder.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DefaultDocumentBuilder = void 0;
      var vscode_languageserver_1 = require_main4();
      var collections_1 = require_collections();
      var promise_util_1 = require_promise_util();
      var documents_1 = require_documents();
      var DefaultDocumentBuilder = class {
        constructor(services) {
          this.updateListeners = [];
          this.buildPhaseListeners = new collections_1.MultiMap();
          this.langiumDocuments = services.workspace.LangiumDocuments;
          this.langiumDocumentFactory = services.workspace.LangiumDocumentFactory;
          this.indexManager = services.workspace.IndexManager;
          this.serviceRegistry = services.ServiceRegistry;
        }
        async build(documents, options = {}, cancelToken = vscode_languageserver_1.CancellationToken.None) {
          await this.buildDocuments(documents, options, cancelToken);
        }
        async update(changed, deleted, cancelToken = vscode_languageserver_1.CancellationToken.None) {
          for (const deletedDocument of deleted) {
            this.langiumDocuments.deleteDocument(deletedDocument);
          }
          this.indexManager.remove(deleted);
          for (const changedUri of changed) {
            this.langiumDocuments.invalidateDocument(changedUri);
          }
          for (const listener of this.updateListeners) {
            listener(changed, deleted);
          }
          await (0, promise_util_1.interruptAndCheck)(cancelToken);
          const changedDocuments = changed.map((e) => this.langiumDocuments.getOrCreateDocument(e));
          const rebuildDocuments = this.collectDocuments(changedDocuments, deleted);
          const buildOptions = {
            // This method is meant to be called after receiving a change notification from the client,
            // so we assume that we want diagnostics to be reported in the editor.
            validationChecks: "all"
          };
          await this.buildDocuments(rebuildDocuments, buildOptions, cancelToken);
        }
        onUpdate(callback) {
          this.updateListeners.push(callback);
          return vscode_languageserver_1.Disposable.create(() => {
            const index = this.updateListeners.indexOf(callback);
            if (index >= 0) {
              this.updateListeners.splice(index, 1);
            }
          });
        }
        collectDocuments(changed, deleted) {
          const allUris = changed.map((e) => e.uri).concat(deleted);
          const affected = this.indexManager.getAffectedDocuments(allUris).toArray();
          affected.forEach((e) => {
            const linker = this.serviceRegistry.getServices(e.uri).references.Linker;
            linker.unlink(e);
            e.state = Math.min(e.state, documents_1.DocumentState.ComputedScopes);
          });
          const docSet = /* @__PURE__ */ new Set([
            ...changed,
            ...affected,
            // Also include all documents haven't completed the document lifecycle yet
            ...this.langiumDocuments.all.filter((e) => e.state < documents_1.DocumentState.Validated)
          ]);
          return Array.from(docSet);
        }
        async buildDocuments(documents, options, cancelToken) {
          await this.runCancelable(documents, documents_1.DocumentState.Parsed, cancelToken, (doc) => this.langiumDocumentFactory.update(doc));
          await this.runCancelable(documents, documents_1.DocumentState.IndexedContent, cancelToken, (doc) => this.indexManager.updateContent(doc, cancelToken));
          await this.runCancelable(documents, documents_1.DocumentState.ComputedScopes, cancelToken, (doc) => this.computeScopes(doc, cancelToken));
          await this.runCancelable(documents, documents_1.DocumentState.Linked, cancelToken, (doc) => this.serviceRegistry.getServices(doc.uri).references.Linker.link(doc, cancelToken));
          await this.runCancelable(documents, documents_1.DocumentState.IndexedReferences, cancelToken, (doc) => this.indexManager.updateReferences(doc, cancelToken));
          const validateDocs = documents.filter((doc) => this.shouldValidate(doc, options));
          await this.runCancelable(validateDocs, documents_1.DocumentState.Validated, cancelToken, (doc) => this.validate(doc, cancelToken));
        }
        async runCancelable(documents, targetState, cancelToken, callback) {
          const filtered = documents.filter((e) => e.state < targetState);
          for (const document2 of filtered) {
            await (0, promise_util_1.interruptAndCheck)(cancelToken);
            await callback(document2);
          }
          await this.notifyBuildPhase(filtered, targetState, cancelToken);
        }
        onBuildPhase(targetState, callback) {
          this.buildPhaseListeners.add(targetState, callback);
          return vscode_languageserver_1.Disposable.create(() => {
            this.buildPhaseListeners.delete(targetState, callback);
          });
        }
        async notifyBuildPhase(documents, state, cancelToken) {
          if (documents.length === 0) {
            return;
          }
          const listeners = this.buildPhaseListeners.get(state);
          for (const listener of listeners) {
            await (0, promise_util_1.interruptAndCheck)(cancelToken);
            await listener(documents, cancelToken);
          }
        }
        /**
         * Precompute the local scopes of the given document. The resulting data structure is used by
         * the `ScopeProvider` service to determine the visible scope of any cross-reference.
         *
         * _Note:_ You should not resolve any cross-references during this phase. Once the phase is completed,
         * you may follow the `ref` property of a reference, which triggers lazy resolution. The result is
         * either the respective target AST node or `undefined` in case the target is not in scope.
         */
        async computeScopes(document2, cancelToken) {
          const scopeComputation = this.serviceRegistry.getServices(document2.uri).references.ScopeComputation;
          document2.precomputedScopes = await scopeComputation.computeLocalScopes(document2, cancelToken);
          document2.state = documents_1.DocumentState.ComputedScopes;
        }
        /**
         * Determine whether the given document should be validated during a build. The default
         * implementation checks the `validationChecks` property of the build options.
         */
        shouldValidate(_document, options) {
          return options.validationChecks === "all";
        }
        /**
         * Run validation checks on the given document and store the resulting diagnostics in the document.
         */
        async validate(document2, cancelToken) {
          const validator = this.serviceRegistry.getServices(document2.uri).validation.DocumentValidator;
          const diagnostics = await validator.validateDocument(document2, cancelToken);
          document2.diagnostics = diagnostics;
          document2.state = documents_1.DocumentState.Validated;
        }
      };
      exports2.DefaultDocumentBuilder = DefaultDocumentBuilder;
    }
  });

  // node_modules/langium/lib/workspace/index-manager.js
  var require_index_manager = __commonJS({
    "node_modules/langium/lib/workspace/index-manager.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DefaultIndexManager = void 0;
      var vscode_languageserver_1 = require_main4();
      var ast_util_1 = require_ast_util();
      var stream_1 = require_stream();
      var uri_util_1 = require_uri_util();
      var documents_1 = require_documents();
      var DefaultIndexManager = class {
        constructor(services) {
          this.simpleIndex = /* @__PURE__ */ new Map();
          this.referenceIndex = /* @__PURE__ */ new Map();
          this.globalScopeCache = /* @__PURE__ */ new Map();
          this.serviceRegistry = services.ServiceRegistry;
          this.astReflection = services.AstReflection;
          this.langiumDocuments = () => services.workspace.LangiumDocuments;
        }
        findAllReferences(targetNode, astNodePath) {
          const targetDocUri = (0, ast_util_1.getDocument)(targetNode).uri;
          const result = [];
          this.referenceIndex.forEach((docRefs) => {
            docRefs.forEach((refDescr) => {
              if ((0, uri_util_1.equalURI)(refDescr.targetUri, targetDocUri) && refDescr.targetPath === astNodePath) {
                result.push(refDescr);
              }
            });
          });
          return (0, stream_1.stream)(result);
        }
        allElements(nodeType = "") {
          if (!this.globalScopeCache.has("")) {
            this.globalScopeCache.set("", Array.from(this.simpleIndex.values()).flat());
          }
          const cached = this.globalScopeCache.get(nodeType);
          if (cached) {
            return (0, stream_1.stream)(cached);
          } else {
            const elements = this.globalScopeCache.get("").filter((e) => this.astReflection.isSubtype(e.type, nodeType));
            this.globalScopeCache.set(nodeType, elements);
            return (0, stream_1.stream)(elements);
          }
        }
        remove(uris) {
          for (const uri of uris) {
            const uriString = uri.toString();
            this.simpleIndex.delete(uriString);
            this.referenceIndex.delete(uriString);
            this.globalScopeCache.clear();
          }
        }
        async updateContent(document2, cancelToken = vscode_languageserver_1.CancellationToken.None) {
          this.globalScopeCache.clear();
          const services = this.serviceRegistry.getServices(document2.uri);
          const exports3 = await services.references.ScopeComputation.computeExports(document2, cancelToken);
          for (const data of exports3) {
            data.node = void 0;
          }
          this.simpleIndex.set(document2.uri.toString(), exports3);
          document2.state = documents_1.DocumentState.IndexedContent;
        }
        async updateReferences(document2, cancelToken = vscode_languageserver_1.CancellationToken.None) {
          const services = this.serviceRegistry.getServices(document2.uri);
          const indexData = await services.workspace.ReferenceDescriptionProvider.createDescriptions(document2, cancelToken);
          this.referenceIndex.set(document2.uri.toString(), indexData);
          document2.state = documents_1.DocumentState.IndexedReferences;
        }
        getAffectedDocuments(uris) {
          return this.langiumDocuments().all.filter((e) => {
            if (uris.some((uri) => (0, uri_util_1.equalURI)(e.uri, uri))) {
              return false;
            }
            for (const uri of uris) {
              if (this.isAffected(e, uri)) {
                return true;
              }
            }
            return false;
          });
        }
        /**
         * Determine whether the given document could be affected by a change of the document
         * identified by the given URI (second parameter).
         */
        isAffected(document2, changed) {
          const changedUriString = changed.toString();
          const documentUri = document2.uri.toString();
          if (document2.references.some((e) => e.error !== void 0)) {
            return true;
          }
          const references = this.referenceIndex.get(documentUri);
          if (references) {
            return references.filter((e) => !e.local).some((e) => (0, uri_util_1.equalURI)(e.targetUri, changedUriString));
          }
          return false;
        }
      };
      exports2.DefaultIndexManager = DefaultIndexManager;
    }
  });

  // node_modules/langium/lib/workspace/workspace-manager.js
  var require_workspace_manager = __commonJS({
    "node_modules/langium/lib/workspace/workspace-manager.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DefaultWorkspaceManager = void 0;
      var vscode_languageserver_1 = require_main4();
      var vscode_uri_1 = require_umd();
      var promise_util_1 = require_promise_util();
      var DefaultWorkspaceManager = class {
        constructor(services) {
          this.serviceRegistry = services.ServiceRegistry;
          this.langiumDocuments = services.workspace.LangiumDocuments;
          this.documentBuilder = services.workspace.DocumentBuilder;
          this.fileSystemProvider = services.workspace.FileSystemProvider;
          this.mutex = services.workspace.MutexLock;
          services.lsp.LanguageServer.onInitialize((params) => {
            var _a4;
            this.folders = (_a4 = params.workspaceFolders) !== null && _a4 !== void 0 ? _a4 : void 0;
          });
          services.lsp.LanguageServer.onInitialized((_params) => {
            this.mutex.lock((token) => {
              var _a4;
              return this.initializeWorkspace((_a4 = this.folders) !== null && _a4 !== void 0 ? _a4 : [], token);
            });
          });
        }
        async initializeWorkspace(folders, cancelToken = vscode_languageserver_1.CancellationToken.None) {
          const fileExtensions = this.serviceRegistry.all.flatMap((e) => e.LanguageMetaData.fileExtensions);
          const documents = [];
          const collector = (document2) => {
            documents.push(document2);
            if (!this.langiumDocuments.hasDocument(document2.uri)) {
              this.langiumDocuments.addDocument(document2);
            }
          };
          await this.loadAdditionalDocuments(folders, collector);
          await Promise.all(folders.map((wf) => [wf, this.getRootFolder(wf)]).map(async (entry) => this.traverseFolder(...entry, fileExtensions, collector)));
          await (0, promise_util_1.interruptAndCheck)(cancelToken);
          await this.documentBuilder.build(documents, void 0, cancelToken);
        }
        /**
         * Load all additional documents that shall be visible in the context of the given workspace
         * folders and add them to the collector. This can be used to include built-in libraries of
         * your language, which can be either loaded from provided files or constructed in memory.
         */
        loadAdditionalDocuments(_folders, _collector) {
          return Promise.resolve();
        }
        /**
         * Determine the root folder of the source documents in the given workspace folder.
         * The default implementation returns the URI of the workspace folder, but you can override
         * this to return a subfolder like `src` instead.
         */
        getRootFolder(workspaceFolder) {
          return vscode_uri_1.URI.parse(workspaceFolder.uri);
        }
        /**
         * Traverse the file system folder identified by the given URI and its subfolders. All
         * contained files that match the file extensions are added to the collector.
         */
        async traverseFolder(workspaceFolder, folderPath, fileExtensions, collector) {
          const content = await this.fileSystemProvider.readDirectory(folderPath);
          await Promise.all(content.map(async (entry) => {
            if (this.includeEntry(workspaceFolder, entry, fileExtensions)) {
              if (entry.isDirectory) {
                await this.traverseFolder(workspaceFolder, entry.uri, fileExtensions, collector);
              } else if (entry.isFile) {
                const document2 = this.langiumDocuments.getOrCreateDocument(entry.uri);
                collector(document2);
              }
            }
          }));
        }
        /**
         * Determine whether the given folder entry shall be included while indexing the workspace.
         */
        includeEntry(workspaceFolder, entry, fileExtensions) {
          const name = vscode_uri_1.Utils.basename(entry.uri);
          if (name.startsWith(".")) {
            return false;
          }
          if (entry.isDirectory) {
            return name !== "node_modules" && name !== "out";
          } else if (entry.isFile) {
            const extname3 = vscode_uri_1.Utils.extname(entry.uri);
            return fileExtensions.includes(extname3);
          }
          return false;
        }
      };
      exports2.DefaultWorkspaceManager = DefaultWorkspaceManager;
    }
  });

  // node_modules/langium/lib/parser/lexer.js
  var require_lexer2 = __commonJS({
    "node_modules/langium/lib/parser/lexer.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.isTokenTypeDictionary = exports2.isIMultiModeLexerDefinition = exports2.isTokenTypeArray = exports2.DefaultLexer = void 0;
      var chevrotain_1 = require_api7();
      var DefaultLexer = class {
        constructor(services) {
          const tokens = services.parser.TokenBuilder.buildTokens(services.Grammar, {
            caseInsensitive: services.LanguageMetaData.caseInsensitive
          });
          this.tokenTypes = this.toTokenTypeDictionary(tokens);
          const lexerTokens = isTokenTypeDictionary(tokens) ? Object.values(tokens) : tokens;
          this.chevrotainLexer = new chevrotain_1.Lexer(lexerTokens);
        }
        get definition() {
          return this.tokenTypes;
        }
        tokenize(text) {
          var _a4;
          const chevrotainResult = this.chevrotainLexer.tokenize(text);
          return {
            tokens: chevrotainResult.tokens,
            errors: chevrotainResult.errors,
            hidden: (_a4 = chevrotainResult.groups.hidden) !== null && _a4 !== void 0 ? _a4 : []
          };
        }
        toTokenTypeDictionary(buildTokens) {
          if (isTokenTypeDictionary(buildTokens))
            return buildTokens;
          const tokens = isIMultiModeLexerDefinition(buildTokens) ? Object.values(buildTokens.modes).flat() : buildTokens;
          const res = {};
          tokens.forEach((token) => res[token.name] = token);
          return res;
        }
      };
      exports2.DefaultLexer = DefaultLexer;
      function isTokenTypeArray(tokenVocabulary) {
        return Array.isArray(tokenVocabulary) && (tokenVocabulary.length === 0 || "name" in tokenVocabulary[0]);
      }
      exports2.isTokenTypeArray = isTokenTypeArray;
      function isIMultiModeLexerDefinition(tokenVocabulary) {
        return tokenVocabulary && "modes" in tokenVocabulary && "defaultMode" in tokenVocabulary;
      }
      exports2.isIMultiModeLexerDefinition = isIMultiModeLexerDefinition;
      function isTokenTypeDictionary(tokenVocabulary) {
        return !isTokenTypeArray(tokenVocabulary) && !isIMultiModeLexerDefinition(tokenVocabulary);
      }
      exports2.isTokenTypeDictionary = isTokenTypeDictionary;
    }
  });

  // node_modules/langium/lib/documentation/jsdoc.js
  var require_jsdoc = __commonJS({
    "node_modules/langium/lib/documentation/jsdoc.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.isJSDoc = exports2.parseJSDoc = void 0;
      var vscode_languageserver_1 = require_main4();
      var vscode_uri_1 = require_umd();
      var template_string_1 = require_template_string();
      var regex_util_1 = require_regex_util();
      function parseJSDoc(node, start, options) {
        let opts;
        let position;
        if (typeof node === "string") {
          position = start;
          opts = options;
        } else {
          position = node.range.start;
          opts = start;
        }
        if (!position) {
          position = vscode_languageserver_1.Position.create(0, 0);
        }
        const lines = getLines(node);
        const normalizedOptions = normalizeOptions(opts);
        const tokens = tokenize({
          lines,
          position,
          options: normalizedOptions
        });
        return parseJSDocComment({
          index: 0,
          tokens,
          position
        });
      }
      exports2.parseJSDoc = parseJSDoc;
      function isJSDoc(node, options) {
        const normalizedOptions = normalizeOptions(options);
        const lines = getLines(node);
        if (lines.length === 0) {
          return false;
        }
        const first = lines[0];
        const last = lines[lines.length - 1];
        const firstRegex = normalizedOptions.start;
        const lastRegex = normalizedOptions.end;
        return Boolean(firstRegex === null || firstRegex === void 0 ? void 0 : firstRegex.exec(first)) && Boolean(lastRegex === null || lastRegex === void 0 ? void 0 : lastRegex.exec(last));
      }
      exports2.isJSDoc = isJSDoc;
      function getLines(node) {
        let content = "";
        if (typeof node === "string") {
          content = node;
        } else {
          content = node.text;
        }
        const lines = content.split(template_string_1.NEWLINE_REGEXP);
        return lines;
      }
      var tagRegex = /\s*(@([\p{L}][\p{L}\p{N}]*)?)/uy;
      var inlineTagRegex = /\{(@[\p{L}][\p{L}\p{N}]*)(\s*)([^\r\n}]+)?\}/gu;
      function tokenize(context) {
        var _a4, _b2, _c2;
        const tokens = [];
        let currentLine = context.position.line;
        let currentCharacter = context.position.character;
        for (let i = 0; i < context.lines.length; i++) {
          const first = i === 0;
          const last = i === context.lines.length - 1;
          let line = context.lines[i];
          let index = 0;
          if (first && context.options.start) {
            const match = (_a4 = context.options.start) === null || _a4 === void 0 ? void 0 : _a4.exec(line);
            if (match) {
              index = match.index + match[0].length;
            }
          } else {
            const match = (_b2 = context.options.line) === null || _b2 === void 0 ? void 0 : _b2.exec(line);
            if (match) {
              index = match.index + match[0].length;
            }
          }
          if (last) {
            const match = (_c2 = context.options.end) === null || _c2 === void 0 ? void 0 : _c2.exec(line);
            if (match) {
              line = line.substring(0, match.index);
            }
          }
          line = line.substring(0, lastCharacter(line));
          const whitespaceEnd = skipWhitespace(line, 0);
          if (whitespaceEnd >= line.length) {
            if (tokens.length > 0) {
              const position = vscode_languageserver_1.Position.create(currentLine, currentCharacter);
              tokens.push({
                type: "break",
                content: "",
                range: vscode_languageserver_1.Range.create(position, position)
              });
            }
          } else {
            tagRegex.lastIndex = index;
            const tagMatch = tagRegex.exec(line);
            if (tagMatch) {
              const fullMatch = tagMatch[0];
              const value = tagMatch[1];
              const start = vscode_languageserver_1.Position.create(currentLine, currentCharacter + index);
              const end = vscode_languageserver_1.Position.create(currentLine, currentCharacter + index + fullMatch.length);
              tokens.push({
                type: "tag",
                content: value,
                range: vscode_languageserver_1.Range.create(start, end)
              });
              index += fullMatch.length;
              index = skipWhitespace(line, index);
            }
            if (index < line.length) {
              const rest = line.substring(index);
              const inlineTagMatches = Array.from(rest.matchAll(inlineTagRegex));
              tokens.push(...buildInlineTokens(inlineTagMatches, rest, currentLine, currentCharacter + index));
            }
          }
          currentLine++;
          currentCharacter = 0;
        }
        if (tokens.length > 0 && tokens[tokens.length - 1].type === "break") {
          return tokens.slice(0, -1);
        }
        return tokens;
      }
      function buildInlineTokens(tags, line, lineIndex, characterIndex) {
        const tokens = [];
        if (tags.length === 0) {
          const start = vscode_languageserver_1.Position.create(lineIndex, characterIndex);
          const end = vscode_languageserver_1.Position.create(lineIndex, characterIndex + line.length);
          tokens.push({
            type: "text",
            content: line,
            range: vscode_languageserver_1.Range.create(start, end)
          });
        } else {
          let lastIndex = 0;
          for (const match of tags) {
            const matchIndex = match.index;
            const startContent = line.substring(lastIndex, matchIndex);
            if (startContent.length > 0) {
              tokens.push({
                type: "text",
                content: line.substring(lastIndex, matchIndex),
                range: vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(lineIndex, lastIndex + characterIndex), vscode_languageserver_1.Position.create(lineIndex, matchIndex + characterIndex))
              });
            }
            let offset = startContent.length + 1;
            const tagName = match[1];
            tokens.push({
              type: "inline-tag",
              content: tagName,
              range: vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(lineIndex, lastIndex + offset + characterIndex), vscode_languageserver_1.Position.create(lineIndex, lastIndex + offset + tagName.length + characterIndex))
            });
            offset += tagName.length;
            if (match.length === 4) {
              offset += match[2].length;
              const value = match[3];
              tokens.push({
                type: "text",
                content: value,
                range: vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(lineIndex, lastIndex + offset + characterIndex), vscode_languageserver_1.Position.create(lineIndex, lastIndex + offset + value.length + characterIndex))
              });
            } else {
              tokens.push({
                type: "text",
                content: "",
                range: vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(lineIndex, lastIndex + offset + characterIndex), vscode_languageserver_1.Position.create(lineIndex, lastIndex + offset + characterIndex))
              });
            }
            lastIndex = matchIndex + match[0].length;
          }
          const endContent = line.substring(lastIndex);
          if (endContent.length > 0) {
            tokens.push({
              type: "text",
              content: endContent,
              range: vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(lineIndex, lastIndex + characterIndex), vscode_languageserver_1.Position.create(lineIndex, lastIndex + characterIndex + endContent.length))
            });
          }
        }
        return tokens;
      }
      var nonWhitespaceRegex = /\S/;
      var whitespaceEndRegex = /\s*$/;
      function skipWhitespace(line, index) {
        const match = line.substring(index).match(nonWhitespaceRegex);
        if (match) {
          return index + match.index;
        } else {
          return line.length;
        }
      }
      function lastCharacter(line) {
        const match = line.match(whitespaceEndRegex);
        if (match && typeof match.index === "number") {
          return match.index;
        }
        return void 0;
      }
      function parseJSDocComment(context) {
        var _a4, _b2, _c2, _d;
        const startPosition = vscode_languageserver_1.Position.create(context.position.line, context.position.character);
        if (context.tokens.length === 0) {
          return new JSDocCommentImpl([], vscode_languageserver_1.Range.create(startPosition, startPosition));
        }
        const elements = [];
        while (context.index < context.tokens.length) {
          const element = parseJSDocElement(context, elements[elements.length - 1]);
          if (element) {
            elements.push(element);
          }
        }
        const start = (_b2 = (_a4 = elements[0]) === null || _a4 === void 0 ? void 0 : _a4.range.start) !== null && _b2 !== void 0 ? _b2 : startPosition;
        const end = (_d = (_c2 = elements[elements.length - 1]) === null || _c2 === void 0 ? void 0 : _c2.range.end) !== null && _d !== void 0 ? _d : startPosition;
        return new JSDocCommentImpl(elements, vscode_languageserver_1.Range.create(start, end));
      }
      function parseJSDocElement(context, last) {
        const next = context.tokens[context.index];
        if (next.type === "tag") {
          return parseJSDocTag(context, false);
        } else if (next.type === "text" || next.type === "inline-tag") {
          return parseJSDocText(context);
        } else {
          appendEmptyLine(next, last);
          context.index++;
          return void 0;
        }
      }
      function appendEmptyLine(token, element) {
        if (element) {
          const line = new JSDocLineImpl("", token.range);
          if ("inlines" in element) {
            element.inlines.push(line);
          } else {
            element.content.inlines.push(line);
          }
        }
      }
      function parseJSDocText(context) {
        let token = context.tokens[context.index];
        const firstToken = token;
        let lastToken = token;
        const lines = [];
        while (token && token.type !== "break" && token.type !== "tag") {
          lines.push(parseJSDocInline(context));
          lastToken = token;
          token = context.tokens[context.index];
        }
        return new JSDocTextImpl(lines, vscode_languageserver_1.Range.create(firstToken.range.start, lastToken.range.end));
      }
      function parseJSDocInline(context) {
        const token = context.tokens[context.index];
        if (token.type === "inline-tag") {
          return parseJSDocTag(context, true);
        } else {
          return parseJSDocLine(context);
        }
      }
      function parseJSDocTag(context, inline) {
        const tagToken = context.tokens[context.index++];
        const name = tagToken.content.substring(1);
        const nextToken = context.tokens[context.index];
        if ((nextToken === null || nextToken === void 0 ? void 0 : nextToken.type) === "text") {
          if (inline) {
            const docLine = parseJSDocLine(context);
            return new JSDocTagImpl(name, new JSDocTextImpl([docLine], docLine.range), inline, vscode_languageserver_1.Range.create(tagToken.range.start, docLine.range.end));
          } else {
            const textDoc = parseJSDocText(context);
            return new JSDocTagImpl(name, textDoc, inline, vscode_languageserver_1.Range.create(tagToken.range.start, textDoc.range.end));
          }
        } else {
          const range = tagToken.range;
          return new JSDocTagImpl(name, new JSDocTextImpl([], range), inline, range);
        }
      }
      function parseJSDocLine(context) {
        const token = context.tokens[context.index++];
        return new JSDocLineImpl(token.content, token.range);
      }
      function normalizeOptions(options) {
        if (!options) {
          return normalizeOptions({
            start: "/**",
            end: "*/",
            line: "*"
          });
        }
        const { start, end, line } = options;
        return {
          start: normalizeOption(start, true),
          end: normalizeOption(end, false),
          line: normalizeOption(line, true)
        };
      }
      function normalizeOption(option, start) {
        if (typeof option === "string" || typeof option === "object") {
          const escaped = typeof option === "string" ? (0, regex_util_1.escapeRegExp)(option) : option.source;
          if (start) {
            return new RegExp(`^\\s*${escaped}`);
          } else {
            return new RegExp(`\\s*${escaped}\\s*$`);
          }
        } else {
          return option;
        }
      }
      var JSDocCommentImpl = class {
        constructor(elements, range) {
          this.elements = elements;
          this.range = range;
        }
        getTag(name) {
          return this.getAllTags().find((e) => e.name === name);
        }
        getTags(name) {
          return this.getAllTags().filter((e) => e.name === name);
        }
        getAllTags() {
          return this.elements.filter((e) => "name" in e);
        }
        toString() {
          let value = "";
          for (const element of this.elements) {
            if (value.length === 0) {
              value = element.toString();
            } else {
              const text = element.toString();
              value += fillNewlines(value) + text;
            }
          }
          return value.trim();
        }
        toMarkdown(options) {
          let value = "";
          for (const element of this.elements) {
            if (value.length === 0) {
              value = element.toMarkdown(options);
            } else {
              const text = element.toMarkdown(options);
              value += fillNewlines(value) + text;
            }
          }
          return value.trim();
        }
      };
      var JSDocTagImpl = class {
        constructor(name, content, inline, range) {
          this.name = name;
          this.content = content;
          this.inline = inline;
          this.range = range;
        }
        toString() {
          let text = `@${this.name}`;
          const content = this.content.toString();
          if (this.content.inlines.length === 1) {
            text = `${text} ${content}`;
          } else if (this.content.inlines.length > 1) {
            text = `${text}
${content}`;
          }
          if (this.inline) {
            return `{${text}}`;
          } else {
            return text;
          }
        }
        toMarkdown(options) {
          const content = this.content.toMarkdown(options);
          if (this.inline) {
            const rendered = renderInlineTag(this.name, content, options !== null && options !== void 0 ? options : {});
            if (typeof rendered === "string") {
              return rendered;
            }
          }
          let marker = "";
          if ((options === null || options === void 0 ? void 0 : options.tag) === "italic" || (options === null || options === void 0 ? void 0 : options.tag) === void 0) {
            marker = "*";
          } else if ((options === null || options === void 0 ? void 0 : options.tag) === "bold") {
            marker = "**";
          } else if ((options === null || options === void 0 ? void 0 : options.tag) === "bold-italic") {
            marker = "***";
          }
          let text = `${marker}@${this.name}${marker}`;
          if (this.content.inlines.length === 1) {
            text = `${text} \u2014 ${content}`;
          } else if (this.content.inlines.length > 1) {
            text = `${text}
${content}`;
          }
          if (this.inline) {
            return `{${text}}`;
          } else {
            return text;
          }
        }
      };
      function renderInlineTag(tag, content, options) {
        var _a4, _b2;
        if (tag === "linkplain" || tag === "linkcode" || tag === "link") {
          const index = content.indexOf(" ");
          let display = content;
          if (index > 0) {
            const displayStart = skipWhitespace(content, index);
            display = content.substring(displayStart);
            content = content.substring(0, index);
          }
          if (tag === "linkcode" || tag === "link" && options.link === "code") {
            display = `\`${display}\``;
          }
          const renderedLink = (_b2 = (_a4 = options.renderLink) === null || _a4 === void 0 ? void 0 : _a4.call(options, content, display)) !== null && _b2 !== void 0 ? _b2 : renderLinkDefault(content, display);
          return renderedLink;
        }
        return void 0;
      }
      function renderLinkDefault(content, display) {
        try {
          vscode_uri_1.URI.parse(content, true);
          return `[${display}](${content})`;
        } catch (_a4) {
          return content;
        }
      }
      var JSDocTextImpl = class {
        constructor(lines, range) {
          this.inlines = lines;
          this.range = range;
        }
        toString() {
          let text = "";
          for (let i = 0; i < this.inlines.length; i++) {
            const inline = this.inlines[i];
            const next = this.inlines[i + 1];
            text += inline.toString();
            if (next && next.range.start.line > inline.range.start.line) {
              text += "\n";
            }
          }
          return text;
        }
        toMarkdown(options) {
          let text = "";
          for (let i = 0; i < this.inlines.length; i++) {
            const inline = this.inlines[i];
            const next = this.inlines[i + 1];
            text += inline.toMarkdown(options);
            if (next && next.range.start.line > inline.range.start.line) {
              text += "\n";
            }
          }
          return text;
        }
      };
      var JSDocLineImpl = class {
        constructor(text, range) {
          this.text = text;
          this.range = range;
        }
        toString() {
          return this.text;
        }
        toMarkdown() {
          return this.text;
        }
      };
      function fillNewlines(text) {
        if (text.endsWith("\n")) {
          return "\n";
        } else {
          return "\n\n";
        }
      }
    }
  });

  // node_modules/langium/lib/documentation/documentation-provider.js
  var require_documentation_provider = __commonJS({
    "node_modules/langium/lib/documentation/documentation-provider.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.JSDocDocumentationProvider = void 0;
      var syntax_tree_1 = require_syntax_tree();
      var ast_util_1 = require_ast_util();
      var cst_util_1 = require_cst_util();
      var jsdoc_1 = require_jsdoc();
      var JSDocDocumentationProvider = class {
        constructor(services) {
          this.indexManager = services.shared.workspace.IndexManager;
          this.grammarConfig = services.parser.GrammarConfig;
        }
        getDocumentation(node) {
          const lastNode = (0, cst_util_1.findCommentNode)(node.$cstNode, this.grammarConfig.multilineCommentRules);
          if ((0, syntax_tree_1.isLeafCstNode)(lastNode) && (0, jsdoc_1.isJSDoc)(lastNode)) {
            const parsedJSDoc = (0, jsdoc_1.parseJSDoc)(lastNode);
            return parsedJSDoc.toMarkdown({
              renderLink: (link, display) => {
                return this.documentationLinkRenderer(node, link, display);
              }
            });
          }
          return void 0;
        }
        documentationLinkRenderer(node, name, display) {
          var _a4;
          const description = (_a4 = this.findNameInPrecomputedScopes(node, name)) !== null && _a4 !== void 0 ? _a4 : this.findNameInGlobalScope(node, name);
          if (description && description.nameSegment) {
            const line = description.nameSegment.range.start.line + 1;
            const character = description.nameSegment.range.start.character + 1;
            const uri = description.documentUri.with({ fragment: `L${line},${character}` });
            return `[${display}](${uri.toString()})`;
          } else {
            return void 0;
          }
        }
        findNameInPrecomputedScopes(node, name) {
          const document2 = (0, ast_util_1.getDocument)(node);
          const precomputed = document2.precomputedScopes;
          if (!precomputed) {
            return void 0;
          }
          let currentNode = node;
          do {
            const allDescriptions = precomputed.get(currentNode);
            const description = allDescriptions.find((e) => e.name === name);
            if (description) {
              return description;
            }
            currentNode = currentNode.$container;
          } while (currentNode);
          return void 0;
        }
        findNameInGlobalScope(node, name) {
          const description = this.indexManager.allElements().find((e) => e.name === name);
          return description;
        }
      };
      exports2.JSDocDocumentationProvider = JSDocDocumentationProvider;
    }
  });

  // node_modules/langium/lib/documentation/index.js
  var require_documentation = __commonJS({
    "node_modules/langium/lib/documentation/index.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_documentation_provider(), exports2);
      __exportStar(require_jsdoc(), exports2);
    }
  });

  // node_modules/langium/lib/default-module.js
  var require_default_module = __commonJS({
    "node_modules/langium/lib/default-module.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createDefaultSharedModule = exports2.createDefaultModule = void 0;
      var vscode_languageserver_1 = require_main4();
      var vscode_languageserver_textdocument_1 = require_main5();
      var grammar_config_1 = require_grammar_config();
      var completion_parser_builder_1 = require_completion_parser_builder();
      var completion_provider_1 = require_completion_provider();
      var document_highlight_provider_1 = require_document_highlight_provider();
      var document_symbol_provider_1 = require_document_symbol_provider();
      var folding_range_provider_1 = require_folding_range_provider();
      var definition_provider_1 = require_definition_provider();
      var hover_provider_1 = require_hover_provider();
      var language_server_1 = require_language_server();
      var references_provider_1 = require_references_provider();
      var rename_provider_1 = require_rename_provider();
      var langium_parser_builder_1 = require_langium_parser_builder();
      var token_builder_1 = require_token_builder();
      var value_converter_1 = require_value_converter();
      var linker_1 = require_linker();
      var name_provider_1 = require_name_provider();
      var references_1 = require_references();
      var scope_computation_1 = require_scope_computation();
      var scope_provider_1 = require_scope_provider();
      var json_serializer_1 = require_json_serializer();
      var service_registry_1 = require_service_registry();
      var promise_util_1 = require_promise_util();
      var document_validator_1 = require_document_validator();
      var validation_registry_1 = require_validation_registry();
      var ast_descriptions_1 = require_ast_descriptions();
      var ast_node_locator_1 = require_ast_node_locator();
      var configuration_1 = require_configuration2();
      var document_builder_1 = require_document_builder();
      var documents_1 = require_documents();
      var index_manager_1 = require_index_manager();
      var workspace_manager_1 = require_workspace_manager();
      var lexer_1 = require_lexer2();
      var documentation_1 = require_documentation();
      function createDefaultModule(context) {
        return {
          documentation: {
            DocumentationProvider: (services) => new documentation_1.JSDocDocumentationProvider(services)
          },
          parser: {
            GrammarConfig: (services) => (0, grammar_config_1.createGrammarConfig)(services),
            LangiumParser: (services) => (0, langium_parser_builder_1.createLangiumParser)(services),
            CompletionParser: (services) => (0, completion_parser_builder_1.createCompletionParser)(services),
            ValueConverter: () => new value_converter_1.DefaultValueConverter(),
            TokenBuilder: () => new token_builder_1.DefaultTokenBuilder(),
            Lexer: (services) => new lexer_1.DefaultLexer(services)
          },
          lsp: {
            CompletionProvider: (services) => new completion_provider_1.DefaultCompletionProvider(services),
            DocumentSymbolProvider: (services) => new document_symbol_provider_1.DefaultDocumentSymbolProvider(services),
            HoverProvider: (services) => new hover_provider_1.MultilineCommentHoverProvider(services),
            FoldingRangeProvider: (services) => new folding_range_provider_1.DefaultFoldingRangeProvider(services),
            ReferencesProvider: (services) => new references_provider_1.DefaultReferencesProvider(services),
            DefinitionProvider: (services) => new definition_provider_1.DefaultDefinitionProvider(services),
            DocumentHighlightProvider: (services) => new document_highlight_provider_1.DefaultDocumentHighlightProvider(services),
            RenameProvider: (services) => new rename_provider_1.DefaultRenameProvider(services)
          },
          workspace: {
            AstNodeLocator: () => new ast_node_locator_1.DefaultAstNodeLocator(),
            AstNodeDescriptionProvider: (services) => new ast_descriptions_1.DefaultAstNodeDescriptionProvider(services),
            ReferenceDescriptionProvider: (services) => new ast_descriptions_1.DefaultReferenceDescriptionProvider(services)
          },
          references: {
            Linker: (services) => new linker_1.DefaultLinker(services),
            NameProvider: () => new name_provider_1.DefaultNameProvider(),
            ScopeProvider: (services) => new scope_provider_1.DefaultScopeProvider(services),
            ScopeComputation: (services) => new scope_computation_1.DefaultScopeComputation(services),
            References: (services) => new references_1.DefaultReferences(services)
          },
          serializer: {
            JsonSerializer: (services) => new json_serializer_1.DefaultJsonSerializer(services)
          },
          validation: {
            DocumentValidator: (services) => new document_validator_1.DefaultDocumentValidator(services),
            ValidationRegistry: (services) => new validation_registry_1.ValidationRegistry(services)
          },
          shared: () => context.shared
        };
      }
      exports2.createDefaultModule = createDefaultModule;
      function createDefaultSharedModule(context) {
        return {
          ServiceRegistry: () => new service_registry_1.DefaultServiceRegistry(),
          lsp: {
            Connection: () => context.connection,
            LanguageServer: (services) => new language_server_1.DefaultLanguageServer(services)
          },
          workspace: {
            LangiumDocuments: (services) => new documents_1.DefaultLangiumDocuments(services),
            LangiumDocumentFactory: (services) => new documents_1.DefaultLangiumDocumentFactory(services),
            DocumentBuilder: (services) => new document_builder_1.DefaultDocumentBuilder(services),
            TextDocuments: () => new vscode_languageserver_1.TextDocuments(vscode_languageserver_textdocument_1.TextDocument),
            IndexManager: (services) => new index_manager_1.DefaultIndexManager(services),
            WorkspaceManager: (services) => new workspace_manager_1.DefaultWorkspaceManager(services),
            FileSystemProvider: (services) => context.fileSystemProvider(services),
            MutexLock: () => new promise_util_1.MutexLock(),
            ConfigurationProvider: (services) => new configuration_1.DefaultConfigurationProvider(services)
          }
        };
      }
      exports2.createDefaultSharedModule = createDefaultSharedModule;
    }
  });

  // node_modules/langium/lib/services.js
  var require_services = __commonJS({
    "node_modules/langium/lib/services.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
    }
  });

  // node_modules/langium/lib/generator/node-joiner.js
  var require_node_joiner = __commonJS({
    "node_modules/langium/lib/generator/node-joiner.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.joinTracedToNodeIf = exports2.joinTracedToNode = exports2.joinToNode = void 0;
      var generator_node_1 = require_generator_node();
      function joinToNode(iterable, toGenerated = String, { filter, prefix, suffix, separator, appendNewLineIfNotEmpty } = {}) {
        return reduceWithIsLast(iterable, (node, it, i, isLast) => {
          if (filter && !filter(it, i, isLast)) {
            return node;
          }
          const content = toGenerated(it, i, isLast);
          return (node !== null && node !== void 0 ? node : node = new generator_node_1.CompositeGeneratorNode()).append(prefix && prefix(it, i, isLast)).append(content).append(suffix && suffix(it, i, isLast)).appendIf(!isLast && content !== void 0, separator).appendNewLineIfNotEmptyIf(
            // append 'newLineIfNotEmpty' elements only if 'node' has some content already,
            //  as if the parent is an IndentNode with 'indentImmediately' set to 'false'
            //  the indentation is not properly applied to the first non-empty line of the (this) child node
            !node.isEmpty() && !!appendNewLineIfNotEmpty
          );
        });
      }
      exports2.joinToNode = joinToNode;
      function joinTracedToNode(source, property) {
        return (iterable, toGenerated = String, options) => {
          return (0, generator_node_1.traceToNode)(source, property)(joinToNode(iterable, source && property ? (element, index, isLast) => (0, generator_node_1.traceToNode)(source, property, index)(toGenerated(element, index, isLast)) : toGenerated, options));
        };
      }
      exports2.joinTracedToNode = joinTracedToNode;
      function joinTracedToNodeIf(condition, source, property) {
        return condition ? joinTracedToNode(typeof source === "function" ? source() : source, property) : () => void 0;
      }
      exports2.joinTracedToNodeIf = joinTracedToNodeIf;
      function reduceWithIsLast(iterable, callbackfn, initial) {
        const iterator = iterable[Symbol.iterator]();
        let next = iterator.next();
        let index = 0;
        let result = initial;
        while (!next.done) {
          const nextNext = iterator.next();
          result = callbackfn(result, next.value, index, Boolean(nextNext.done));
          next = nextNext;
          index++;
        }
        return result;
      }
    }
  });

  // node_modules/langium/lib/generator/index.js
  var require_generator = __commonJS({
    "node_modules/langium/lib/generator/index.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.normalizeEOL = exports2.expandToStringWithNL = exports2.expandToString = void 0;
      __exportStar(require_generator_node(), exports2);
      __exportStar(require_node_joiner(), exports2);
      __exportStar(require_template_node(), exports2);
      var template_string_1 = require_template_string();
      Object.defineProperty(exports2, "expandToString", { enumerable: true, get: function() {
        return template_string_1.expandToString;
      } });
      Object.defineProperty(exports2, "expandToStringWithNL", { enumerable: true, get: function() {
        return template_string_1.expandToStringWithNL;
      } });
      Object.defineProperty(exports2, "normalizeEOL", { enumerable: true, get: function() {
        return template_string_1.normalizeEOL;
      } });
    }
  });

  // node_modules/langium/lib/grammar/language-meta-data.js
  var require_language_meta_data = __commonJS({
    "node_modules/langium/lib/grammar/language-meta-data.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
    }
  });

  // node_modules/langium/lib/grammar/index.js
  var require_grammar2 = __commonJS({
    "node_modules/langium/lib/grammar/index.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_ast_reflection_interpreter(), exports2);
      __exportStar(require_grammar_config(), exports2);
      __exportStar(require_langium_grammar_module(), exports2);
      __exportStar(require_language_meta_data(), exports2);
    }
  });

  // node_modules/langium/lib/parser/parser-config.js
  var require_parser_config = __commonJS({
    "node_modules/langium/lib/parser/parser-config.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
    }
  });

  // node_modules/langium/lib/parser/index.js
  var require_parser2 = __commonJS({
    "node_modules/langium/lib/parser/index.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_completion_parser_builder(), exports2);
      __exportStar(require_cst_node_builder(), exports2);
      __exportStar(require_langium_parser_builder(), exports2);
      __exportStar(require_langium_parser(), exports2);
      __exportStar(require_lexer2(), exports2);
      __exportStar(require_parser_config(), exports2);
      __exportStar(require_token_builder(), exports2);
      __exportStar(require_value_converter(), exports2);
    }
  });

  // node_modules/langium/lib/references/index.js
  var require_references2 = __commonJS({
    "node_modules/langium/lib/references/index.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_linker(), exports2);
      __exportStar(require_name_provider(), exports2);
      __exportStar(require_references(), exports2);
      __exportStar(require_scope_computation(), exports2);
      __exportStar(require_scope_provider(), exports2);
    }
  });

  // node_modules/langium/lib/serializer/index.js
  var require_serializer = __commonJS({
    "node_modules/langium/lib/serializer/index.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_json_serializer(), exports2);
    }
  });

  // node_modules/langium/lib/utils/index.js
  var require_utils = __commonJS({
    "node_modules/langium/lib/utils/index.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_ast_util(), exports2);
      __exportStar(require_collections(), exports2);
      __exportStar(require_cst_util(), exports2);
      __exportStar(require_errors(), exports2);
      __exportStar(require_grammar_util(), exports2);
      __exportStar(require_promise_util(), exports2);
      __exportStar(require_regex_util(), exports2);
      __exportStar(require_stream(), exports2);
      __exportStar(require_uri_util(), exports2);
    }
  });

  // node_modules/langium/lib/validation/index.js
  var require_validation = __commonJS({
    "node_modules/langium/lib/validation/index.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_document_validator(), exports2);
      __exportStar(require_validation_registry(), exports2);
    }
  });

  // node_modules/langium/lib/workspace/index.js
  var require_workspace = __commonJS({
    "node_modules/langium/lib/workspace/index.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_ast_descriptions(), exports2);
      __exportStar(require_ast_node_locator(), exports2);
      __exportStar(require_configuration2(), exports2);
      __exportStar(require_document_builder(), exports2);
      __exportStar(require_documents(), exports2);
      __exportStar(require_file_system_provider(), exports2);
      __exportStar(require_index_manager(), exports2);
      __exportStar(require_workspace_manager(), exports2);
    }
  });

  // node_modules/langium/lib/index.js
  var require_lib2 = __commonJS({
    "node_modules/langium/lib/index.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      var __importStar = exports2 && exports2.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.GrammarAST = void 0;
      __exportStar(require_default_module(), exports2);
      __exportStar(require_dependency_injection(), exports2);
      __exportStar(require_service_registry(), exports2);
      __exportStar(require_services(), exports2);
      __exportStar(require_syntax_tree(), exports2);
      __exportStar(require_documentation(), exports2);
      __exportStar(require_generator(), exports2);
      __exportStar(require_grammar2(), exports2);
      __exportStar(require_lsp(), exports2);
      __exportStar(require_parser2(), exports2);
      __exportStar(require_references2(), exports2);
      __exportStar(require_serializer(), exports2);
      __exportStar(require_utils(), exports2);
      __exportStar(require_validation(), exports2);
      __exportStar(require_workspace(), exports2);
      var GrammarAST = __importStar(require_ast());
      exports2.GrammarAST = GrammarAST;
    }
  });

  // node_modules/vscode-languageserver/browser.js
  var require_browser3 = __commonJS({
    "node_modules/vscode-languageserver/browser.js"(exports2, module2) {
      "use strict";
      module2.exports = require_main4();
    }
  });

  // out/language/generated/ast.js
  var require_ast2 = __commonJS({
    "out/language/generated/ast.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.reflection = exports2.HelloWorldAstReflection = exports2.isPerson = exports2.Person = exports2.isModel = exports2.Model = exports2.isGreeting = exports2.Greeting = void 0;
      var langium_1 = require_lib2();
      exports2.Greeting = "Greeting";
      function isGreeting(item) {
        return exports2.reflection.isInstance(item, exports2.Greeting);
      }
      exports2.isGreeting = isGreeting;
      exports2.Model = "Model";
      function isModel(item) {
        return exports2.reflection.isInstance(item, exports2.Model);
      }
      exports2.isModel = isModel;
      exports2.Person = "Person";
      function isPerson(item) {
        return exports2.reflection.isInstance(item, exports2.Person);
      }
      exports2.isPerson = isPerson;
      var HelloWorldAstReflection = class extends langium_1.AbstractAstReflection {
        getAllTypes() {
          return ["Greeting", "Model", "Person"];
        }
        computeIsSubtype(subtype, supertype) {
          switch (subtype) {
            default: {
              return false;
            }
          }
        }
        getReferenceType(refInfo) {
          const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
          switch (referenceId) {
            case "Greeting:person": {
              return exports2.Person;
            }
            default: {
              throw new Error(`${referenceId} is not a valid reference id.`);
            }
          }
        }
        getTypeMetaData(type) {
          switch (type) {
            case "Model": {
              return {
                name: "Model",
                mandatory: [
                  { name: "greetings", type: "array" },
                  { name: "persons", type: "array" }
                ]
              };
            }
            default: {
              return {
                name: type,
                mandatory: []
              };
            }
          }
        }
      };
      exports2.HelloWorldAstReflection = HelloWorldAstReflection;
      exports2.reflection = new HelloWorldAstReflection();
    }
  });

  // out/language/generated/grammar.js
  var require_grammar3 = __commonJS({
    "out/language/generated/grammar.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.HelloWorldGrammar = void 0;
      var langium_1 = require_lib2();
      var loadedHelloWorldGrammar;
      var HelloWorldGrammar = () => loadedHelloWorldGrammar !== null && loadedHelloWorldGrammar !== void 0 ? loadedHelloWorldGrammar : loadedHelloWorldGrammar = (0, langium_1.loadGrammarFromJson)(`{
  "$type": "Grammar",
  "isDeclared": true,
  "name": "HelloWorld",
  "rules": [
    {
      "$type": "ParserRule",
      "name": "Model",
      "entry": true,
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "persons",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@1"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "greetings",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@2"
              },
              "arguments": []
            }
          }
        ],
        "cardinality": "*"
      },
      "definesHiddenTokens": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Person",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "person"
          },
          {
            "$type": "Assignment",
            "feature": "name",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@4"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Greeting",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "Hello"
          },
          {
            "$type": "Assignment",
            "feature": "person",
            "operator": "=",
            "terminal": {
              "$type": "CrossReference",
              "type": {
                "$ref": "#/rules@1"
              },
              "terminal": {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@4"
                },
                "arguments": []
              },
              "deprecatedSyntax": false
            }
          },
          {
            "$type": "Keyword",
            "value": "!"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "TerminalRule",
      "hidden": true,
      "name": "WS",
      "definition": {
        "$type": "RegexToken",
        "regex": "\\\\s+"
      },
      "fragment": false
    },
    {
      "$type": "TerminalRule",
      "name": "ID",
      "definition": {
        "$type": "RegexToken",
        "regex": "[_a-zA-Z][\\\\w_]*"
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "name": "INT",
      "type": {
        "$type": "ReturnType",
        "name": "number"
      },
      "definition": {
        "$type": "RegexToken",
        "regex": "[0-9]+"
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "name": "STRING",
      "definition": {
        "$type": "RegexToken",
        "regex": "\\"(\\\\\\\\.|[^\\"\\\\\\\\])*\\"|'(\\\\\\\\.|[^'\\\\\\\\])*'"
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "hidden": true,
      "name": "ML_COMMENT",
      "definition": {
        "$type": "RegexToken",
        "regex": "\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/"
      },
      "fragment": false
    },
    {
      "$type": "TerminalRule",
      "hidden": true,
      "name": "SL_COMMENT",
      "definition": {
        "$type": "RegexToken",
        "regex": "\\\\/\\\\/[^\\\\n\\\\r]*"
      },
      "fragment": false
    }
  ],
  "definesHiddenTokens": false,
  "hiddenTokens": [],
  "imports": [],
  "interfaces": [],
  "types": [],
  "usedGrammars": []
}`);
      exports2.HelloWorldGrammar = HelloWorldGrammar;
    }
  });

  // out/language/generated/module.js
  var require_module2 = __commonJS({
    "out/language/generated/module.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.HelloWorldGeneratedModule = exports2.HelloWorldGeneratedSharedModule = exports2.HelloWorldLanguageMetaData = void 0;
      var ast_1 = require_ast2();
      var grammar_1 = require_grammar3();
      exports2.HelloWorldLanguageMetaData = {
        languageId: "hello-world",
        fileExtensions: [".hello"],
        caseInsensitive: false
      };
      exports2.HelloWorldGeneratedSharedModule = {
        AstReflection: () => new ast_1.HelloWorldAstReflection()
      };
      exports2.HelloWorldGeneratedModule = {
        Grammar: () => (0, grammar_1.HelloWorldGrammar)(),
        LanguageMetaData: () => exports2.HelloWorldLanguageMetaData,
        parser: {}
      };
    }
  });

  // out/language/hello-world-validator.js
  var require_hello_world_validator = __commonJS({
    "out/language/hello-world-validator.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.HelloWorldValidator = exports2.registerValidationChecks = void 0;
      function registerValidationChecks(services) {
        const registry = services.validation.ValidationRegistry;
        const validator = services.validation.HelloWorldValidator;
        const checks = {
          Person: validator.checkPersonStartsWithCapital
        };
        registry.register(checks, validator);
      }
      exports2.registerValidationChecks = registerValidationChecks;
      var HelloWorldValidator = class {
        checkPersonStartsWithCapital(person, accept) {
          if (person.name) {
            const firstChar = person.name.substring(0, 1);
            if (firstChar.toUpperCase() !== firstChar) {
              accept("warning", "Person name should start with a capital.", { node: person, property: "name" });
            }
          }
        }
      };
      exports2.HelloWorldValidator = HelloWorldValidator;
    }
  });

  // out/language/hello-semantic-tokens.js
  var require_hello_semantic_tokens = __commonJS({
    "out/language/hello-semantic-tokens.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.HelloSemanticTokenProvider = void 0;
      var langium_1 = require_lib2();
      var ast_1 = require_ast();
      var vscode_languageserver_1 = require_main4();
      var HelloSemanticTokenProvider = class extends langium_1.AbstractSemanticTokenProvider {
        constructor(services) {
          super(services);
          this.services = services;
        }
        highlightElement(node, acceptor) {
          console.log(this.services.shared.workspace.LangiumDocuments.all.map((d) => d.uri.toString()).toArray());
          console.log("mimimimi3");
          if (node.$cstNode !== void 0 && node.$container === void 0) {
            (0, langium_1.flattenCst)(node.$cstNode).forEach((cst) => {
              if ((0, ast_1.isKeyword)(cst.feature) && "person" !== cst.feature.value) {
                acceptor({
                  node: cst.element,
                  keyword: cst.feature.value,
                  type: vscode_languageserver_1.SemanticTokenTypes.keyword
                });
              }
            });
          }
        }
      };
      exports2.HelloSemanticTokenProvider = HelloSemanticTokenProvider;
    }
  });

  // node_modules/vscode/dist/node_modules/tslib/tslib.es6.js
  function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  }
  var init_tslib_es6 = __esm({
    "node_modules/vscode/dist/node_modules/tslib/tslib.es6.js"() {
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/errors.js
  function onUnexpectedError(e) {
    if (!isCancellationError(e)) {
      errorHandler.onUnexpectedError(e);
    }
    return void 0;
  }
  function isCancellationError(error) {
    if (error instanceof CancellationError) {
      return true;
    }
    return error instanceof Error && error.name === canceledName && error.message === canceledName;
  }
  function illegalArgument(name) {
    if (name) {
      return new Error(`Illegal argument: ${name}`);
    } else {
      return new Error("Illegal argument");
    }
  }
  function illegalState(name) {
    if (name) {
      return new Error(`Illegal state: ${name}`);
    } else {
      return new Error("Illegal state");
    }
  }
  var ErrorHandler, errorHandler, canceledName, CancellationError, ErrorNoTelemetry;
  var init_errors = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/errors.js"() {
      ErrorHandler = class {
        constructor() {
          this.listeners = [];
          this.unexpectedErrorHandler = function(e) {
            setTimeout(() => {
              if (e.stack) {
                if (ErrorNoTelemetry.isErrorNoTelemetry(e)) {
                  throw new ErrorNoTelemetry(e.message + "\n\n" + e.stack);
                }
                throw new Error(e.message + "\n\n" + e.stack);
              }
              throw e;
            }, 0);
          };
        }
        addListener(listener) {
          this.listeners.push(listener);
          return () => {
            this._removeListener(listener);
          };
        }
        emit(e) {
          this.listeners.forEach((listener) => {
            listener(e);
          });
        }
        _removeListener(listener) {
          this.listeners.splice(this.listeners.indexOf(listener), 1);
        }
        setUnexpectedErrorHandler(newUnexpectedErrorHandler) {
          this.unexpectedErrorHandler = newUnexpectedErrorHandler;
        }
        getUnexpectedErrorHandler() {
          return this.unexpectedErrorHandler;
        }
        onUnexpectedError(e) {
          this.unexpectedErrorHandler(e);
          this.emit(e);
        }
        // For external errors, we don't want the listeners to be called
        onUnexpectedExternalError(e) {
          this.unexpectedErrorHandler(e);
        }
      };
      errorHandler = new ErrorHandler();
      canceledName = "Canceled";
      CancellationError = class extends Error {
        constructor() {
          super(canceledName);
          this.name = this.message;
        }
      };
      ErrorNoTelemetry = class extends Error {
        constructor(msg) {
          super(msg);
          this.name = "CodeExpectedError";
        }
        static fromError(err) {
          if (err instanceof ErrorNoTelemetry) {
            return err;
          }
          const result = new ErrorNoTelemetry();
          result.message = err.message;
          result.stack = err.stack;
          return result;
        }
        static isErrorNoTelemetry(err) {
          return err.name === "CodeExpectedError";
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/arrays.js
  function equals(one, other, itemEquals = (a, b) => a === b) {
    if (one === other) {
      return true;
    }
    if (!one || !other) {
      return false;
    }
    if (one.length !== other.length) {
      return false;
    }
    for (let i = 0, len = one.length; i < len; i++) {
      if (!itemEquals(one[i], other[i])) {
        return false;
      }
    }
    return true;
  }
  function coalesceInPlace(array) {
    let to = 0;
    for (let i = 0; i < array.length; i++) {
      if (!!array[i]) {
        array[to] = array[i];
        to += 1;
      }
    }
    array.length = to;
  }
  function shuffle(array, _seed) {
    let rand;
    if (typeof _seed === "number") {
      let seed = _seed;
      rand = () => {
        const x = Math.sin(seed++) * 179426549;
        return x - Math.floor(x);
      };
    } else {
      rand = Math.random;
    }
    for (let i = array.length - 1; i > 0; i -= 1) {
      const j = Math.floor(rand() * (i + 1));
      const temp = array[i];
      array[i] = array[j];
      array[j] = temp;
    }
  }
  var CompareResult, CallbackIterable;
  var init_arrays = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/arrays.js"() {
      init_errors();
      (function(CompareResult2) {
        function isLessThan(result) {
          return result < 0;
        }
        CompareResult2.isLessThan = isLessThan;
        function isGreaterThan(result) {
          return result > 0;
        }
        CompareResult2.isGreaterThan = isGreaterThan;
        function isNeitherLessOrGreaterThan(result) {
          return result === 0;
        }
        CompareResult2.isNeitherLessOrGreaterThan = isNeitherLessOrGreaterThan;
        CompareResult2.greaterThan = 1;
        CompareResult2.lessThan = -1;
        CompareResult2.neitherLessOrGreaterThan = 0;
      })(CompareResult || (CompareResult = {}));
      CallbackIterable = class {
        constructor(iterate) {
          this.iterate = iterate;
        }
        forEach(handler) {
          this.iterate((item) => {
            handler(item);
            return true;
          });
        }
        toArray() {
          const result = [];
          this.iterate((item) => {
            result.push(item);
            return true;
          });
          return result;
        }
        filter(predicate) {
          return new CallbackIterable((cb) => this.iterate((item) => predicate(item) ? cb(item) : true));
        }
        map(mapFn) {
          return new CallbackIterable((cb) => this.iterate((item) => cb(mapFn(item))));
        }
        some(predicate) {
          let result = false;
          this.iterate((item) => {
            result = predicate(item);
            return !result;
          });
          return result;
        }
        findFirst(predicate) {
          let result;
          this.iterate((item) => {
            if (predicate(item)) {
              result = item;
              return false;
            }
            return true;
          });
          return result;
        }
        findLast(predicate) {
          let result;
          this.iterate((item) => {
            if (predicate(item)) {
              result = item;
            }
            return true;
          });
          return result;
        }
        findLastMaxBy(comparator) {
          let result;
          let first = true;
          this.iterate((item) => {
            if (first || CompareResult.isGreaterThan(comparator(item, result))) {
              first = false;
              result = item;
            }
            return true;
          });
          return result;
        }
      };
      CallbackIterable.empty = new CallbackIterable((_callback) => {
      });
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/map.js
  var _a, _b, _c, ResourceMapEntry, ResourceMap, ResourceSet, LinkedMap, LRUCache;
  var init_map = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/map.js"() {
      ResourceMapEntry = class {
        constructor(uri, value) {
          this.uri = uri;
          this.value = value;
        }
      };
      ResourceMap = class {
        constructor(mapOrKeyFn, toKey) {
          this[_a] = "ResourceMap";
          if (mapOrKeyFn instanceof ResourceMap) {
            this.map = new Map(mapOrKeyFn.map);
            this.toKey = toKey !== null && toKey !== void 0 ? toKey : ResourceMap.defaultToKey;
          } else {
            this.map = /* @__PURE__ */ new Map();
            this.toKey = mapOrKeyFn !== null && mapOrKeyFn !== void 0 ? mapOrKeyFn : ResourceMap.defaultToKey;
          }
        }
        set(resource, value) {
          this.map.set(this.toKey(resource), new ResourceMapEntry(resource, value));
          return this;
        }
        get(resource) {
          var _d;
          return (_d = this.map.get(this.toKey(resource))) === null || _d === void 0 ? void 0 : _d.value;
        }
        has(resource) {
          return this.map.has(this.toKey(resource));
        }
        get size() {
          return this.map.size;
        }
        clear() {
          this.map.clear();
        }
        delete(resource) {
          return this.map.delete(this.toKey(resource));
        }
        forEach(clb, thisArg) {
          if (typeof thisArg !== "undefined") {
            clb = clb.bind(thisArg);
          }
          for (const [_, entry] of this.map) {
            clb(entry.value, entry.uri, this);
          }
        }
        *values() {
          for (const entry of this.map.values()) {
            yield entry.value;
          }
        }
        *keys() {
          for (const entry of this.map.values()) {
            yield entry.uri;
          }
        }
        *entries() {
          for (const entry of this.map.values()) {
            yield [entry.uri, entry.value];
          }
        }
        *[(_a = Symbol.toStringTag, Symbol.iterator)]() {
          for (const [, entry] of this.map) {
            yield [entry.uri, entry.value];
          }
        }
      };
      ResourceMap.defaultToKey = (resource) => resource.toString();
      ResourceSet = class {
        constructor(entriesOrKey, toKey) {
          this[_b] = "ResourceSet";
          if (!entriesOrKey || typeof entriesOrKey === "function") {
            this._map = new ResourceMap(entriesOrKey);
          } else {
            this._map = new ResourceMap(toKey);
            entriesOrKey.forEach(this.add, this);
          }
        }
        get size() {
          return this._map.size;
        }
        add(value) {
          this._map.set(value, value);
          return this;
        }
        clear() {
          this._map.clear();
        }
        delete(value) {
          return this._map.delete(value);
        }
        forEach(callbackfn, thisArg) {
          this._map.forEach((_value, key) => callbackfn.call(thisArg, key, key, this));
        }
        has(value) {
          return this._map.has(value);
        }
        entries() {
          return this._map.entries();
        }
        keys() {
          return this._map.keys();
        }
        values() {
          return this._map.keys();
        }
        [(_b = Symbol.toStringTag, Symbol.iterator)]() {
          return this.keys();
        }
      };
      LinkedMap = class {
        constructor() {
          this[_c] = "LinkedMap";
          this._map = /* @__PURE__ */ new Map();
          this._head = void 0;
          this._tail = void 0;
          this._size = 0;
          this._state = 0;
        }
        clear() {
          this._map.clear();
          this._head = void 0;
          this._tail = void 0;
          this._size = 0;
          this._state++;
        }
        isEmpty() {
          return !this._head && !this._tail;
        }
        get size() {
          return this._size;
        }
        get first() {
          var _d;
          return (_d = this._head) === null || _d === void 0 ? void 0 : _d.value;
        }
        get last() {
          var _d;
          return (_d = this._tail) === null || _d === void 0 ? void 0 : _d.value;
        }
        has(key) {
          return this._map.has(key);
        }
        get(key, touch = 0) {
          const item = this._map.get(key);
          if (!item) {
            return void 0;
          }
          if (touch !== 0) {
            this.touch(item, touch);
          }
          return item.value;
        }
        set(key, value, touch = 0) {
          let item = this._map.get(key);
          if (item) {
            item.value = value;
            if (touch !== 0) {
              this.touch(item, touch);
            }
          } else {
            item = { key, value, next: void 0, previous: void 0 };
            switch (touch) {
              case 0:
                this.addItemLast(item);
                break;
              case 1:
                this.addItemFirst(item);
                break;
              case 2:
                this.addItemLast(item);
                break;
              default:
                this.addItemLast(item);
                break;
            }
            this._map.set(key, item);
            this._size++;
          }
          return this;
        }
        delete(key) {
          return !!this.remove(key);
        }
        remove(key) {
          const item = this._map.get(key);
          if (!item) {
            return void 0;
          }
          this._map.delete(key);
          this.removeItem(item);
          this._size--;
          return item.value;
        }
        shift() {
          if (!this._head && !this._tail) {
            return void 0;
          }
          if (!this._head || !this._tail) {
            throw new Error("Invalid list");
          }
          const item = this._head;
          this._map.delete(item.key);
          this.removeItem(item);
          this._size--;
          return item.value;
        }
        forEach(callbackfn, thisArg) {
          const state = this._state;
          let current = this._head;
          while (current) {
            if (thisArg) {
              callbackfn.bind(thisArg)(current.value, current.key, this);
            } else {
              callbackfn(current.value, current.key, this);
            }
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            current = current.next;
          }
        }
        keys() {
          const map = this;
          const state = this._state;
          let current = this._head;
          const iterator = {
            [Symbol.iterator]() {
              return iterator;
            },
            next() {
              if (map._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
              }
              if (current) {
                const result = { value: current.key, done: false };
                current = current.next;
                return result;
              } else {
                return { value: void 0, done: true };
              }
            }
          };
          return iterator;
        }
        values() {
          const map = this;
          const state = this._state;
          let current = this._head;
          const iterator = {
            [Symbol.iterator]() {
              return iterator;
            },
            next() {
              if (map._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
              }
              if (current) {
                const result = { value: current.value, done: false };
                current = current.next;
                return result;
              } else {
                return { value: void 0, done: true };
              }
            }
          };
          return iterator;
        }
        entries() {
          const map = this;
          const state = this._state;
          let current = this._head;
          const iterator = {
            [Symbol.iterator]() {
              return iterator;
            },
            next() {
              if (map._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
              }
              if (current) {
                const result = { value: [current.key, current.value], done: false };
                current = current.next;
                return result;
              } else {
                return { value: void 0, done: true };
              }
            }
          };
          return iterator;
        }
        [(_c = Symbol.toStringTag, Symbol.iterator)]() {
          return this.entries();
        }
        trimOld(newSize) {
          if (newSize >= this.size) {
            return;
          }
          if (newSize === 0) {
            this.clear();
            return;
          }
          let current = this._head;
          let currentSize = this.size;
          while (current && currentSize > newSize) {
            this._map.delete(current.key);
            current = current.next;
            currentSize--;
          }
          this._head = current;
          this._size = currentSize;
          if (current) {
            current.previous = void 0;
          }
          this._state++;
        }
        addItemFirst(item) {
          if (!this._head && !this._tail) {
            this._tail = item;
          } else if (!this._head) {
            throw new Error("Invalid list");
          } else {
            item.next = this._head;
            this._head.previous = item;
          }
          this._head = item;
          this._state++;
        }
        addItemLast(item) {
          if (!this._head && !this._tail) {
            this._head = item;
          } else if (!this._tail) {
            throw new Error("Invalid list");
          } else {
            item.previous = this._tail;
            this._tail.next = item;
          }
          this._tail = item;
          this._state++;
        }
        removeItem(item) {
          if (item === this._head && item === this._tail) {
            this._head = void 0;
            this._tail = void 0;
          } else if (item === this._head) {
            if (!item.next) {
              throw new Error("Invalid list");
            }
            item.next.previous = void 0;
            this._head = item.next;
          } else if (item === this._tail) {
            if (!item.previous) {
              throw new Error("Invalid list");
            }
            item.previous.next = void 0;
            this._tail = item.previous;
          } else {
            const next = item.next;
            const previous = item.previous;
            if (!next || !previous) {
              throw new Error("Invalid list");
            }
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = void 0;
          this._state++;
        }
        touch(item, touch) {
          if (!this._head || !this._tail) {
            throw new Error("Invalid list");
          }
          if (touch !== 1 && touch !== 2) {
            return;
          }
          if (touch === 1) {
            if (item === this._head) {
              return;
            }
            const next = item.next;
            const previous = item.previous;
            if (item === this._tail) {
              previous.next = void 0;
              this._tail = previous;
            } else {
              next.previous = previous;
              previous.next = next;
            }
            item.previous = void 0;
            item.next = this._head;
            this._head.previous = item;
            this._head = item;
            this._state++;
          } else if (touch === 2) {
            if (item === this._tail) {
              return;
            }
            const next = item.next;
            const previous = item.previous;
            if (item === this._head) {
              next.previous = void 0;
              this._head = next;
            } else {
              next.previous = previous;
              previous.next = next;
            }
            item.next = void 0;
            item.previous = this._tail;
            this._tail.next = item;
            this._tail = item;
            this._state++;
          }
        }
        toJSON() {
          const data = [];
          this.forEach((value, key) => {
            data.push([key, value]);
          });
          return data;
        }
        fromJSON(data) {
          this.clear();
          for (const [key, value] of data) {
            this.set(key, value);
          }
        }
      };
      LRUCache = class extends LinkedMap {
        constructor(limit, ratio = 1) {
          super();
          this._limit = limit;
          this._ratio = Math.min(Math.max(0, ratio), 1);
        }
        get limit() {
          return this._limit;
        }
        set limit(limit) {
          this._limit = limit;
          this.checkTrim();
        }
        get ratio() {
          return this._ratio;
        }
        set ratio(ratio) {
          this._ratio = Math.min(Math.max(0, ratio), 1);
          this.checkTrim();
        }
        get(key, touch = 2) {
          return super.get(key, touch);
        }
        peek(key) {
          return super.get(
            key,
            0
            /* Touch.None */
          );
        }
        set(key, value) {
          super.set(
            key,
            value,
            2
            /* Touch.AsNew */
          );
          this.checkTrim();
          return this;
        }
        checkTrim() {
          if (this.size > this._limit) {
            this.trimOld(Math.round(this._limit * this._ratio));
          }
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/functional.js
  function once(fn) {
    const _this = this;
    let didCall = false;
    let result;
    return function() {
      if (didCall) {
        return result;
      }
      didCall = true;
      result = fn.apply(_this, arguments);
      return result;
    };
  }
  var init_functional = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/functional.js"() {
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/iterator.js
  var Iterable;
  var init_iterator = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/iterator.js"() {
      (function(Iterable2) {
        function is(thing) {
          return thing && typeof thing === "object" && typeof thing[Symbol.iterator] === "function";
        }
        Iterable2.is = is;
        const _empty2 = Object.freeze([]);
        function empty() {
          return _empty2;
        }
        Iterable2.empty = empty;
        function* single(element) {
          yield element;
        }
        Iterable2.single = single;
        function wrap(iterableOrElement) {
          if (is(iterableOrElement)) {
            return iterableOrElement;
          } else {
            return single(iterableOrElement);
          }
        }
        Iterable2.wrap = wrap;
        function from(iterable) {
          return iterable || _empty2;
        }
        Iterable2.from = from;
        function isEmpty(iterable) {
          return !iterable || iterable[Symbol.iterator]().next().done === true;
        }
        Iterable2.isEmpty = isEmpty;
        function first(iterable) {
          return iterable[Symbol.iterator]().next().value;
        }
        Iterable2.first = first;
        function some(iterable, predicate) {
          for (const element of iterable) {
            if (predicate(element)) {
              return true;
            }
          }
          return false;
        }
        Iterable2.some = some;
        function find(iterable, predicate) {
          for (const element of iterable) {
            if (predicate(element)) {
              return element;
            }
          }
          return void 0;
        }
        Iterable2.find = find;
        function* filter(iterable, predicate) {
          for (const element of iterable) {
            if (predicate(element)) {
              yield element;
            }
          }
        }
        Iterable2.filter = filter;
        function* map(iterable, fn) {
          let index = 0;
          for (const element of iterable) {
            yield fn(element, index++);
          }
        }
        Iterable2.map = map;
        function* concat(...iterables) {
          for (const iterable of iterables) {
            for (const element of iterable) {
              yield element;
            }
          }
        }
        Iterable2.concat = concat;
        function reduce(iterable, reducer, initialValue) {
          let value = initialValue;
          for (const element of iterable) {
            value = reducer(value, element);
          }
          return value;
        }
        Iterable2.reduce = reduce;
        function* slice(arr, from2, to = arr.length) {
          if (from2 < 0) {
            from2 += arr.length;
          }
          if (to < 0) {
            to += arr.length;
          } else if (to > arr.length) {
            to = arr.length;
          }
          for (; from2 < to; from2++) {
            yield arr[from2];
          }
        }
        Iterable2.slice = slice;
        function consume(iterable, atMost = Number.POSITIVE_INFINITY) {
          const consumed = [];
          if (atMost === 0) {
            return [consumed, iterable];
          }
          const iterator = iterable[Symbol.iterator]();
          for (let i = 0; i < atMost; i++) {
            const next = iterator.next();
            if (next.done) {
              return [consumed, Iterable2.empty()];
            }
            consumed.push(next.value);
          }
          return [consumed, { [Symbol.iterator]() {
            return iterator;
          } }];
        }
        Iterable2.consume = consume;
      })(Iterable || (Iterable = {}));
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/lifecycle.js
  function setDisposableTracker(tracker) {
    disposableTracker = tracker;
  }
  function trackDisposable(x) {
    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.trackDisposable(x);
    return x;
  }
  function markAsDisposed(disposable) {
    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.markAsDisposed(disposable);
  }
  function setParentOfDisposable(child, parent) {
    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.setParent(child, parent);
  }
  function setParentOfDisposables(children, parent) {
    if (!disposableTracker) {
      return;
    }
    for (const child of children) {
      disposableTracker.setParent(child, parent);
    }
  }
  function dispose(arg) {
    if (Iterable.is(arg)) {
      const errors = [];
      for (const d of arg) {
        if (d) {
          try {
            d.dispose();
          } catch (e) {
            errors.push(e);
          }
        }
      }
      if (errors.length === 1) {
        throw errors[0];
      } else if (errors.length > 1) {
        throw new AggregateError(errors, "Encountered errors while disposing of store");
      }
      return Array.isArray(arg) ? [] : arg;
    } else if (arg) {
      arg.dispose();
      return arg;
    }
  }
  function combinedDisposable(...disposables) {
    const parent = toDisposable(() => dispose(disposables));
    setParentOfDisposables(disposables, parent);
    return parent;
  }
  function toDisposable(fn) {
    const self2 = trackDisposable({
      dispose: once(() => {
        markAsDisposed(self2);
        fn();
      })
    });
    return self2;
  }
  var TRACK_DISPOSABLES, disposableTracker, DisposableStore, Disposable, DisposableMap;
  var init_lifecycle = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/lifecycle.js"() {
      init_functional();
      init_iterator();
      TRACK_DISPOSABLES = false;
      disposableTracker = null;
      if (TRACK_DISPOSABLES) {
        const __is_disposable_tracked__ = "__is_disposable_tracked__";
        setDisposableTracker(new class {
          trackDisposable(x) {
            const stack = new Error("Potentially leaked disposable").stack;
            setTimeout(() => {
              if (!x[__is_disposable_tracked__]) {
                console.log(stack);
              }
            }, 3e3);
          }
          setParent(child, parent) {
            if (child && child !== Disposable.None) {
              try {
                child[__is_disposable_tracked__] = true;
              } catch (_a4) {
              }
            }
          }
          markAsDisposed(disposable) {
            if (disposable && disposable !== Disposable.None) {
              try {
                disposable[__is_disposable_tracked__] = true;
              } catch (_a4) {
              }
            }
          }
          markAsSingleton(disposable) {
          }
        }());
      }
      DisposableStore = class {
        constructor() {
          this._toDispose = /* @__PURE__ */ new Set();
          this._isDisposed = false;
          trackDisposable(this);
        }
        /**
         * Dispose of all registered disposables and mark this object as disposed.
         *
         * Any future disposables added to this object will be disposed of on `add`.
         */
        dispose() {
          if (this._isDisposed) {
            return;
          }
          markAsDisposed(this);
          this._isDisposed = true;
          this.clear();
        }
        /**
         * @return `true` if this object has been disposed of.
         */
        get isDisposed() {
          return this._isDisposed;
        }
        /**
         * Dispose of all registered disposables but do not mark this object as disposed.
         */
        clear() {
          if (this._toDispose.size === 0) {
            return;
          }
          try {
            dispose(this._toDispose);
          } finally {
            this._toDispose.clear();
          }
        }
        /**
         * Add a new {@link IDisposable disposable} to the collection.
         */
        add(o) {
          if (!o) {
            return o;
          }
          if (o === this) {
            throw new Error("Cannot register a disposable on itself!");
          }
          setParentOfDisposable(o, this);
          if (this._isDisposed) {
            if (!DisposableStore.DISABLE_DISPOSED_WARNING) {
              console.warn(new Error("Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!").stack);
            }
          } else {
            this._toDispose.add(o);
          }
          return o;
        }
      };
      DisposableStore.DISABLE_DISPOSED_WARNING = false;
      Disposable = class {
        constructor() {
          this._store = new DisposableStore();
          trackDisposable(this);
          setParentOfDisposable(this._store, this);
        }
        dispose() {
          markAsDisposed(this);
          this._store.dispose();
        }
        /**
         * Adds `o` to the collection of disposables managed by this object.
         */
        _register(o) {
          if (o === this) {
            throw new Error("Cannot register a disposable on itself!");
          }
          return this._store.add(o);
        }
      };
      Disposable.None = Object.freeze({ dispose() {
      } });
      DisposableMap = class {
        constructor() {
          this._store = /* @__PURE__ */ new Map();
          this._isDisposed = false;
          trackDisposable(this);
        }
        /**
         * Disposes of all stored values and mark this object as disposed.
         *
         * Trying to use this object after it has been disposed of is an error.
         */
        dispose() {
          markAsDisposed(this);
          this._isDisposed = true;
          this.clearAndDisposeAll();
        }
        /**
         * Disposes of all stored values and clear the map, but DO NOT mark this object as disposed.
         */
        clearAndDisposeAll() {
          if (!this._store.size) {
            return;
          }
          try {
            dispose(this._store.values());
          } finally {
            this._store.clear();
          }
        }
        has(key) {
          return this._store.has(key);
        }
        get(key) {
          return this._store.get(key);
        }
        set(key, value, skipDisposeOnOverwrite = false) {
          var _a4;
          if (this._isDisposed) {
            console.warn(new Error("Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!").stack);
          }
          if (!skipDisposeOnOverwrite) {
            (_a4 = this._store.get(key)) === null || _a4 === void 0 ? void 0 : _a4.dispose();
          }
          this._store.set(key, value);
        }
        /**
         * Delete the value stored for `key` from this map and also dispose of it.
         */
        deleteAndDispose(key) {
          var _a4;
          (_a4 = this._store.get(key)) === null || _a4 === void 0 ? void 0 : _a4.dispose();
          this._store.delete(key);
        }
        [Symbol.iterator]() {
          return this._store[Symbol.iterator]();
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/linkedList.js
  var Node, LinkedList;
  var init_linkedList = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/linkedList.js"() {
      Node = class {
        constructor(element) {
          this.element = element;
          this.next = Node.Undefined;
          this.prev = Node.Undefined;
        }
      };
      Node.Undefined = new Node(void 0);
      LinkedList = class {
        constructor() {
          this._first = Node.Undefined;
          this._last = Node.Undefined;
          this._size = 0;
        }
        get size() {
          return this._size;
        }
        isEmpty() {
          return this._first === Node.Undefined;
        }
        clear() {
          let node = this._first;
          while (node !== Node.Undefined) {
            const next = node.next;
            node.prev = Node.Undefined;
            node.next = Node.Undefined;
            node = next;
          }
          this._first = Node.Undefined;
          this._last = Node.Undefined;
          this._size = 0;
        }
        unshift(element) {
          return this._insert(element, false);
        }
        push(element) {
          return this._insert(element, true);
        }
        _insert(element, atTheEnd) {
          const newNode = new Node(element);
          if (this._first === Node.Undefined) {
            this._first = newNode;
            this._last = newNode;
          } else if (atTheEnd) {
            const oldLast = this._last;
            this._last = newNode;
            newNode.prev = oldLast;
            oldLast.next = newNode;
          } else {
            const oldFirst = this._first;
            this._first = newNode;
            newNode.next = oldFirst;
            oldFirst.prev = newNode;
          }
          this._size += 1;
          let didRemove = false;
          return () => {
            if (!didRemove) {
              didRemove = true;
              this._remove(newNode);
            }
          };
        }
        shift() {
          if (this._first === Node.Undefined) {
            return void 0;
          } else {
            const res = this._first.element;
            this._remove(this._first);
            return res;
          }
        }
        pop() {
          if (this._last === Node.Undefined) {
            return void 0;
          } else {
            const res = this._last.element;
            this._remove(this._last);
            return res;
          }
        }
        _remove(node) {
          if (node.prev !== Node.Undefined && node.next !== Node.Undefined) {
            const anchor = node.prev;
            anchor.next = node.next;
            node.next.prev = anchor;
          } else if (node.prev === Node.Undefined && node.next === Node.Undefined) {
            this._first = Node.Undefined;
            this._last = Node.Undefined;
          } else if (node.next === Node.Undefined) {
            this._last = this._last.prev;
            this._last.next = Node.Undefined;
          } else if (node.prev === Node.Undefined) {
            this._first = this._first.next;
            this._first.prev = Node.Undefined;
          }
          this._size -= 1;
        }
        *[Symbol.iterator]() {
          let node = this._first;
          while (node !== Node.Undefined) {
            yield node.element;
            node = node.next;
          }
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/stopwatch.js
  var hasPerformanceNow, StopWatch;
  var init_stopwatch = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/stopwatch.js"() {
      hasPerformanceNow = globalThis.performance && typeof globalThis.performance.now === "function";
      StopWatch = class {
        static create(highResolution) {
          return new StopWatch(highResolution);
        }
        constructor(highResolution) {
          this._now = hasPerformanceNow && highResolution === false ? Date.now : globalThis.performance.now.bind(globalThis.performance);
          this._startTime = this._now();
          this._stopTime = -1;
        }
        stop() {
          this._stopTime = this._now();
        }
        reset() {
          this._startTime = this._now();
          this._stopTime = -1;
        }
        elapsed() {
          if (this._stopTime !== -1) {
            return this._stopTime - this._startTime;
          }
          return this._now() - this._startTime;
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/event.js
  var _enableDisposeWithListenerWarning, _enableSnapshotPotentialLeakWarning, Event, EventProfiling, _globalLeakWarningThreshold, LeakageMonitor, Stacktrace, id, UniqueContainer, compactionThreshold, forEachListener, Emitter, EventDeliveryQueuePrivate;
  var init_event = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/event.js"() {
      init_errors();
      init_functional();
      init_lifecycle();
      init_linkedList();
      init_stopwatch();
      _enableDisposeWithListenerWarning = false;
      _enableSnapshotPotentialLeakWarning = false;
      (function(Event2) {
        Event2.None = () => Disposable.None;
        function _addLeakageTraceLogic(options) {
          if (_enableSnapshotPotentialLeakWarning) {
            const { onDidAddListener: origListenerDidAdd } = options;
            const stack = Stacktrace.create();
            let count = 0;
            options.onDidAddListener = () => {
              if (++count === 2) {
                console.warn("snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here");
                stack.print();
              }
              origListenerDidAdd === null || origListenerDidAdd === void 0 ? void 0 : origListenerDidAdd();
            };
          }
        }
        function defer(event, disposable) {
          return debounce(event, () => void 0, 0, void 0, true, void 0, disposable);
        }
        Event2.defer = defer;
        function once2(event) {
          return (listener, thisArgs = null, disposables) => {
            let didFire = false;
            let result = void 0;
            result = event((e) => {
              if (didFire) {
                return;
              } else if (result) {
                result.dispose();
              } else {
                didFire = true;
              }
              return listener.call(thisArgs, e);
            }, null, disposables);
            if (didFire) {
              result.dispose();
            }
            return result;
          };
        }
        Event2.once = once2;
        function map(event, map2, disposable) {
          return snapshot((listener, thisArgs = null, disposables) => event((i) => listener.call(thisArgs, map2(i)), null, disposables), disposable);
        }
        Event2.map = map;
        function forEach(event, each, disposable) {
          return snapshot((listener, thisArgs = null, disposables) => event((i) => {
            each(i);
            listener.call(thisArgs, i);
          }, null, disposables), disposable);
        }
        Event2.forEach = forEach;
        function filter(event, filter2, disposable) {
          return snapshot((listener, thisArgs = null, disposables) => event((e) => filter2(e) && listener.call(thisArgs, e), null, disposables), disposable);
        }
        Event2.filter = filter;
        function signal(event) {
          return event;
        }
        Event2.signal = signal;
        function any(...events) {
          return (listener, thisArgs = null, disposables) => combinedDisposable(...events.map((event) => event((e) => listener.call(thisArgs, e), null, disposables)));
        }
        Event2.any = any;
        function reduce(event, merge, initial, disposable) {
          let output = initial;
          return map(event, (e) => {
            output = merge(output, e);
            return output;
          }, disposable);
        }
        Event2.reduce = reduce;
        function snapshot(event, disposable) {
          let listener;
          const options = {
            onWillAddFirstListener() {
              listener = event(emitter.fire, emitter);
            },
            onDidRemoveLastListener() {
              listener === null || listener === void 0 ? void 0 : listener.dispose();
            }
          };
          if (!disposable) {
            _addLeakageTraceLogic(options);
          }
          const emitter = new Emitter(options);
          disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);
          return emitter.event;
        }
        function debounce(event, merge, delay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold, disposable) {
          let subscription;
          let output = void 0;
          let handle = void 0;
          let numDebouncedCalls = 0;
          let doFire;
          const options = {
            leakWarningThreshold,
            onWillAddFirstListener() {
              subscription = event((cur) => {
                numDebouncedCalls++;
                output = merge(output, cur);
                if (leading && !handle) {
                  emitter.fire(output);
                  output = void 0;
                }
                doFire = () => {
                  const _output = output;
                  output = void 0;
                  handle = void 0;
                  if (!leading || numDebouncedCalls > 1) {
                    emitter.fire(_output);
                  }
                  numDebouncedCalls = 0;
                };
                if (typeof delay === "number") {
                  clearTimeout(handle);
                  handle = setTimeout(doFire, delay);
                } else {
                  if (handle === void 0) {
                    handle = 0;
                    queueMicrotask(doFire);
                  }
                }
              });
            },
            onWillRemoveListener() {
              if (flushOnListenerRemove && numDebouncedCalls > 0) {
                doFire === null || doFire === void 0 ? void 0 : doFire();
              }
            },
            onDidRemoveLastListener() {
              doFire = void 0;
              subscription.dispose();
            }
          };
          if (!disposable) {
            _addLeakageTraceLogic(options);
          }
          const emitter = new Emitter(options);
          disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);
          return emitter.event;
        }
        Event2.debounce = debounce;
        function accumulate(event, delay = 0, disposable) {
          return Event2.debounce(event, (last, e) => {
            if (!last) {
              return [e];
            }
            last.push(e);
            return last;
          }, delay, void 0, true, void 0, disposable);
        }
        Event2.accumulate = accumulate;
        function latch(event, equals3 = (a, b) => a === b, disposable) {
          let firstCall = true;
          let cache;
          return filter(event, (value) => {
            const shouldEmit = firstCall || !equals3(value, cache);
            firstCall = false;
            cache = value;
            return shouldEmit;
          }, disposable);
        }
        Event2.latch = latch;
        function split(event, isT, disposable) {
          return [
            Event2.filter(event, isT, disposable),
            Event2.filter(event, (e) => !isT(e), disposable)
          ];
        }
        Event2.split = split;
        function buffer(event, flushAfterTimeout = false, _buffer = []) {
          let buffer2 = _buffer.slice();
          let listener = event((e) => {
            if (buffer2) {
              buffer2.push(e);
            } else {
              emitter.fire(e);
            }
          });
          const flush = () => {
            buffer2 === null || buffer2 === void 0 ? void 0 : buffer2.forEach((e) => emitter.fire(e));
            buffer2 = null;
          };
          const emitter = new Emitter({
            onWillAddFirstListener() {
              if (!listener) {
                listener = event((e) => emitter.fire(e));
              }
            },
            onDidAddFirstListener() {
              if (buffer2) {
                if (flushAfterTimeout) {
                  setTimeout(flush);
                } else {
                  flush();
                }
              }
            },
            onDidRemoveLastListener() {
              if (listener) {
                listener.dispose();
              }
              listener = null;
            }
          });
          return emitter.event;
        }
        Event2.buffer = buffer;
        class ChainableEvent {
          constructor(event) {
            this.event = event;
            this.disposables = new DisposableStore();
          }
          /** @see {@link Event.map} */
          map(fn) {
            return new ChainableEvent(map(this.event, fn, this.disposables));
          }
          /** @see {@link Event.forEach} */
          forEach(fn) {
            return new ChainableEvent(forEach(this.event, fn, this.disposables));
          }
          filter(fn) {
            return new ChainableEvent(filter(this.event, fn, this.disposables));
          }
          /** @see {@link Event.reduce} */
          reduce(merge, initial) {
            return new ChainableEvent(reduce(this.event, merge, initial, this.disposables));
          }
          /** @see {@link Event.reduce} */
          latch() {
            return new ChainableEvent(latch(this.event, void 0, this.disposables));
          }
          debounce(merge, delay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold) {
            return new ChainableEvent(debounce(this.event, merge, delay, leading, flushOnListenerRemove, leakWarningThreshold, this.disposables));
          }
          /**
           * Attach a listener to the event.
           */
          on(listener, thisArgs, disposables) {
            return this.event(listener, thisArgs, disposables);
          }
          /** @see {@link Event.once} */
          once(listener, thisArgs, disposables) {
            return once2(this.event)(listener, thisArgs, disposables);
          }
          dispose() {
            this.disposables.dispose();
          }
        }
        function chain(event) {
          return new ChainableEvent(event);
        }
        Event2.chain = chain;
        function fromNodeEventEmitter(emitter, eventName, map2 = (id2) => id2) {
          const fn = (...args) => result.fire(map2(...args));
          const onFirstListenerAdd = () => emitter.on(eventName, fn);
          const onLastListenerRemove = () => emitter.removeListener(eventName, fn);
          const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });
          return result.event;
        }
        Event2.fromNodeEventEmitter = fromNodeEventEmitter;
        function fromDOMEventEmitter(emitter, eventName, map2 = (id2) => id2) {
          const fn = (...args) => result.fire(map2(...args));
          const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);
          const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);
          const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });
          return result.event;
        }
        Event2.fromDOMEventEmitter = fromDOMEventEmitter;
        function toPromise(event) {
          return new Promise((resolve2) => once2(event)(resolve2));
        }
        Event2.toPromise = toPromise;
        function runAndSubscribe(event, handler) {
          handler(void 0);
          return event((e) => handler(e));
        }
        Event2.runAndSubscribe = runAndSubscribe;
        function runAndSubscribeWithStore(event, handler) {
          let store = null;
          function run(e) {
            store === null || store === void 0 ? void 0 : store.dispose();
            store = new DisposableStore();
            handler(e, store);
          }
          run(void 0);
          const disposable = event((e) => run(e));
          return toDisposable(() => {
            disposable.dispose();
            store === null || store === void 0 ? void 0 : store.dispose();
          });
        }
        Event2.runAndSubscribeWithStore = runAndSubscribeWithStore;
        class EmitterObserver {
          constructor(_observable, store) {
            this._observable = _observable;
            this._counter = 0;
            this._hasChanged = false;
            const options = {
              onWillAddFirstListener: () => {
                _observable.addObserver(this);
              },
              onDidRemoveLastListener: () => {
                _observable.removeObserver(this);
              }
            };
            if (!store) {
              _addLeakageTraceLogic(options);
            }
            this.emitter = new Emitter(options);
            if (store) {
              store.add(this.emitter);
            }
          }
          beginUpdate(_observable) {
            this._counter++;
          }
          handlePossibleChange(_observable) {
          }
          handleChange(_observable, _change) {
            this._hasChanged = true;
          }
          endUpdate(_observable) {
            this._counter--;
            if (this._counter === 0) {
              this._observable.reportChanges();
              if (this._hasChanged) {
                this._hasChanged = false;
                this.emitter.fire(this._observable.get());
              }
            }
          }
        }
        function fromObservable(obs, store) {
          const observer = new EmitterObserver(obs, store);
          return observer.emitter.event;
        }
        Event2.fromObservable = fromObservable;
        function fromObservableLight(observable) {
          return (listener) => {
            let count = 0;
            let didChange = false;
            const observer = {
              beginUpdate() {
                count++;
              },
              endUpdate() {
                count--;
                if (count === 0) {
                  observable.reportChanges();
                  if (didChange) {
                    didChange = false;
                    listener();
                  }
                }
              },
              handlePossibleChange() {
              },
              handleChange() {
                didChange = true;
              }
            };
            observable.addObserver(observer);
            observable.reportChanges();
            return {
              dispose() {
                observable.removeObserver(observer);
              }
            };
          };
        }
        Event2.fromObservableLight = fromObservableLight;
      })(Event || (Event = {}));
      EventProfiling = class {
        constructor(name) {
          this.listenerCount = 0;
          this.invocationCount = 0;
          this.elapsedOverall = 0;
          this.durations = [];
          this.name = `${name}_${EventProfiling._idPool++}`;
          EventProfiling.all.add(this);
        }
        start(listenerCount) {
          this._stopWatch = new StopWatch();
          this.listenerCount = listenerCount;
        }
        stop() {
          if (this._stopWatch) {
            const elapsed = this._stopWatch.elapsed();
            this.durations.push(elapsed);
            this.elapsedOverall += elapsed;
            this.invocationCount += 1;
            this._stopWatch = void 0;
          }
        }
      };
      EventProfiling.all = /* @__PURE__ */ new Set();
      EventProfiling._idPool = 0;
      _globalLeakWarningThreshold = -1;
      LeakageMonitor = class {
        constructor(threshold, name = Math.random().toString(18).slice(2, 5)) {
          this.threshold = threshold;
          this.name = name;
          this._warnCountdown = 0;
        }
        dispose() {
          var _a4;
          (_a4 = this._stacks) === null || _a4 === void 0 ? void 0 : _a4.clear();
        }
        check(stack, listenerCount) {
          const threshold = this.threshold;
          if (threshold <= 0 || listenerCount < threshold) {
            return void 0;
          }
          if (!this._stacks) {
            this._stacks = /* @__PURE__ */ new Map();
          }
          const count = this._stacks.get(stack.value) || 0;
          this._stacks.set(stack.value, count + 1);
          this._warnCountdown -= 1;
          if (this._warnCountdown <= 0) {
            this._warnCountdown = threshold * 0.5;
            let topStack;
            let topCount = 0;
            for (const [stack2, count2] of this._stacks) {
              if (!topStack || topCount < count2) {
                topStack = stack2;
                topCount = count2;
              }
            }
            console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);
            console.warn(topStack);
          }
          return () => {
            const count2 = this._stacks.get(stack.value) || 0;
            this._stacks.set(stack.value, count2 - 1);
          };
        }
      };
      Stacktrace = class {
        static create() {
          var _a4;
          return new Stacktrace((_a4 = new Error().stack) !== null && _a4 !== void 0 ? _a4 : "");
        }
        constructor(value) {
          this.value = value;
        }
        print() {
          console.warn(this.value.split("\n").slice(2).join("\n"));
        }
      };
      id = 0;
      UniqueContainer = class {
        constructor(value) {
          this.value = value;
          this.id = id++;
        }
      };
      compactionThreshold = 2;
      forEachListener = (listeners, fn) => {
        if (listeners instanceof UniqueContainer) {
          fn(listeners);
        } else {
          for (let i = 0; i < listeners.length; i++) {
            const l = listeners[i];
            if (l) {
              fn(l);
            }
          }
        }
      };
      Emitter = class {
        constructor(options) {
          var _a4, _b2, _c2, _d, _e;
          this._size = 0;
          this._options = options;
          this._leakageMon = _globalLeakWarningThreshold > 0 || ((_a4 = this._options) === null || _a4 === void 0 ? void 0 : _a4.leakWarningThreshold) ? new LeakageMonitor((_c2 = (_b2 = this._options) === null || _b2 === void 0 ? void 0 : _b2.leakWarningThreshold) !== null && _c2 !== void 0 ? _c2 : _globalLeakWarningThreshold) : void 0;
          this._perfMon = ((_d = this._options) === null || _d === void 0 ? void 0 : _d._profName) ? new EventProfiling(this._options._profName) : void 0;
          this._deliveryQueue = (_e = this._options) === null || _e === void 0 ? void 0 : _e.deliveryQueue;
        }
        dispose() {
          var _a4, _b2, _c2, _d;
          if (!this._disposed) {
            this._disposed = true;
            if (((_a4 = this._deliveryQueue) === null || _a4 === void 0 ? void 0 : _a4.current) === this) {
              this._deliveryQueue.reset();
            }
            if (this._listeners) {
              if (_enableDisposeWithListenerWarning) {
                const listeners = this._listeners;
                queueMicrotask(() => {
                  forEachListener(listeners, (l) => {
                    var _a5;
                    return (_a5 = l.stack) === null || _a5 === void 0 ? void 0 : _a5.print();
                  });
                });
              }
              this._listeners = void 0;
              this._size = 0;
            }
            (_c2 = (_b2 = this._options) === null || _b2 === void 0 ? void 0 : _b2.onDidRemoveLastListener) === null || _c2 === void 0 ? void 0 : _c2.call(_b2);
            (_d = this._leakageMon) === null || _d === void 0 ? void 0 : _d.dispose();
          }
        }
        /**
         * For the public to allow to subscribe
         * to events from this Emitter
         */
        get event() {
          var _a4;
          (_a4 = this._event) !== null && _a4 !== void 0 ? _a4 : this._event = (callback, thisArgs, disposables) => {
            var _a5, _b2, _c2, _d, _e;
            if (this._leakageMon && this._size > this._leakageMon.threshold * 3) {
              console.warn(`[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far`);
              return Disposable.None;
            }
            if (this._disposed) {
              return Disposable.None;
            }
            if (thisArgs) {
              callback = callback.bind(thisArgs);
            }
            const contained = new UniqueContainer(callback);
            let removeMonitor;
            let stack;
            if (this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2)) {
              contained.stack = Stacktrace.create();
              removeMonitor = this._leakageMon.check(contained.stack, this._size + 1);
            }
            if (_enableDisposeWithListenerWarning) {
              contained.stack = stack !== null && stack !== void 0 ? stack : Stacktrace.create();
            }
            if (!this._listeners) {
              (_b2 = (_a5 = this._options) === null || _a5 === void 0 ? void 0 : _a5.onWillAddFirstListener) === null || _b2 === void 0 ? void 0 : _b2.call(_a5, this);
              this._listeners = contained;
              (_d = (_c2 = this._options) === null || _c2 === void 0 ? void 0 : _c2.onDidAddFirstListener) === null || _d === void 0 ? void 0 : _d.call(_c2, this);
            } else if (this._listeners instanceof UniqueContainer) {
              (_e = this._deliveryQueue) !== null && _e !== void 0 ? _e : this._deliveryQueue = new EventDeliveryQueuePrivate();
              this._listeners = [this._listeners, contained];
            } else {
              this._listeners.push(contained);
            }
            this._size++;
            const result = toDisposable(() => {
              removeMonitor === null || removeMonitor === void 0 ? void 0 : removeMonitor();
              this._removeListener(contained);
            });
            if (disposables instanceof DisposableStore) {
              disposables.add(result);
            } else if (Array.isArray(disposables)) {
              disposables.push(result);
            }
            return result;
          };
          return this._event;
        }
        _removeListener(listener) {
          var _a4, _b2, _c2, _d;
          (_b2 = (_a4 = this._options) === null || _a4 === void 0 ? void 0 : _a4.onWillRemoveListener) === null || _b2 === void 0 ? void 0 : _b2.call(_a4, this);
          if (!this._listeners) {
            return;
          }
          if (this._size === 1) {
            this._listeners = void 0;
            (_d = (_c2 = this._options) === null || _c2 === void 0 ? void 0 : _c2.onDidRemoveLastListener) === null || _d === void 0 ? void 0 : _d.call(_c2, this);
            this._size = 0;
            return;
          }
          const listeners = this._listeners;
          const index = listeners.indexOf(listener);
          if (index === -1) {
            console.log("disposed?", this._disposed);
            console.log("size?", this._size);
            console.log("arr?", JSON.stringify(this._listeners));
            throw new Error("Attempted to dispose unknown listener");
          }
          this._size--;
          listeners[index] = void 0;
          const adjustDeliveryQueue = this._deliveryQueue.current === this;
          if (this._size * compactionThreshold <= listeners.length) {
            let n = 0;
            for (let i = 0; i < listeners.length; i++) {
              if (listeners[i]) {
                listeners[n++] = listeners[i];
              } else if (adjustDeliveryQueue) {
                this._deliveryQueue.end--;
                if (n < this._deliveryQueue.i) {
                  this._deliveryQueue.i--;
                }
              }
            }
            listeners.length = n;
          }
        }
        _deliver(listener, value) {
          var _a4;
          if (!listener) {
            return;
          }
          const errorHandler2 = ((_a4 = this._options) === null || _a4 === void 0 ? void 0 : _a4.onListenerError) || onUnexpectedError;
          if (!errorHandler2) {
            listener.value(value);
            return;
          }
          try {
            listener.value(value);
          } catch (e) {
            errorHandler2(e);
          }
        }
        /** Delivers items in the queue. Assumes the queue is ready to go. */
        _deliverQueue(dq) {
          const listeners = dq.current._listeners;
          while (dq.i < dq.end) {
            this._deliver(listeners[dq.i++], dq.value);
          }
          dq.reset();
        }
        /**
         * To be kept private to fire an event to
         * subscribers
         */
        fire(event) {
          var _a4, _b2, _c2, _d;
          if ((_a4 = this._deliveryQueue) === null || _a4 === void 0 ? void 0 : _a4.current) {
            this._deliverQueue(this._deliveryQueue);
            (_b2 = this._perfMon) === null || _b2 === void 0 ? void 0 : _b2.stop();
          }
          (_c2 = this._perfMon) === null || _c2 === void 0 ? void 0 : _c2.start(this._size);
          if (!this._listeners) {
          } else if (this._listeners instanceof UniqueContainer) {
            this._deliver(this._listeners, event);
          } else {
            const dq = this._deliveryQueue;
            dq.enqueue(this, event, this._listeners.length);
            this._deliverQueue(dq);
          }
          (_d = this._perfMon) === null || _d === void 0 ? void 0 : _d.stop();
        }
        hasListeners() {
          return this._size > 0;
        }
      };
      EventDeliveryQueuePrivate = class {
        constructor() {
          this.i = -1;
          this.end = 0;
        }
        enqueue(emitter, value, end) {
          this.i = 0;
          this.end = end;
          this.current = emitter;
          this.value = value;
        }
        reset() {
          this.i = this.end;
          this.current = void 0;
          this.value = void 0;
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/cancellation.js
  var shortcutEvent, CancellationToken, MutableToken, CancellationTokenSource;
  var init_cancellation = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/cancellation.js"() {
      init_event();
      shortcutEvent = Object.freeze(function(callback, context) {
        const handle = setTimeout(callback.bind(context), 0);
        return { dispose() {
          clearTimeout(handle);
        } };
      });
      (function(CancellationToken2) {
        function isCancellationToken(thing) {
          if (thing === CancellationToken2.None || thing === CancellationToken2.Cancelled) {
            return true;
          }
          if (thing instanceof MutableToken) {
            return true;
          }
          if (!thing || typeof thing !== "object") {
            return false;
          }
          return typeof thing.isCancellationRequested === "boolean" && typeof thing.onCancellationRequested === "function";
        }
        CancellationToken2.isCancellationToken = isCancellationToken;
        CancellationToken2.None = Object.freeze({
          isCancellationRequested: false,
          onCancellationRequested: Event.None
        });
        CancellationToken2.Cancelled = Object.freeze({
          isCancellationRequested: true,
          onCancellationRequested: shortcutEvent
        });
      })(CancellationToken || (CancellationToken = {}));
      MutableToken = class {
        constructor() {
          this._isCancelled = false;
          this._emitter = null;
        }
        cancel() {
          if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
              this._emitter.fire(void 0);
              this.dispose();
            }
          }
        }
        get isCancellationRequested() {
          return this._isCancelled;
        }
        get onCancellationRequested() {
          if (this._isCancelled) {
            return shortcutEvent;
          }
          if (!this._emitter) {
            this._emitter = new Emitter();
          }
          return this._emitter.event;
        }
        dispose() {
          if (this._emitter) {
            this._emitter.dispose();
            this._emitter = null;
          }
        }
      };
      CancellationTokenSource = class {
        constructor(parent) {
          this._token = void 0;
          this._parentListener = void 0;
          this._parentListener = parent && parent.onCancellationRequested(this.cancel, this);
        }
        get token() {
          if (!this._token) {
            this._token = new MutableToken();
          }
          return this._token;
        }
        cancel() {
          if (!this._token) {
            this._token = CancellationToken.Cancelled;
          } else if (this._token instanceof MutableToken) {
            this._token.cancel();
          }
        }
        dispose(cancel = false) {
          var _a4;
          if (cancel) {
            this.cancel();
          }
          (_a4 = this._parentListener) === null || _a4 === void 0 ? void 0 : _a4.dispose();
          if (!this._token) {
            this._token = CancellationToken.None;
          } else if (this._token instanceof MutableToken) {
            this._token.dispose();
          }
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/cache.js
  var LRUCachedFunction;
  var init_cache = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/cache.js"() {
      init_cancellation();
      LRUCachedFunction = class {
        constructor(fn) {
          this.fn = fn;
          this.lastCache = void 0;
          this.lastArgKey = void 0;
        }
        get(arg) {
          const key = JSON.stringify(arg);
          if (this.lastArgKey !== key) {
            this.lastArgKey = key;
            this.lastCache = this.fn(arg);
          }
          return this.lastCache;
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/lazy.js
  var Lazy;
  var init_lazy = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/lazy.js"() {
      Lazy = class {
        constructor(executor) {
          this.executor = executor;
          this._didRun = false;
        }
        /**
         * True if the lazy value has been resolved.
         */
        get hasValue() {
          return this._didRun;
        }
        /**
         * Get the wrapped value.
         *
         * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only
         * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value
         */
        get value() {
          if (!this._didRun) {
            try {
              this._value = this.executor();
            } catch (err) {
              this._error = err;
            } finally {
              this._didRun = true;
            }
          }
          if (this._error) {
            throw this._error;
          }
          return this._value;
        }
        /**
         * Get the wrapped value without forcing evaluation.
         */
        get rawValue() {
          return this._value;
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/strings.js
  function isFalsyOrWhitespace(str) {
    if (!str || typeof str !== "string") {
      return true;
    }
    return str.trim().length === 0;
  }
  function escapeRegExpCharacters(value) {
    return value.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, "\\$&");
  }
  function compare(a, b) {
    if (a < b) {
      return -1;
    } else if (a > b) {
      return 1;
    } else {
      return 0;
    }
  }
  function compareSubstring(a, b, aStart = 0, aEnd = a.length, bStart = 0, bEnd = b.length) {
    for (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {
      const codeA = a.charCodeAt(aStart);
      const codeB = b.charCodeAt(bStart);
      if (codeA < codeB) {
        return -1;
      } else if (codeA > codeB) {
        return 1;
      }
    }
    const aLen = aEnd - aStart;
    const bLen = bEnd - bStart;
    if (aLen < bLen) {
      return -1;
    } else if (aLen > bLen) {
      return 1;
    }
    return 0;
  }
  function compareIgnoreCase(a, b) {
    return compareSubstringIgnoreCase(a, b, 0, a.length, 0, b.length);
  }
  function compareSubstringIgnoreCase(a, b, aStart = 0, aEnd = a.length, bStart = 0, bEnd = b.length) {
    for (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {
      let codeA = a.charCodeAt(aStart);
      let codeB = b.charCodeAt(bStart);
      if (codeA === codeB) {
        continue;
      }
      if (codeA >= 128 || codeB >= 128) {
        return compareSubstring(a.toLowerCase(), b.toLowerCase(), aStart, aEnd, bStart, bEnd);
      }
      if (isLowerAsciiLetter(codeA)) {
        codeA -= 32;
      }
      if (isLowerAsciiLetter(codeB)) {
        codeB -= 32;
      }
      const diff = codeA - codeB;
      if (diff === 0) {
        continue;
      }
      return diff;
    }
    const aLen = aEnd - aStart;
    const bLen = bEnd - bStart;
    if (aLen < bLen) {
      return -1;
    } else if (aLen > bLen) {
      return 1;
    }
    return 0;
  }
  function isLowerAsciiLetter(code) {
    return code >= 97 && code <= 122;
  }
  function equalsIgnoreCase(a, b) {
    return a.length === b.length && compareSubstringIgnoreCase(a, b) === 0;
  }
  function startsWithIgnoreCase(str, candidate) {
    const candidateLength = candidate.length;
    if (candidate.length > str.length) {
      return false;
    }
    return compareSubstringIgnoreCase(str, candidate, 0, candidateLength) === 0;
  }
  function isHighSurrogate(charCode) {
    return 55296 <= charCode && charCode <= 56319;
  }
  function isLowSurrogate(charCode) {
    return 56320 <= charCode && charCode <= 57343;
  }
  function computeCodePoint(highSurrogate, lowSurrogate) {
    return (highSurrogate - 55296 << 10) + (lowSurrogate - 56320) + 65536;
  }
  function getNextCodePoint(str, len, offset) {
    const charCode = str.charCodeAt(offset);
    if (isHighSurrogate(charCode) && offset + 1 < len) {
      const nextCharCode = str.charCodeAt(offset + 1);
      if (isLowSurrogate(nextCharCode)) {
        return computeCodePoint(charCode, nextCharCode);
      }
    }
    return charCode;
  }
  function getPrevCodePoint(str, offset) {
    const charCode = str.charCodeAt(offset - 1);
    if (isLowSurrogate(charCode) && offset > 1) {
      const prevCharCode = str.charCodeAt(offset - 2);
      if (isHighSurrogate(prevCharCode)) {
        return computeCodePoint(prevCharCode, charCode);
      }
    }
    return charCode;
  }
  function nextCharLength(str, initialOffset) {
    const iterator = new GraphemeIterator(str, initialOffset);
    return iterator.nextGraphemeLength();
  }
  function breakBetweenGraphemeBreakType(breakTypeA, breakTypeB) {
    if (breakTypeA === 0) {
      return breakTypeB !== 5 && breakTypeB !== 7;
    }
    if (breakTypeA === 2) {
      if (breakTypeB === 3) {
        return false;
      }
    }
    if (breakTypeA === 4 || breakTypeA === 2 || breakTypeA === 3) {
      return true;
    }
    if (breakTypeB === 4 || breakTypeB === 2 || breakTypeB === 3) {
      return true;
    }
    if (breakTypeA === 8) {
      if (breakTypeB === 8 || breakTypeB === 9 || breakTypeB === 11 || breakTypeB === 12) {
        return false;
      }
    }
    if (breakTypeA === 11 || breakTypeA === 9) {
      if (breakTypeB === 9 || breakTypeB === 10) {
        return false;
      }
    }
    if (breakTypeA === 12 || breakTypeA === 10) {
      if (breakTypeB === 10) {
        return false;
      }
    }
    if (breakTypeB === 5 || breakTypeB === 13) {
      return false;
    }
    if (breakTypeB === 7) {
      return false;
    }
    if (breakTypeA === 1) {
      return false;
    }
    if (breakTypeA === 13 && breakTypeB === 14) {
      return false;
    }
    if (breakTypeA === 6 && breakTypeB === 6) {
      return false;
    }
    return true;
  }
  function getGraphemeBreakRawData() {
    return JSON.parse("[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]");
  }
  var _a2, CodePointIterator, GraphemeIterator, UTF8_BOM_CHARACTER, GraphemeBreakTree, AmbiguousCharacters, InvisibleCharacters;
  var init_strings = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/strings.js"() {
      init_cache();
      init_lazy();
      CodePointIterator = class {
        get offset() {
          return this._offset;
        }
        constructor(str, offset = 0) {
          this._str = str;
          this._len = str.length;
          this._offset = offset;
        }
        setOffset(offset) {
          this._offset = offset;
        }
        prevCodePoint() {
          const codePoint = getPrevCodePoint(this._str, this._offset);
          this._offset -= codePoint >= 65536 ? 2 : 1;
          return codePoint;
        }
        nextCodePoint() {
          const codePoint = getNextCodePoint(this._str, this._len, this._offset);
          this._offset += codePoint >= 65536 ? 2 : 1;
          return codePoint;
        }
        eol() {
          return this._offset >= this._len;
        }
      };
      GraphemeIterator = class {
        get offset() {
          return this._iterator.offset;
        }
        constructor(str, offset = 0) {
          this._iterator = new CodePointIterator(str, offset);
        }
        nextGraphemeLength() {
          const graphemeBreakTree = GraphemeBreakTree.getInstance();
          const iterator = this._iterator;
          const initialOffset = iterator.offset;
          let graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.nextCodePoint());
          while (!iterator.eol()) {
            const offset = iterator.offset;
            const nextGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.nextCodePoint());
            if (breakBetweenGraphemeBreakType(graphemeBreakType, nextGraphemeBreakType)) {
              iterator.setOffset(offset);
              break;
            }
            graphemeBreakType = nextGraphemeBreakType;
          }
          return iterator.offset - initialOffset;
        }
        prevGraphemeLength() {
          const graphemeBreakTree = GraphemeBreakTree.getInstance();
          const iterator = this._iterator;
          const initialOffset = iterator.offset;
          let graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.prevCodePoint());
          while (iterator.offset > 0) {
            const offset = iterator.offset;
            const prevGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.prevCodePoint());
            if (breakBetweenGraphemeBreakType(prevGraphemeBreakType, graphemeBreakType)) {
              iterator.setOffset(offset);
              break;
            }
            graphemeBreakType = prevGraphemeBreakType;
          }
          return initialOffset - iterator.offset;
        }
        eol() {
          return this._iterator.eol();
        }
      };
      UTF8_BOM_CHARACTER = String.fromCharCode(
        65279
        /* CharCode.UTF8_BOM */
      );
      GraphemeBreakTree = class {
        static getInstance() {
          if (!GraphemeBreakTree._INSTANCE) {
            GraphemeBreakTree._INSTANCE = new GraphemeBreakTree();
          }
          return GraphemeBreakTree._INSTANCE;
        }
        constructor() {
          this._data = getGraphemeBreakRawData();
        }
        getGraphemeBreakType(codePoint) {
          if (codePoint < 32) {
            if (codePoint === 10) {
              return 3;
            }
            if (codePoint === 13) {
              return 2;
            }
            return 4;
          }
          if (codePoint < 127) {
            return 0;
          }
          const data = this._data;
          const nodeCount = data.length / 3;
          let nodeIndex = 1;
          while (nodeIndex <= nodeCount) {
            if (codePoint < data[3 * nodeIndex]) {
              nodeIndex = 2 * nodeIndex;
            } else if (codePoint > data[3 * nodeIndex + 1]) {
              nodeIndex = 2 * nodeIndex + 1;
            } else {
              return data[3 * nodeIndex + 2];
            }
          }
          return 0;
        }
      };
      GraphemeBreakTree._INSTANCE = null;
      AmbiguousCharacters = class {
        static getInstance(locales) {
          return AmbiguousCharacters.cache.get(Array.from(locales));
        }
        static getLocales() {
          return AmbiguousCharacters._locales.value;
        }
        constructor(confusableDictionary) {
          this.confusableDictionary = confusableDictionary;
        }
        isAmbiguous(codePoint) {
          return this.confusableDictionary.has(codePoint);
        }
        /**
         * Returns the non basic ASCII code point that the given code point can be confused,
         * or undefined if such code point does note exist.
         */
        getPrimaryConfusable(codePoint) {
          return this.confusableDictionary.get(codePoint);
        }
        getConfusableCodePoints() {
          return new Set(this.confusableDictionary.keys());
        }
      };
      _a2 = AmbiguousCharacters;
      AmbiguousCharacters.ambiguousCharacterData = new Lazy(() => {
        return JSON.parse('{"_common":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,8218,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,8242,96,1370,96,1523,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71922,67,71913,67,65315,67,8557,67,8450,67,8493,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71919,87,71910,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,66293,90,71909,90,65338,90,8484,90,8488,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65297,49,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125,119846,109],"_default":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"cs":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"de":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"es":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"fr":[65374,126,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"it":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ja":[8211,45,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65292,44,65307,59],"ko":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pl":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pt-BR":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"qps-ploc":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ru":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"tr":[160,32,8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"zh-hans":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41],"zh-hant":[8211,45,65374,126,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65307,59]}');
      });
      AmbiguousCharacters.cache = new LRUCachedFunction((locales) => {
        function arrayToMap(arr) {
          const result = /* @__PURE__ */ new Map();
          for (let i = 0; i < arr.length; i += 2) {
            result.set(arr[i], arr[i + 1]);
          }
          return result;
        }
        function mergeMaps(map1, map2) {
          const result = new Map(map1);
          for (const [key, value] of map2) {
            result.set(key, value);
          }
          return result;
        }
        function intersectMaps(map1, map2) {
          if (!map1) {
            return map2;
          }
          const result = /* @__PURE__ */ new Map();
          for (const [key, value] of map1) {
            if (map2.has(key)) {
              result.set(key, value);
            }
          }
          return result;
        }
        const data = _a2.ambiguousCharacterData.value;
        let filteredLocales = locales.filter((l) => !l.startsWith("_") && l in data);
        if (filteredLocales.length === 0) {
          filteredLocales = ["_default"];
        }
        let languageSpecificMap = void 0;
        for (const locale of filteredLocales) {
          const map2 = arrayToMap(data[locale]);
          languageSpecificMap = intersectMaps(languageSpecificMap, map2);
        }
        const commonMap = arrayToMap(data["_common"]);
        const map = mergeMaps(commonMap, languageSpecificMap);
        return new AmbiguousCharacters(map);
      });
      AmbiguousCharacters._locales = new Lazy(() => Object.keys(AmbiguousCharacters.ambiguousCharacterData.value).filter((k) => !k.startsWith("_")));
      InvisibleCharacters = class {
        static getRawData() {
          return JSON.parse("[9,10,11,12,13,32,127,160,173,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12288,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999]");
        }
        static getData() {
          if (!this._data) {
            this._data = new Set(InvisibleCharacters.getRawData());
          }
          return this._data;
        }
        static isInvisibleCharacter(codePoint) {
          return InvisibleCharacters.getData().has(codePoint);
        }
        static get codePoints() {
          return InvisibleCharacters.getData();
        }
      };
      InvisibleCharacters._data = void 0;
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/filters.js
  function or(...filter) {
    return function(word, wordToMatchAgainst) {
      for (let i = 0, len = filter.length; i < len; i++) {
        const match = filter[i](word, wordToMatchAgainst);
        if (match) {
          return match;
        }
      }
      return null;
    };
  }
  function _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {
    if (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {
      return null;
    }
    let matches;
    if (ignoreCase) {
      matches = startsWithIgnoreCase(wordToMatchAgainst, word);
    } else {
      matches = wordToMatchAgainst.indexOf(word) === 0;
    }
    if (!matches) {
      return null;
    }
    return word.length > 0 ? [{ start: 0, end: word.length }] : [];
  }
  function matchesContiguousSubString(word, wordToMatchAgainst) {
    const index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());
    if (index === -1) {
      return null;
    }
    return [{ start: index, end: index + word.length }];
  }
  function matchesSubString(word, wordToMatchAgainst) {
    return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);
  }
  function _matchesSubString(word, wordToMatchAgainst, i, j) {
    if (i === word.length) {
      return [];
    } else if (j === wordToMatchAgainst.length) {
      return null;
    } else {
      if (word[i] === wordToMatchAgainst[j]) {
        let result = null;
        if (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {
          return join({ start: j, end: j + 1 }, result);
        }
        return null;
      }
      return _matchesSubString(word, wordToMatchAgainst, i, j + 1);
    }
  }
  function isLower(code) {
    return 97 <= code && code <= 122;
  }
  function isUpper(code) {
    return 65 <= code && code <= 90;
  }
  function isNumber(code) {
    return 48 <= code && code <= 57;
  }
  function isWhitespace(code) {
    return code === 32 || code === 9 || code === 10 || code === 13;
  }
  function isAlphanumeric(code) {
    return isLower(code) || isUpper(code) || isNumber(code);
  }
  function join(head, tail) {
    if (tail.length === 0) {
      tail = [head];
    } else if (head.end === tail[0].start) {
      tail[0].start = head.start;
    } else {
      tail.unshift(head);
    }
    return tail;
  }
  function nextAnchor(camelCaseWord, start) {
    for (let i = start; i < camelCaseWord.length; i++) {
      const c = camelCaseWord.charCodeAt(i);
      if (isUpper(c) || isNumber(c) || i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1))) {
        return i;
      }
    }
    return camelCaseWord.length;
  }
  function _matchesCamelCase(word, camelCaseWord, i, j) {
    if (i === word.length) {
      return [];
    } else if (j === camelCaseWord.length) {
      return null;
    } else if (word[i] !== camelCaseWord[j].toLowerCase()) {
      return null;
    } else {
      let result = null;
      let nextUpperIndex = j + 1;
      result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);
      while (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {
        result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);
        nextUpperIndex++;
      }
      return result === null ? null : join({ start: j, end: j + 1 }, result);
    }
  }
  function analyzeCamelCaseWord(word) {
    let upper = 0, lower = 0, alpha = 0, numeric = 0, code = 0;
    for (let i = 0; i < word.length; i++) {
      code = word.charCodeAt(i);
      if (isUpper(code)) {
        upper++;
      }
      if (isLower(code)) {
        lower++;
      }
      if (isAlphanumeric(code)) {
        alpha++;
      }
      if (isNumber(code)) {
        numeric++;
      }
    }
    const upperPercent = upper / word.length;
    const lowerPercent = lower / word.length;
    const alphaPercent = alpha / word.length;
    const numericPercent = numeric / word.length;
    return { upperPercent, lowerPercent, alphaPercent, numericPercent };
  }
  function isUpperCaseWord(analysis) {
    const { upperPercent, lowerPercent } = analysis;
    return lowerPercent === 0 && upperPercent > 0.6;
  }
  function isCamelCaseWord(analysis) {
    const { upperPercent, lowerPercent, alphaPercent, numericPercent } = analysis;
    return lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;
  }
  function isCamelCasePattern(word) {
    let upper = 0, lower = 0, code = 0, whitespace = 0;
    for (let i = 0; i < word.length; i++) {
      code = word.charCodeAt(i);
      if (isUpper(code)) {
        upper++;
      }
      if (isLower(code)) {
        lower++;
      }
      if (isWhitespace(code)) {
        whitespace++;
      }
    }
    if ((upper === 0 || lower === 0) && whitespace === 0) {
      return word.length <= 30;
    } else {
      return upper <= 5;
    }
  }
  function matchesCamelCase(word, camelCaseWord) {
    if (!camelCaseWord) {
      return null;
    }
    camelCaseWord = camelCaseWord.trim();
    if (camelCaseWord.length === 0) {
      return null;
    }
    if (!isCamelCasePattern(word)) {
      return null;
    }
    if (camelCaseWord.length > 60) {
      return null;
    }
    const analysis = analyzeCamelCaseWord(camelCaseWord);
    if (!isCamelCaseWord(analysis)) {
      if (!isUpperCaseWord(analysis)) {
        return null;
      }
      camelCaseWord = camelCaseWord.toLowerCase();
    }
    let result = null;
    let i = 0;
    word = word.toLowerCase();
    while (i < camelCaseWord.length && (result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null) {
      i = nextAnchor(camelCaseWord, i + 1);
    }
    return result;
  }
  function initTable() {
    const table = [];
    const row = [];
    for (let i = 0; i <= _maxLen; i++) {
      row[i] = 0;
    }
    for (let i = 0; i <= _maxLen; i++) {
      table.push(row.slice(0));
    }
    return table;
  }
  function initArr(maxLen) {
    const row = [];
    for (let i = 0; i <= maxLen; i++) {
      row[i] = 0;
    }
    return row;
  }
  var matchesStrictPrefix, matchesPrefix, wordSeparators, fuzzyContiguousFilter, fuzzySeparateFilter, fuzzyRegExpCache, _maxLen, _minWordMatchPos, _maxWordMatchPos, _diag, _table, _arrows, FuzzyScore, FuzzyScoreOptions;
  var init_filters = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/filters.js"() {
      init_map();
      init_strings();
      matchesStrictPrefix = _matchesPrefix.bind(void 0, false);
      matchesPrefix = _matchesPrefix.bind(void 0, true);
      wordSeparators = /* @__PURE__ */ new Set();
      "()[]{}<>`'\"-/;:,.?!".split("").forEach((s) => wordSeparators.add(s.charCodeAt(0)));
      fuzzyContiguousFilter = or(matchesPrefix, matchesCamelCase, matchesContiguousSubString);
      fuzzySeparateFilter = or(matchesPrefix, matchesCamelCase, matchesSubString);
      fuzzyRegExpCache = new LRUCache(1e4);
      _maxLen = 128;
      _minWordMatchPos = initArr(2 * _maxLen);
      _maxWordMatchPos = initArr(2 * _maxLen);
      _diag = initTable();
      _table = initTable();
      _arrows = initTable();
      (function(FuzzyScore2) {
        FuzzyScore2.Default = [-100, 0];
        function isDefault(score) {
          return !score || score.length === 2 && score[0] === -100 && score[1] === 0;
        }
        FuzzyScore2.isDefault = isDefault;
      })(FuzzyScore || (FuzzyScore = {}));
      FuzzyScoreOptions = class {
        constructor(firstMatchCanBeWeak, boostFullMatch) {
          this.firstMatchCanBeWeak = firstMatchCanBeWeak;
          this.boostFullMatch = boostFullMatch;
        }
      };
      FuzzyScoreOptions.default = { boostFullMatch: true, firstMatchCanBeWeak: false };
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/types.js
  function isString(str) {
    return typeof str === "string";
  }
  function isStringArray(value) {
    return Array.isArray(value) && value.every((elem) => isString(elem));
  }
  function isObject(obj) {
    return typeof obj === "object" && obj !== null && !Array.isArray(obj) && !(obj instanceof RegExp) && !(obj instanceof Date);
  }
  function isNumber2(obj) {
    return typeof obj === "number" && !isNaN(obj);
  }
  var init_types = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/types.js"() {
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/codicons.js
  function register(id2, fontCharacter) {
    if (isString(fontCharacter)) {
      const val = _codiconFontCharacters[fontCharacter];
      if (val === void 0) {
        throw new Error(`${id2} references an unknown codicon: ${fontCharacter}`);
      }
      fontCharacter = val;
    }
    _codiconFontCharacters[id2] = fontCharacter;
    return { id: id2 };
  }
  var _codiconFontCharacters, Codicon;
  var init_codicons = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/codicons.js"() {
      init_types();
      _codiconFontCharacters = /* @__PURE__ */ Object.create(null);
      Codicon = {
        // built-in icons, with image name
        add: register("add", 6e4),
        plus: register("plus", 6e4),
        gistNew: register("gist-new", 6e4),
        repoCreate: register("repo-create", 6e4),
        lightbulb: register("lightbulb", 60001),
        lightBulb: register("light-bulb", 60001),
        repo: register("repo", 60002),
        repoDelete: register("repo-delete", 60002),
        gistFork: register("gist-fork", 60003),
        repoForked: register("repo-forked", 60003),
        gitPullRequest: register("git-pull-request", 60004),
        gitPullRequestAbandoned: register("git-pull-request-abandoned", 60004),
        recordKeys: register("record-keys", 60005),
        keyboard: register("keyboard", 60005),
        tag: register("tag", 60006),
        tagAdd: register("tag-add", 60006),
        tagRemove: register("tag-remove", 60006),
        person: register("person", 60007),
        personFollow: register("person-follow", 60007),
        personOutline: register("person-outline", 60007),
        personFilled: register("person-filled", 60007),
        gitBranch: register("git-branch", 60008),
        gitBranchCreate: register("git-branch-create", 60008),
        gitBranchDelete: register("git-branch-delete", 60008),
        sourceControl: register("source-control", 60008),
        mirror: register("mirror", 60009),
        mirrorPublic: register("mirror-public", 60009),
        star: register("star", 60010),
        starAdd: register("star-add", 60010),
        starDelete: register("star-delete", 60010),
        starEmpty: register("star-empty", 60010),
        comment: register("comment", 60011),
        commentAdd: register("comment-add", 60011),
        alert: register("alert", 60012),
        warning: register("warning", 60012),
        search: register("search", 60013),
        searchSave: register("search-save", 60013),
        logOut: register("log-out", 60014),
        signOut: register("sign-out", 60014),
        logIn: register("log-in", 60015),
        signIn: register("sign-in", 60015),
        eye: register("eye", 60016),
        eyeUnwatch: register("eye-unwatch", 60016),
        eyeWatch: register("eye-watch", 60016),
        circleFilled: register("circle-filled", 60017),
        primitiveDot: register("primitive-dot", 60017),
        closeDirty: register("close-dirty", 60017),
        debugBreakpoint: register("debug-breakpoint", 60017),
        debugBreakpointDisabled: register("debug-breakpoint-disabled", 60017),
        debugHint: register("debug-hint", 60017),
        primitiveSquare: register("primitive-square", 60018),
        edit: register("edit", 60019),
        pencil: register("pencil", 60019),
        info: register("info", 60020),
        issueOpened: register("issue-opened", 60020),
        gistPrivate: register("gist-private", 60021),
        gitForkPrivate: register("git-fork-private", 60021),
        lock: register("lock", 60021),
        mirrorPrivate: register("mirror-private", 60021),
        close: register("close", 60022),
        removeClose: register("remove-close", 60022),
        x: register("x", 60022),
        repoSync: register("repo-sync", 60023),
        sync: register("sync", 60023),
        clone: register("clone", 60024),
        desktopDownload: register("desktop-download", 60024),
        beaker: register("beaker", 60025),
        microscope: register("microscope", 60025),
        vm: register("vm", 60026),
        deviceDesktop: register("device-desktop", 60026),
        file: register("file", 60027),
        fileText: register("file-text", 60027),
        more: register("more", 60028),
        ellipsis: register("ellipsis", 60028),
        kebabHorizontal: register("kebab-horizontal", 60028),
        mailReply: register("mail-reply", 60029),
        reply: register("reply", 60029),
        organization: register("organization", 60030),
        organizationFilled: register("organization-filled", 60030),
        organizationOutline: register("organization-outline", 60030),
        newFile: register("new-file", 60031),
        fileAdd: register("file-add", 60031),
        newFolder: register("new-folder", 60032),
        fileDirectoryCreate: register("file-directory-create", 60032),
        trash: register("trash", 60033),
        trashcan: register("trashcan", 60033),
        history: register("history", 60034),
        clock: register("clock", 60034),
        folder: register("folder", 60035),
        fileDirectory: register("file-directory", 60035),
        symbolFolder: register("symbol-folder", 60035),
        logoGithub: register("logo-github", 60036),
        markGithub: register("mark-github", 60036),
        github: register("github", 60036),
        terminal: register("terminal", 60037),
        console: register("console", 60037),
        repl: register("repl", 60037),
        zap: register("zap", 60038),
        symbolEvent: register("symbol-event", 60038),
        error: register("error", 60039),
        stop: register("stop", 60039),
        variable: register("variable", 60040),
        symbolVariable: register("symbol-variable", 60040),
        array: register("array", 60042),
        symbolArray: register("symbol-array", 60042),
        symbolModule: register("symbol-module", 60043),
        symbolPackage: register("symbol-package", 60043),
        symbolNamespace: register("symbol-namespace", 60043),
        symbolObject: register("symbol-object", 60043),
        symbolMethod: register("symbol-method", 60044),
        symbolFunction: register("symbol-function", 60044),
        symbolConstructor: register("symbol-constructor", 60044),
        symbolBoolean: register("symbol-boolean", 60047),
        symbolNull: register("symbol-null", 60047),
        symbolNumeric: register("symbol-numeric", 60048),
        symbolNumber: register("symbol-number", 60048),
        symbolStructure: register("symbol-structure", 60049),
        symbolStruct: register("symbol-struct", 60049),
        symbolParameter: register("symbol-parameter", 60050),
        symbolTypeParameter: register("symbol-type-parameter", 60050),
        symbolKey: register("symbol-key", 60051),
        symbolText: register("symbol-text", 60051),
        symbolReference: register("symbol-reference", 60052),
        goToFile: register("go-to-file", 60052),
        symbolEnum: register("symbol-enum", 60053),
        symbolValue: register("symbol-value", 60053),
        symbolRuler: register("symbol-ruler", 60054),
        symbolUnit: register("symbol-unit", 60054),
        activateBreakpoints: register("activate-breakpoints", 60055),
        archive: register("archive", 60056),
        arrowBoth: register("arrow-both", 60057),
        arrowDown: register("arrow-down", 60058),
        arrowLeft: register("arrow-left", 60059),
        arrowRight: register("arrow-right", 60060),
        arrowSmallDown: register("arrow-small-down", 60061),
        arrowSmallLeft: register("arrow-small-left", 60062),
        arrowSmallRight: register("arrow-small-right", 60063),
        arrowSmallUp: register("arrow-small-up", 60064),
        arrowUp: register("arrow-up", 60065),
        bell: register("bell", 60066),
        bold: register("bold", 60067),
        book: register("book", 60068),
        bookmark: register("bookmark", 60069),
        debugBreakpointConditionalUnverified: register("debug-breakpoint-conditional-unverified", 60070),
        debugBreakpointConditional: register("debug-breakpoint-conditional", 60071),
        debugBreakpointConditionalDisabled: register("debug-breakpoint-conditional-disabled", 60071),
        debugBreakpointDataUnverified: register("debug-breakpoint-data-unverified", 60072),
        debugBreakpointData: register("debug-breakpoint-data", 60073),
        debugBreakpointDataDisabled: register("debug-breakpoint-data-disabled", 60073),
        debugBreakpointLogUnverified: register("debug-breakpoint-log-unverified", 60074),
        debugBreakpointLog: register("debug-breakpoint-log", 60075),
        debugBreakpointLogDisabled: register("debug-breakpoint-log-disabled", 60075),
        briefcase: register("briefcase", 60076),
        broadcast: register("broadcast", 60077),
        browser: register("browser", 60078),
        bug: register("bug", 60079),
        calendar: register("calendar", 60080),
        caseSensitive: register("case-sensitive", 60081),
        check: register("check", 60082),
        checklist: register("checklist", 60083),
        chevronDown: register("chevron-down", 60084),
        dropDownButton: register("drop-down-button", 60084),
        chevronLeft: register("chevron-left", 60085),
        chevronRight: register("chevron-right", 60086),
        chevronUp: register("chevron-up", 60087),
        chromeClose: register("chrome-close", 60088),
        chromeMaximize: register("chrome-maximize", 60089),
        chromeMinimize: register("chrome-minimize", 60090),
        chromeRestore: register("chrome-restore", 60091),
        circle: register("circle", 60092),
        circleOutline: register("circle-outline", 60092),
        debugBreakpointUnverified: register("debug-breakpoint-unverified", 60092),
        circleSlash: register("circle-slash", 60093),
        circuitBoard: register("circuit-board", 60094),
        clearAll: register("clear-all", 60095),
        clippy: register("clippy", 60096),
        closeAll: register("close-all", 60097),
        cloudDownload: register("cloud-download", 60098),
        cloudUpload: register("cloud-upload", 60099),
        code: register("code", 60100),
        collapseAll: register("collapse-all", 60101),
        colorMode: register("color-mode", 60102),
        commentDiscussion: register("comment-discussion", 60103),
        compareChanges: register("compare-changes", 60157),
        creditCard: register("credit-card", 60105),
        dash: register("dash", 60108),
        dashboard: register("dashboard", 60109),
        database: register("database", 60110),
        debugContinue: register("debug-continue", 60111),
        debugDisconnect: register("debug-disconnect", 60112),
        debugPause: register("debug-pause", 60113),
        debugRestart: register("debug-restart", 60114),
        debugStart: register("debug-start", 60115),
        debugStepInto: register("debug-step-into", 60116),
        debugStepOut: register("debug-step-out", 60117),
        debugStepOver: register("debug-step-over", 60118),
        debugStop: register("debug-stop", 60119),
        debug: register("debug", 60120),
        deviceCameraVideo: register("device-camera-video", 60121),
        deviceCamera: register("device-camera", 60122),
        deviceMobile: register("device-mobile", 60123),
        diffAdded: register("diff-added", 60124),
        diffIgnored: register("diff-ignored", 60125),
        diffModified: register("diff-modified", 60126),
        diffRemoved: register("diff-removed", 60127),
        diffRenamed: register("diff-renamed", 60128),
        diff: register("diff", 60129),
        discard: register("discard", 60130),
        editorLayout: register("editor-layout", 60131),
        emptyWindow: register("empty-window", 60132),
        exclude: register("exclude", 60133),
        extensions: register("extensions", 60134),
        eyeClosed: register("eye-closed", 60135),
        fileBinary: register("file-binary", 60136),
        fileCode: register("file-code", 60137),
        fileMedia: register("file-media", 60138),
        filePdf: register("file-pdf", 60139),
        fileSubmodule: register("file-submodule", 60140),
        fileSymlinkDirectory: register("file-symlink-directory", 60141),
        fileSymlinkFile: register("file-symlink-file", 60142),
        fileZip: register("file-zip", 60143),
        files: register("files", 60144),
        filter: register("filter", 60145),
        flame: register("flame", 60146),
        foldDown: register("fold-down", 60147),
        foldUp: register("fold-up", 60148),
        fold: register("fold", 60149),
        folderActive: register("folder-active", 60150),
        folderOpened: register("folder-opened", 60151),
        gear: register("gear", 60152),
        gift: register("gift", 60153),
        gistSecret: register("gist-secret", 60154),
        gist: register("gist", 60155),
        gitCommit: register("git-commit", 60156),
        gitCompare: register("git-compare", 60157),
        gitMerge: register("git-merge", 60158),
        githubAction: register("github-action", 60159),
        githubAlt: register("github-alt", 60160),
        globe: register("globe", 60161),
        grabber: register("grabber", 60162),
        graph: register("graph", 60163),
        gripper: register("gripper", 60164),
        heart: register("heart", 60165),
        home: register("home", 60166),
        horizontalRule: register("horizontal-rule", 60167),
        hubot: register("hubot", 60168),
        inbox: register("inbox", 60169),
        issueClosed: register("issue-closed", 60324),
        issueReopened: register("issue-reopened", 60171),
        issues: register("issues", 60172),
        italic: register("italic", 60173),
        jersey: register("jersey", 60174),
        json: register("json", 60175),
        bracket: register("bracket", 60175),
        kebabVertical: register("kebab-vertical", 60176),
        key: register("key", 60177),
        law: register("law", 60178),
        lightbulbAutofix: register("lightbulb-autofix", 60179),
        linkExternal: register("link-external", 60180),
        link: register("link", 60181),
        listOrdered: register("list-ordered", 60182),
        listUnordered: register("list-unordered", 60183),
        liveShare: register("live-share", 60184),
        loading: register("loading", 60185),
        location: register("location", 60186),
        mailRead: register("mail-read", 60187),
        mail: register("mail", 60188),
        markdown: register("markdown", 60189),
        megaphone: register("megaphone", 60190),
        mention: register("mention", 60191),
        milestone: register("milestone", 60192),
        mortarBoard: register("mortar-board", 60193),
        move: register("move", 60194),
        multipleWindows: register("multiple-windows", 60195),
        mute: register("mute", 60196),
        noNewline: register("no-newline", 60197),
        note: register("note", 60198),
        octoface: register("octoface", 60199),
        openPreview: register("open-preview", 60200),
        package_: register("package", 60201),
        paintcan: register("paintcan", 60202),
        pin: register("pin", 60203),
        play: register("play", 60204),
        run: register("run", 60204),
        plug: register("plug", 60205),
        preserveCase: register("preserve-case", 60206),
        preview: register("preview", 60207),
        project: register("project", 60208),
        pulse: register("pulse", 60209),
        question: register("question", 60210),
        quote: register("quote", 60211),
        radioTower: register("radio-tower", 60212),
        reactions: register("reactions", 60213),
        references: register("references", 60214),
        refresh: register("refresh", 60215),
        regex: register("regex", 60216),
        remoteExplorer: register("remote-explorer", 60217),
        remote: register("remote", 60218),
        remove: register("remove", 60219),
        replaceAll: register("replace-all", 60220),
        replace: register("replace", 60221),
        repoClone: register("repo-clone", 60222),
        repoForcePush: register("repo-force-push", 60223),
        repoPull: register("repo-pull", 60224),
        repoPush: register("repo-push", 60225),
        report: register("report", 60226),
        requestChanges: register("request-changes", 60227),
        rocket: register("rocket", 60228),
        rootFolderOpened: register("root-folder-opened", 60229),
        rootFolder: register("root-folder", 60230),
        rss: register("rss", 60231),
        ruby: register("ruby", 60232),
        saveAll: register("save-all", 60233),
        saveAs: register("save-as", 60234),
        save: register("save", 60235),
        screenFull: register("screen-full", 60236),
        screenNormal: register("screen-normal", 60237),
        searchStop: register("search-stop", 60238),
        server: register("server", 60240),
        settingsGear: register("settings-gear", 60241),
        settings: register("settings", 60242),
        shield: register("shield", 60243),
        smiley: register("smiley", 60244),
        sortPrecedence: register("sort-precedence", 60245),
        splitHorizontal: register("split-horizontal", 60246),
        splitVertical: register("split-vertical", 60247),
        squirrel: register("squirrel", 60248),
        starFull: register("star-full", 60249),
        starHalf: register("star-half", 60250),
        symbolClass: register("symbol-class", 60251),
        symbolColor: register("symbol-color", 60252),
        symbolCustomColor: register("symbol-customcolor", 60252),
        symbolConstant: register("symbol-constant", 60253),
        symbolEnumMember: register("symbol-enum-member", 60254),
        symbolField: register("symbol-field", 60255),
        symbolFile: register("symbol-file", 60256),
        symbolInterface: register("symbol-interface", 60257),
        symbolKeyword: register("symbol-keyword", 60258),
        symbolMisc: register("symbol-misc", 60259),
        symbolOperator: register("symbol-operator", 60260),
        symbolProperty: register("symbol-property", 60261),
        wrench: register("wrench", 60261),
        wrenchSubaction: register("wrench-subaction", 60261),
        symbolSnippet: register("symbol-snippet", 60262),
        tasklist: register("tasklist", 60263),
        telescope: register("telescope", 60264),
        textSize: register("text-size", 60265),
        threeBars: register("three-bars", 60266),
        thumbsdown: register("thumbsdown", 60267),
        thumbsup: register("thumbsup", 60268),
        tools: register("tools", 60269),
        triangleDown: register("triangle-down", 60270),
        triangleLeft: register("triangle-left", 60271),
        triangleRight: register("triangle-right", 60272),
        triangleUp: register("triangle-up", 60273),
        twitter: register("twitter", 60274),
        unfold: register("unfold", 60275),
        unlock: register("unlock", 60276),
        unmute: register("unmute", 60277),
        unverified: register("unverified", 60278),
        verified: register("verified", 60279),
        versions: register("versions", 60280),
        vmActive: register("vm-active", 60281),
        vmOutline: register("vm-outline", 60282),
        vmRunning: register("vm-running", 60283),
        watch: register("watch", 60284),
        whitespace: register("whitespace", 60285),
        wholeWord: register("whole-word", 60286),
        window: register("window", 60287),
        wordWrap: register("word-wrap", 60288),
        zoomIn: register("zoom-in", 60289),
        zoomOut: register("zoom-out", 60290),
        listFilter: register("list-filter", 60291),
        listFlat: register("list-flat", 60292),
        listSelection: register("list-selection", 60293),
        selection: register("selection", 60293),
        listTree: register("list-tree", 60294),
        debugBreakpointFunctionUnverified: register("debug-breakpoint-function-unverified", 60295),
        debugBreakpointFunction: register("debug-breakpoint-function", 60296),
        debugBreakpointFunctionDisabled: register("debug-breakpoint-function-disabled", 60296),
        debugStackframeActive: register("debug-stackframe-active", 60297),
        circleSmallFilled: register("circle-small-filled", 60298),
        debugStackframeDot: register("debug-stackframe-dot", 60298),
        debugStackframe: register("debug-stackframe", 60299),
        debugStackframeFocused: register("debug-stackframe-focused", 60299),
        debugBreakpointUnsupported: register("debug-breakpoint-unsupported", 60300),
        symbolString: register("symbol-string", 60301),
        debugReverseContinue: register("debug-reverse-continue", 60302),
        debugStepBack: register("debug-step-back", 60303),
        debugRestartFrame: register("debug-restart-frame", 60304),
        callIncoming: register("call-incoming", 60306),
        callOutgoing: register("call-outgoing", 60307),
        menu: register("menu", 60308),
        expandAll: register("expand-all", 60309),
        feedback: register("feedback", 60310),
        groupByRefType: register("group-by-ref-type", 60311),
        ungroupByRefType: register("ungroup-by-ref-type", 60312),
        account: register("account", 60313),
        bellDot: register("bell-dot", 60314),
        debugConsole: register("debug-console", 60315),
        library: register("library", 60316),
        output: register("output", 60317),
        runAll: register("run-all", 60318),
        syncIgnored: register("sync-ignored", 60319),
        pinned: register("pinned", 60320),
        githubInverted: register("github-inverted", 60321),
        debugAlt: register("debug-alt", 60305),
        serverProcess: register("server-process", 60322),
        serverEnvironment: register("server-environment", 60323),
        pass: register("pass", 60324),
        stopCircle: register("stop-circle", 60325),
        playCircle: register("play-circle", 60326),
        record: register("record", 60327),
        debugAltSmall: register("debug-alt-small", 60328),
        vmConnect: register("vm-connect", 60329),
        cloud: register("cloud", 60330),
        merge: register("merge", 60331),
        exportIcon: register("export", 60332),
        graphLeft: register("graph-left", 60333),
        magnet: register("magnet", 60334),
        notebook: register("notebook", 60335),
        redo: register("redo", 60336),
        checkAll: register("check-all", 60337),
        pinnedDirty: register("pinned-dirty", 60338),
        passFilled: register("pass-filled", 60339),
        circleLargeFilled: register("circle-large-filled", 60340),
        circleLarge: register("circle-large", 60341),
        circleLargeOutline: register("circle-large-outline", 60341),
        combine: register("combine", 60342),
        gather: register("gather", 60342),
        table: register("table", 60343),
        variableGroup: register("variable-group", 60344),
        typeHierarchy: register("type-hierarchy", 60345),
        typeHierarchySub: register("type-hierarchy-sub", 60346),
        typeHierarchySuper: register("type-hierarchy-super", 60347),
        gitPullRequestCreate: register("git-pull-request-create", 60348),
        runAbove: register("run-above", 60349),
        runBelow: register("run-below", 60350),
        notebookTemplate: register("notebook-template", 60351),
        debugRerun: register("debug-rerun", 60352),
        workspaceTrusted: register("workspace-trusted", 60353),
        workspaceUntrusted: register("workspace-untrusted", 60354),
        workspaceUnspecified: register("workspace-unspecified", 60355),
        terminalCmd: register("terminal-cmd", 60356),
        terminalDebian: register("terminal-debian", 60357),
        terminalLinux: register("terminal-linux", 60358),
        terminalPowershell: register("terminal-powershell", 60359),
        terminalTmux: register("terminal-tmux", 60360),
        terminalUbuntu: register("terminal-ubuntu", 60361),
        terminalBash: register("terminal-bash", 60362),
        arrowSwap: register("arrow-swap", 60363),
        copy: register("copy", 60364),
        personAdd: register("person-add", 60365),
        filterFilled: register("filter-filled", 60366),
        wand: register("wand", 60367),
        debugLineByLine: register("debug-line-by-line", 60368),
        inspect: register("inspect", 60369),
        layers: register("layers", 60370),
        layersDot: register("layers-dot", 60371),
        layersActive: register("layers-active", 60372),
        compass: register("compass", 60373),
        compassDot: register("compass-dot", 60374),
        compassActive: register("compass-active", 60375),
        azure: register("azure", 60376),
        issueDraft: register("issue-draft", 60377),
        gitPullRequestClosed: register("git-pull-request-closed", 60378),
        gitPullRequestDraft: register("git-pull-request-draft", 60379),
        debugAll: register("debug-all", 60380),
        debugCoverage: register("debug-coverage", 60381),
        runErrors: register("run-errors", 60382),
        folderLibrary: register("folder-library", 60383),
        debugContinueSmall: register("debug-continue-small", 60384),
        beakerStop: register("beaker-stop", 60385),
        graphLine: register("graph-line", 60386),
        graphScatter: register("graph-scatter", 60387),
        pieChart: register("pie-chart", 60388),
        bracketDot: register("bracket-dot", 60389),
        bracketError: register("bracket-error", 60390),
        lockSmall: register("lock-small", 60391),
        azureDevops: register("azure-devops", 60392),
        verifiedFilled: register("verified-filled", 60393),
        newLine: register("newline", 60394),
        layout: register("layout", 60395),
        layoutActivitybarLeft: register("layout-activitybar-left", 60396),
        layoutActivitybarRight: register("layout-activitybar-right", 60397),
        layoutPanelLeft: register("layout-panel-left", 60398),
        layoutPanelCenter: register("layout-panel-center", 60399),
        layoutPanelJustify: register("layout-panel-justify", 60400),
        layoutPanelRight: register("layout-panel-right", 60401),
        layoutPanel: register("layout-panel", 60402),
        layoutSidebarLeft: register("layout-sidebar-left", 60403),
        layoutSidebarRight: register("layout-sidebar-right", 60404),
        layoutStatusbar: register("layout-statusbar", 60405),
        layoutMenubar: register("layout-menubar", 60406),
        layoutCentered: register("layout-centered", 60407),
        layoutSidebarRightOff: register("layout-sidebar-right-off", 60416),
        layoutPanelOff: register("layout-panel-off", 60417),
        layoutSidebarLeftOff: register("layout-sidebar-left-off", 60418),
        target: register("target", 60408),
        indent: register("indent", 60409),
        recordSmall: register("record-small", 60410),
        errorSmall: register("error-small", 60411),
        arrowCircleDown: register("arrow-circle-down", 60412),
        arrowCircleLeft: register("arrow-circle-left", 60413),
        arrowCircleRight: register("arrow-circle-right", 60414),
        arrowCircleUp: register("arrow-circle-up", 60415),
        heartFilled: register("heart-filled", 60420),
        map: register("map", 60421),
        mapFilled: register("map-filled", 60422),
        circleSmall: register("circle-small", 60423),
        bellSlash: register("bell-slash", 60424),
        bellSlashDot: register("bell-slash-dot", 60425),
        commentUnresolved: register("comment-unresolved", 60426),
        gitPullRequestGoToChanges: register("git-pull-request-go-to-changes", 60427),
        gitPullRequestNewChanges: register("git-pull-request-new-changes", 60428),
        searchFuzzy: register("search-fuzzy", 60429),
        commentDraft: register("comment-draft", 60430),
        send: register("send", 60431),
        sparkle: register("sparkle", 60432),
        insert: register("insert", 60433),
        // derived icons, that could become separate icons
        dialogError: register("dialog-error", "error"),
        dialogWarning: register("dialog-warning", "warning"),
        dialogInfo: register("dialog-info", "info"),
        dialogClose: register("dialog-close", "close"),
        treeItemExpanded: register("tree-item-expanded", "chevron-down"),
        treeFilterOnTypeOn: register("tree-filter-on-type-on", "list-filter"),
        treeFilterOnTypeOff: register("tree-filter-on-type-off", "list-selection"),
        treeFilterClear: register("tree-filter-clear", "close"),
        treeItemLoading: register("tree-item-loading", "loading"),
        menuSelection: register("menu-selection", "check"),
        menuSubmenu: register("menu-submenu", "chevron-right"),
        menuBarMore: register("menubar-more", "more"),
        scrollbarButtonLeft: register("scrollbar-button-left", "triangle-left"),
        scrollbarButtonRight: register("scrollbar-button-right", "triangle-right"),
        scrollbarButtonUp: register("scrollbar-button-up", "triangle-up"),
        scrollbarButtonDown: register("scrollbar-button-down", "triangle-down"),
        toolBarMore: register("toolbar-more", "more"),
        quickInputBack: register("quick-input-back", "arrow-left")
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/themables.js
  var ThemeColor, ThemeIcon;
  var init_themables = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/themables.js"() {
      init_codicons();
      (function(ThemeColor5) {
        function isThemeColor(obj) {
          return obj && typeof obj === "object" && typeof obj.id === "string";
        }
        ThemeColor5.isThemeColor = isThemeColor;
      })(ThemeColor || (ThemeColor = {}));
      (function(ThemeIcon5) {
        ThemeIcon5.iconNameSegment = "[A-Za-z0-9]+";
        ThemeIcon5.iconNameExpression = "[A-Za-z0-9-]+";
        ThemeIcon5.iconModifierExpression = "~[A-Za-z]+";
        ThemeIcon5.iconNameCharacter = "[A-Za-z0-9~-]";
        const ThemeIconIdRegex = new RegExp(`^(${ThemeIcon5.iconNameExpression})(${ThemeIcon5.iconModifierExpression})?$`);
        function asClassNameArray(icon) {
          const match = ThemeIconIdRegex.exec(icon.id);
          if (!match) {
            return asClassNameArray(Codicon.error);
          }
          const [, id2, modifier] = match;
          const classNames = ["codicon", "codicon-" + id2];
          if (modifier) {
            classNames.push("codicon-modifier-" + modifier.substring(1));
          }
          return classNames;
        }
        ThemeIcon5.asClassNameArray = asClassNameArray;
        function asClassName(icon) {
          return asClassNameArray(icon).join(" ");
        }
        ThemeIcon5.asClassName = asClassName;
        function asCSSSelector(icon) {
          return "." + asClassNameArray(icon).join(".");
        }
        ThemeIcon5.asCSSSelector = asCSSSelector;
        function isThemeIcon(obj) {
          return obj && typeof obj === "object" && typeof obj.id === "string" && (typeof obj.color === "undefined" || ThemeColor.isThemeColor(obj.color));
        }
        ThemeIcon5.isThemeIcon = isThemeIcon;
        const _regexFromString = new RegExp(`^\\$\\((${ThemeIcon5.iconNameExpression}(?:${ThemeIcon5.iconModifierExpression})?)\\)$`);
        function fromString(str) {
          const match = _regexFromString.exec(str);
          if (!match) {
            return void 0;
          }
          const [, name] = match;
          return { id: name };
        }
        ThemeIcon5.fromString = fromString;
        function fromId(id2) {
          return { id: id2 };
        }
        ThemeIcon5.fromId = fromId;
        function modify(icon, modifier) {
          let id2 = icon.id;
          const tildeIndex = id2.lastIndexOf("~");
          if (tildeIndex !== -1) {
            id2 = id2.substring(0, tildeIndex);
          }
          if (modifier) {
            id2 = `${id2}~${modifier}`;
          }
          return { id: id2 };
        }
        ThemeIcon5.modify = modify;
        function getModifier(icon) {
          const tildeIndex = icon.id.lastIndexOf("~");
          if (tildeIndex !== -1) {
            return icon.id.substring(tildeIndex + 1);
          }
          return void 0;
        }
        ThemeIcon5.getModifier = getModifier;
        function isEqual2(ti1, ti2) {
          var _a4, _b2;
          return ti1.id === ti2.id && ((_a4 = ti1.color) === null || _a4 === void 0 ? void 0 : _a4.id) === ((_b2 = ti2.color) === null || _b2 === void 0 ? void 0 : _b2.id);
        }
        ThemeIcon5.isEqual = isEqual2;
      })(ThemeIcon || (ThemeIcon = {}));
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/iconLabels.js
  function escapeIcons(text) {
    return text.replace(escapeIconsRegex, (match, escaped) => escaped ? match : `\\${match}`);
  }
  var iconsRegex, escapeIconsRegex, markdownEscapedIconsRegex, stripIconsRegex, _parseIconsRegex;
  var init_iconLabels = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/iconLabels.js"() {
      init_filters();
      init_strings();
      init_themables();
      iconsRegex = new RegExp(`\\$\\(${ThemeIcon.iconNameExpression}(?:${ThemeIcon.iconModifierExpression})?\\)`, "g");
      escapeIconsRegex = new RegExp(`(\\\\)?${iconsRegex.source}`, "g");
      markdownEscapedIconsRegex = new RegExp(`\\\\${iconsRegex.source}`, "g");
      stripIconsRegex = new RegExp(`(\\s)?(\\\\)?${iconsRegex.source}(\\s)?`, "g");
      _parseIconsRegex = new RegExp(`\\$\\(${ThemeIcon.iconNameCharacter}+\\)`, "g");
    }
  });

  // node_modules/monaco-editor/esm/vs/nls.js
  function _format(message, args) {
    let result;
    if (args.length === 0) {
      result = message;
    } else {
      result = message.replace(/\{(\d+)\}/g, (match, rest) => {
        const index = rest[0];
        const arg = args[index];
        let result2 = match;
        if (typeof arg === "string") {
          result2 = arg;
        } else if (typeof arg === "number" || typeof arg === "boolean" || arg === void 0 || arg === null) {
          result2 = String(arg);
        }
        return result2;
      });
    }
    if (isPseudo) {
      result = "\uFF3B" + result.replace(/[aouei]/g, "$&$&") + "\uFF3D";
    }
    return result;
  }
  function localize(data, message, ...args) {
    return _format(message, args);
  }
  function getConfiguredDefaultLocale(_) {
    return void 0;
  }
  var isPseudo;
  var init_nls = __esm({
    "node_modules/monaco-editor/esm/vs/nls.js"() {
      isPseudo = typeof document !== "undefined" && document.location && document.location.hash.indexOf("pseudo=true") >= 0;
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/platform.js
  var _a3, LANGUAGE_DEFAULT, _isWindows, _isMacintosh, _isLinux, _isLinuxSnap, _isNative, _isWeb, _isElectron, _isIOS, _isCI, _isMobile, _locale, _language, _platformLocale, _translationsConfigFile, _userAgent, globals, nodeProcess, isElectronProcess, isElectronRenderer, _platform, isWindows, isMacintosh, isLinux, isNative, isWeb, isWebWorker, userAgent, language, Language, setTimeout0IsFaster, setTimeout0, isChrome, isFirefox, isSafari, isEdge, isAndroid;
  var init_platform = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/platform.js"() {
      init_nls();
      LANGUAGE_DEFAULT = "en";
      _isWindows = false;
      _isMacintosh = false;
      _isLinux = false;
      _isLinuxSnap = false;
      _isNative = false;
      _isWeb = false;
      _isElectron = false;
      _isIOS = false;
      _isCI = false;
      _isMobile = false;
      _locale = void 0;
      _language = LANGUAGE_DEFAULT;
      _platformLocale = LANGUAGE_DEFAULT;
      _translationsConfigFile = void 0;
      _userAgent = void 0;
      globals = typeof self === "object" ? self : typeof global === "object" ? global : {};
      nodeProcess = void 0;
      if (typeof globals.vscode !== "undefined" && typeof globals.vscode.process !== "undefined") {
        nodeProcess = globals.vscode.process;
      } else if (typeof process !== "undefined") {
        nodeProcess = process;
      }
      isElectronProcess = typeof ((_a3 = nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.versions) === null || _a3 === void 0 ? void 0 : _a3.electron) === "string";
      isElectronRenderer = isElectronProcess && (nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.type) === "renderer";
      if (typeof navigator === "object" && !isElectronRenderer) {
        _userAgent = navigator.userAgent;
        _isWindows = _userAgent.indexOf("Windows") >= 0;
        _isMacintosh = _userAgent.indexOf("Macintosh") >= 0;
        _isIOS = (_userAgent.indexOf("Macintosh") >= 0 || _userAgent.indexOf("iPad") >= 0 || _userAgent.indexOf("iPhone") >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;
        _isLinux = _userAgent.indexOf("Linux") >= 0;
        _isMobile = (_userAgent === null || _userAgent === void 0 ? void 0 : _userAgent.indexOf("Mobi")) >= 0;
        _isWeb = true;
        const configuredLocale = getConfiguredDefaultLocale(
          // This call _must_ be done in the file that calls `nls.getConfiguredDefaultLocale`
          // to ensure that the NLS AMD Loader plugin has been loaded and configured.
          // This is because the loader plugin decides what the default locale is based on
          // how it's able to resolve the strings.
          localize({ key: "ensureLoaderPluginIsLoaded", comment: ["{Locked}"] }, "_")
        );
        _locale = configuredLocale || LANGUAGE_DEFAULT;
        _language = _locale;
        _platformLocale = navigator.language;
      } else if (typeof nodeProcess === "object") {
        _isWindows = nodeProcess.platform === "win32";
        _isMacintosh = nodeProcess.platform === "darwin";
        _isLinux = nodeProcess.platform === "linux";
        _isLinuxSnap = _isLinux && !!nodeProcess.env["SNAP"] && !!nodeProcess.env["SNAP_REVISION"];
        _isElectron = isElectronProcess;
        _isCI = !!nodeProcess.env["CI"] || !!nodeProcess.env["BUILD_ARTIFACTSTAGINGDIRECTORY"];
        _locale = LANGUAGE_DEFAULT;
        _language = LANGUAGE_DEFAULT;
        const rawNlsConfig = nodeProcess.env["VSCODE_NLS_CONFIG"];
        if (rawNlsConfig) {
          try {
            const nlsConfig = JSON.parse(rawNlsConfig);
            const resolved = nlsConfig.availableLanguages["*"];
            _locale = nlsConfig.locale;
            _platformLocale = nlsConfig.osLocale;
            _language = resolved ? resolved : LANGUAGE_DEFAULT;
            _translationsConfigFile = nlsConfig._translationsConfigFile;
          } catch (e) {
          }
        }
        _isNative = true;
      } else {
        console.error("Unable to resolve platform.");
      }
      _platform = 0;
      if (_isMacintosh) {
        _platform = 1;
      } else if (_isWindows) {
        _platform = 3;
      } else if (_isLinux) {
        _platform = 2;
      }
      isWindows = _isWindows;
      isMacintosh = _isMacintosh;
      isLinux = _isLinux;
      isNative = _isNative;
      isWeb = _isWeb;
      isWebWorker = _isWeb && typeof globals.importScripts === "function";
      userAgent = _userAgent;
      language = _language;
      (function(Language2) {
        function value() {
          return language;
        }
        Language2.value = value;
        function isDefaultVariant() {
          if (language.length === 2) {
            return language === "en";
          } else if (language.length >= 3) {
            return language[0] === "e" && language[1] === "n" && language[2] === "-";
          } else {
            return false;
          }
        }
        Language2.isDefaultVariant = isDefaultVariant;
        function isDefault() {
          return language === "en";
        }
        Language2.isDefault = isDefault;
      })(Language || (Language = {}));
      setTimeout0IsFaster = typeof globals.postMessage === "function" && !globals.importScripts;
      setTimeout0 = (() => {
        if (setTimeout0IsFaster) {
          const pending = [];
          globals.addEventListener("message", (e) => {
            if (e.data && e.data.vscodeScheduleAsyncWork) {
              for (let i = 0, len = pending.length; i < len; i++) {
                const candidate = pending[i];
                if (candidate.id === e.data.vscodeScheduleAsyncWork) {
                  pending.splice(i, 1);
                  candidate.callback();
                  return;
                }
              }
            }
          });
          let lastId = 0;
          return (callback) => {
            const myId = ++lastId;
            pending.push({
              id: myId,
              callback
            });
            globals.postMessage({ vscodeScheduleAsyncWork: myId }, "*");
          };
        }
        return (callback) => setTimeout(callback);
      })();
      isChrome = !!(userAgent && userAgent.indexOf("Chrome") >= 0);
      isFirefox = !!(userAgent && userAgent.indexOf("Firefox") >= 0);
      isSafari = !!(!isChrome && (userAgent && userAgent.indexOf("Safari") >= 0));
      isEdge = !!(userAgent && userAgent.indexOf("Edg/") >= 0);
      isAndroid = !!(userAgent && userAgent.indexOf("Android") >= 0);
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/process.js
  var safeProcess, cwd, env, platform, arch;
  var init_process = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/process.js"() {
      init_platform();
      if (typeof globals.vscode !== "undefined" && typeof globals.vscode.process !== "undefined") {
        const sandboxProcess = globals.vscode.process;
        safeProcess = {
          get platform() {
            return sandboxProcess.platform;
          },
          get arch() {
            return sandboxProcess.arch;
          },
          get env() {
            return sandboxProcess.env;
          },
          cwd() {
            return sandboxProcess.cwd();
          }
        };
      } else if (typeof process !== "undefined") {
        safeProcess = {
          get platform() {
            return process.platform;
          },
          get arch() {
            return process.arch;
          },
          get env() {
            return process.env;
          },
          cwd() {
            return process.env["VSCODE_CWD"] || process.cwd();
          }
        };
      } else {
        safeProcess = {
          // Supported
          get platform() {
            return isWindows ? "win32" : isMacintosh ? "darwin" : "linux";
          },
          get arch() {
            return void 0;
          },
          // Unsupported
          get env() {
            return {};
          },
          cwd() {
            return "/";
          }
        };
      }
      cwd = safeProcess.cwd;
      env = safeProcess.env;
      platform = safeProcess.platform;
      arch = safeProcess.arch;
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/path.js
  function validateObject(pathObject, name) {
    if (pathObject === null || typeof pathObject !== "object") {
      throw new ErrorInvalidArgType(name, "Object", pathObject);
    }
  }
  function validateString(value, name) {
    if (typeof value !== "string") {
      throw new ErrorInvalidArgType(name, "string", value);
    }
  }
  function isPathSeparator(code) {
    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
  }
  function isPosixPathSeparator(code) {
    return code === CHAR_FORWARD_SLASH;
  }
  function isWindowsDeviceRoot(code) {
    return code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z || code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;
  }
  function normalizeString(path, allowAboveRoot, separator, isPathSeparator3) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code = 0;
    for (let i = 0; i <= path.length; ++i) {
      if (i < path.length) {
        code = path.charCodeAt(i);
      } else if (isPathSeparator3(code)) {
        break;
      } else {
        code = CHAR_FORWARD_SLASH;
      }
      if (isPathSeparator3(code)) {
        if (lastSlash === i - 1 || dots === 1) {
        } else if (dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {
            if (res.length > 2) {
              const lastSlashIndex = res.lastIndexOf(separator);
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
              }
              lastSlash = i;
              dots = 0;
              continue;
            } else if (res.length !== 0) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            res += res.length > 0 ? `${separator}..` : "..";
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0) {
            res += `${separator}${path.slice(lastSlash + 1, i)}`;
          } else {
            res = path.slice(lastSlash + 1, i);
          }
          lastSegmentLength = i - lastSlash - 1;
        }
        lastSlash = i;
        dots = 0;
      } else if (code === CHAR_DOT && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  function _format2(sep2, pathObject) {
    validateObject(pathObject, "pathObject");
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || `${pathObject.name || ""}${pathObject.ext || ""}`;
    if (!dir) {
      return base;
    }
    return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep2}${base}`;
  }
  var CHAR_UPPERCASE_A, CHAR_LOWERCASE_A, CHAR_UPPERCASE_Z, CHAR_LOWERCASE_Z, CHAR_DOT, CHAR_FORWARD_SLASH, CHAR_BACKWARD_SLASH, CHAR_COLON, CHAR_QUESTION_MARK, ErrorInvalidArgType, platformIsWin32, win32, posixCwd, posix, normalize, isAbsolute, join2, resolve, relative, dirname, basename, extname, format, parse, toNamespacedPath, sep, delimiter;
  var init_path = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/path.js"() {
      init_process();
      CHAR_UPPERCASE_A = 65;
      CHAR_LOWERCASE_A = 97;
      CHAR_UPPERCASE_Z = 90;
      CHAR_LOWERCASE_Z = 122;
      CHAR_DOT = 46;
      CHAR_FORWARD_SLASH = 47;
      CHAR_BACKWARD_SLASH = 92;
      CHAR_COLON = 58;
      CHAR_QUESTION_MARK = 63;
      ErrorInvalidArgType = class extends Error {
        constructor(name, expected, actual) {
          let determiner;
          if (typeof expected === "string" && expected.indexOf("not ") === 0) {
            determiner = "must not be";
            expected = expected.replace(/^not /, "");
          } else {
            determiner = "must be";
          }
          const type = name.indexOf(".") !== -1 ? "property" : "argument";
          let msg = `The "${name}" ${type} ${determiner} of type ${expected}`;
          msg += `. Received type ${typeof actual}`;
          super(msg);
          this.code = "ERR_INVALID_ARG_TYPE";
        }
      };
      platformIsWin32 = platform === "win32";
      win32 = {
        // path.resolve([from ...], to)
        resolve(...pathSegments) {
          let resolvedDevice = "";
          let resolvedTail = "";
          let resolvedAbsolute = false;
          for (let i = pathSegments.length - 1; i >= -1; i--) {
            let path;
            if (i >= 0) {
              path = pathSegments[i];
              validateString(path, "path");
              if (path.length === 0) {
                continue;
              }
            } else if (resolvedDevice.length === 0) {
              path = cwd();
            } else {
              path = env[`=${resolvedDevice}`] || cwd();
              if (path === void 0 || path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() && path.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
                path = `${resolvedDevice}\\`;
              }
            }
            const len = path.length;
            let rootEnd = 0;
            let device = "";
            let isAbsolute2 = false;
            const code = path.charCodeAt(0);
            if (len === 1) {
              if (isPathSeparator(code)) {
                rootEnd = 1;
                isAbsolute2 = true;
              }
            } else if (isPathSeparator(code)) {
              isAbsolute2 = true;
              if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                  j++;
                }
                if (j < len && j !== last) {
                  const firstPart = path.slice(last, j);
                  last = j;
                  while (j < len && isPathSeparator(path.charCodeAt(j))) {
                    j++;
                  }
                  if (j < len && j !== last) {
                    last = j;
                    while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                      j++;
                    }
                    if (j === len || j !== last) {
                      device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                      rootEnd = j;
                    }
                  }
                }
              } else {
                rootEnd = 1;
              }
            } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
              device = path.slice(0, 2);
              rootEnd = 2;
              if (len > 2 && isPathSeparator(path.charCodeAt(2))) {
                isAbsolute2 = true;
                rootEnd = 3;
              }
            }
            if (device.length > 0) {
              if (resolvedDevice.length > 0) {
                if (device.toLowerCase() !== resolvedDevice.toLowerCase()) {
                  continue;
                }
              } else {
                resolvedDevice = device;
              }
            }
            if (resolvedAbsolute) {
              if (resolvedDevice.length > 0) {
                break;
              }
            } else {
              resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
              resolvedAbsolute = isAbsolute2;
              if (isAbsolute2 && resolvedDevice.length > 0) {
                break;
              }
            }
          }
          resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
          return resolvedAbsolute ? `${resolvedDevice}\\${resolvedTail}` : `${resolvedDevice}${resolvedTail}` || ".";
        },
        normalize(path) {
          validateString(path, "path");
          const len = path.length;
          if (len === 0) {
            return ".";
          }
          let rootEnd = 0;
          let device;
          let isAbsolute2 = false;
          const code = path.charCodeAt(0);
          if (len === 1) {
            return isPosixPathSeparator(code) ? "\\" : path;
          }
          if (isPathSeparator(code)) {
            isAbsolute2 = true;
            if (isPathSeparator(path.charCodeAt(1))) {
              let j = 2;
              let last = j;
              while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                j++;
              }
              if (j < len && j !== last) {
                const firstPart = path.slice(last, j);
                last = j;
                while (j < len && isPathSeparator(path.charCodeAt(j))) {
                  j++;
                }
                if (j < len && j !== last) {
                  last = j;
                  while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                    j++;
                  }
                  if (j === len) {
                    return `\\\\${firstPart}\\${path.slice(last)}\\`;
                  }
                  if (j !== last) {
                    device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                    rootEnd = j;
                  }
                }
              }
            } else {
              rootEnd = 1;
            }
          } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
            device = path.slice(0, 2);
            rootEnd = 2;
            if (len > 2 && isPathSeparator(path.charCodeAt(2))) {
              isAbsolute2 = true;
              rootEnd = 3;
            }
          }
          let tail = rootEnd < len ? normalizeString(path.slice(rootEnd), !isAbsolute2, "\\", isPathSeparator) : "";
          if (tail.length === 0 && !isAbsolute2) {
            tail = ".";
          }
          if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {
            tail += "\\";
          }
          if (device === void 0) {
            return isAbsolute2 ? `\\${tail}` : tail;
          }
          return isAbsolute2 ? `${device}\\${tail}` : `${device}${tail}`;
        },
        isAbsolute(path) {
          validateString(path, "path");
          const len = path.length;
          if (len === 0) {
            return false;
          }
          const code = path.charCodeAt(0);
          return isPathSeparator(code) || // Possible device root
          len > 2 && isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON && isPathSeparator(path.charCodeAt(2));
        },
        join(...paths) {
          if (paths.length === 0) {
            return ".";
          }
          let joined;
          let firstPart;
          for (let i = 0; i < paths.length; ++i) {
            const arg = paths[i];
            validateString(arg, "path");
            if (arg.length > 0) {
              if (joined === void 0) {
                joined = firstPart = arg;
              } else {
                joined += `\\${arg}`;
              }
            }
          }
          if (joined === void 0) {
            return ".";
          }
          let needsReplace = true;
          let slashCount = 0;
          if (typeof firstPart === "string" && isPathSeparator(firstPart.charCodeAt(0))) {
            ++slashCount;
            const firstLen = firstPart.length;
            if (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {
              ++slashCount;
              if (firstLen > 2) {
                if (isPathSeparator(firstPart.charCodeAt(2))) {
                  ++slashCount;
                } else {
                  needsReplace = false;
                }
              }
            }
          }
          if (needsReplace) {
            while (slashCount < joined.length && isPathSeparator(joined.charCodeAt(slashCount))) {
              slashCount++;
            }
            if (slashCount >= 2) {
              joined = `\\${joined.slice(slashCount)}`;
            }
          }
          return win32.normalize(joined);
        },
        // It will solve the relative path from `from` to `to`, for instance:
        //  from = 'C:\\orandea\\test\\aaa'
        //  to = 'C:\\orandea\\impl\\bbb'
        // The output of the function should be: '..\\..\\impl\\bbb'
        relative(from, to) {
          validateString(from, "from");
          validateString(to, "to");
          if (from === to) {
            return "";
          }
          const fromOrig = win32.resolve(from);
          const toOrig = win32.resolve(to);
          if (fromOrig === toOrig) {
            return "";
          }
          from = fromOrig.toLowerCase();
          to = toOrig.toLowerCase();
          if (from === to) {
            return "";
          }
          let fromStart = 0;
          while (fromStart < from.length && from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {
            fromStart++;
          }
          let fromEnd = from.length;
          while (fromEnd - 1 > fromStart && from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {
            fromEnd--;
          }
          const fromLen = fromEnd - fromStart;
          let toStart = 0;
          while (toStart < to.length && to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
            toStart++;
          }
          let toEnd = to.length;
          while (toEnd - 1 > toStart && to.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {
            toEnd--;
          }
          const toLen = toEnd - toStart;
          const length = fromLen < toLen ? fromLen : toLen;
          let lastCommonSep = -1;
          let i = 0;
          for (; i < length; i++) {
            const fromCode = from.charCodeAt(fromStart + i);
            if (fromCode !== to.charCodeAt(toStart + i)) {
              break;
            } else if (fromCode === CHAR_BACKWARD_SLASH) {
              lastCommonSep = i;
            }
          }
          if (i !== length) {
            if (lastCommonSep === -1) {
              return toOrig;
            }
          } else {
            if (toLen > length) {
              if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {
                return toOrig.slice(toStart + i + 1);
              }
              if (i === 2) {
                return toOrig.slice(toStart + i);
              }
            }
            if (fromLen > length) {
              if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {
                lastCommonSep = i;
              } else if (i === 2) {
                lastCommonSep = 3;
              }
            }
            if (lastCommonSep === -1) {
              lastCommonSep = 0;
            }
          }
          let out = "";
          for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
            if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {
              out += out.length === 0 ? ".." : "\\..";
            }
          }
          toStart += lastCommonSep;
          if (out.length > 0) {
            return `${out}${toOrig.slice(toStart, toEnd)}`;
          }
          if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
            ++toStart;
          }
          return toOrig.slice(toStart, toEnd);
        },
        toNamespacedPath(path) {
          if (typeof path !== "string" || path.length === 0) {
            return path;
          }
          const resolvedPath = win32.resolve(path);
          if (resolvedPath.length <= 2) {
            return path;
          }
          if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {
            if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {
              const code = resolvedPath.charCodeAt(2);
              if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {
                return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
              }
            }
          } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) && resolvedPath.charCodeAt(1) === CHAR_COLON && resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
            return `\\\\?\\${resolvedPath}`;
          }
          return path;
        },
        dirname(path) {
          validateString(path, "path");
          const len = path.length;
          if (len === 0) {
            return ".";
          }
          let rootEnd = -1;
          let offset = 0;
          const code = path.charCodeAt(0);
          if (len === 1) {
            return isPathSeparator(code) ? path : ".";
          }
          if (isPathSeparator(code)) {
            rootEnd = offset = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
              let j = 2;
              let last = j;
              while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                j++;
              }
              if (j < len && j !== last) {
                last = j;
                while (j < len && isPathSeparator(path.charCodeAt(j))) {
                  j++;
                }
                if (j < len && j !== last) {
                  last = j;
                  while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                    j++;
                  }
                  if (j === len) {
                    return path;
                  }
                  if (j !== last) {
                    rootEnd = offset = j + 1;
                  }
                }
              }
            }
          } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
            rootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;
            offset = rootEnd;
          }
          let end = -1;
          let matchedSlash = true;
          for (let i = len - 1; i >= offset; --i) {
            if (isPathSeparator(path.charCodeAt(i))) {
              if (!matchedSlash) {
                end = i;
                break;
              }
            } else {
              matchedSlash = false;
            }
          }
          if (end === -1) {
            if (rootEnd === -1) {
              return ".";
            }
            end = rootEnd;
          }
          return path.slice(0, end);
        },
        basename(path, ext) {
          if (ext !== void 0) {
            validateString(ext, "ext");
          }
          validateString(path, "path");
          let start = 0;
          let end = -1;
          let matchedSlash = true;
          let i;
          if (path.length >= 2 && isWindowsDeviceRoot(path.charCodeAt(0)) && path.charCodeAt(1) === CHAR_COLON) {
            start = 2;
          }
          if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
            if (ext === path) {
              return "";
            }
            let extIdx = ext.length - 1;
            let firstNonSlashEnd = -1;
            for (i = path.length - 1; i >= start; --i) {
              const code = path.charCodeAt(i);
              if (isPathSeparator(code)) {
                if (!matchedSlash) {
                  start = i + 1;
                  break;
                }
              } else {
                if (firstNonSlashEnd === -1) {
                  matchedSlash = false;
                  firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                  if (code === ext.charCodeAt(extIdx)) {
                    if (--extIdx === -1) {
                      end = i;
                    }
                  } else {
                    extIdx = -1;
                    end = firstNonSlashEnd;
                  }
                }
              }
            }
            if (start === end) {
              end = firstNonSlashEnd;
            } else if (end === -1) {
              end = path.length;
            }
            return path.slice(start, end);
          }
          for (i = path.length - 1; i >= start; --i) {
            if (isPathSeparator(path.charCodeAt(i))) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
          }
          if (end === -1) {
            return "";
          }
          return path.slice(start, end);
        },
        extname(path) {
          validateString(path, "path");
          let start = 0;
          let startDot = -1;
          let startPart = 0;
          let end = -1;
          let matchedSlash = true;
          let preDotState = 0;
          if (path.length >= 2 && path.charCodeAt(1) === CHAR_COLON && isWindowsDeviceRoot(path.charCodeAt(0))) {
            start = startPart = 2;
          }
          for (let i = path.length - 1; i >= start; --i) {
            const code = path.charCodeAt(i);
            if (isPathSeparator(code)) {
              if (!matchedSlash) {
                startPart = i + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
            if (code === CHAR_DOT) {
              if (startDot === -1) {
                startDot = i;
              } else if (preDotState !== 1) {
                preDotState = 1;
              }
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
          preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
          preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            return "";
          }
          return path.slice(startDot, end);
        },
        format: _format2.bind(null, "\\"),
        parse(path) {
          validateString(path, "path");
          const ret = { root: "", dir: "", base: "", ext: "", name: "" };
          if (path.length === 0) {
            return ret;
          }
          const len = path.length;
          let rootEnd = 0;
          let code = path.charCodeAt(0);
          if (len === 1) {
            if (isPathSeparator(code)) {
              ret.root = ret.dir = path;
              return ret;
            }
            ret.base = ret.name = path;
            return ret;
          }
          if (isPathSeparator(code)) {
            rootEnd = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
              let j = 2;
              let last = j;
              while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                j++;
              }
              if (j < len && j !== last) {
                last = j;
                while (j < len && isPathSeparator(path.charCodeAt(j))) {
                  j++;
                }
                if (j < len && j !== last) {
                  last = j;
                  while (j < len && !isPathSeparator(path.charCodeAt(j))) {
                    j++;
                  }
                  if (j === len) {
                    rootEnd = j;
                  } else if (j !== last) {
                    rootEnd = j + 1;
                  }
                }
              }
            }
          } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
            if (len <= 2) {
              ret.root = ret.dir = path;
              return ret;
            }
            rootEnd = 2;
            if (isPathSeparator(path.charCodeAt(2))) {
              if (len === 3) {
                ret.root = ret.dir = path;
                return ret;
              }
              rootEnd = 3;
            }
          }
          if (rootEnd > 0) {
            ret.root = path.slice(0, rootEnd);
          }
          let startDot = -1;
          let startPart = rootEnd;
          let end = -1;
          let matchedSlash = true;
          let i = path.length - 1;
          let preDotState = 0;
          for (; i >= rootEnd; --i) {
            code = path.charCodeAt(i);
            if (isPathSeparator(code)) {
              if (!matchedSlash) {
                startPart = i + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
            if (code === CHAR_DOT) {
              if (startDot === -1) {
                startDot = i;
              } else if (preDotState !== 1) {
                preDotState = 1;
              }
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (end !== -1) {
            if (startDot === -1 || // We saw a non-dot character immediately before the dot
            preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
            preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
              ret.base = ret.name = path.slice(startPart, end);
            } else {
              ret.name = path.slice(startPart, startDot);
              ret.base = path.slice(startPart, end);
              ret.ext = path.slice(startDot, end);
            }
          }
          if (startPart > 0 && startPart !== rootEnd) {
            ret.dir = path.slice(0, startPart - 1);
          } else {
            ret.dir = ret.root;
          }
          return ret;
        },
        sep: "\\",
        delimiter: ";",
        win32: null,
        posix: null
      };
      posixCwd = (() => {
        if (platformIsWin32) {
          const regexp = /\\/g;
          return () => {
            const cwd2 = cwd().replace(regexp, "/");
            return cwd2.slice(cwd2.indexOf("/"));
          };
        }
        return () => cwd();
      })();
      posix = {
        // path.resolve([from ...], to)
        resolve(...pathSegments) {
          let resolvedPath = "";
          let resolvedAbsolute = false;
          for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
            const path = i >= 0 ? pathSegments[i] : posixCwd();
            validateString(path, "path");
            if (path.length === 0) {
              continue;
            }
            resolvedPath = `${path}/${resolvedPath}`;
            resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
          }
          resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
          if (resolvedAbsolute) {
            return `/${resolvedPath}`;
          }
          return resolvedPath.length > 0 ? resolvedPath : ".";
        },
        normalize(path) {
          validateString(path, "path");
          if (path.length === 0) {
            return ".";
          }
          const isAbsolute2 = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
          const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;
          path = normalizeString(path, !isAbsolute2, "/", isPosixPathSeparator);
          if (path.length === 0) {
            if (isAbsolute2) {
              return "/";
            }
            return trailingSeparator ? "./" : ".";
          }
          if (trailingSeparator) {
            path += "/";
          }
          return isAbsolute2 ? `/${path}` : path;
        },
        isAbsolute(path) {
          validateString(path, "path");
          return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;
        },
        join(...paths) {
          if (paths.length === 0) {
            return ".";
          }
          let joined;
          for (let i = 0; i < paths.length; ++i) {
            const arg = paths[i];
            validateString(arg, "path");
            if (arg.length > 0) {
              if (joined === void 0) {
                joined = arg;
              } else {
                joined += `/${arg}`;
              }
            }
          }
          if (joined === void 0) {
            return ".";
          }
          return posix.normalize(joined);
        },
        relative(from, to) {
          validateString(from, "from");
          validateString(to, "to");
          if (from === to) {
            return "";
          }
          from = posix.resolve(from);
          to = posix.resolve(to);
          if (from === to) {
            return "";
          }
          const fromStart = 1;
          const fromEnd = from.length;
          const fromLen = fromEnd - fromStart;
          const toStart = 1;
          const toLen = to.length - toStart;
          const length = fromLen < toLen ? fromLen : toLen;
          let lastCommonSep = -1;
          let i = 0;
          for (; i < length; i++) {
            const fromCode = from.charCodeAt(fromStart + i);
            if (fromCode !== to.charCodeAt(toStart + i)) {
              break;
            } else if (fromCode === CHAR_FORWARD_SLASH) {
              lastCommonSep = i;
            }
          }
          if (i === length) {
            if (toLen > length) {
              if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {
                return to.slice(toStart + i + 1);
              }
              if (i === 0) {
                return to.slice(toStart + i);
              }
            } else if (fromLen > length) {
              if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {
                lastCommonSep = i;
              } else if (i === 0) {
                lastCommonSep = 0;
              }
            }
          }
          let out = "";
          for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
            if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {
              out += out.length === 0 ? ".." : "/..";
            }
          }
          return `${out}${to.slice(toStart + lastCommonSep)}`;
        },
        toNamespacedPath(path) {
          return path;
        },
        dirname(path) {
          validateString(path, "path");
          if (path.length === 0) {
            return ".";
          }
          const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
          let end = -1;
          let matchedSlash = true;
          for (let i = path.length - 1; i >= 1; --i) {
            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
              if (!matchedSlash) {
                end = i;
                break;
              }
            } else {
              matchedSlash = false;
            }
          }
          if (end === -1) {
            return hasRoot ? "/" : ".";
          }
          if (hasRoot && end === 1) {
            return "//";
          }
          return path.slice(0, end);
        },
        basename(path, ext) {
          if (ext !== void 0) {
            validateString(ext, "ext");
          }
          validateString(path, "path");
          let start = 0;
          let end = -1;
          let matchedSlash = true;
          let i;
          if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
            if (ext === path) {
              return "";
            }
            let extIdx = ext.length - 1;
            let firstNonSlashEnd = -1;
            for (i = path.length - 1; i >= 0; --i) {
              const code = path.charCodeAt(i);
              if (code === CHAR_FORWARD_SLASH) {
                if (!matchedSlash) {
                  start = i + 1;
                  break;
                }
              } else {
                if (firstNonSlashEnd === -1) {
                  matchedSlash = false;
                  firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                  if (code === ext.charCodeAt(extIdx)) {
                    if (--extIdx === -1) {
                      end = i;
                    }
                  } else {
                    extIdx = -1;
                    end = firstNonSlashEnd;
                  }
                }
              }
            }
            if (start === end) {
              end = firstNonSlashEnd;
            } else if (end === -1) {
              end = path.length;
            }
            return path.slice(start, end);
          }
          for (i = path.length - 1; i >= 0; --i) {
            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
          }
          if (end === -1) {
            return "";
          }
          return path.slice(start, end);
        },
        extname(path) {
          validateString(path, "path");
          let startDot = -1;
          let startPart = 0;
          let end = -1;
          let matchedSlash = true;
          let preDotState = 0;
          for (let i = path.length - 1; i >= 0; --i) {
            const code = path.charCodeAt(i);
            if (code === CHAR_FORWARD_SLASH) {
              if (!matchedSlash) {
                startPart = i + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
            if (code === CHAR_DOT) {
              if (startDot === -1) {
                startDot = i;
              } else if (preDotState !== 1) {
                preDotState = 1;
              }
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
          preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
          preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            return "";
          }
          return path.slice(startDot, end);
        },
        format: _format2.bind(null, "/"),
        parse(path) {
          validateString(path, "path");
          const ret = { root: "", dir: "", base: "", ext: "", name: "" };
          if (path.length === 0) {
            return ret;
          }
          const isAbsolute2 = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
          let start;
          if (isAbsolute2) {
            ret.root = "/";
            start = 1;
          } else {
            start = 0;
          }
          let startDot = -1;
          let startPart = 0;
          let end = -1;
          let matchedSlash = true;
          let i = path.length - 1;
          let preDotState = 0;
          for (; i >= start; --i) {
            const code = path.charCodeAt(i);
            if (code === CHAR_FORWARD_SLASH) {
              if (!matchedSlash) {
                startPart = i + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
            if (code === CHAR_DOT) {
              if (startDot === -1) {
                startDot = i;
              } else if (preDotState !== 1) {
                preDotState = 1;
              }
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (end !== -1) {
            const start2 = startPart === 0 && isAbsolute2 ? 1 : startPart;
            if (startDot === -1 || // We saw a non-dot character immediately before the dot
            preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
            preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
              ret.base = ret.name = path.slice(start2, end);
            } else {
              ret.name = path.slice(start2, startDot);
              ret.base = path.slice(start2, end);
              ret.ext = path.slice(startDot, end);
            }
          }
          if (startPart > 0) {
            ret.dir = path.slice(0, startPart - 1);
          } else if (isAbsolute2) {
            ret.dir = "/";
          }
          return ret;
        },
        sep: "/",
        delimiter: ":",
        win32: null,
        posix: null
      };
      posix.win32 = win32.win32 = win32;
      posix.posix = win32.posix = posix;
      normalize = platformIsWin32 ? win32.normalize : posix.normalize;
      isAbsolute = platformIsWin32 ? win32.isAbsolute : posix.isAbsolute;
      join2 = platformIsWin32 ? win32.join : posix.join;
      resolve = platformIsWin32 ? win32.resolve : posix.resolve;
      relative = platformIsWin32 ? win32.relative : posix.relative;
      dirname = platformIsWin32 ? win32.dirname : posix.dirname;
      basename = platformIsWin32 ? win32.basename : posix.basename;
      extname = platformIsWin32 ? win32.extname : posix.extname;
      format = platformIsWin32 ? win32.format : posix.format;
      parse = platformIsWin32 ? win32.parse : posix.parse;
      toNamespacedPath = platformIsWin32 ? win32.toNamespacedPath : posix.toNamespacedPath;
      sep = platformIsWin32 ? win32.sep : posix.sep;
      delimiter = platformIsWin32 ? win32.delimiter : posix.delimiter;
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/extpath.js
  function isPathSeparator2(code) {
    return code === 47 || code === 92;
  }
  function toSlashes(osPath) {
    return osPath.replace(/[\\/]/g, posix.sep);
  }
  function toPosixPath(osPath) {
    if (osPath.indexOf("/") === -1) {
      osPath = toSlashes(osPath);
    }
    if (/^[a-zA-Z]:(\/|$)/.test(osPath)) {
      osPath = "/" + osPath;
    }
    return osPath;
  }
  function getRoot(path, sep2 = posix.sep) {
    if (!path) {
      return "";
    }
    const len = path.length;
    const firstLetter = path.charCodeAt(0);
    if (isPathSeparator2(firstLetter)) {
      if (isPathSeparator2(path.charCodeAt(1))) {
        if (!isPathSeparator2(path.charCodeAt(2))) {
          let pos2 = 3;
          const start = pos2;
          for (; pos2 < len; pos2++) {
            if (isPathSeparator2(path.charCodeAt(pos2))) {
              break;
            }
          }
          if (start !== pos2 && !isPathSeparator2(path.charCodeAt(pos2 + 1))) {
            pos2 += 1;
            for (; pos2 < len; pos2++) {
              if (isPathSeparator2(path.charCodeAt(pos2))) {
                return path.slice(0, pos2 + 1).replace(/[\\/]/g, sep2);
              }
            }
          }
        }
      }
      return sep2;
    } else if (isWindowsDriveLetter(firstLetter)) {
      if (path.charCodeAt(1) === 58) {
        if (isPathSeparator2(path.charCodeAt(2))) {
          return path.slice(0, 2) + sep2;
        } else {
          return path.slice(0, 2);
        }
      }
    }
    let pos = path.indexOf("://");
    if (pos !== -1) {
      pos += 3;
      for (; pos < len; pos++) {
        if (isPathSeparator2(path.charCodeAt(pos))) {
          return path.slice(0, pos + 1);
        }
      }
    }
    return "";
  }
  function isEqualOrParent(base, parentCandidate, ignoreCase, separator = sep) {
    if (base === parentCandidate) {
      return true;
    }
    if (!base || !parentCandidate) {
      return false;
    }
    if (parentCandidate.length > base.length) {
      return false;
    }
    if (ignoreCase) {
      const beginsWith = startsWithIgnoreCase(base, parentCandidate);
      if (!beginsWith) {
        return false;
      }
      if (parentCandidate.length === base.length) {
        return true;
      }
      let sepOffset = parentCandidate.length;
      if (parentCandidate.charAt(parentCandidate.length - 1) === separator) {
        sepOffset--;
      }
      return base.charAt(sepOffset) === separator;
    }
    if (parentCandidate.charAt(parentCandidate.length - 1) !== separator) {
      parentCandidate += separator;
    }
    return base.indexOf(parentCandidate) === 0;
  }
  function isWindowsDriveLetter(char0) {
    return char0 >= 65 && char0 <= 90 || char0 >= 97 && char0 <= 122;
  }
  var init_extpath = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/extpath.js"() {
      init_path();
      init_platform();
      init_strings();
      init_types();
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/uri.js
  function _validateUri(ret, _strict) {
    if (!ret.scheme && _strict) {
      throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${ret.authority}", path: "${ret.path}", query: "${ret.query}", fragment: "${ret.fragment}"}`);
    }
    if (ret.scheme && !_schemePattern.test(ret.scheme)) {
      throw new Error("[UriError]: Scheme contains illegal characters.");
    }
    if (ret.path) {
      if (ret.authority) {
        if (!_singleSlashStart.test(ret.path)) {
          throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
        }
      } else {
        if (_doubleSlashStart.test(ret.path)) {
          throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
        }
      }
    }
  }
  function _schemeFix(scheme, _strict) {
    if (!scheme && !_strict) {
      return "file";
    }
    return scheme;
  }
  function _referenceResolution(scheme, path) {
    switch (scheme) {
      case "https":
      case "http":
      case "file":
        if (!path) {
          path = _slash;
        } else if (path[0] !== _slash) {
          path = _slash + path;
        }
        break;
    }
    return path;
  }
  function encodeURIComponentFast(uriComponent, isPath, isAuthority) {
    let res = void 0;
    let nativeEncodePos = -1;
    for (let pos = 0; pos < uriComponent.length; pos++) {
      const code = uriComponent.charCodeAt(pos);
      if (code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 48 && code <= 57 || code === 45 || code === 46 || code === 95 || code === 126 || isPath && code === 47 || isAuthority && code === 91 || isAuthority && code === 93 || isAuthority && code === 58) {
        if (nativeEncodePos !== -1) {
          res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
          nativeEncodePos = -1;
        }
        if (res !== void 0) {
          res += uriComponent.charAt(pos);
        }
      } else {
        if (res === void 0) {
          res = uriComponent.substr(0, pos);
        }
        const escaped = encodeTable[code];
        if (escaped !== void 0) {
          if (nativeEncodePos !== -1) {
            res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
            nativeEncodePos = -1;
          }
          res += escaped;
        } else if (nativeEncodePos === -1) {
          nativeEncodePos = pos;
        }
      }
    }
    if (nativeEncodePos !== -1) {
      res += encodeURIComponent(uriComponent.substring(nativeEncodePos));
    }
    return res !== void 0 ? res : uriComponent;
  }
  function encodeURIComponentMinimal(path) {
    let res = void 0;
    for (let pos = 0; pos < path.length; pos++) {
      const code = path.charCodeAt(pos);
      if (code === 35 || code === 63) {
        if (res === void 0) {
          res = path.substr(0, pos);
        }
        res += encodeTable[code];
      } else {
        if (res !== void 0) {
          res += path[pos];
        }
      }
    }
    return res !== void 0 ? res : path;
  }
  function uriToFsPath(uri, keepDriveLetterCasing) {
    let value;
    if (uri.authority && uri.path.length > 1 && uri.scheme === "file") {
      value = `//${uri.authority}${uri.path}`;
    } else if (uri.path.charCodeAt(0) === 47 && (uri.path.charCodeAt(1) >= 65 && uri.path.charCodeAt(1) <= 90 || uri.path.charCodeAt(1) >= 97 && uri.path.charCodeAt(1) <= 122) && uri.path.charCodeAt(2) === 58) {
      if (!keepDriveLetterCasing) {
        value = uri.path[1].toLowerCase() + uri.path.substr(2);
      } else {
        value = uri.path.substr(1);
      }
    } else {
      value = uri.path;
    }
    if (isWindows) {
      value = value.replace(/\//g, "\\");
    }
    return value;
  }
  function _asFormatted(uri, skipEncoding) {
    const encoder = !skipEncoding ? encodeURIComponentFast : encodeURIComponentMinimal;
    let res = "";
    let { scheme, authority, path, query, fragment } = uri;
    if (scheme) {
      res += scheme;
      res += ":";
    }
    if (authority || scheme === "file") {
      res += _slash;
      res += _slash;
    }
    if (authority) {
      let idx = authority.indexOf("@");
      if (idx !== -1) {
        const userinfo = authority.substr(0, idx);
        authority = authority.substr(idx + 1);
        idx = userinfo.lastIndexOf(":");
        if (idx === -1) {
          res += encoder(userinfo, false, false);
        } else {
          res += encoder(userinfo.substr(0, idx), false, false);
          res += ":";
          res += encoder(userinfo.substr(idx + 1), false, true);
        }
        res += "@";
      }
      authority = authority.toLowerCase();
      idx = authority.lastIndexOf(":");
      if (idx === -1) {
        res += encoder(authority, false, true);
      } else {
        res += encoder(authority.substr(0, idx), false, true);
        res += authority.substr(idx);
      }
    }
    if (path) {
      if (path.length >= 3 && path.charCodeAt(0) === 47 && path.charCodeAt(2) === 58) {
        const code = path.charCodeAt(1);
        if (code >= 65 && code <= 90) {
          path = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`;
        }
      } else if (path.length >= 2 && path.charCodeAt(1) === 58) {
        const code = path.charCodeAt(0);
        if (code >= 65 && code <= 90) {
          path = `${String.fromCharCode(code + 32)}:${path.substr(2)}`;
        }
      }
      res += encoder(path, true, false);
    }
    if (query) {
      res += "?";
      res += encoder(query, false, false);
    }
    if (fragment) {
      res += "#";
      res += !skipEncoding ? encodeURIComponentFast(fragment, false, false) : fragment;
    }
    return res;
  }
  function decodeURIComponentGraceful(str) {
    try {
      return decodeURIComponent(str);
    } catch (_a4) {
      if (str.length > 3) {
        return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));
      } else {
        return str;
      }
    }
  }
  function percentDecode(str) {
    if (!str.match(_rEncodedAsHex)) {
      return str;
    }
    return str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));
  }
  var _schemePattern, _singleSlashStart, _doubleSlashStart, _empty, _slash, _regexp, URI, _pathSepMarker, Uri, encodeTable, _rEncodedAsHex;
  var init_uri = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/uri.js"() {
      init_path();
      init_platform();
      _schemePattern = /^\w[\w\d+.-]*$/;
      _singleSlashStart = /^\//;
      _doubleSlashStart = /^\/\//;
      _empty = "";
      _slash = "/";
      _regexp = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
      URI = class {
        static isUri(thing) {
          if (thing instanceof URI) {
            return true;
          }
          if (!thing) {
            return false;
          }
          return typeof thing.authority === "string" && typeof thing.fragment === "string" && typeof thing.path === "string" && typeof thing.query === "string" && typeof thing.scheme === "string" && typeof thing.fsPath === "string" && typeof thing.with === "function" && typeof thing.toString === "function";
        }
        /**
         * @internal
         */
        constructor(schemeOrData, authority, path, query, fragment, _strict = false) {
          if (typeof schemeOrData === "object") {
            this.scheme = schemeOrData.scheme || _empty;
            this.authority = schemeOrData.authority || _empty;
            this.path = schemeOrData.path || _empty;
            this.query = schemeOrData.query || _empty;
            this.fragment = schemeOrData.fragment || _empty;
          } else {
            this.scheme = _schemeFix(schemeOrData, _strict);
            this.authority = authority || _empty;
            this.path = _referenceResolution(this.scheme, path || _empty);
            this.query = query || _empty;
            this.fragment = fragment || _empty;
            _validateUri(this, _strict);
          }
        }
        // ---- filesystem path -----------------------
        /**
         * Returns a string representing the corresponding file system path of this URI.
         * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
         * platform specific path separator.
         *
         * * Will *not* validate the path for invalid characters and semantics.
         * * Will *not* look at the scheme of this URI.
         * * The result shall *not* be used for display purposes but for accessing a file on disk.
         *
         *
         * The *difference* to `URI#path` is the use of the platform specific separator and the handling
         * of UNC paths. See the below sample of a file-uri with an authority (UNC path).
         *
         * ```ts
            const u = URI.parse('file://server/c$/folder/file.txt')
            u.authority === 'server'
            u.path === '/shares/c$/file.txt'
            u.fsPath === '\\server\c$\folder\file.txt'
        ```
         *
         * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,
         * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working
         * with URIs that represent files on disk (`file` scheme).
         */
        get fsPath() {
          return uriToFsPath(this, false);
        }
        // ---- modify to new -------------------------
        with(change) {
          if (!change) {
            return this;
          }
          let { scheme, authority, path, query, fragment } = change;
          if (scheme === void 0) {
            scheme = this.scheme;
          } else if (scheme === null) {
            scheme = _empty;
          }
          if (authority === void 0) {
            authority = this.authority;
          } else if (authority === null) {
            authority = _empty;
          }
          if (path === void 0) {
            path = this.path;
          } else if (path === null) {
            path = _empty;
          }
          if (query === void 0) {
            query = this.query;
          } else if (query === null) {
            query = _empty;
          }
          if (fragment === void 0) {
            fragment = this.fragment;
          } else if (fragment === null) {
            fragment = _empty;
          }
          if (scheme === this.scheme && authority === this.authority && path === this.path && query === this.query && fragment === this.fragment) {
            return this;
          }
          return new Uri(scheme, authority, path, query, fragment);
        }
        // ---- parse & validate ------------------------
        /**
         * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,
         * `file:///usr/home`, or `scheme:with/path`.
         *
         * @param value A string which represents an URI (see `URI#toString`).
         */
        static parse(value, _strict = false) {
          const match = _regexp.exec(value);
          if (!match) {
            return new Uri(_empty, _empty, _empty, _empty, _empty);
          }
          return new Uri(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);
        }
        /**
         * Creates a new URI from a file system path, e.g. `c:\my\files`,
         * `/usr/home`, or `\\server\share\some\path`.
         *
         * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument
         * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**
         * `URI.parse('file://' + path)` because the path might contain characters that are
         * interpreted (# and ?). See the following sample:
         * ```ts
        const good = URI.file('/coding/c#/project1');
        good.scheme === 'file';
        good.path === '/coding/c#/project1';
        good.fragment === '';
        const bad = URI.parse('file://' + '/coding/c#/project1');
        bad.scheme === 'file';
        bad.path === '/coding/c'; // path is now broken
        bad.fragment === '/project1';
        ```
         *
         * @param path A file system path (see `URI#fsPath`)
         */
        static file(path) {
          let authority = _empty;
          if (isWindows) {
            path = path.replace(/\\/g, _slash);
          }
          if (path[0] === _slash && path[1] === _slash) {
            const idx = path.indexOf(_slash, 2);
            if (idx === -1) {
              authority = path.substring(2);
              path = _slash;
            } else {
              authority = path.substring(2, idx);
              path = path.substring(idx) || _slash;
            }
          }
          return new Uri("file", authority, path, _empty, _empty);
        }
        /**
         * Creates new URI from uri components.
         *
         * Unless `strict` is `true` the scheme is defaults to be `file`. This function performs
         * validation and should be used for untrusted uri components retrieved from storage,
         * user input, command arguments etc
         */
        static from(components, strict) {
          const result = new Uri(components.scheme, components.authority, components.path, components.query, components.fragment, strict);
          return result;
        }
        /**
         * Join a URI path with path fragments and normalizes the resulting path.
         *
         * @param uri The input URI.
         * @param pathFragment The path fragment to add to the URI path.
         * @returns The resulting URI.
         */
        static joinPath(uri, ...pathFragment) {
          if (!uri.path) {
            throw new Error(`[UriError]: cannot call joinPath on URI without path`);
          }
          let newPath;
          if (isWindows && uri.scheme === "file") {
            newPath = URI.file(win32.join(uriToFsPath(uri, true), ...pathFragment)).path;
          } else {
            newPath = posix.join(uri.path, ...pathFragment);
          }
          return uri.with({ path: newPath });
        }
        // ---- printing/externalize ---------------------------
        /**
         * Creates a string representation for this URI. It's guaranteed that calling
         * `URI.parse` with the result of this function creates an URI which is equal
         * to this URI.
         *
         * * The result shall *not* be used for display purposes but for externalization or transport.
         * * The result will be encoded using the percentage encoding and encoding happens mostly
         * ignore the scheme-specific encoding rules.
         *
         * @param skipEncoding Do not encode the result, default is `false`
         */
        toString(skipEncoding = false) {
          return _asFormatted(this, skipEncoding);
        }
        toJSON() {
          return this;
        }
        static revive(data) {
          var _a4, _b2;
          if (!data) {
            return data;
          } else if (data instanceof URI) {
            return data;
          } else {
            const result = new Uri(data);
            result._formatted = (_a4 = data.external) !== null && _a4 !== void 0 ? _a4 : null;
            result._fsPath = data._sep === _pathSepMarker ? (_b2 = data.fsPath) !== null && _b2 !== void 0 ? _b2 : null : null;
            return result;
          }
        }
      };
      _pathSepMarker = isWindows ? 1 : void 0;
      Uri = class extends URI {
        constructor() {
          super(...arguments);
          this._formatted = null;
          this._fsPath = null;
        }
        get fsPath() {
          if (!this._fsPath) {
            this._fsPath = uriToFsPath(this, false);
          }
          return this._fsPath;
        }
        toString(skipEncoding = false) {
          if (!skipEncoding) {
            if (!this._formatted) {
              this._formatted = _asFormatted(this, false);
            }
            return this._formatted;
          } else {
            return _asFormatted(this, true);
          }
        }
        toJSON() {
          const res = {
            $mid: 1
            /* MarshalledId.Uri */
          };
          if (this._fsPath) {
            res.fsPath = this._fsPath;
            res._sep = _pathSepMarker;
          }
          if (this._formatted) {
            res.external = this._formatted;
          }
          if (this.path) {
            res.path = this.path;
          }
          if (this.scheme) {
            res.scheme = this.scheme;
          }
          if (this.authority) {
            res.authority = this.authority;
          }
          if (this.query) {
            res.query = this.query;
          }
          if (this.fragment) {
            res.fragment = this.fragment;
          }
          return res;
        }
      };
      encodeTable = {
        [
          58
          /* CharCode.Colon */
        ]: "%3A",
        [
          47
          /* CharCode.Slash */
        ]: "%2F",
        [
          63
          /* CharCode.QuestionMark */
        ]: "%3F",
        [
          35
          /* CharCode.Hash */
        ]: "%23",
        [
          91
          /* CharCode.OpenSquareBracket */
        ]: "%5B",
        [
          93
          /* CharCode.CloseSquareBracket */
        ]: "%5D",
        [
          64
          /* CharCode.AtSign */
        ]: "%40",
        [
          33
          /* CharCode.ExclamationMark */
        ]: "%21",
        [
          36
          /* CharCode.DollarSign */
        ]: "%24",
        [
          38
          /* CharCode.Ampersand */
        ]: "%26",
        [
          39
          /* CharCode.SingleQuote */
        ]: "%27",
        [
          40
          /* CharCode.OpenParen */
        ]: "%28",
        [
          41
          /* CharCode.CloseParen */
        ]: "%29",
        [
          42
          /* CharCode.Asterisk */
        ]: "%2A",
        [
          43
          /* CharCode.Plus */
        ]: "%2B",
        [
          44
          /* CharCode.Comma */
        ]: "%2C",
        [
          59
          /* CharCode.Semicolon */
        ]: "%3B",
        [
          61
          /* CharCode.Equals */
        ]: "%3D",
        [
          32
          /* CharCode.Space */
        ]: "%20"
      };
      _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/network.js
  var Schemas, connectionTokenQueryName, RemoteAuthoritiesImpl, RemoteAuthorities, FileAccessImpl, FileAccess, COI;
  var init_network = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/network.js"() {
      init_errors();
      init_lifecycle();
      init_map();
      init_platform();
      init_uri();
      (function(Schemas2) {
        Schemas2.inMemory = "inmemory";
        Schemas2.vscode = "vscode";
        Schemas2.internal = "private";
        Schemas2.walkThrough = "walkThrough";
        Schemas2.walkThroughSnippet = "walkThroughSnippet";
        Schemas2.http = "http";
        Schemas2.https = "https";
        Schemas2.file = "file";
        Schemas2.mailto = "mailto";
        Schemas2.untitled = "untitled";
        Schemas2.data = "data";
        Schemas2.command = "command";
        Schemas2.vscodeRemote = "vscode-remote";
        Schemas2.vscodeRemoteResource = "vscode-remote-resource";
        Schemas2.vscodeManagedRemoteResource = "vscode-managed-remote-resource";
        Schemas2.vscodeUserData = "vscode-userdata";
        Schemas2.vscodeCustomEditor = "vscode-custom-editor";
        Schemas2.vscodeNotebookCell = "vscode-notebook-cell";
        Schemas2.vscodeNotebookCellMetadata = "vscode-notebook-cell-metadata";
        Schemas2.vscodeNotebookCellOutput = "vscode-notebook-cell-output";
        Schemas2.vscodeInteractiveInput = "vscode-interactive-input";
        Schemas2.vscodeSettings = "vscode-settings";
        Schemas2.vscodeWorkspaceTrust = "vscode-workspace-trust";
        Schemas2.vscodeTerminal = "vscode-terminal";
        Schemas2.vscodeChatSesssion = "vscode-chat-editor";
        Schemas2.webviewPanel = "webview-panel";
        Schemas2.vscodeWebview = "vscode-webview";
        Schemas2.extension = "extension";
        Schemas2.vscodeFileResource = "vscode-file";
        Schemas2.tmp = "tmp";
        Schemas2.vsls = "vsls";
        Schemas2.vscodeSourceControl = "vscode-scm";
      })(Schemas || (Schemas = {}));
      connectionTokenQueryName = "tkn";
      RemoteAuthoritiesImpl = class {
        constructor() {
          this._hosts = /* @__PURE__ */ Object.create(null);
          this._ports = /* @__PURE__ */ Object.create(null);
          this._connectionTokens = /* @__PURE__ */ Object.create(null);
          this._preferredWebSchema = "http";
          this._delegate = null;
          this._remoteResourcesPath = `/${Schemas.vscodeRemoteResource}`;
        }
        setPreferredWebSchema(schema) {
          this._preferredWebSchema = schema;
        }
        setDelegate(delegate) {
          this._delegate = delegate;
        }
        setServerRootPath(serverRootPath) {
          this._remoteResourcesPath = `${serverRootPath}/${Schemas.vscodeRemoteResource}`;
        }
        set(authority, host, port) {
          this._hosts[authority] = host;
          this._ports[authority] = port;
        }
        setConnectionToken(authority, connectionToken) {
          this._connectionTokens[authority] = connectionToken;
        }
        getPreferredWebSchema() {
          return this._preferredWebSchema;
        }
        rewrite(uri) {
          if (this._delegate) {
            try {
              return this._delegate(uri);
            } catch (err) {
              onUnexpectedError(err);
              return uri;
            }
          }
          const authority = uri.authority;
          let host = this._hosts[authority];
          if (host && host.indexOf(":") !== -1 && host.indexOf("[") === -1) {
            host = `[${host}]`;
          }
          const port = this._ports[authority];
          const connectionToken = this._connectionTokens[authority];
          let query = `path=${encodeURIComponent(uri.path)}`;
          if (typeof connectionToken === "string") {
            query += `&${connectionTokenQueryName}=${encodeURIComponent(connectionToken)}`;
          }
          return URI.from({
            scheme: isWeb ? this._preferredWebSchema : Schemas.vscodeRemoteResource,
            authority: `${host}:${port}`,
            path: this._remoteResourcesPath,
            query
          });
        }
      };
      RemoteAuthorities = new RemoteAuthoritiesImpl();
      FileAccessImpl = class {
        constructor() {
          this.staticBrowserUris = new ResourceMap();
        }
        /**
         * Returns a URI to use in contexts where the browser is responsible
         * for loading (e.g. fetch()) or when used within the DOM.
         *
         * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.
         */
        asBrowserUri(resourcePath) {
          const uri = this.toUri(resourcePath, window.monacoRequire);
          return this.uriToBrowserUri(uri);
        }
        /**
         * Returns a URI to use in contexts where the browser is responsible
         * for loading (e.g. fetch()) or when used within the DOM.
         *
         * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.
         */
        uriToBrowserUri(uri) {
          var _a4;
          if (uri.scheme === Schemas.vscodeRemote) {
            return RemoteAuthorities.rewrite(uri);
          }
          if (
            // ...only ever for `file` resources
            uri.scheme === Schemas.file && // ...and we run in native environments
            (isNative || // ...or web worker extensions on desktop
            isWebWorker && globals.origin === `${Schemas.vscodeFileResource}://${FileAccessImpl.FALLBACK_AUTHORITY}`)
          ) {
            return uri.with({
              scheme: Schemas.vscodeFileResource,
              // We need to provide an authority here so that it can serve
              // as origin for network and loading matters in chromium.
              // If the URI is not coming with an authority already, we
              // add our own
              authority: uri.authority || FileAccessImpl.FALLBACK_AUTHORITY,
              query: null,
              fragment: null
            });
          }
          return (_a4 = this.staticBrowserUris.get(uri)) !== null && _a4 !== void 0 ? _a4 : uri;
        }
        /**
         * Returns the `file` URI to use in contexts where node.js
         * is responsible for loading.
         */
        asFileUri(resourcePath) {
          const uri = this.toUri(resourcePath, window.monacoRequire);
          return this.uriToFileUri(uri);
        }
        /**
         * Returns the `file` URI to use in contexts where node.js
         * is responsible for loading.
         */
        uriToFileUri(uri) {
          if (uri.scheme === Schemas.vscodeFileResource) {
            return uri.with({
              scheme: Schemas.file,
              // Only preserve the `authority` if it is different from
              // our fallback authority. This ensures we properly preserve
              // Windows UNC paths that come with their own authority.
              authority: uri.authority !== FileAccessImpl.FALLBACK_AUTHORITY ? uri.authority : null,
              query: null,
              fragment: null
            });
          }
          return uri;
        }
        toUri(uriOrModule, moduleIdToUrl) {
          if (URI.isUri(uriOrModule)) {
            return uriOrModule;
          }
          return URI.parse(moduleIdToUrl.toUrl(uriOrModule));
        }
        registerStaticBrowserUri(uri, browserUri) {
          this.staticBrowserUris.set(uri, browserUri);
          return toDisposable(() => {
            if (this.staticBrowserUris.get(uri) === browserUri) {
              this.staticBrowserUris.delete(uri);
            }
          });
        }
        getRegisteredBrowserUris() {
          return this.staticBrowserUris.keys();
        }
      };
      FileAccessImpl.FALLBACK_AUTHORITY = "vscode-app";
      FileAccess = new FileAccessImpl();
      (function(COI2) {
        const coiHeaders = /* @__PURE__ */ new Map([
          ["1", { "Cross-Origin-Opener-Policy": "same-origin" }],
          ["2", { "Cross-Origin-Embedder-Policy": "require-corp" }],
          ["3", { "Cross-Origin-Opener-Policy": "same-origin", "Cross-Origin-Embedder-Policy": "require-corp" }]
        ]);
        COI2.CoopAndCoep = Object.freeze(coiHeaders.get("3"));
        const coiSearchParamName = "vscode-coi";
        function getHeadersFromQuery(url) {
          let params;
          if (typeof url === "string") {
            params = new URL(url).searchParams;
          } else if (url instanceof URL) {
            params = url.searchParams;
          } else if (URI.isUri(url)) {
            params = new URL(url.toString(true)).searchParams;
          }
          const value = params === null || params === void 0 ? void 0 : params.get(coiSearchParamName);
          if (!value) {
            return void 0;
          }
          return coiHeaders.get(value);
        }
        COI2.getHeadersFromQuery = getHeadersFromQuery;
        function addSearchParam(urlOrSearch, coop, coep) {
          if (!globalThis.crossOriginIsolated) {
            return;
          }
          const value = coop && coep ? "3" : coep ? "2" : "1";
          if (urlOrSearch instanceof URLSearchParams) {
            urlOrSearch.set(coiSearchParamName, value);
          } else {
            urlOrSearch[coiSearchParamName] = value;
          }
        }
        COI2.addSearchParam = addSearchParam;
      })(COI || (COI = {}));
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/resources.js
  function originalFSPath(uri) {
    return uriToFsPath(uri, true);
  }
  var ExtUri, extUri, extUriBiasedIgnorePathCase, extUriIgnorePathCase, isEqual, isEqualOrParent2, getComparisonKey, basenameOrAuthority, basename2, extname2, dirname2, joinPath, normalizePath, relativePath, resolvePath, isAbsolutePath, isEqualAuthority, hasTrailingPathSeparator, removeTrailingPathSeparator, addTrailingPathSeparator, DataUri;
  var init_resources = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/resources.js"() {
      init_extpath();
      init_network();
      init_path();
      init_platform();
      init_strings();
      init_uri();
      ExtUri = class {
        constructor(_ignorePathCasing) {
          this._ignorePathCasing = _ignorePathCasing;
        }
        compare(uri1, uri2, ignoreFragment = false) {
          if (uri1 === uri2) {
            return 0;
          }
          return compare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));
        }
        isEqual(uri1, uri2, ignoreFragment = false) {
          if (uri1 === uri2) {
            return true;
          }
          if (!uri1 || !uri2) {
            return false;
          }
          return this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);
        }
        getComparisonKey(uri, ignoreFragment = false) {
          return uri.with({
            path: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : void 0,
            fragment: ignoreFragment ? null : void 0
          }).toString();
        }
        ignorePathCasing(uri) {
          return this._ignorePathCasing(uri);
        }
        isEqualOrParent(base, parentCandidate, ignoreFragment = false) {
          if (base.scheme === parentCandidate.scheme) {
            if (base.scheme === Schemas.file) {
              return isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), this._ignorePathCasing(base)) && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);
            }
            if (isEqualAuthority(base.authority, parentCandidate.authority)) {
              return isEqualOrParent(base.path, parentCandidate.path, this._ignorePathCasing(base), "/") && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);
            }
          }
          return false;
        }
        // --- path math
        joinPath(resource, ...pathFragment) {
          return URI.joinPath(resource, ...pathFragment);
        }
        basenameOrAuthority(resource) {
          return basename2(resource) || resource.authority;
        }
        basename(resource) {
          return posix.basename(resource.path);
        }
        extname(resource) {
          return posix.extname(resource.path);
        }
        dirname(resource) {
          if (resource.path.length === 0) {
            return resource;
          }
          let dirname3;
          if (resource.scheme === Schemas.file) {
            dirname3 = URI.file(dirname(originalFSPath(resource))).path;
          } else {
            dirname3 = posix.dirname(resource.path);
            if (resource.authority && dirname3.length && dirname3.charCodeAt(0) !== 47) {
              console.error(`dirname("${resource.toString})) resulted in a relative path`);
              dirname3 = "/";
            }
          }
          return resource.with({
            path: dirname3
          });
        }
        normalizePath(resource) {
          if (!resource.path.length) {
            return resource;
          }
          let normalizedPath;
          if (resource.scheme === Schemas.file) {
            normalizedPath = URI.file(normalize(originalFSPath(resource))).path;
          } else {
            normalizedPath = posix.normalize(resource.path);
          }
          return resource.with({
            path: normalizedPath
          });
        }
        relativePath(from, to) {
          if (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {
            return void 0;
          }
          if (from.scheme === Schemas.file) {
            const relativePath2 = relative(originalFSPath(from), originalFSPath(to));
            return isWindows ? toSlashes(relativePath2) : relativePath2;
          }
          let fromPath = from.path || "/";
          const toPath = to.path || "/";
          if (this._ignorePathCasing(from)) {
            let i = 0;
            for (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {
              if (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {
                if (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {
                  break;
                }
              }
            }
            fromPath = toPath.substr(0, i) + fromPath.substr(i);
          }
          return posix.relative(fromPath, toPath);
        }
        resolvePath(base, path) {
          if (base.scheme === Schemas.file) {
            const newURI = URI.file(resolve(originalFSPath(base), path));
            return base.with({
              authority: newURI.authority,
              path: newURI.path
            });
          }
          path = toPosixPath(path);
          return base.with({
            path: posix.resolve(base.path, path)
          });
        }
        // --- misc
        isAbsolutePath(resource) {
          return !!resource.path && resource.path[0] === "/";
        }
        isEqualAuthority(a1, a2) {
          return a1 === a2 || a1 !== void 0 && a2 !== void 0 && equalsIgnoreCase(a1, a2);
        }
        hasTrailingPathSeparator(resource, sep2 = sep) {
          if (resource.scheme === Schemas.file) {
            const fsp = originalFSPath(resource);
            return fsp.length > getRoot(fsp).length && fsp[fsp.length - 1] === sep2;
          } else {
            const p = resource.path;
            return p.length > 1 && p.charCodeAt(p.length - 1) === 47 && !/^[a-zA-Z]:(\/$|\\$)/.test(resource.fsPath);
          }
        }
        removeTrailingPathSeparator(resource, sep2 = sep) {
          if (hasTrailingPathSeparator(resource, sep2)) {
            return resource.with({ path: resource.path.substr(0, resource.path.length - 1) });
          }
          return resource;
        }
        addTrailingPathSeparator(resource, sep2 = sep) {
          let isRootSep = false;
          if (resource.scheme === Schemas.file) {
            const fsp = originalFSPath(resource);
            isRootSep = fsp !== void 0 && fsp.length === getRoot(fsp).length && fsp[fsp.length - 1] === sep2;
          } else {
            sep2 = "/";
            const p = resource.path;
            isRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === 47;
          }
          if (!isRootSep && !hasTrailingPathSeparator(resource, sep2)) {
            return resource.with({ path: resource.path + "/" });
          }
          return resource;
        }
      };
      extUri = new ExtUri(() => false);
      extUriBiasedIgnorePathCase = new ExtUri((uri) => {
        return uri.scheme === Schemas.file ? !isLinux : true;
      });
      extUriIgnorePathCase = new ExtUri((_) => true);
      isEqual = extUri.isEqual.bind(extUri);
      isEqualOrParent2 = extUri.isEqualOrParent.bind(extUri);
      getComparisonKey = extUri.getComparisonKey.bind(extUri);
      basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);
      basename2 = extUri.basename.bind(extUri);
      extname2 = extUri.extname.bind(extUri);
      dirname2 = extUri.dirname.bind(extUri);
      joinPath = extUri.joinPath.bind(extUri);
      normalizePath = extUri.normalizePath.bind(extUri);
      relativePath = extUri.relativePath.bind(extUri);
      resolvePath = extUri.resolvePath.bind(extUri);
      isAbsolutePath = extUri.isAbsolutePath.bind(extUri);
      isEqualAuthority = extUri.isEqualAuthority.bind(extUri);
      hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);
      removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);
      addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri);
      (function(DataUri2) {
        DataUri2.META_DATA_LABEL = "label";
        DataUri2.META_DATA_DESCRIPTION = "description";
        DataUri2.META_DATA_SIZE = "size";
        DataUri2.META_DATA_MIME = "mime";
        function parseMetaData(dataUri) {
          const metadata = /* @__PURE__ */ new Map();
          const meta = dataUri.path.substring(dataUri.path.indexOf(";") + 1, dataUri.path.lastIndexOf(";"));
          meta.split(";").forEach((property) => {
            const [key, value] = property.split(":");
            if (key && value) {
              metadata.set(key, value);
            }
          });
          const mime = dataUri.path.substring(0, dataUri.path.indexOf(";"));
          if (mime) {
            metadata.set(DataUri2.META_DATA_MIME, mime);
          }
          return metadata;
        }
        DataUri2.parseMetaData = parseMetaData;
      })(DataUri || (DataUri = {}));
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/htmlContent.js
  function escapeMarkdownSyntaxTokens(text) {
    return text.replace(/[\\`*_{}[\]()#+\-!~]/g, "\\$&");
  }
  var MarkdownString;
  var init_htmlContent = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/htmlContent.js"() {
      init_errors();
      init_iconLabels();
      init_resources();
      init_strings();
      init_uri();
      MarkdownString = class {
        constructor(value = "", isTrustedOrOptions = false) {
          var _a4, _b2, _c2;
          this.value = value;
          if (typeof this.value !== "string") {
            throw illegalArgument("value");
          }
          if (typeof isTrustedOrOptions === "boolean") {
            this.isTrusted = isTrustedOrOptions;
            this.supportThemeIcons = false;
            this.supportHtml = false;
          } else {
            this.isTrusted = (_a4 = isTrustedOrOptions.isTrusted) !== null && _a4 !== void 0 ? _a4 : void 0;
            this.supportThemeIcons = (_b2 = isTrustedOrOptions.supportThemeIcons) !== null && _b2 !== void 0 ? _b2 : false;
            this.supportHtml = (_c2 = isTrustedOrOptions.supportHtml) !== null && _c2 !== void 0 ? _c2 : false;
          }
        }
        appendText(value, newlineStyle = 0) {
          this.value += escapeMarkdownSyntaxTokens(this.supportThemeIcons ? escapeIcons(value) : value).replace(/([ \t]+)/g, (_match, g1) => "&nbsp;".repeat(g1.length)).replace(/\>/gm, "\\>").replace(/\n/g, newlineStyle === 1 ? "\\\n" : "\n\n");
          return this;
        }
        appendMarkdown(value) {
          this.value += value;
          return this;
        }
        appendCodeblock(langId, code) {
          this.value += "\n```";
          this.value += langId;
          this.value += "\n";
          this.value += code;
          this.value += "\n```\n";
          return this;
        }
        appendLink(target, label, title) {
          this.value += "[";
          this.value += this._escape(label, "]");
          this.value += "](";
          this.value += this._escape(String(target), ")");
          if (title) {
            this.value += ` "${this._escape(this._escape(title, '"'), ")")}"`;
          }
          this.value += ")";
          return this;
        }
        _escape(value, ch) {
          const r = new RegExp(escapeRegExpCharacters(ch), "g");
          return value.replace(r, (match, offset) => {
            if (value.charAt(offset - 1) !== "\\") {
              return `\\${match}`;
            } else {
              return match;
            }
          });
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/mime.js
  function normalizeMimeType(mimeType, strict) {
    var _a4;
    const match = _simplePattern.exec(mimeType);
    if (!match) {
      return strict ? void 0 : mimeType;
    }
    return `${match[1].toLowerCase()}/${match[2].toLowerCase()}${(_a4 = match[3]) !== null && _a4 !== void 0 ? _a4 : ""}`;
  }
  var Mimes, _simplePattern;
  var init_mime = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/mime.js"() {
      init_path();
      Mimes = Object.freeze({
        text: "text/plain",
        binary: "application/octet-stream",
        unknown: "application/unknown",
        markdown: "text/markdown",
        latex: "text/latex",
        uriList: "text/uri-list"
      });
      _simplePattern = /^(.+)\/(.+?)(;.+)?$/;
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/uuid.js
  var generateUuid;
  var init_uuid = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/uuid.js"() {
      generateUuid = function() {
        if (typeof crypto === "object" && typeof crypto.randomUUID === "function") {
          return crypto.randomUUID.bind(crypto);
        }
        let getRandomValues;
        if (typeof crypto === "object" && typeof crypto.getRandomValues === "function") {
          getRandomValues = crypto.getRandomValues.bind(crypto);
        } else {
          getRandomValues = function(bucket) {
            for (let i = 0; i < bucket.length; i++) {
              bucket[i] = Math.floor(Math.random() * 256);
            }
            return bucket;
          };
        }
        const _data = new Uint8Array(16);
        const _hex = [];
        for (let i = 0; i < 256; i++) {
          _hex.push(i.toString(16).padStart(2, "0"));
        }
        return function generateUuid2() {
          getRandomValues(_data);
          _data[6] = _data[6] & 15 | 64;
          _data[8] = _data[8] & 63 | 128;
          let i = 0;
          let result = "";
          result += _hex[_data[i++]];
          result += _hex[_data[i++]];
          result += _hex[_data[i++]];
          result += _hex[_data[i++]];
          result += "-";
          result += _hex[_data[i++]];
          result += _hex[_data[i++]];
          result += "-";
          result += _hex[_data[i++]];
          result += _hex[_data[i++]];
          result += "-";
          result += _hex[_data[i++]];
          result += _hex[_data[i++]];
          result += "-";
          result += _hex[_data[i++]];
          result += _hex[_data[i++]];
          result += _hex[_data[i++]];
          result += _hex[_data[i++]];
          result += _hex[_data[i++]];
          result += _hex[_data[i++]];
          return result;
        };
      }();
    }
  });

  // node_modules/monaco-editor/esm/vs/platform/instantiation/common/instantiation.js
  function storeServiceDependency(id2, target, index) {
    if (target[_util.DI_TARGET] === target) {
      target[_util.DI_DEPENDENCIES].push({ id: id2, index });
    } else {
      target[_util.DI_DEPENDENCIES] = [{ id: id2, index }];
      target[_util.DI_TARGET] = target;
    }
  }
  function createDecorator(serviceId) {
    if (_util.serviceIds.has(serviceId)) {
      return _util.serviceIds.get(serviceId);
    }
    const id2 = function(target, key, index) {
      if (arguments.length !== 3) {
        throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
      }
      storeServiceDependency(id2, target, index);
    };
    id2.toString = () => serviceId;
    _util.serviceIds.set(serviceId, id2);
    return id2;
  }
  var _util, IInstantiationService;
  var init_instantiation = __esm({
    "node_modules/monaco-editor/esm/vs/platform/instantiation/common/instantiation.js"() {
      (function(_util2) {
        _util2.serviceIds = /* @__PURE__ */ new Map();
        _util2.DI_TARGET = "$di$target";
        _util2.DI_DEPENDENCIES = "$di$dependencies";
        function getServiceDependencies(ctor) {
          return ctor[_util2.DI_DEPENDENCIES] || [];
        }
        _util2.getServiceDependencies = getServiceDependencies;
      })(_util || (_util = {}));
      IInstantiationService = createDecorator("instantiationService");
    }
  });

  // node_modules/monaco-editor/esm/vs/platform/remote/common/remoteHosts.js
  var init_remoteHosts = __esm({
    "node_modules/monaco-editor/esm/vs/platform/remote/common/remoteHosts.js"() {
      init_network();
    }
  });

  // node_modules/monaco-editor/esm/vs/platform/extensions/common/extensions.js
  var ExtensionIdentifier, ExtensionIdentifierMap, IBuiltinExtensionsScannerService;
  var init_extensions = __esm({
    "node_modules/monaco-editor/esm/vs/platform/extensions/common/extensions.js"() {
      init_strings();
      init_instantiation();
      init_remoteHosts();
      ExtensionIdentifier = class {
        constructor(value) {
          this.value = value;
          this._lower = value.toLowerCase();
        }
        static equals(a, b) {
          if (typeof a === "undefined" || a === null) {
            return typeof b === "undefined" || b === null;
          }
          if (typeof b === "undefined" || b === null) {
            return false;
          }
          if (typeof a === "string" || typeof b === "string") {
            const aValue = typeof a === "string" ? a : a.value;
            const bValue = typeof b === "string" ? b : b.value;
            return equalsIgnoreCase(aValue, bValue);
          }
          return a._lower === b._lower;
        }
        /**
         * Gives the value by which to index (for equality).
         */
        static toKey(id2) {
          if (typeof id2 === "string") {
            return id2.toLowerCase();
          }
          return id2._lower;
        }
      };
      ExtensionIdentifierMap = class {
        constructor() {
          this._map = /* @__PURE__ */ new Map();
        }
        clear() {
          this._map.clear();
        }
        delete(id2) {
          this._map.delete(ExtensionIdentifier.toKey(id2));
        }
        get(id2) {
          return this._map.get(ExtensionIdentifier.toKey(id2));
        }
        has(id2) {
          return this._map.has(ExtensionIdentifier.toKey(id2));
        }
        set(id2, value) {
          this._map.set(ExtensionIdentifier.toKey(id2), value);
        }
        values() {
          return this._map.values();
        }
        forEach(callbackfn) {
          this._map.forEach(callbackfn);
        }
        [Symbol.iterator]() {
          return this._map[Symbol.iterator]();
        }
      };
      IBuiltinExtensionsScannerService = createDecorator("IBuiltinExtensionsScannerService");
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/ternarySearchTree.js
  var StringIterator, ConfigKeysIterator, PathIterator, UriIterator, TernarySearchTreeNode, TernarySearchTree;
  var init_ternarySearchTree = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/ternarySearchTree.js"() {
      init_arrays();
      init_strings();
      StringIterator = class {
        constructor() {
          this._value = "";
          this._pos = 0;
        }
        reset(key) {
          this._value = key;
          this._pos = 0;
          return this;
        }
        next() {
          this._pos += 1;
          return this;
        }
        hasNext() {
          return this._pos < this._value.length - 1;
        }
        cmp(a) {
          const aCode = a.charCodeAt(0);
          const thisCode = this._value.charCodeAt(this._pos);
          return aCode - thisCode;
        }
        value() {
          return this._value[this._pos];
        }
      };
      ConfigKeysIterator = class {
        constructor(_caseSensitive = true) {
          this._caseSensitive = _caseSensitive;
        }
        reset(key) {
          this._value = key;
          this._from = 0;
          this._to = 0;
          return this.next();
        }
        hasNext() {
          return this._to < this._value.length;
        }
        next() {
          this._from = this._to;
          let justSeps = true;
          for (; this._to < this._value.length; this._to++) {
            const ch = this._value.charCodeAt(this._to);
            if (ch === 46) {
              if (justSeps) {
                this._from++;
              } else {
                break;
              }
            } else {
              justSeps = false;
            }
          }
          return this;
        }
        cmp(a) {
          return this._caseSensitive ? compareSubstring(a, this._value, 0, a.length, this._from, this._to) : compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);
        }
        value() {
          return this._value.substring(this._from, this._to);
        }
      };
      PathIterator = class {
        constructor(_splitOnBackslash = true, _caseSensitive = true) {
          this._splitOnBackslash = _splitOnBackslash;
          this._caseSensitive = _caseSensitive;
        }
        reset(key) {
          this._from = 0;
          this._to = 0;
          this._value = key;
          this._valueLen = key.length;
          for (let pos = key.length - 1; pos >= 0; pos--, this._valueLen--) {
            const ch = this._value.charCodeAt(pos);
            if (!(ch === 47 || this._splitOnBackslash && ch === 92)) {
              break;
            }
          }
          return this.next();
        }
        hasNext() {
          return this._to < this._valueLen;
        }
        next() {
          this._from = this._to;
          let justSeps = true;
          for (; this._to < this._valueLen; this._to++) {
            const ch = this._value.charCodeAt(this._to);
            if (ch === 47 || this._splitOnBackslash && ch === 92) {
              if (justSeps) {
                this._from++;
              } else {
                break;
              }
            } else {
              justSeps = false;
            }
          }
          return this;
        }
        cmp(a) {
          return this._caseSensitive ? compareSubstring(a, this._value, 0, a.length, this._from, this._to) : compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);
        }
        value() {
          return this._value.substring(this._from, this._to);
        }
      };
      UriIterator = class {
        constructor(_ignorePathCasing, _ignoreQueryAndFragment) {
          this._ignorePathCasing = _ignorePathCasing;
          this._ignoreQueryAndFragment = _ignoreQueryAndFragment;
          this._states = [];
          this._stateIdx = 0;
        }
        reset(key) {
          this._value = key;
          this._states = [];
          if (this._value.scheme) {
            this._states.push(
              1
              /* UriIteratorState.Scheme */
            );
          }
          if (this._value.authority) {
            this._states.push(
              2
              /* UriIteratorState.Authority */
            );
          }
          if (this._value.path) {
            this._pathIterator = new PathIterator(false, !this._ignorePathCasing(key));
            this._pathIterator.reset(key.path);
            if (this._pathIterator.value()) {
              this._states.push(
                3
                /* UriIteratorState.Path */
              );
            }
          }
          if (!this._ignoreQueryAndFragment(key)) {
            if (this._value.query) {
              this._states.push(
                4
                /* UriIteratorState.Query */
              );
            }
            if (this._value.fragment) {
              this._states.push(
                5
                /* UriIteratorState.Fragment */
              );
            }
          }
          this._stateIdx = 0;
          return this;
        }
        next() {
          if (this._states[this._stateIdx] === 3 && this._pathIterator.hasNext()) {
            this._pathIterator.next();
          } else {
            this._stateIdx += 1;
          }
          return this;
        }
        hasNext() {
          return this._states[this._stateIdx] === 3 && this._pathIterator.hasNext() || this._stateIdx < this._states.length - 1;
        }
        cmp(a) {
          if (this._states[this._stateIdx] === 1) {
            return compareIgnoreCase(a, this._value.scheme);
          } else if (this._states[this._stateIdx] === 2) {
            return compareIgnoreCase(a, this._value.authority);
          } else if (this._states[this._stateIdx] === 3) {
            return this._pathIterator.cmp(a);
          } else if (this._states[this._stateIdx] === 4) {
            return compare(a, this._value.query);
          } else if (this._states[this._stateIdx] === 5) {
            return compare(a, this._value.fragment);
          }
          throw new Error();
        }
        value() {
          if (this._states[this._stateIdx] === 1) {
            return this._value.scheme;
          } else if (this._states[this._stateIdx] === 2) {
            return this._value.authority;
          } else if (this._states[this._stateIdx] === 3) {
            return this._pathIterator.value();
          } else if (this._states[this._stateIdx] === 4) {
            return this._value.query;
          } else if (this._states[this._stateIdx] === 5) {
            return this._value.fragment;
          }
          throw new Error();
        }
      };
      TernarySearchTreeNode = class {
        constructor() {
          this.height = 1;
        }
        isEmpty() {
          return !this.left && !this.mid && !this.right && !this.value;
        }
        rotateLeft() {
          const tmp = this.right;
          this.right = tmp.left;
          tmp.left = this;
          this.updateHeight();
          tmp.updateHeight();
          return tmp;
        }
        rotateRight() {
          const tmp = this.left;
          this.left = tmp.right;
          tmp.right = this;
          this.updateHeight();
          tmp.updateHeight();
          return tmp;
        }
        updateHeight() {
          this.height = 1 + Math.max(this.heightLeft, this.heightRight);
        }
        balanceFactor() {
          return this.heightRight - this.heightLeft;
        }
        get heightLeft() {
          var _a4, _b2;
          return (_b2 = (_a4 = this.left) === null || _a4 === void 0 ? void 0 : _a4.height) !== null && _b2 !== void 0 ? _b2 : 0;
        }
        get heightRight() {
          var _a4, _b2;
          return (_b2 = (_a4 = this.right) === null || _a4 === void 0 ? void 0 : _a4.height) !== null && _b2 !== void 0 ? _b2 : 0;
        }
      };
      TernarySearchTree = class {
        static forUris(ignorePathCasing = () => false, ignoreQueryAndFragment = () => false) {
          return new TernarySearchTree(new UriIterator(ignorePathCasing, ignoreQueryAndFragment));
        }
        static forPaths(ignorePathCasing = false) {
          return new TernarySearchTree(new PathIterator(void 0, !ignorePathCasing));
        }
        static forStrings() {
          return new TernarySearchTree(new StringIterator());
        }
        static forConfigKeys() {
          return new TernarySearchTree(new ConfigKeysIterator());
        }
        constructor(segments) {
          this._iter = segments;
        }
        clear() {
          this._root = void 0;
        }
        fill(values, keys) {
          if (keys) {
            const arr = keys.slice(0);
            shuffle(arr);
            for (const k of arr) {
              this.set(k, values);
            }
          } else {
            const arr = values.slice(0);
            shuffle(arr);
            for (const entry of arr) {
              this.set(entry[0], entry[1]);
            }
          }
        }
        set(key, element) {
          const iter = this._iter.reset(key);
          let node;
          if (!this._root) {
            this._root = new TernarySearchTreeNode();
            this._root.segment = iter.value();
          }
          const stack = [];
          node = this._root;
          while (true) {
            const val = iter.cmp(node.segment);
            if (val > 0) {
              if (!node.left) {
                node.left = new TernarySearchTreeNode();
                node.left.segment = iter.value();
              }
              stack.push([-1, node]);
              node = node.left;
            } else if (val < 0) {
              if (!node.right) {
                node.right = new TernarySearchTreeNode();
                node.right.segment = iter.value();
              }
              stack.push([1, node]);
              node = node.right;
            } else if (iter.hasNext()) {
              iter.next();
              if (!node.mid) {
                node.mid = new TernarySearchTreeNode();
                node.mid.segment = iter.value();
              }
              stack.push([0, node]);
              node = node.mid;
            } else {
              break;
            }
          }
          const oldElement = node.value;
          node.value = element;
          node.key = key;
          for (let i = stack.length - 1; i >= 0; i--) {
            const node2 = stack[i][1];
            node2.updateHeight();
            const bf = node2.balanceFactor();
            if (bf < -1 || bf > 1) {
              const d1 = stack[i][0];
              const d2 = stack[i + 1][0];
              if (d1 === 1 && d2 === 1) {
                stack[i][1] = node2.rotateLeft();
              } else if (d1 === -1 && d2 === -1) {
                stack[i][1] = node2.rotateRight();
              } else if (d1 === 1 && d2 === -1) {
                node2.right = stack[i + 1][1] = stack[i + 1][1].rotateRight();
                stack[i][1] = node2.rotateLeft();
              } else if (d1 === -1 && d2 === 1) {
                node2.left = stack[i + 1][1] = stack[i + 1][1].rotateLeft();
                stack[i][1] = node2.rotateRight();
              } else {
                throw new Error();
              }
              if (i > 0) {
                switch (stack[i - 1][0]) {
                  case -1:
                    stack[i - 1][1].left = stack[i][1];
                    break;
                  case 1:
                    stack[i - 1][1].right = stack[i][1];
                    break;
                  case 0:
                    stack[i - 1][1].mid = stack[i][1];
                    break;
                }
              } else {
                this._root = stack[0][1];
              }
            }
          }
          return oldElement;
        }
        get(key) {
          var _a4;
          return (_a4 = this._getNode(key)) === null || _a4 === void 0 ? void 0 : _a4.value;
        }
        _getNode(key) {
          const iter = this._iter.reset(key);
          let node = this._root;
          while (node) {
            const val = iter.cmp(node.segment);
            if (val > 0) {
              node = node.left;
            } else if (val < 0) {
              node = node.right;
            } else if (iter.hasNext()) {
              iter.next();
              node = node.mid;
            } else {
              break;
            }
          }
          return node;
        }
        has(key) {
          const node = this._getNode(key);
          return !((node === null || node === void 0 ? void 0 : node.value) === void 0 && (node === null || node === void 0 ? void 0 : node.mid) === void 0);
        }
        delete(key) {
          return this._delete(key, false);
        }
        deleteSuperstr(key) {
          return this._delete(key, true);
        }
        _delete(key, superStr) {
          var _a4;
          const iter = this._iter.reset(key);
          const stack = [];
          let node = this._root;
          while (node) {
            const val = iter.cmp(node.segment);
            if (val > 0) {
              stack.push([-1, node]);
              node = node.left;
            } else if (val < 0) {
              stack.push([1, node]);
              node = node.right;
            } else if (iter.hasNext()) {
              iter.next();
              stack.push([0, node]);
              node = node.mid;
            } else {
              break;
            }
          }
          if (!node) {
            return;
          }
          if (superStr) {
            node.left = void 0;
            node.mid = void 0;
            node.right = void 0;
            node.height = 1;
          } else {
            node.key = void 0;
            node.value = void 0;
          }
          if (!node.mid && !node.value) {
            if (node.left && node.right) {
              const min = this._min(node.right);
              if (min.key) {
                const { key: key2, value, segment } = min;
                this._delete(min.key, false);
                node.key = key2;
                node.value = value;
                node.segment = segment;
              }
            } else {
              const newChild = (_a4 = node.left) !== null && _a4 !== void 0 ? _a4 : node.right;
              if (stack.length > 0) {
                const [dir, parent] = stack[stack.length - 1];
                switch (dir) {
                  case -1:
                    parent.left = newChild;
                    break;
                  case 0:
                    parent.mid = newChild;
                    break;
                  case 1:
                    parent.right = newChild;
                    break;
                }
              } else {
                this._root = newChild;
              }
            }
          }
          for (let i = stack.length - 1; i >= 0; i--) {
            const node2 = stack[i][1];
            node2.updateHeight();
            const bf = node2.balanceFactor();
            if (bf > 1) {
              if (node2.right.balanceFactor() >= 0) {
                stack[i][1] = node2.rotateLeft();
              } else {
                node2.right = node2.right.rotateRight();
                stack[i][1] = node2.rotateLeft();
              }
            } else if (bf < -1) {
              if (node2.left.balanceFactor() <= 0) {
                stack[i][1] = node2.rotateRight();
              } else {
                node2.left = node2.left.rotateLeft();
                stack[i][1] = node2.rotateRight();
              }
            }
            if (i > 0) {
              switch (stack[i - 1][0]) {
                case -1:
                  stack[i - 1][1].left = stack[i][1];
                  break;
                case 1:
                  stack[i - 1][1].right = stack[i][1];
                  break;
                case 0:
                  stack[i - 1][1].mid = stack[i][1];
                  break;
              }
            } else {
              this._root = stack[0][1];
            }
          }
        }
        _min(node) {
          while (node.left) {
            node = node.left;
          }
          return node;
        }
        findSubstr(key) {
          const iter = this._iter.reset(key);
          let node = this._root;
          let candidate = void 0;
          while (node) {
            const val = iter.cmp(node.segment);
            if (val > 0) {
              node = node.left;
            } else if (val < 0) {
              node = node.right;
            } else if (iter.hasNext()) {
              iter.next();
              candidate = node.value || candidate;
              node = node.mid;
            } else {
              break;
            }
          }
          return node && node.value || candidate;
        }
        findSuperstr(key) {
          return this._findSuperstrOrElement(key, false);
        }
        _findSuperstrOrElement(key, allowValue) {
          const iter = this._iter.reset(key);
          let node = this._root;
          while (node) {
            const val = iter.cmp(node.segment);
            if (val > 0) {
              node = node.left;
            } else if (val < 0) {
              node = node.right;
            } else if (iter.hasNext()) {
              iter.next();
              node = node.mid;
            } else {
              if (!node.mid) {
                if (allowValue) {
                  return node.value;
                } else {
                  return void 0;
                }
              } else {
                return this._entries(node.mid);
              }
            }
          }
          return void 0;
        }
        hasElementOrSubtree(key) {
          return this._findSuperstrOrElement(key, true) !== void 0;
        }
        forEach(callback) {
          for (const [key, value] of this) {
            callback(value, key);
          }
        }
        *[Symbol.iterator]() {
          yield* this._entries(this._root);
        }
        _entries(node) {
          const result = [];
          this._dfsEntries(node, result);
          return result[Symbol.iterator]();
        }
        _dfsEntries(node, bucket) {
          if (!node) {
            return;
          }
          if (node.left) {
            this._dfsEntries(node.left, bucket);
          }
          if (node.value) {
            bucket.push([node.key, node.value]);
          }
          if (node.mid) {
            this._dfsEntries(node.mid, bucket);
          }
          if (node.right) {
            this._dfsEntries(node.right, bucket);
          }
        }
        // for debug/testing
        _isBalanced() {
          const nodeIsBalanced = (node) => {
            if (!node) {
              return true;
            }
            const bf = node.balanceFactor();
            if (bf < -1 || bf > 1) {
              return false;
            }
            return nodeIsBalanced(node.left) && nodeIsBalanced(node.right);
          };
          return nodeIsBalanced(this._root);
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/platform/files/common/files.js
  function markAsFileSystemProviderError(error, code) {
    error.name = code ? `${code} (FileSystemError)` : `FileSystemError`;
    return error;
  }
  var IFileService, FileType, FilePermission, FileSystemProviderErrorCode, FileKind, ByteSize;
  var init_files = __esm({
    "node_modules/monaco-editor/esm/vs/platform/files/common/files.js"() {
      init_ternarySearchTree();
      init_path();
      init_strings();
      init_types();
      init_uri();
      init_nls();
      init_instantiation();
      init_platform();
      init_network();
      IFileService = createDecorator("fileService");
      (function(FileType3) {
        FileType3[FileType3["Unknown"] = 0] = "Unknown";
        FileType3[FileType3["File"] = 1] = "File";
        FileType3[FileType3["Directory"] = 2] = "Directory";
        FileType3[FileType3["SymbolicLink"] = 64] = "SymbolicLink";
      })(FileType || (FileType = {}));
      (function(FilePermission3) {
        FilePermission3[FilePermission3["Readonly"] = 1] = "Readonly";
        FilePermission3[FilePermission3["Locked"] = 2] = "Locked";
      })(FilePermission || (FilePermission = {}));
      (function(FileSystemProviderErrorCode2) {
        FileSystemProviderErrorCode2["FileExists"] = "EntryExists";
        FileSystemProviderErrorCode2["FileNotFound"] = "EntryNotFound";
        FileSystemProviderErrorCode2["FileNotADirectory"] = "EntryNotADirectory";
        FileSystemProviderErrorCode2["FileIsADirectory"] = "EntryIsADirectory";
        FileSystemProviderErrorCode2["FileExceedsStorageQuota"] = "EntryExceedsStorageQuota";
        FileSystemProviderErrorCode2["FileTooLarge"] = "EntryTooLarge";
        FileSystemProviderErrorCode2["FileWriteLocked"] = "EntryWriteLocked";
        FileSystemProviderErrorCode2["NoPermissions"] = "NoPermissions";
        FileSystemProviderErrorCode2["Unavailable"] = "Unavailable";
        FileSystemProviderErrorCode2["Unknown"] = "Unknown";
      })(FileSystemProviderErrorCode || (FileSystemProviderErrorCode = {}));
      (function(FileKind2) {
        FileKind2[FileKind2["FILE"] = 0] = "FILE";
        FileKind2[FileKind2["FOLDER"] = 1] = "FOLDER";
        FileKind2[FileKind2["ROOT_FOLDER"] = 2] = "ROOT_FOLDER";
      })(FileKind || (FileKind = {}));
      ByteSize = class {
        static formatSize(size) {
          if (!isNumber2(size)) {
            size = 0;
          }
          if (size < ByteSize.KB) {
            return localize("sizeB", "{0}B", size.toFixed(0));
          }
          if (size < ByteSize.MB) {
            return localize("sizeKB", "{0}KB", (size / ByteSize.KB).toFixed(2));
          }
          if (size < ByteSize.GB) {
            return localize("sizeMB", "{0}MB", (size / ByteSize.MB).toFixed(2));
          }
          if (size < ByteSize.TB) {
            return localize("sizeGB", "{0}GB", (size / ByteSize.GB).toFixed(2));
          }
          return localize("sizeTB", "{0}TB", (size / ByteSize.TB).toFixed(2));
        }
      };
      ByteSize.KB = 1024;
      ByteSize.MB = ByteSize.KB * ByteSize.KB;
      ByteSize.GB = ByteSize.MB * ByteSize.KB;
      ByteSize.TB = ByteSize.GB * ByteSize.KB;
    }
  });

  // node_modules/vscode/dist/vscode/vs/platform/remote/common/remoteAuthorityResolver.js
  var IRemoteAuthorityResolverService, RemoteAuthorityResolverErrorCode;
  var init_remoteAuthorityResolver = __esm({
    "node_modules/vscode/dist/vscode/vs/platform/remote/common/remoteAuthorityResolver.js"() {
      init_errors();
      init_instantiation();
      IRemoteAuthorityResolverService = createDecorator("remoteAuthorityResolverService");
      (function(RemoteAuthorityResolverErrorCode2) {
        RemoteAuthorityResolverErrorCode2["Unknown"] = "Unknown";
        RemoteAuthorityResolverErrorCode2["NotAvailable"] = "NotAvailable";
        RemoteAuthorityResolverErrorCode2["TemporarilyNotAvailable"] = "TemporarilyNotAvailable";
        RemoteAuthorityResolverErrorCode2["NoResolverFound"] = "NoResolverFound";
        RemoteAuthorityResolverErrorCode2["InvalidAuthority"] = "InvalidAuthority";
      })(
        RemoteAuthorityResolverErrorCode || (RemoteAuthorityResolverErrorCode = {})
      );
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/stream.js
  var init_stream = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/stream.js"() {
      init_errors();
      init_lifecycle();
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/buffer.js
  function binaryIndexOf(haystack, needle, offset = 0) {
    const needleLen = needle.byteLength;
    const haystackLen = haystack.byteLength;
    if (needleLen === 0) {
      return 0;
    }
    if (needleLen === 1) {
      return haystack.indexOf(needle[0]);
    }
    if (needleLen > haystackLen - offset) {
      return -1;
    }
    const table = indexOfTable.value;
    table.fill(needle.length);
    for (let i2 = 0; i2 < needle.length; i2++) {
      table[needle[i2]] = needle.length - i2 - 1;
    }
    let i = offset + needle.length - 1;
    let j = i;
    let result = -1;
    while (i < haystackLen) {
      if (haystack[i] === needle[j]) {
        if (j === 0) {
          result = i;
          break;
        }
        i--;
        j--;
      } else {
        i += Math.max(needle.length - j, table[haystack[i]]);
        j = needle.length - 1;
      }
    }
    return result;
  }
  function readUInt32BE(source, offset) {
    return source[offset] * Math.pow(2, 24) + source[offset + 1] * Math.pow(2, 16) + source[offset + 2] * Math.pow(2, 8) + source[offset + 3];
  }
  function writeUInt32BE(destination, value, offset) {
    destination[offset + 3] = value;
    value = value >>> 8;
    destination[offset + 2] = value;
    value = value >>> 8;
    destination[offset + 1] = value;
    value = value >>> 8;
    destination[offset] = value;
  }
  function readUInt32LE(source, offset) {
    return source[offset + 0] << 0 >>> 0 | source[offset + 1] << 8 >>> 0 | source[offset + 2] << 16 >>> 0 | source[offset + 3] << 24 >>> 0;
  }
  function writeUInt32LE(destination, value, offset) {
    destination[offset + 0] = value & 255;
    value = value >>> 8;
    destination[offset + 1] = value & 255;
    value = value >>> 8;
    destination[offset + 2] = value & 255;
    value = value >>> 8;
    destination[offset + 3] = value & 255;
  }
  function readUInt8(source, offset) {
    return source[offset];
  }
  function writeUInt8(destination, value, offset) {
    destination[offset] = value;
  }
  function decodeBase64(encoded) {
    let building = 0;
    let remainder = 0;
    let bufi = 0;
    const buffer = new Uint8Array(Math.floor(encoded.length / 4 * 3));
    const append = (value) => {
      switch (remainder) {
        case 3:
          buffer[bufi++] = building | value;
          remainder = 0;
          break;
        case 2:
          buffer[bufi++] = building | value >>> 2;
          building = value << 6;
          remainder = 3;
          break;
        case 1:
          buffer[bufi++] = building | value >>> 4;
          building = value << 4;
          remainder = 2;
          break;
        default:
          building = value << 2;
          remainder = 1;
      }
    };
    for (let i = 0; i < encoded.length; i++) {
      const code = encoded.charCodeAt(i);
      if (code >= 65 && code <= 90) {
        append(code - 65);
      } else if (code >= 97 && code <= 122) {
        append(code - 97 + 26);
      } else if (code >= 48 && code <= 57) {
        append(code - 48 + 52);
      } else if (code === 43 || code === 45) {
        append(62);
      } else if (code === 47 || code === 95) {
        append(63);
      } else if (code === 61) {
        break;
      } else {
        throw new SyntaxError(`Unexpected base64 character ${encoded[i]}`);
      }
    }
    const unpadded = bufi;
    while (remainder > 0) {
      append(0);
    }
    return VSBuffer.wrap(buffer).slice(0, unpadded);
  }
  function encodeBase64({ buffer }, padded = true, urlSafe = false) {
    const dictionary = urlSafe ? base64UrlSafeAlphabet : base64Alphabet;
    let output = "";
    const remainder = buffer.byteLength % 3;
    let i = 0;
    for (; i < buffer.byteLength - remainder; i += 3) {
      const a = buffer[i + 0];
      const b = buffer[i + 1];
      const c = buffer[i + 2];
      output += dictionary[a >>> 2];
      output += dictionary[(a << 4 | b >>> 4) & 63];
      output += dictionary[(b << 2 | c >>> 6) & 63];
      output += dictionary[c & 63];
    }
    if (remainder === 1) {
      const a = buffer[i + 0];
      output += dictionary[a >>> 2];
      output += dictionary[a << 4 & 63];
      if (padded) {
        output += "==";
      }
    } else if (remainder === 2) {
      const a = buffer[i + 0];
      const b = buffer[i + 1];
      output += dictionary[a >>> 2];
      output += dictionary[(a << 4 | b >>> 4) & 63];
      output += dictionary[b << 2 & 63];
      if (padded) {
        output += "=";
      }
    }
    return output;
  }
  var hasBuffer, indexOfTable, textEncoder, textDecoder, VSBuffer, base64Alphabet, base64UrlSafeAlphabet;
  var init_buffer = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/buffer.js"() {
      init_lazy();
      init_stream();
      hasBuffer = typeof Buffer !== "undefined";
      indexOfTable = new Lazy(() => new Uint8Array(256));
      VSBuffer = class {
        /**
         * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
         * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
         */
        static alloc(byteLength) {
          if (hasBuffer) {
            return new VSBuffer(Buffer.allocUnsafe(byteLength));
          } else {
            return new VSBuffer(new Uint8Array(byteLength));
          }
        }
        /**
         * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for
         * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,
         * which is not transferrable.
         */
        static wrap(actual) {
          if (hasBuffer && !Buffer.isBuffer(actual)) {
            actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);
          }
          return new VSBuffer(actual);
        }
        /**
         * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
         * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
         */
        static fromString(source, options) {
          const dontUseNodeBuffer = (options === null || options === void 0 ? void 0 : options.dontUseNodeBuffer) || false;
          if (!dontUseNodeBuffer && hasBuffer) {
            return new VSBuffer(Buffer.from(source));
          } else {
            if (!textEncoder) {
              textEncoder = new TextEncoder();
            }
            return new VSBuffer(textEncoder.encode(source));
          }
        }
        /**
         * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
         * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
         */
        static fromByteArray(source) {
          const result = VSBuffer.alloc(source.length);
          for (let i = 0, len = source.length; i < len; i++) {
            result.buffer[i] = source[i];
          }
          return result;
        }
        /**
         * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
         * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
         */
        static concat(buffers, totalLength) {
          if (typeof totalLength === "undefined") {
            totalLength = 0;
            for (let i = 0, len = buffers.length; i < len; i++) {
              totalLength += buffers[i].byteLength;
            }
          }
          const ret = VSBuffer.alloc(totalLength);
          let offset = 0;
          for (let i = 0, len = buffers.length; i < len; i++) {
            const element = buffers[i];
            ret.set(element, offset);
            offset += element.byteLength;
          }
          return ret;
        }
        constructor(buffer) {
          this.buffer = buffer;
          this.byteLength = this.buffer.byteLength;
        }
        /**
         * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
         * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
         */
        clone() {
          const result = VSBuffer.alloc(this.byteLength);
          result.set(this);
          return result;
        }
        toString() {
          if (hasBuffer) {
            return this.buffer.toString();
          } else {
            if (!textDecoder) {
              textDecoder = new TextDecoder();
            }
            return textDecoder.decode(this.buffer);
          }
        }
        slice(start, end) {
          return new VSBuffer(this.buffer.subarray(start, end));
        }
        set(array, offset) {
          if (array instanceof VSBuffer) {
            this.buffer.set(array.buffer, offset);
          } else if (array instanceof Uint8Array) {
            this.buffer.set(array, offset);
          } else if (array instanceof ArrayBuffer) {
            this.buffer.set(new Uint8Array(array), offset);
          } else if (ArrayBuffer.isView(array)) {
            this.buffer.set(new Uint8Array(array.buffer, array.byteOffset, array.byteLength), offset);
          } else {
            throw new Error(`Unknown argument 'array'`);
          }
        }
        readUInt32BE(offset) {
          return readUInt32BE(this.buffer, offset);
        }
        writeUInt32BE(value, offset) {
          writeUInt32BE(this.buffer, value, offset);
        }
        readUInt32LE(offset) {
          return readUInt32LE(this.buffer, offset);
        }
        writeUInt32LE(value, offset) {
          writeUInt32LE(this.buffer, value, offset);
        }
        readUInt8(offset) {
          return readUInt8(this.buffer, offset);
        }
        writeUInt8(value, offset) {
          writeUInt8(this.buffer, value, offset);
        }
        indexOf(subarray, offset = 0) {
          return binaryIndexOf(this.buffer, subarray instanceof VSBuffer ? subarray.buffer : subarray, offset);
        }
      };
      base64Alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      base64UrlSafeAlphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
    }
  });

  // node_modules/vscode/dist/vscode/vs/workbench/contrib/notebook/common/notebookCommon.js
  var CellKind, NotebookCellExecutionState, NotebookCellsChangeType, SelectionStateType, CellUri, NotebookWorkingCopyTypeIdentifier, textDecoder2, MOVE_CURSOR_1_LINE_COMMAND, MOVE_CURSOR_1_LINE_COMMAND_BYTES, BACKSPACE_CHARACTER, CARRIAGE_RETURN_CHARACTER;
  var init_notebookCommon = __esm({
    "node_modules/vscode/dist/vscode/vs/workbench/contrib/notebook/common/notebookCommon.js"() {
      init_buffer();
      init_network();
      (function(CellKind2) {
        CellKind2[CellKind2["Markup"] = 1] = "Markup";
        CellKind2[CellKind2["Code"] = 2] = "Code";
      })(CellKind || (CellKind = {}));
      (function(NotebookCellExecutionState3) {
        NotebookCellExecutionState3[NotebookCellExecutionState3["Unconfirmed"] = 1] = "Unconfirmed";
        NotebookCellExecutionState3[NotebookCellExecutionState3["Pending"] = 2] = "Pending";
        NotebookCellExecutionState3[NotebookCellExecutionState3["Executing"] = 3] = "Executing";
      })(NotebookCellExecutionState || (NotebookCellExecutionState = {}));
      (function(NotebookCellsChangeType2) {
        NotebookCellsChangeType2[NotebookCellsChangeType2["ModelChange"] = 1] = "ModelChange";
        NotebookCellsChangeType2[NotebookCellsChangeType2["Move"] = 2] = "Move";
        NotebookCellsChangeType2[NotebookCellsChangeType2["ChangeCellLanguage"] = 5] = "ChangeCellLanguage";
        NotebookCellsChangeType2[NotebookCellsChangeType2["Initialize"] = 6] = "Initialize";
        NotebookCellsChangeType2[NotebookCellsChangeType2["ChangeCellMetadata"] = 7] = "ChangeCellMetadata";
        NotebookCellsChangeType2[NotebookCellsChangeType2["Output"] = 8] = "Output";
        NotebookCellsChangeType2[NotebookCellsChangeType2["OutputItem"] = 9] = "OutputItem";
        NotebookCellsChangeType2[NotebookCellsChangeType2["ChangeCellContent"] = 10] = "ChangeCellContent";
        NotebookCellsChangeType2[NotebookCellsChangeType2["ChangeDocumentMetadata"] = 11] = "ChangeDocumentMetadata";
        NotebookCellsChangeType2[NotebookCellsChangeType2["ChangeCellInternalMetadata"] = 12] = "ChangeCellInternalMetadata";
        NotebookCellsChangeType2[NotebookCellsChangeType2["ChangeCellMime"] = 13] = "ChangeCellMime";
        NotebookCellsChangeType2[NotebookCellsChangeType2["Unknown"] = 100] = "Unknown";
      })(NotebookCellsChangeType || (NotebookCellsChangeType = {}));
      (function(SelectionStateType2) {
        SelectionStateType2[SelectionStateType2["Handle"] = 0] = "Handle";
        SelectionStateType2[SelectionStateType2["Index"] = 1] = "Index";
      })(SelectionStateType || (SelectionStateType = {}));
      (function(CellUri2) {
        CellUri2.scheme = Schemas.vscodeNotebookCell;
        const _lengths = ["W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f"];
        const _padRegexp = new RegExp(`^[${_lengths.join("")}]+`);
        const _radix = 7;
        function generate(notebook, handle) {
          const s = handle.toString(_radix);
          const p = s.length < _lengths.length ? _lengths[s.length - 1] : "z";
          const fragment = `${p}${s}s${encodeBase64(VSBuffer.fromString(notebook.scheme), true, true)}`;
          return notebook.with({ scheme: CellUri2.scheme, fragment });
        }
        CellUri2.generate = generate;
        function parse2(cell) {
          if (cell.scheme !== CellUri2.scheme) {
            return void 0;
          }
          const idx = cell.fragment.indexOf("s");
          if (idx < 0) {
            return void 0;
          }
          const handle = parseInt(cell.fragment.substring(0, idx).replace(_padRegexp, ""), _radix);
          const _scheme = decodeBase64(cell.fragment.substring(idx + 1)).toString();
          if (isNaN(handle)) {
            return void 0;
          }
          return {
            handle,
            notebook: cell.with({ scheme: _scheme, fragment: null })
          };
        }
        CellUri2.parse = parse2;
        function generateCellOutputUri(notebook, outputId) {
          return notebook.with({
            scheme: Schemas.vscodeNotebookCellOutput,
            fragment: `op${outputId ?? ""},${notebook.scheme !== Schemas.file ? notebook.scheme : ""}`
          });
        }
        CellUri2.generateCellOutputUri = generateCellOutputUri;
        function parseCellOutputUri(uri) {
          if (uri.scheme !== Schemas.vscodeNotebookCellOutput) {
            return;
          }
          const match = /^op([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})?\,(.*)$/i.exec(uri.fragment);
          if (!match) {
            return void 0;
          }
          const outputId = match[1] && match[1] !== "" ? match[1] : void 0;
          const scheme = match[2];
          return {
            outputId,
            notebook: uri.with({
              scheme: scheme || Schemas.file,
              fragment: null
            })
          };
        }
        CellUri2.parseCellOutputUri = parseCellOutputUri;
        function generateCellPropertyUri(notebook, handle, scheme) {
          return CellUri2.generate(notebook, handle).with({ scheme });
        }
        CellUri2.generateCellPropertyUri = generateCellPropertyUri;
        function parseCellPropertyUri(uri, propertyScheme) {
          if (uri.scheme !== propertyScheme) {
            return void 0;
          }
          return CellUri2.parse(uri.with({ scheme: CellUri2.scheme }));
        }
        CellUri2.parseCellPropertyUri = parseCellPropertyUri;
      })(CellUri || (CellUri = {}));
      NotebookWorkingCopyTypeIdentifier = class {
        static {
          this._prefix = "notebook/";
        }
        static create(viewType) {
          return `${NotebookWorkingCopyTypeIdentifier._prefix}${viewType}`;
        }
        static parse(candidate) {
          if (candidate.startsWith(NotebookWorkingCopyTypeIdentifier._prefix)) {
            return candidate.substring(NotebookWorkingCopyTypeIdentifier._prefix.length);
          }
          return void 0;
        }
      };
      textDecoder2 = new TextDecoder();
      MOVE_CURSOR_1_LINE_COMMAND = `${String.fromCharCode(27)}[A`;
      MOVE_CURSOR_1_LINE_COMMAND_BYTES = MOVE_CURSOR_1_LINE_COMMAND.split("").map((c) => c.charCodeAt(0));
      BACKSPACE_CHARACTER = "\b".charCodeAt(0);
      CARRIAGE_RETURN_CHARACTER = "\r".charCodeAt(0);
    }
  });

  // node_modules/vscode/dist/vscode/vs/workbench/api/common/extHostTypes.js
  function es5ClassCompat(target) {
    const interceptFunctions = {
      apply: function() {
        const args = arguments.length === 1 ? [] : arguments[1];
        return Reflect.construct(target, args, arguments[0].constructor);
      },
      call: function() {
        if (arguments.length === 0) {
          return Reflect.construct(target, []);
        } else {
          const [thisArg, ...restArgs] = arguments;
          return Reflect.construct(target, restArgs, thisArg.constructor);
        }
      }
    };
    return Object.assign(target, interceptFunctions);
  }
  function computeTaskExecutionId(values) {
    let id2 = "";
    for (let i = 0; i < values.length; i++) {
      id2 += values[i].replace(/,/g, ",,") + ",";
    }
    return id2;
  }
  function isStrArrayOrUndefined(arg) {
    return typeof arg === "undefined" || isStringArray(arg);
  }
  var Disposable_1, Position_1, Range_1, Selection_1, TextEdit_1, NotebookEdit_1, SnippetString_1, Location_1, SymbolInformation_1, DocumentSymbol_1, CodeActionKind_1, MarkdownString_1, TaskGroup_1, Task_1, TreeItem_1, FileSystemError_1, TestMessage_1, FileCoverage_1, TerminalOutputAnchor, TerminalQuickFixType, Disposable2, Position, Range, Selection, EndOfLine, EnvironmentVariableMutatorType, TextEdit, NotebookEdit, SnippetTextEdit, WorkspaceEdit, SnippetString, DiagnosticTag, DiagnosticSeverity, Location, DiagnosticRelatedInformation, Diagnostic, Hover, DocumentHighlightKind, DocumentHighlight, SymbolKind, SymbolTag, SymbolInformation, DocumentSymbol, CodeActionTriggerKind, CodeAction, CodeActionKind, SelectionRange, CallHierarchyItem, CallHierarchyIncomingCall, CallHierarchyOutgoingCall, LanguageStatusSeverity, CodeLens, MarkdownString2, ParameterInformation, SignatureInformation, SignatureHelp, SignatureHelpTriggerKind, InlayHintKind, InlayHintLabelPart, InlayHint, CompletionTriggerKind, CompletionItemKind, CompletionItemTag, CompletionItem, CompletionList, InlineSuggestion, InlineSuggestionList, ViewColumn, StatusBarAlignment, TextEditorLineNumbersStyle, TextDocumentSaveReason, TextEditorRevealType, TextEditorSelectionChangeKind, TextDocumentChangeReason, DecorationRangeBehavior, DocumentLink, Color, ColorInformation, ColorPresentation, SourceControlInputBoxValidationType, TerminalExitReason, TerminalLink, TerminalLocation, TerminalProfile, TaskRevealKind, TaskPanelKind, TaskGroup, ProcessExecution, ShellExecution, ShellQuoting, TaskScope, CustomExecution, Task, ProgressLocation, ViewBadge, TreeItem, TreeItemCollapsibleState, TreeItemCheckboxState, DataTransferItem, DataTransfer, DocumentDropEdit, DocumentPasteEdit, ThemeIcon2, ThemeColor2, ConfigurationTarget, RelativePattern, breakpointIds, Breakpoint, SourceBreakpoint, FunctionBreakpoint, DataBreakpoint, DebugAdapterExecutable, DebugAdapterServer, DebugAdapterNamedPipeServer, DebugAdapterInlineImplementation, StackFrameFocus, ThreadFocus, EvaluatableExpression, InlineCompletionTriggerKind, InlineValueText, InlineValueVariableLookup, InlineValueEvaluatableExpression, InlineValueContext, FileChangeType, FileSystemError, FoldingRange, FoldingRangeKind, CommentThreadCollapsibleState, CommentMode, CommentState, CommentThreadState, SemanticTokensLegend, SemanticTokensBuilder, SemanticTokens, SemanticTokensEdit, SemanticTokensEdits, DebugConsoleMode, QuickInputButtons, QuickPickItemKind, InputBoxValidationSeverity, ExtensionKind, FileDecoration, ColorTheme, ColorThemeKind, NotebookRange, _encoder, _NotebookCellOutputItem, NotebookCellOutputItem, NotebookCellKind, NotebookCellExecutionState2, NotebookCellStatusBarAlignment, NotebookEditorRevealType, NotebookControllerAffinity, NotebookControllerAffinity2, TimelineItem, ExtensionMode, ExtensionRuntime, StandardTokenType, LinkedEditingRanges, TestResultState, TestRunProfileKind, TestRunRequest, TestRunRequest22, TestMessage, TestTag, CoveredCount, FileCoverage, StatementCoverage, BranchCoverage, FunctionCoverage, ExternalUriOpenerPriority, WorkspaceTrustState, PortAutoForwardAction, TypeHierarchyItem, TextTabInput, TextDiffTabInput, CustomEditorTabInput, WebviewEditorTabInput, NotebookEditorTabInput, NotebookDiffEditorTabInput, TerminalEditorTabInput, InteractiveSessionVoteDirection, InteractiveSessionCopyKind, InteractiveEditorResponseFeedbackKind;
  var init_extHostTypes = __esm({
    "node_modules/vscode/dist/vscode/vs/workbench/api/common/extHostTypes.js"() {
      init_tslib_es6();
      init_arrays();
      init_errors();
      init_htmlContent();
      init_map();
      init_mime();
      init_strings();
      init_types();
      init_uri();
      init_uuid();
      init_extensions();
      init_files();
      init_remoteAuthorityResolver();
      init_notebookCommon();
      (function(TerminalOutputAnchor2) {
        TerminalOutputAnchor2[TerminalOutputAnchor2["Top"] = 0] = "Top";
        TerminalOutputAnchor2[TerminalOutputAnchor2["Bottom"] = 1] = "Bottom";
      })(TerminalOutputAnchor || (TerminalOutputAnchor = {}));
      (function(TerminalQuickFixType2) {
        TerminalQuickFixType2[TerminalQuickFixType2["Command"] = 0] = "Command";
        TerminalQuickFixType2[TerminalQuickFixType2["Opener"] = 1] = "Opener";
      })(TerminalQuickFixType || (TerminalQuickFixType = {}));
      Disposable2 = Disposable_1 = class Disposable3 {
        static from(...inDisposables) {
          let disposables = inDisposables;
          return new Disposable_1(function() {
            if (disposables) {
              for (const disposable of disposables) {
                if (disposable && typeof disposable.dispose === "function") {
                  disposable.dispose();
                }
              }
              disposables = void 0;
            }
          });
        }
        #callOnDispose;
        constructor(callOnDispose) {
          this.#callOnDispose = callOnDispose;
        }
        dispose() {
          if (typeof this.#callOnDispose === "function") {
            this.#callOnDispose();
            this.#callOnDispose = void 0;
          }
        }
      };
      Disposable2 = Disposable_1 = __decorate([
        es5ClassCompat
      ], Disposable2);
      Position = Position_1 = class Position2 {
        static Min(...positions) {
          if (positions.length === 0) {
            throw new TypeError();
          }
          let result = positions[0];
          for (let i = 1; i < positions.length; i++) {
            const p = positions[i];
            if (p.isBefore(result)) {
              result = p;
            }
          }
          return result;
        }
        static Max(...positions) {
          if (positions.length === 0) {
            throw new TypeError();
          }
          let result = positions[0];
          for (let i = 1; i < positions.length; i++) {
            const p = positions[i];
            if (p.isAfter(result)) {
              result = p;
            }
          }
          return result;
        }
        static isPosition(other) {
          if (!other) {
            return false;
          }
          if (other instanceof Position_1) {
            return true;
          }
          const { line, character } = other;
          if (typeof line === "number" && typeof character === "number") {
            return true;
          }
          return false;
        }
        static of(obj) {
          if (obj instanceof Position_1) {
            return obj;
          } else if (this.isPosition(obj)) {
            return new Position_1(obj.line, obj.character);
          }
          throw new Error("Invalid argument, is NOT a position-like object");
        }
        get line() {
          return this._line;
        }
        get character() {
          return this._character;
        }
        constructor(line, character) {
          if (line < 0) {
            throw illegalArgument("line must be non-negative");
          }
          if (character < 0) {
            throw illegalArgument("character must be non-negative");
          }
          this._line = line;
          this._character = character;
        }
        isBefore(other) {
          if (this._line < other._line) {
            return true;
          }
          if (other._line < this._line) {
            return false;
          }
          return this._character < other._character;
        }
        isBeforeOrEqual(other) {
          if (this._line < other._line) {
            return true;
          }
          if (other._line < this._line) {
            return false;
          }
          return this._character <= other._character;
        }
        isAfter(other) {
          return !this.isBeforeOrEqual(other);
        }
        isAfterOrEqual(other) {
          return !this.isBefore(other);
        }
        isEqual(other) {
          return this._line === other._line && this._character === other._character;
        }
        compareTo(other) {
          if (this._line < other._line) {
            return -1;
          } else if (this._line > other.line) {
            return 1;
          } else {
            if (this._character < other._character) {
              return -1;
            } else if (this._character > other._character) {
              return 1;
            } else {
              return 0;
            }
          }
        }
        translate(lineDeltaOrChange, characterDelta = 0) {
          if (lineDeltaOrChange === null || characterDelta === null) {
            throw illegalArgument();
          }
          let lineDelta;
          if (typeof lineDeltaOrChange === "undefined") {
            lineDelta = 0;
          } else if (typeof lineDeltaOrChange === "number") {
            lineDelta = lineDeltaOrChange;
          } else {
            lineDelta = typeof lineDeltaOrChange.lineDelta === "number" ? lineDeltaOrChange.lineDelta : 0;
            characterDelta = typeof lineDeltaOrChange.characterDelta === "number" ? lineDeltaOrChange.characterDelta : 0;
          }
          if (lineDelta === 0 && characterDelta === 0) {
            return this;
          }
          return new Position_1(this.line + lineDelta, this.character + characterDelta);
        }
        with(lineOrChange, character = this.character) {
          if (lineOrChange === null || character === null) {
            throw illegalArgument();
          }
          let line;
          if (typeof lineOrChange === "undefined") {
            line = this.line;
          } else if (typeof lineOrChange === "number") {
            line = lineOrChange;
          } else {
            line = typeof lineOrChange.line === "number" ? lineOrChange.line : this.line;
            character = typeof lineOrChange.character === "number" ? lineOrChange.character : this.character;
          }
          if (line === this.line && character === this.character) {
            return this;
          }
          return new Position_1(line, character);
        }
        toJSON() {
          return { line: this.line, character: this.character };
        }
      };
      Position = Position_1 = __decorate([
        es5ClassCompat
      ], Position);
      Range = Range_1 = class Range2 {
        static isRange(thing) {
          if (thing instanceof Range_1) {
            return true;
          }
          if (!thing) {
            return false;
          }
          return Position.isPosition(thing.start) && Position.isPosition(thing.end);
        }
        static of(obj) {
          if (obj instanceof Range_1) {
            return obj;
          }
          if (this.isRange(obj)) {
            return new Range_1(obj.start, obj.end);
          }
          throw new Error("Invalid argument, is NOT a range-like object");
        }
        get start() {
          return this._start;
        }
        get end() {
          return this._end;
        }
        constructor(startLineOrStart, startColumnOrEnd, endLine, endColumn) {
          let start;
          let end;
          if (typeof startLineOrStart === "number" && typeof startColumnOrEnd === "number" && typeof endLine === "number" && typeof endColumn === "number") {
            start = new Position(startLineOrStart, startColumnOrEnd);
            end = new Position(endLine, endColumn);
          } else if (Position.isPosition(startLineOrStart) && Position.isPosition(startColumnOrEnd)) {
            start = Position.of(startLineOrStart);
            end = Position.of(startColumnOrEnd);
          }
          if (!start || !end) {
            throw new Error("Invalid arguments");
          }
          if (start.isBefore(end)) {
            this._start = start;
            this._end = end;
          } else {
            this._start = end;
            this._end = start;
          }
        }
        contains(positionOrRange) {
          if (Range_1.isRange(positionOrRange)) {
            return this.contains(positionOrRange.start) && this.contains(positionOrRange.end);
          } else if (Position.isPosition(positionOrRange)) {
            if (Position.of(positionOrRange).isBefore(this._start)) {
              return false;
            }
            if (this._end.isBefore(positionOrRange)) {
              return false;
            }
            return true;
          }
          return false;
        }
        isEqual(other) {
          return this._start.isEqual(other._start) && this._end.isEqual(other._end);
        }
        intersection(other) {
          const start = Position.Max(other.start, this._start);
          const end = Position.Min(other.end, this._end);
          if (start.isAfter(end)) {
            return void 0;
          }
          return new Range_1(start, end);
        }
        union(other) {
          if (this.contains(other)) {
            return this;
          } else if (other.contains(this)) {
            return other;
          }
          const start = Position.Min(other.start, this._start);
          const end = Position.Max(other.end, this.end);
          return new Range_1(start, end);
        }
        get isEmpty() {
          return this._start.isEqual(this._end);
        }
        get isSingleLine() {
          return this._start.line === this._end.line;
        }
        with(startOrChange, end = this.end) {
          if (startOrChange === null || end === null) {
            throw illegalArgument();
          }
          let start;
          if (!startOrChange) {
            start = this.start;
          } else if (Position.isPosition(startOrChange)) {
            start = startOrChange;
          } else {
            start = startOrChange.start || this.start;
            end = startOrChange.end || this.end;
          }
          if (start.isEqual(this._start) && end.isEqual(this.end)) {
            return this;
          }
          return new Range_1(start, end);
        }
        toJSON() {
          return [this.start, this.end];
        }
      };
      Range = Range_1 = __decorate([
        es5ClassCompat
      ], Range);
      Selection = Selection_1 = class Selection2 extends Range {
        static isSelection(thing) {
          if (thing instanceof Selection_1) {
            return true;
          }
          if (!thing) {
            return false;
          }
          return Range.isRange(thing) && Position.isPosition(thing.anchor) && Position.isPosition(thing.active) && typeof thing.isReversed === "boolean";
        }
        get anchor() {
          return this._anchor;
        }
        get active() {
          return this._active;
        }
        constructor(anchorLineOrAnchor, anchorColumnOrActive, activeLine, activeColumn) {
          let anchor;
          let active;
          if (typeof anchorLineOrAnchor === "number" && typeof anchorColumnOrActive === "number" && typeof activeLine === "number" && typeof activeColumn === "number") {
            anchor = new Position(anchorLineOrAnchor, anchorColumnOrActive);
            active = new Position(activeLine, activeColumn);
          } else if (Position.isPosition(anchorLineOrAnchor) && Position.isPosition(anchorColumnOrActive)) {
            anchor = Position.of(anchorLineOrAnchor);
            active = Position.of(anchorColumnOrActive);
          }
          if (!anchor || !active) {
            throw new Error("Invalid arguments");
          }
          super(anchor, active);
          this._anchor = anchor;
          this._active = active;
        }
        get isReversed() {
          return this._anchor === this._end;
        }
        toJSON() {
          return {
            start: this.start,
            end: this.end,
            active: this.active,
            anchor: this.anchor
          };
        }
      };
      Selection = Selection_1 = __decorate([
        es5ClassCompat
      ], Selection);
      (function(EndOfLine3) {
        EndOfLine3[EndOfLine3["LF"] = 1] = "LF";
        EndOfLine3[EndOfLine3["CRLF"] = 2] = "CRLF";
      })(EndOfLine || (EndOfLine = {}));
      (function(EnvironmentVariableMutatorType3) {
        EnvironmentVariableMutatorType3[EnvironmentVariableMutatorType3["Replace"] = 1] = "Replace";
        EnvironmentVariableMutatorType3[EnvironmentVariableMutatorType3["Append"] = 2] = "Append";
        EnvironmentVariableMutatorType3[EnvironmentVariableMutatorType3["Prepend"] = 3] = "Prepend";
      })(EnvironmentVariableMutatorType || (EnvironmentVariableMutatorType = {}));
      TextEdit = TextEdit_1 = class TextEdit2 {
        static isTextEdit(thing) {
          if (thing instanceof TextEdit_1) {
            return true;
          }
          if (!thing) {
            return false;
          }
          return Range.isRange(thing) && typeof thing.newText === "string";
        }
        static replace(range, newText) {
          return new TextEdit_1(range, newText);
        }
        static insert(position, newText) {
          return TextEdit_1.replace(new Range(position, position), newText);
        }
        static delete(range) {
          return TextEdit_1.replace(range, "");
        }
        static setEndOfLine(eol) {
          const ret = new TextEdit_1(new Range(new Position(0, 0), new Position(0, 0)), "");
          ret.newEol = eol;
          return ret;
        }
        get range() {
          return this._range;
        }
        set range(value) {
          if (value && !Range.isRange(value)) {
            throw illegalArgument("range");
          }
          this._range = value;
        }
        get newText() {
          return this._newText || "";
        }
        set newText(value) {
          if (value && typeof value !== "string") {
            throw illegalArgument("newText");
          }
          this._newText = value;
        }
        get newEol() {
          return this._newEol;
        }
        set newEol(value) {
          if (value && typeof value !== "number") {
            throw illegalArgument("newEol");
          }
          this._newEol = value;
        }
        constructor(range, newText) {
          this._range = range;
          this._newText = newText;
        }
        toJSON() {
          return {
            range: this.range,
            newText: this.newText,
            newEol: this._newEol
          };
        }
      };
      TextEdit = TextEdit_1 = __decorate([
        es5ClassCompat
      ], TextEdit);
      NotebookEdit = NotebookEdit_1 = class NotebookEdit2 {
        static isNotebookCellEdit(thing) {
          if (thing instanceof NotebookEdit_1) {
            return true;
          }
          if (!thing) {
            return false;
          }
          return NotebookRange.isNotebookRange(thing) && Array.isArray(thing.newCells);
        }
        static replaceCells(range, newCells) {
          return new NotebookEdit_1(range, newCells);
        }
        static insertCells(index, newCells) {
          return new NotebookEdit_1(new NotebookRange(index, index), newCells);
        }
        static deleteCells(range) {
          return new NotebookEdit_1(range, []);
        }
        static updateCellMetadata(index, newMetadata) {
          const edit = new NotebookEdit_1(new NotebookRange(index, index), []);
          edit.newCellMetadata = newMetadata;
          return edit;
        }
        static updateNotebookMetadata(newMetadata) {
          const edit = new NotebookEdit_1(new NotebookRange(0, 0), []);
          edit.newNotebookMetadata = newMetadata;
          return edit;
        }
        constructor(range, newCells) {
          this.range = range;
          this.newCells = newCells;
        }
      };
      NotebookEdit = NotebookEdit_1 = __decorate([
        es5ClassCompat
      ], NotebookEdit);
      SnippetTextEdit = class {
        static isSnippetTextEdit(thing) {
          if (thing instanceof SnippetTextEdit) {
            return true;
          }
          if (!thing) {
            return false;
          }
          return Range.isRange(thing.range) && SnippetString.isSnippetString(thing.snippet);
        }
        static replace(range, snippet) {
          return new SnippetTextEdit(range, snippet);
        }
        static insert(position, snippet) {
          return SnippetTextEdit.replace(new Range(position, position), snippet);
        }
        constructor(range, snippet) {
          this.range = range;
          this.snippet = snippet;
        }
      };
      WorkspaceEdit = class WorkspaceEdit2 {
        constructor() {
          this._edits = [];
        }
        _allEntries() {
          return this._edits;
        }
        renameFile(from, to, options, metadata) {
          this._edits.push({ _type: 1, from, to, options, metadata });
        }
        createFile(uri, options, metadata) {
          this._edits.push({ _type: 1, from: void 0, to: uri, options, metadata });
        }
        deleteFile(uri, options, metadata) {
          this._edits.push({ _type: 1, from: uri, to: void 0, options, metadata });
        }
        replaceNotebookMetadata(uri, value, metadata) {
          this._edits.push({ _type: 3, metadata, uri, edit: { editType: 5, metadata: value }, notebookMetadata: value });
        }
        replaceNotebookCells(uri, startOrRange, cellData, metadata) {
          const start = startOrRange.start;
          const end = startOrRange.end;
          if (start !== end || cellData.length > 0) {
            this._edits.push({ _type: 5, uri, index: start, count: end - start, cells: cellData, metadata });
          }
        }
        replaceNotebookCellMetadata(uri, index, cellMetadata, metadata) {
          this._edits.push({ _type: 3, metadata, uri, edit: { editType: 3, index, metadata: cellMetadata } });
        }
        replace(uri, range, newText, metadata) {
          this._edits.push({ _type: 2, uri, edit: new TextEdit(range, newText), metadata });
        }
        insert(resource, position, newText, metadata) {
          this.replace(resource, new Range(position, position), newText, metadata);
        }
        delete(resource, range, metadata) {
          this.replace(resource, range, "", metadata);
        }
        has(uri) {
          return this._edits.some((edit) => edit._type === 2 && edit.uri.toString() === uri.toString());
        }
        set(uri, edits) {
          if (!edits) {
            for (let i = 0; i < this._edits.length; i++) {
              const element = this._edits[i];
              switch (element._type) {
                case 2:
                case 6:
                case 3:
                case 5:
                  if (element.uri.toString() === uri.toString()) {
                    this._edits[i] = void 0;
                  }
                  break;
              }
            }
            coalesceInPlace(this._edits);
          } else {
            for (const editOrTuple of edits) {
              if (!editOrTuple) {
                continue;
              }
              let edit;
              let metadata;
              if (Array.isArray(editOrTuple)) {
                edit = editOrTuple[0];
                metadata = editOrTuple[1];
              } else {
                edit = editOrTuple;
              }
              if (NotebookEdit.isNotebookCellEdit(edit)) {
                if (edit.newCellMetadata) {
                  this.replaceNotebookCellMetadata(uri, edit.range.start, edit.newCellMetadata, metadata);
                } else if (edit.newNotebookMetadata) {
                  this.replaceNotebookMetadata(uri, edit.newNotebookMetadata, metadata);
                } else {
                  this.replaceNotebookCells(uri, edit.range, edit.newCells, metadata);
                }
              } else if (SnippetTextEdit.isSnippetTextEdit(edit)) {
                this._edits.push({ _type: 6, uri, range: edit.range, edit: edit.snippet, metadata });
              } else {
                this._edits.push({ _type: 2, uri, edit, metadata });
              }
            }
          }
        }
        get(uri) {
          const res = [];
          for (const candidate of this._edits) {
            if (candidate._type === 2 && candidate.uri.toString() === uri.toString()) {
              res.push(candidate.edit);
            }
          }
          return res;
        }
        entries() {
          const textEdits = new ResourceMap();
          for (const candidate of this._edits) {
            if (candidate._type === 2) {
              let textEdit = textEdits.get(candidate.uri);
              if (!textEdit) {
                textEdit = [candidate.uri, []];
                textEdits.set(candidate.uri, textEdit);
              }
              textEdit[1].push(candidate.edit);
            }
          }
          return [...textEdits.values()];
        }
        get size() {
          return this.entries().length;
        }
        toJSON() {
          return this.entries();
        }
      };
      WorkspaceEdit = __decorate([
        es5ClassCompat
      ], WorkspaceEdit);
      SnippetString = SnippetString_1 = class SnippetString2 {
        static isSnippetString(thing) {
          if (thing instanceof SnippetString_1) {
            return true;
          }
          if (!thing) {
            return false;
          }
          return typeof thing.value === "string";
        }
        static _escape(value) {
          return value.replace(/\$|}|\\/g, "\\$&");
        }
        constructor(value) {
          this._tabstop = 1;
          this.value = value || "";
        }
        appendText(string) {
          this.value += SnippetString_1._escape(string);
          return this;
        }
        appendTabstop(number = this._tabstop++) {
          this.value += "$";
          this.value += number;
          return this;
        }
        appendPlaceholder(value, number = this._tabstop++) {
          if (typeof value === "function") {
            const nested = new SnippetString_1();
            nested._tabstop = this._tabstop;
            value(nested);
            this._tabstop = nested._tabstop;
            value = nested.value;
          } else {
            value = SnippetString_1._escape(value);
          }
          this.value += "${";
          this.value += number;
          this.value += ":";
          this.value += value;
          this.value += "}";
          return this;
        }
        appendChoice(values, number = this._tabstop++) {
          const value = values.map((s) => s.replace(/\$|}|\\|,/g, "\\$&")).join(",");
          this.value += "${";
          this.value += number;
          this.value += "|";
          this.value += value;
          this.value += "|}";
          return this;
        }
        appendVariable(name, defaultValue) {
          if (typeof defaultValue === "function") {
            const nested = new SnippetString_1();
            nested._tabstop = this._tabstop;
            defaultValue(nested);
            this._tabstop = nested._tabstop;
            defaultValue = nested.value;
          } else if (typeof defaultValue === "string") {
            defaultValue = defaultValue.replace(/\$|}/g, "\\$&");
          }
          this.value += "${";
          this.value += name;
          if (defaultValue) {
            this.value += ":";
            this.value += defaultValue;
          }
          this.value += "}";
          return this;
        }
      };
      SnippetString = SnippetString_1 = __decorate([
        es5ClassCompat
      ], SnippetString);
      (function(DiagnosticTag3) {
        DiagnosticTag3[DiagnosticTag3["Unnecessary"] = 1] = "Unnecessary";
        DiagnosticTag3[DiagnosticTag3["Deprecated"] = 2] = "Deprecated";
      })(DiagnosticTag || (DiagnosticTag = {}));
      (function(DiagnosticSeverity3) {
        DiagnosticSeverity3[DiagnosticSeverity3["Hint"] = 3] = "Hint";
        DiagnosticSeverity3[DiagnosticSeverity3["Information"] = 2] = "Information";
        DiagnosticSeverity3[DiagnosticSeverity3["Warning"] = 1] = "Warning";
        DiagnosticSeverity3[DiagnosticSeverity3["Error"] = 0] = "Error";
      })(DiagnosticSeverity || (DiagnosticSeverity = {}));
      Location = Location_1 = class Location2 {
        static isLocation(thing) {
          if (thing instanceof Location_1) {
            return true;
          }
          if (!thing) {
            return false;
          }
          return Range.isRange(thing.range) && URI.isUri(thing.uri);
        }
        constructor(uri, rangeOrPosition) {
          this.uri = uri;
          if (!rangeOrPosition)
            ;
          else if (Range.isRange(rangeOrPosition)) {
            this.range = Range.of(rangeOrPosition);
          } else if (Position.isPosition(rangeOrPosition)) {
            this.range = new Range(rangeOrPosition, rangeOrPosition);
          } else {
            throw new Error("Illegal argument");
          }
        }
        toJSON() {
          return {
            uri: this.uri,
            range: this.range
          };
        }
      };
      Location = Location_1 = __decorate([
        es5ClassCompat
      ], Location);
      DiagnosticRelatedInformation = class DiagnosticRelatedInformation2 {
        static is(thing) {
          if (!thing) {
            return false;
          }
          return typeof thing.message === "string" && thing.location && Range.isRange(thing.location.range) && URI.isUri(thing.location.uri);
        }
        constructor(location, message) {
          this.location = location;
          this.message = message;
        }
        static isEqual(a, b) {
          if (a === b) {
            return true;
          }
          if (!a || !b) {
            return false;
          }
          return a.message === b.message && a.location.range.isEqual(b.location.range) && a.location.uri.toString() === b.location.uri.toString();
        }
      };
      DiagnosticRelatedInformation = __decorate([
        es5ClassCompat
      ], DiagnosticRelatedInformation);
      Diagnostic = class Diagnostic2 {
        constructor(range, message, severity = DiagnosticSeverity.Error) {
          if (!Range.isRange(range)) {
            throw new TypeError("range must be set");
          }
          if (!message) {
            throw new TypeError("message must be set");
          }
          this.range = range;
          this.message = message;
          this.severity = severity;
        }
        toJSON() {
          return {
            severity: DiagnosticSeverity[this.severity],
            message: this.message,
            range: this.range,
            source: this.source,
            code: this.code
          };
        }
        static isEqual(a, b) {
          if (a === b) {
            return true;
          }
          if (!a || !b) {
            return false;
          }
          return a.message === b.message && a.severity === b.severity && a.code === b.code && a.severity === b.severity && a.source === b.source && a.range.isEqual(b.range) && equals(a.tags, b.tags) && equals(a.relatedInformation, b.relatedInformation, DiagnosticRelatedInformation.isEqual);
        }
      };
      Diagnostic = __decorate([
        es5ClassCompat
      ], Diagnostic);
      Hover = class Hover2 {
        constructor(contents, range) {
          if (!contents) {
            throw new Error("Illegal argument, contents must be defined");
          }
          if (Array.isArray(contents)) {
            this.contents = contents;
          } else {
            this.contents = [contents];
          }
          this.range = range;
        }
      };
      Hover = __decorate([
        es5ClassCompat
      ], Hover);
      (function(DocumentHighlightKind3) {
        DocumentHighlightKind3[DocumentHighlightKind3["Text"] = 0] = "Text";
        DocumentHighlightKind3[DocumentHighlightKind3["Read"] = 1] = "Read";
        DocumentHighlightKind3[DocumentHighlightKind3["Write"] = 2] = "Write";
      })(DocumentHighlightKind || (DocumentHighlightKind = {}));
      DocumentHighlight = class DocumentHighlight2 {
        constructor(range, kind = DocumentHighlightKind.Text) {
          this.range = range;
          this.kind = kind;
        }
        toJSON() {
          return {
            range: this.range,
            kind: DocumentHighlightKind[this.kind]
          };
        }
      };
      DocumentHighlight = __decorate([
        es5ClassCompat
      ], DocumentHighlight);
      (function(SymbolKind3) {
        SymbolKind3[SymbolKind3["File"] = 0] = "File";
        SymbolKind3[SymbolKind3["Module"] = 1] = "Module";
        SymbolKind3[SymbolKind3["Namespace"] = 2] = "Namespace";
        SymbolKind3[SymbolKind3["Package"] = 3] = "Package";
        SymbolKind3[SymbolKind3["Class"] = 4] = "Class";
        SymbolKind3[SymbolKind3["Method"] = 5] = "Method";
        SymbolKind3[SymbolKind3["Property"] = 6] = "Property";
        SymbolKind3[SymbolKind3["Field"] = 7] = "Field";
        SymbolKind3[SymbolKind3["Constructor"] = 8] = "Constructor";
        SymbolKind3[SymbolKind3["Enum"] = 9] = "Enum";
        SymbolKind3[SymbolKind3["Interface"] = 10] = "Interface";
        SymbolKind3[SymbolKind3["Function"] = 11] = "Function";
        SymbolKind3[SymbolKind3["Variable"] = 12] = "Variable";
        SymbolKind3[SymbolKind3["Constant"] = 13] = "Constant";
        SymbolKind3[SymbolKind3["String"] = 14] = "String";
        SymbolKind3[SymbolKind3["Number"] = 15] = "Number";
        SymbolKind3[SymbolKind3["Boolean"] = 16] = "Boolean";
        SymbolKind3[SymbolKind3["Array"] = 17] = "Array";
        SymbolKind3[SymbolKind3["Object"] = 18] = "Object";
        SymbolKind3[SymbolKind3["Key"] = 19] = "Key";
        SymbolKind3[SymbolKind3["Null"] = 20] = "Null";
        SymbolKind3[SymbolKind3["EnumMember"] = 21] = "EnumMember";
        SymbolKind3[SymbolKind3["Struct"] = 22] = "Struct";
        SymbolKind3[SymbolKind3["Event"] = 23] = "Event";
        SymbolKind3[SymbolKind3["Operator"] = 24] = "Operator";
        SymbolKind3[SymbolKind3["TypeParameter"] = 25] = "TypeParameter";
      })(SymbolKind || (SymbolKind = {}));
      (function(SymbolTag3) {
        SymbolTag3[SymbolTag3["Deprecated"] = 1] = "Deprecated";
      })(SymbolTag || (SymbolTag = {}));
      SymbolInformation = SymbolInformation_1 = class SymbolInformation2 {
        static validate(candidate) {
          if (!candidate.name) {
            throw new Error("name must not be falsy");
          }
        }
        constructor(name, kind, rangeOrContainer, locationOrUri, containerName) {
          this.name = name;
          this.kind = kind;
          this.containerName = containerName;
          if (typeof rangeOrContainer === "string") {
            this.containerName = rangeOrContainer;
          }
          if (locationOrUri instanceof Location) {
            this.location = locationOrUri;
          } else if (rangeOrContainer instanceof Range) {
            this.location = new Location(locationOrUri, rangeOrContainer);
          }
          SymbolInformation_1.validate(this);
        }
        toJSON() {
          return {
            name: this.name,
            kind: SymbolKind[this.kind],
            location: this.location,
            containerName: this.containerName
          };
        }
      };
      SymbolInformation = SymbolInformation_1 = __decorate([
        es5ClassCompat
      ], SymbolInformation);
      DocumentSymbol = DocumentSymbol_1 = class DocumentSymbol2 {
        static validate(candidate) {
          if (!candidate.name) {
            throw new Error("name must not be falsy");
          }
          if (!candidate.range.contains(candidate.selectionRange)) {
            throw new Error("selectionRange must be contained in fullRange");
          }
          candidate.children?.forEach(DocumentSymbol_1.validate);
        }
        constructor(name, detail, kind, range, selectionRange) {
          this.name = name;
          this.detail = detail;
          this.kind = kind;
          this.range = range;
          this.selectionRange = selectionRange;
          this.children = [];
          DocumentSymbol_1.validate(this);
        }
      };
      DocumentSymbol = DocumentSymbol_1 = __decorate([
        es5ClassCompat
      ], DocumentSymbol);
      (function(CodeActionTriggerKind3) {
        CodeActionTriggerKind3[CodeActionTriggerKind3["Invoke"] = 1] = "Invoke";
        CodeActionTriggerKind3[CodeActionTriggerKind3["Automatic"] = 2] = "Automatic";
      })(CodeActionTriggerKind || (CodeActionTriggerKind = {}));
      CodeAction = class CodeAction2 {
        constructor(title, kind) {
          this.title = title;
          this.kind = kind;
        }
      };
      CodeAction = __decorate([
        es5ClassCompat
      ], CodeAction);
      CodeActionKind = class CodeActionKind2 {
        static {
          CodeActionKind_1 = this;
        }
        static {
          this.sep = ".";
        }
        constructor(value) {
          this.value = value;
        }
        append(parts) {
          return new CodeActionKind_1(this.value ? this.value + CodeActionKind_1.sep + parts : parts);
        }
        intersects(other) {
          return this.contains(other) || other.contains(this);
        }
        contains(other) {
          return this.value === other.value || other.value.startsWith(this.value + CodeActionKind_1.sep);
        }
      };
      CodeActionKind = CodeActionKind_1 = __decorate([
        es5ClassCompat
      ], CodeActionKind);
      CodeActionKind.Empty = new CodeActionKind("");
      CodeActionKind.QuickFix = CodeActionKind.Empty.append("quickfix");
      CodeActionKind.Refactor = CodeActionKind.Empty.append("refactor");
      CodeActionKind.RefactorExtract = CodeActionKind.Refactor.append("extract");
      CodeActionKind.RefactorInline = CodeActionKind.Refactor.append("inline");
      CodeActionKind.RefactorMove = CodeActionKind.Refactor.append("move");
      CodeActionKind.RefactorRewrite = CodeActionKind.Refactor.append("rewrite");
      CodeActionKind.Source = CodeActionKind.Empty.append("source");
      CodeActionKind.SourceOrganizeImports = CodeActionKind.Source.append("organizeImports");
      CodeActionKind.SourceFixAll = CodeActionKind.Source.append("fixAll");
      CodeActionKind.Notebook = CodeActionKind.Empty.append("notebook");
      SelectionRange = class SelectionRange2 {
        constructor(range, parent) {
          this.range = range;
          this.parent = parent;
          if (parent && !parent.range.contains(this.range)) {
            throw new Error("Invalid argument: parent must contain this range");
          }
        }
      };
      SelectionRange = __decorate([
        es5ClassCompat
      ], SelectionRange);
      CallHierarchyItem = class {
        constructor(kind, name, detail, uri, range, selectionRange) {
          this.kind = kind;
          this.name = name;
          this.detail = detail;
          this.uri = uri;
          this.range = range;
          this.selectionRange = selectionRange;
        }
      };
      CallHierarchyIncomingCall = class {
        constructor(item, fromRanges) {
          this.fromRanges = fromRanges;
          this.from = item;
        }
      };
      CallHierarchyOutgoingCall = class {
        constructor(item, fromRanges) {
          this.fromRanges = fromRanges;
          this.to = item;
        }
      };
      (function(LanguageStatusSeverity3) {
        LanguageStatusSeverity3[LanguageStatusSeverity3["Information"] = 0] = "Information";
        LanguageStatusSeverity3[LanguageStatusSeverity3["Warning"] = 1] = "Warning";
        LanguageStatusSeverity3[LanguageStatusSeverity3["Error"] = 2] = "Error";
      })(LanguageStatusSeverity || (LanguageStatusSeverity = {}));
      CodeLens = class CodeLens2 {
        constructor(range, command) {
          this.range = range;
          this.command = command;
        }
        get isResolved() {
          return !!this.command;
        }
      };
      CodeLens = __decorate([
        es5ClassCompat
      ], CodeLens);
      MarkdownString2 = MarkdownString_1 = class MarkdownString3 {
        #delegate;
        static isMarkdownString(thing) {
          if (thing instanceof MarkdownString_1) {
            return true;
          }
          return thing && thing.appendCodeblock && thing.appendMarkdown && thing.appendText && thing.value !== void 0;
        }
        constructor(value, supportThemeIcons = false) {
          this.#delegate = new MarkdownString(value, { supportThemeIcons });
        }
        get value() {
          return this.#delegate.value;
        }
        set value(value) {
          this.#delegate.value = value;
        }
        get isTrusted() {
          return this.#delegate.isTrusted;
        }
        set isTrusted(value) {
          this.#delegate.isTrusted = value;
        }
        get supportThemeIcons() {
          return this.#delegate.supportThemeIcons;
        }
        set supportThemeIcons(value) {
          this.#delegate.supportThemeIcons = value;
        }
        get supportHtml() {
          return this.#delegate.supportHtml;
        }
        set supportHtml(value) {
          this.#delegate.supportHtml = value;
        }
        get baseUri() {
          return this.#delegate.baseUri;
        }
        set baseUri(value) {
          this.#delegate.baseUri = value;
        }
        appendText(value) {
          this.#delegate.appendText(value);
          return this;
        }
        appendMarkdown(value) {
          this.#delegate.appendMarkdown(value);
          return this;
        }
        appendCodeblock(value, language2) {
          this.#delegate.appendCodeblock(language2 ?? "", value);
          return this;
        }
      };
      MarkdownString2 = MarkdownString_1 = __decorate([
        es5ClassCompat
      ], MarkdownString2);
      ParameterInformation = class ParameterInformation2 {
        constructor(label, documentation) {
          this.label = label;
          this.documentation = documentation;
        }
      };
      ParameterInformation = __decorate([
        es5ClassCompat
      ], ParameterInformation);
      SignatureInformation = class SignatureInformation2 {
        constructor(label, documentation) {
          this.label = label;
          this.documentation = documentation;
          this.parameters = [];
        }
      };
      SignatureInformation = __decorate([
        es5ClassCompat
      ], SignatureInformation);
      SignatureHelp = class SignatureHelp2 {
        constructor() {
          this.activeSignature = 0;
          this.activeParameter = 0;
          this.signatures = [];
        }
      };
      SignatureHelp = __decorate([
        es5ClassCompat
      ], SignatureHelp);
      (function(SignatureHelpTriggerKind3) {
        SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["Invoke"] = 1] = "Invoke";
        SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["TriggerCharacter"] = 2] = "TriggerCharacter";
        SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["ContentChange"] = 3] = "ContentChange";
      })(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {}));
      (function(InlayHintKind3) {
        InlayHintKind3[InlayHintKind3["Type"] = 1] = "Type";
        InlayHintKind3[InlayHintKind3["Parameter"] = 2] = "Parameter";
      })(InlayHintKind || (InlayHintKind = {}));
      InlayHintLabelPart = class InlayHintLabelPart2 {
        constructor(value) {
          this.value = value;
        }
      };
      InlayHintLabelPart = __decorate([
        es5ClassCompat
      ], InlayHintLabelPart);
      InlayHint = class InlayHint2 {
        constructor(position, label, kind) {
          this.position = position;
          this.label = label;
          this.kind = kind;
        }
      };
      InlayHint = __decorate([
        es5ClassCompat
      ], InlayHint);
      (function(CompletionTriggerKind3) {
        CompletionTriggerKind3[CompletionTriggerKind3["Invoke"] = 0] = "Invoke";
        CompletionTriggerKind3[CompletionTriggerKind3["TriggerCharacter"] = 1] = "TriggerCharacter";
        CompletionTriggerKind3[CompletionTriggerKind3["TriggerForIncompleteCompletions"] = 2] = "TriggerForIncompleteCompletions";
      })(CompletionTriggerKind || (CompletionTriggerKind = {}));
      (function(CompletionItemKind3) {
        CompletionItemKind3[CompletionItemKind3["Text"] = 0] = "Text";
        CompletionItemKind3[CompletionItemKind3["Method"] = 1] = "Method";
        CompletionItemKind3[CompletionItemKind3["Function"] = 2] = "Function";
        CompletionItemKind3[CompletionItemKind3["Constructor"] = 3] = "Constructor";
        CompletionItemKind3[CompletionItemKind3["Field"] = 4] = "Field";
        CompletionItemKind3[CompletionItemKind3["Variable"] = 5] = "Variable";
        CompletionItemKind3[CompletionItemKind3["Class"] = 6] = "Class";
        CompletionItemKind3[CompletionItemKind3["Interface"] = 7] = "Interface";
        CompletionItemKind3[CompletionItemKind3["Module"] = 8] = "Module";
        CompletionItemKind3[CompletionItemKind3["Property"] = 9] = "Property";
        CompletionItemKind3[CompletionItemKind3["Unit"] = 10] = "Unit";
        CompletionItemKind3[CompletionItemKind3["Value"] = 11] = "Value";
        CompletionItemKind3[CompletionItemKind3["Enum"] = 12] = "Enum";
        CompletionItemKind3[CompletionItemKind3["Keyword"] = 13] = "Keyword";
        CompletionItemKind3[CompletionItemKind3["Snippet"] = 14] = "Snippet";
        CompletionItemKind3[CompletionItemKind3["Color"] = 15] = "Color";
        CompletionItemKind3[CompletionItemKind3["File"] = 16] = "File";
        CompletionItemKind3[CompletionItemKind3["Reference"] = 17] = "Reference";
        CompletionItemKind3[CompletionItemKind3["Folder"] = 18] = "Folder";
        CompletionItemKind3[CompletionItemKind3["EnumMember"] = 19] = "EnumMember";
        CompletionItemKind3[CompletionItemKind3["Constant"] = 20] = "Constant";
        CompletionItemKind3[CompletionItemKind3["Struct"] = 21] = "Struct";
        CompletionItemKind3[CompletionItemKind3["Event"] = 22] = "Event";
        CompletionItemKind3[CompletionItemKind3["Operator"] = 23] = "Operator";
        CompletionItemKind3[CompletionItemKind3["TypeParameter"] = 24] = "TypeParameter";
        CompletionItemKind3[CompletionItemKind3["User"] = 25] = "User";
        CompletionItemKind3[CompletionItemKind3["Issue"] = 26] = "Issue";
      })(CompletionItemKind || (CompletionItemKind = {}));
      (function(CompletionItemTag3) {
        CompletionItemTag3[CompletionItemTag3["Deprecated"] = 1] = "Deprecated";
      })(CompletionItemTag || (CompletionItemTag = {}));
      CompletionItem = class CompletionItem2 {
        constructor(label, kind) {
          this.label = label;
          this.kind = kind;
        }
        toJSON() {
          return {
            label: this.label,
            kind: this.kind && CompletionItemKind[this.kind],
            detail: this.detail,
            documentation: this.documentation,
            sortText: this.sortText,
            filterText: this.filterText,
            preselect: this.preselect,
            insertText: this.insertText,
            textEdit: this.textEdit
          };
        }
      };
      CompletionItem = __decorate([
        es5ClassCompat
      ], CompletionItem);
      CompletionList = class CompletionList2 {
        constructor(items = [], isIncomplete = false) {
          this.items = items;
          this.isIncomplete = isIncomplete;
        }
      };
      CompletionList = __decorate([
        es5ClassCompat
      ], CompletionList);
      InlineSuggestion = class InlineSuggestion2 {
        constructor(insertText, range, command) {
          this.insertText = insertText;
          this.range = range;
          this.command = command;
        }
      };
      InlineSuggestion = __decorate([
        es5ClassCompat
      ], InlineSuggestion);
      InlineSuggestionList = class InlineSuggestionList2 {
        constructor(items) {
          this.commands = void 0;
          this.suppressSuggestions = void 0;
          this.items = items;
        }
      };
      InlineSuggestionList = __decorate([
        es5ClassCompat
      ], InlineSuggestionList);
      (function(ViewColumn3) {
        ViewColumn3[ViewColumn3["Active"] = -1] = "Active";
        ViewColumn3[ViewColumn3["Beside"] = -2] = "Beside";
        ViewColumn3[ViewColumn3["One"] = 1] = "One";
        ViewColumn3[ViewColumn3["Two"] = 2] = "Two";
        ViewColumn3[ViewColumn3["Three"] = 3] = "Three";
        ViewColumn3[ViewColumn3["Four"] = 4] = "Four";
        ViewColumn3[ViewColumn3["Five"] = 5] = "Five";
        ViewColumn3[ViewColumn3["Six"] = 6] = "Six";
        ViewColumn3[ViewColumn3["Seven"] = 7] = "Seven";
        ViewColumn3[ViewColumn3["Eight"] = 8] = "Eight";
        ViewColumn3[ViewColumn3["Nine"] = 9] = "Nine";
      })(ViewColumn || (ViewColumn = {}));
      (function(StatusBarAlignment3) {
        StatusBarAlignment3[StatusBarAlignment3["Left"] = 1] = "Left";
        StatusBarAlignment3[StatusBarAlignment3["Right"] = 2] = "Right";
      })(StatusBarAlignment || (StatusBarAlignment = {}));
      (function(TextEditorLineNumbersStyle3) {
        TextEditorLineNumbersStyle3[TextEditorLineNumbersStyle3["Off"] = 0] = "Off";
        TextEditorLineNumbersStyle3[TextEditorLineNumbersStyle3["On"] = 1] = "On";
        TextEditorLineNumbersStyle3[TextEditorLineNumbersStyle3["Relative"] = 2] = "Relative";
      })(TextEditorLineNumbersStyle || (TextEditorLineNumbersStyle = {}));
      (function(TextDocumentSaveReason3) {
        TextDocumentSaveReason3[TextDocumentSaveReason3["Manual"] = 1] = "Manual";
        TextDocumentSaveReason3[TextDocumentSaveReason3["AfterDelay"] = 2] = "AfterDelay";
        TextDocumentSaveReason3[TextDocumentSaveReason3["FocusOut"] = 3] = "FocusOut";
      })(TextDocumentSaveReason || (TextDocumentSaveReason = {}));
      (function(TextEditorRevealType3) {
        TextEditorRevealType3[TextEditorRevealType3["Default"] = 0] = "Default";
        TextEditorRevealType3[TextEditorRevealType3["InCenter"] = 1] = "InCenter";
        TextEditorRevealType3[TextEditorRevealType3["InCenterIfOutsideViewport"] = 2] = "InCenterIfOutsideViewport";
        TextEditorRevealType3[TextEditorRevealType3["AtTop"] = 3] = "AtTop";
      })(TextEditorRevealType || (TextEditorRevealType = {}));
      (function(TextEditorSelectionChangeKind3) {
        TextEditorSelectionChangeKind3[TextEditorSelectionChangeKind3["Keyboard"] = 1] = "Keyboard";
        TextEditorSelectionChangeKind3[TextEditorSelectionChangeKind3["Mouse"] = 2] = "Mouse";
        TextEditorSelectionChangeKind3[TextEditorSelectionChangeKind3["Command"] = 3] = "Command";
      })(TextEditorSelectionChangeKind || (TextEditorSelectionChangeKind = {}));
      (function(TextDocumentChangeReason3) {
        TextDocumentChangeReason3[TextDocumentChangeReason3["Undo"] = 1] = "Undo";
        TextDocumentChangeReason3[TextDocumentChangeReason3["Redo"] = 2] = "Redo";
      })(TextDocumentChangeReason || (TextDocumentChangeReason = {}));
      (function(DecorationRangeBehavior3) {
        DecorationRangeBehavior3[DecorationRangeBehavior3["OpenOpen"] = 0] = "OpenOpen";
        DecorationRangeBehavior3[DecorationRangeBehavior3["ClosedClosed"] = 1] = "ClosedClosed";
        DecorationRangeBehavior3[DecorationRangeBehavior3["OpenClosed"] = 2] = "OpenClosed";
        DecorationRangeBehavior3[DecorationRangeBehavior3["ClosedOpen"] = 3] = "ClosedOpen";
      })(DecorationRangeBehavior || (DecorationRangeBehavior = {}));
      (function(TextEditorSelectionChangeKind3) {
        function fromValue(s) {
          switch (s) {
            case "keyboard":
              return TextEditorSelectionChangeKind3.Keyboard;
            case "mouse":
              return TextEditorSelectionChangeKind3.Mouse;
            case "api":
              return TextEditorSelectionChangeKind3.Command;
          }
          return void 0;
        }
        TextEditorSelectionChangeKind3.fromValue = fromValue;
      })(TextEditorSelectionChangeKind || (TextEditorSelectionChangeKind = {}));
      DocumentLink = class DocumentLink2 {
        constructor(range, target) {
          if (target && !URI.isUri(target)) {
            throw illegalArgument("target");
          }
          if (!Range.isRange(range) || range.isEmpty) {
            throw illegalArgument("range");
          }
          this.range = range;
          this.target = target;
        }
      };
      DocumentLink = __decorate([
        es5ClassCompat
      ], DocumentLink);
      Color = class Color2 {
        constructor(red, green, blue, alpha) {
          this.red = red;
          this.green = green;
          this.blue = blue;
          this.alpha = alpha;
        }
      };
      Color = __decorate([
        es5ClassCompat
      ], Color);
      ColorInformation = class ColorInformation2 {
        constructor(range, color) {
          if (color && !(color instanceof Color)) {
            throw illegalArgument("color");
          }
          if (!Range.isRange(range) || range.isEmpty) {
            throw illegalArgument("range");
          }
          this.range = range;
          this.color = color;
        }
      };
      ColorInformation = __decorate([
        es5ClassCompat
      ], ColorInformation);
      ColorPresentation = class ColorPresentation2 {
        constructor(label) {
          if (!label || typeof label !== "string") {
            throw illegalArgument("label");
          }
          this.label = label;
        }
      };
      ColorPresentation = __decorate([
        es5ClassCompat
      ], ColorPresentation);
      (function(SourceControlInputBoxValidationType2) {
        SourceControlInputBoxValidationType2[SourceControlInputBoxValidationType2["Error"] = 0] = "Error";
        SourceControlInputBoxValidationType2[SourceControlInputBoxValidationType2["Warning"] = 1] = "Warning";
        SourceControlInputBoxValidationType2[SourceControlInputBoxValidationType2["Information"] = 2] = "Information";
      })(
        SourceControlInputBoxValidationType || (SourceControlInputBoxValidationType = {})
      );
      (function(TerminalExitReason3) {
        TerminalExitReason3[TerminalExitReason3["Unknown"] = 0] = "Unknown";
        TerminalExitReason3[TerminalExitReason3["Shutdown"] = 1] = "Shutdown";
        TerminalExitReason3[TerminalExitReason3["Process"] = 2] = "Process";
        TerminalExitReason3[TerminalExitReason3["User"] = 3] = "User";
        TerminalExitReason3[TerminalExitReason3["Extension"] = 4] = "Extension";
      })(TerminalExitReason || (TerminalExitReason = {}));
      TerminalLink = class {
        constructor(startIndex, length, tooltip) {
          this.startIndex = startIndex;
          this.length = length;
          this.tooltip = tooltip;
          if (typeof startIndex !== "number" || startIndex < 0) {
            throw illegalArgument("startIndex");
          }
          if (typeof length !== "number" || length < 1) {
            throw illegalArgument("length");
          }
          if (tooltip !== void 0 && typeof tooltip !== "string") {
            throw illegalArgument("tooltip");
          }
        }
      };
      (function(TerminalLocation3) {
        TerminalLocation3[TerminalLocation3["Panel"] = 1] = "Panel";
        TerminalLocation3[TerminalLocation3["Editor"] = 2] = "Editor";
      })(TerminalLocation || (TerminalLocation = {}));
      TerminalProfile = class {
        constructor(options) {
          this.options = options;
          if (typeof options !== "object") {
            throw illegalArgument("options");
          }
        }
      };
      (function(TaskRevealKind3) {
        TaskRevealKind3[TaskRevealKind3["Always"] = 1] = "Always";
        TaskRevealKind3[TaskRevealKind3["Silent"] = 2] = "Silent";
        TaskRevealKind3[TaskRevealKind3["Never"] = 3] = "Never";
      })(TaskRevealKind || (TaskRevealKind = {}));
      (function(TaskPanelKind3) {
        TaskPanelKind3[TaskPanelKind3["Shared"] = 1] = "Shared";
        TaskPanelKind3[TaskPanelKind3["Dedicated"] = 2] = "Dedicated";
        TaskPanelKind3[TaskPanelKind3["New"] = 3] = "New";
      })(TaskPanelKind || (TaskPanelKind = {}));
      TaskGroup = class TaskGroup2 {
        static {
          TaskGroup_1 = this;
        }
        static {
          this.Clean = new TaskGroup_1("clean", "Clean");
        }
        static {
          this.Build = new TaskGroup_1("build", "Build");
        }
        static {
          this.Rebuild = new TaskGroup_1("rebuild", "Rebuild");
        }
        static {
          this.Test = new TaskGroup_1("test", "Test");
        }
        static from(value) {
          switch (value) {
            case "clean":
              return TaskGroup_1.Clean;
            case "build":
              return TaskGroup_1.Build;
            case "rebuild":
              return TaskGroup_1.Rebuild;
            case "test":
              return TaskGroup_1.Test;
            default:
              return void 0;
          }
        }
        constructor(id2, label) {
          this.label = label;
          if (typeof id2 !== "string") {
            throw illegalArgument("name");
          }
          if (typeof label !== "string") {
            throw illegalArgument("name");
          }
          this._id = id2;
        }
        get id() {
          return this._id;
        }
      };
      TaskGroup = TaskGroup_1 = __decorate([
        es5ClassCompat
      ], TaskGroup);
      ProcessExecution = class ProcessExecution2 {
        constructor(process2, varg1, varg2) {
          if (typeof process2 !== "string") {
            throw illegalArgument("process");
          }
          this._args = [];
          this._process = process2;
          if (varg1 !== void 0) {
            if (Array.isArray(varg1)) {
              this._args = varg1;
              this._options = varg2;
            } else {
              this._options = varg1;
            }
          }
        }
        get process() {
          return this._process;
        }
        set process(value) {
          if (typeof value !== "string") {
            throw illegalArgument("process");
          }
          this._process = value;
        }
        get args() {
          return this._args;
        }
        set args(value) {
          if (!Array.isArray(value)) {
            value = [];
          }
          this._args = value;
        }
        get options() {
          return this._options;
        }
        set options(value) {
          this._options = value;
        }
        computeId() {
          const props = [];
          props.push("process");
          if (this._process !== void 0) {
            props.push(this._process);
          }
          if (this._args && this._args.length > 0) {
            for (const arg of this._args) {
              props.push(arg);
            }
          }
          return computeTaskExecutionId(props);
        }
      };
      ProcessExecution = __decorate([
        es5ClassCompat
      ], ProcessExecution);
      ShellExecution = class ShellExecution2 {
        constructor(arg0, arg1, arg2) {
          this._args = [];
          if (Array.isArray(arg1)) {
            if (!arg0) {
              throw illegalArgument("command can't be undefined or null");
            }
            if (typeof arg0 !== "string" && typeof arg0.value !== "string") {
              throw illegalArgument("command");
            }
            this._command = arg0;
            this._args = arg1;
            this._options = arg2;
          } else {
            if (typeof arg0 !== "string") {
              throw illegalArgument("commandLine");
            }
            this._commandLine = arg0;
            this._options = arg1;
          }
        }
        get commandLine() {
          return this._commandLine;
        }
        set commandLine(value) {
          if (typeof value !== "string") {
            throw illegalArgument("commandLine");
          }
          this._commandLine = value;
        }
        get command() {
          return this._command ? this._command : "";
        }
        set command(value) {
          if (typeof value !== "string" && typeof value.value !== "string") {
            throw illegalArgument("command");
          }
          this._command = value;
        }
        get args() {
          return this._args;
        }
        set args(value) {
          this._args = value || [];
        }
        get options() {
          return this._options;
        }
        set options(value) {
          this._options = value;
        }
        computeId() {
          const props = [];
          props.push("shell");
          if (this._commandLine !== void 0) {
            props.push(this._commandLine);
          }
          if (this._command !== void 0) {
            props.push(typeof this._command === "string" ? this._command : this._command.value);
          }
          if (this._args && this._args.length > 0) {
            for (const arg of this._args) {
              props.push(typeof arg === "string" ? arg : arg.value);
            }
          }
          return computeTaskExecutionId(props);
        }
      };
      ShellExecution = __decorate([
        es5ClassCompat
      ], ShellExecution);
      (function(ShellQuoting3) {
        ShellQuoting3[ShellQuoting3["Escape"] = 1] = "Escape";
        ShellQuoting3[ShellQuoting3["Strong"] = 2] = "Strong";
        ShellQuoting3[ShellQuoting3["Weak"] = 3] = "Weak";
      })(ShellQuoting || (ShellQuoting = {}));
      (function(TaskScope3) {
        TaskScope3[TaskScope3["Global"] = 1] = "Global";
        TaskScope3[TaskScope3["Workspace"] = 2] = "Workspace";
      })(TaskScope || (TaskScope = {}));
      CustomExecution = class {
        constructor(callback) {
          this._callback = callback;
        }
        computeId() {
          return "customExecution" + generateUuid();
        }
        set callback(value) {
          this._callback = value;
        }
        get callback() {
          return this._callback;
        }
      };
      Task = class Task2 {
        static {
          Task_1 = this;
        }
        static {
          this.ExtensionCallbackType = "customExecution";
        }
        static {
          this.ProcessType = "process";
        }
        static {
          this.ShellType = "shell";
        }
        static {
          this.EmptyType = "$empty";
        }
        constructor(definition, arg2, arg3, arg4, arg5, arg6) {
          this.__deprecated = false;
          this._definition = this.definition = definition;
          let problemMatchers;
          if (typeof arg2 === "string") {
            this._name = this.name = arg2;
            this._source = this.source = arg3;
            this.execution = arg4;
            problemMatchers = arg5;
            this.__deprecated = true;
          } else if (arg2 === TaskScope.Global || arg2 === TaskScope.Workspace) {
            this.target = arg2;
            this._name = this.name = arg3;
            this._source = this.source = arg4;
            this.execution = arg5;
            problemMatchers = arg6;
          } else {
            this.target = arg2;
            this._name = this.name = arg3;
            this._source = this.source = arg4;
            this.execution = arg5;
            problemMatchers = arg6;
          }
          if (typeof problemMatchers === "string") {
            this._problemMatchers = [problemMatchers];
            this._hasDefinedMatchers = true;
          } else if (Array.isArray(problemMatchers)) {
            this._problemMatchers = problemMatchers;
            this._hasDefinedMatchers = true;
          } else {
            this._problemMatchers = [];
            this._hasDefinedMatchers = false;
          }
          this._isBackground = false;
          this._presentationOptions = /* @__PURE__ */ Object.create(null);
          this._runOptions = /* @__PURE__ */ Object.create(null);
        }
        get _id() {
          return this.__id;
        }
        set _id(value) {
          this.__id = value;
        }
        get _deprecated() {
          return this.__deprecated;
        }
        clear() {
          if (this.__id === void 0) {
            return;
          }
          this.__id = void 0;
          this._scope = void 0;
          this.computeDefinitionBasedOnExecution();
        }
        computeDefinitionBasedOnExecution() {
          if (this._execution instanceof ProcessExecution) {
            this._definition = {
              type: Task_1.ProcessType,
              id: this._execution.computeId()
            };
          } else if (this._execution instanceof ShellExecution) {
            this._definition = {
              type: Task_1.ShellType,
              id: this._execution.computeId()
            };
          } else if (this._execution instanceof CustomExecution) {
            this._definition = {
              type: Task_1.ExtensionCallbackType,
              id: this._execution.computeId()
            };
          } else {
            this._definition = {
              type: Task_1.EmptyType,
              id: generateUuid()
            };
          }
        }
        get definition() {
          return this._definition;
        }
        set definition(value) {
          if (value === void 0 || value === null) {
            throw illegalArgument("Kind can't be undefined or null");
          }
          this.clear();
          this._definition = value;
        }
        get scope() {
          return this._scope;
        }
        set target(value) {
          this.clear();
          this._scope = value;
        }
        get name() {
          return this._name;
        }
        set name(value) {
          if (typeof value !== "string") {
            throw illegalArgument("name");
          }
          this.clear();
          this._name = value;
        }
        get execution() {
          return this._execution;
        }
        set execution(value) {
          if (value === null) {
            value = void 0;
          }
          this.clear();
          this._execution = value;
          const type = this._definition.type;
          if (Task_1.EmptyType === type || Task_1.ProcessType === type || Task_1.ShellType === type || Task_1.ExtensionCallbackType === type) {
            this.computeDefinitionBasedOnExecution();
          }
        }
        get problemMatchers() {
          return this._problemMatchers;
        }
        set problemMatchers(value) {
          if (!Array.isArray(value)) {
            this.clear();
            this._problemMatchers = [];
            this._hasDefinedMatchers = false;
            return;
          } else {
            this.clear();
            this._problemMatchers = value;
            this._hasDefinedMatchers = true;
          }
        }
        get hasDefinedMatchers() {
          return this._hasDefinedMatchers;
        }
        get isBackground() {
          return this._isBackground;
        }
        set isBackground(value) {
          if (value !== true && value !== false) {
            value = false;
          }
          this.clear();
          this._isBackground = value;
        }
        get source() {
          return this._source;
        }
        set source(value) {
          if (typeof value !== "string" || value.length === 0) {
            throw illegalArgument("source must be a string of length > 0");
          }
          this.clear();
          this._source = value;
        }
        get group() {
          return this._group;
        }
        set group(value) {
          if (value === null) {
            value = void 0;
          }
          this.clear();
          this._group = value;
        }
        get detail() {
          return this._detail;
        }
        set detail(value) {
          if (value === null) {
            value = void 0;
          }
          this._detail = value;
        }
        get presentationOptions() {
          return this._presentationOptions;
        }
        set presentationOptions(value) {
          if (value === null || value === void 0) {
            value = /* @__PURE__ */ Object.create(null);
          }
          this.clear();
          this._presentationOptions = value;
        }
        get runOptions() {
          return this._runOptions;
        }
        set runOptions(value) {
          if (value === null || value === void 0) {
            value = /* @__PURE__ */ Object.create(null);
          }
          this.clear();
          this._runOptions = value;
        }
      };
      Task = Task_1 = __decorate([
        es5ClassCompat
      ], Task);
      (function(ProgressLocation3) {
        ProgressLocation3[ProgressLocation3["SourceControl"] = 1] = "SourceControl";
        ProgressLocation3[ProgressLocation3["Window"] = 10] = "Window";
        ProgressLocation3[ProgressLocation3["Notification"] = 15] = "Notification";
      })(ProgressLocation || (ProgressLocation = {}));
      (function(ViewBadge2) {
        function isViewBadge(thing) {
          const viewBadgeThing = thing;
          if (!isNumber2(viewBadgeThing.value)) {
            console.log("INVALID view badge, invalid value", viewBadgeThing.value);
            return false;
          }
          if (viewBadgeThing.tooltip && !isString(viewBadgeThing.tooltip)) {
            console.log("INVALID view badge, invalid tooltip", viewBadgeThing.tooltip);
            return false;
          }
          return true;
        }
        ViewBadge2.isViewBadge = isViewBadge;
      })(ViewBadge || (ViewBadge = {}));
      TreeItem = TreeItem_1 = class TreeItem2 {
        static isTreeItem(thing, extension) {
          const treeItemThing = thing;
          if (treeItemThing.checkboxState !== void 0) {
            const checkbox = isNumber2(treeItemThing.checkboxState) ? treeItemThing.checkboxState : isObject(treeItemThing.checkboxState) && isNumber2(treeItemThing.checkboxState.state) ? treeItemThing.checkboxState.state : void 0;
            const tooltip = !isNumber2(treeItemThing.checkboxState) && isObject(treeItemThing.checkboxState) ? treeItemThing.checkboxState.tooltip : void 0;
            if (checkbox === void 0 || checkbox !== TreeItemCheckboxState.Checked && checkbox !== TreeItemCheckboxState.Unchecked || tooltip !== void 0 && !isString(tooltip)) {
              console.log("INVALID tree item, invalid checkboxState", treeItemThing.checkboxState);
              return false;
            }
          }
          if (thing instanceof TreeItem_1) {
            return true;
          }
          if (treeItemThing.label !== void 0 && !isString(treeItemThing.label) && !treeItemThing.label?.label) {
            console.log("INVALID tree item, invalid label", treeItemThing.label);
            return false;
          }
          if (treeItemThing.id !== void 0 && !isString(treeItemThing.id)) {
            console.log("INVALID tree item, invalid id", treeItemThing.id);
            return false;
          }
          if (treeItemThing.iconPath !== void 0 && !isString(treeItemThing.iconPath) && !URI.isUri(treeItemThing.iconPath) && (!treeItemThing.iconPath || !isString(treeItemThing.iconPath.id))) {
            const asLightAndDarkThing = treeItemThing.iconPath;
            if (!asLightAndDarkThing || !isString(asLightAndDarkThing.light) && !URI.isUri(asLightAndDarkThing.light) && !isString(asLightAndDarkThing.dark) && !URI.isUri(asLightAndDarkThing.dark)) {
              console.log("INVALID tree item, invalid iconPath", treeItemThing.iconPath);
              return false;
            }
          }
          if (treeItemThing.description !== void 0 && !isString(treeItemThing.description) && typeof treeItemThing.description !== "boolean") {
            console.log("INVALID tree item, invalid description", treeItemThing.description);
            return false;
          }
          if (treeItemThing.resourceUri !== void 0 && !URI.isUri(treeItemThing.resourceUri)) {
            console.log("INVALID tree item, invalid resourceUri", treeItemThing.resourceUri);
            return false;
          }
          if (treeItemThing.tooltip !== void 0 && !isString(treeItemThing.tooltip) && !(treeItemThing.tooltip instanceof MarkdownString2)) {
            console.log("INVALID tree item, invalid tooltip", treeItemThing.tooltip);
            return false;
          }
          if (treeItemThing.command !== void 0 && !treeItemThing.command.command) {
            console.log("INVALID tree item, invalid command", treeItemThing.command);
            return false;
          }
          if (treeItemThing.collapsibleState !== void 0 && treeItemThing.collapsibleState < TreeItemCollapsibleState.None && treeItemThing.collapsibleState > TreeItemCollapsibleState.Expanded) {
            console.log("INVALID tree item, invalid collapsibleState", treeItemThing.collapsibleState);
            return false;
          }
          if (treeItemThing.contextValue !== void 0 && !isString(treeItemThing.contextValue)) {
            console.log("INVALID tree item, invalid contextValue", treeItemThing.contextValue);
            return false;
          }
          if (treeItemThing.accessibilityInformation !== void 0 && !treeItemThing.accessibilityInformation?.label) {
            console.log("INVALID tree item, invalid accessibilityInformation", treeItemThing.accessibilityInformation);
            return false;
          }
          return true;
        }
        constructor(arg1, collapsibleState = TreeItemCollapsibleState.None) {
          this.collapsibleState = collapsibleState;
          if (URI.isUri(arg1)) {
            this.resourceUri = arg1;
          } else {
            this.label = arg1;
          }
        }
      };
      TreeItem = TreeItem_1 = __decorate([
        es5ClassCompat
      ], TreeItem);
      (function(TreeItemCollapsibleState3) {
        TreeItemCollapsibleState3[TreeItemCollapsibleState3["None"] = 0] = "None";
        TreeItemCollapsibleState3[TreeItemCollapsibleState3["Collapsed"] = 1] = "Collapsed";
        TreeItemCollapsibleState3[TreeItemCollapsibleState3["Expanded"] = 2] = "Expanded";
      })(TreeItemCollapsibleState || (TreeItemCollapsibleState = {}));
      (function(TreeItemCheckboxState3) {
        TreeItemCheckboxState3[TreeItemCheckboxState3["Unchecked"] = 0] = "Unchecked";
        TreeItemCheckboxState3[TreeItemCheckboxState3["Checked"] = 1] = "Checked";
      })(TreeItemCheckboxState || (TreeItemCheckboxState = {}));
      DataTransferItem = class DataTransferItem2 {
        async asString() {
          return typeof this.value === "string" ? this.value : JSON.stringify(this.value);
        }
        asFile() {
          return void 0;
        }
        constructor(value) {
          this.value = value;
        }
      };
      DataTransferItem = __decorate([
        es5ClassCompat
      ], DataTransferItem);
      DataTransfer = class DataTransfer2 {
        #items = /* @__PURE__ */ new Map();
        constructor(init) {
          for (const [mime, item] of init ?? []) {
            const existing = this.#items.get(this.#normalizeMime(mime));
            if (existing) {
              existing.push(item);
            } else {
              this.#items.set(this.#normalizeMime(mime), [item]);
            }
          }
        }
        get(mimeType) {
          return this.#items.get(this.#normalizeMime(mimeType))?.[0];
        }
        set(mimeType, value) {
          this.#items.set(this.#normalizeMime(mimeType), [value]);
        }
        forEach(callbackfn, thisArg) {
          for (const [mime, items] of this.#items) {
            for (const item of items) {
              callbackfn.call(thisArg, item, mime, this);
            }
          }
        }
        *[Symbol.iterator]() {
          for (const [mime, items] of this.#items) {
            for (const item of items) {
              yield [mime, item];
            }
          }
        }
        #normalizeMime(mimeType) {
          return mimeType.toLowerCase();
        }
      };
      DataTransfer = __decorate([
        es5ClassCompat
      ], DataTransfer);
      DocumentDropEdit = class DocumentDropEdit2 {
        constructor(insertText) {
          this.insertText = insertText;
        }
      };
      DocumentDropEdit = __decorate([
        es5ClassCompat
      ], DocumentDropEdit);
      DocumentPasteEdit = class DocumentPasteEdit2 {
        constructor(insertText, id2, label) {
          this.id = id2;
          this.label = label;
          this.insertText = insertText;
        }
      };
      DocumentPasteEdit = __decorate([
        es5ClassCompat
      ], DocumentPasteEdit);
      ThemeIcon2 = class ThemeIcon3 {
        constructor(id2, color) {
          this.id = id2;
          this.color = color;
        }
        static isThemeIcon(thing) {
          if (typeof thing.id !== "string") {
            console.log("INVALID ThemeIcon, invalid id", thing.id);
            return false;
          }
          return true;
        }
      };
      ThemeIcon2 = __decorate([
        es5ClassCompat
      ], ThemeIcon2);
      ThemeIcon2.File = new ThemeIcon2("file");
      ThemeIcon2.Folder = new ThemeIcon2("folder");
      ThemeColor2 = class ThemeColor3 {
        constructor(id2) {
          this.id = id2;
        }
      };
      ThemeColor2 = __decorate([
        es5ClassCompat
      ], ThemeColor2);
      (function(ConfigurationTarget3) {
        ConfigurationTarget3[ConfigurationTarget3["Global"] = 1] = "Global";
        ConfigurationTarget3[ConfigurationTarget3["Workspace"] = 2] = "Workspace";
        ConfigurationTarget3[ConfigurationTarget3["WorkspaceFolder"] = 3] = "WorkspaceFolder";
      })(ConfigurationTarget || (ConfigurationTarget = {}));
      RelativePattern = class RelativePattern2 {
        get base() {
          return this._base;
        }
        set base(base) {
          this._base = base;
          this._baseUri = URI.file(base);
        }
        get baseUri() {
          return this._baseUri;
        }
        set baseUri(baseUri) {
          this._baseUri = baseUri;
          this._base = baseUri.fsPath;
        }
        constructor(base, pattern) {
          if (typeof base !== "string") {
            if (!base || !URI.isUri(base) && !URI.isUri(base.uri)) {
              throw illegalArgument("base");
            }
          }
          if (typeof pattern !== "string") {
            throw illegalArgument("pattern");
          }
          if (typeof base === "string") {
            this.baseUri = URI.file(base);
          } else if (URI.isUri(base)) {
            this.baseUri = base;
          } else {
            this.baseUri = base.uri;
          }
          this.pattern = pattern;
        }
        toJSON() {
          return {
            pattern: this.pattern,
            base: this.base,
            baseUri: this.baseUri.toJSON()
          };
        }
      };
      RelativePattern = __decorate([
        es5ClassCompat
      ], RelativePattern);
      breakpointIds = /* @__PURE__ */ new WeakMap();
      Breakpoint = class Breakpoint2 {
        constructor(enabled, condition, hitCondition, logMessage) {
          this.enabled = typeof enabled === "boolean" ? enabled : true;
          if (typeof condition === "string") {
            this.condition = condition;
          }
          if (typeof hitCondition === "string") {
            this.hitCondition = hitCondition;
          }
          if (typeof logMessage === "string") {
            this.logMessage = logMessage;
          }
        }
        get id() {
          if (!this._id) {
            this._id = breakpointIds.get(this) ?? generateUuid();
          }
          return this._id;
        }
      };
      Breakpoint = __decorate([
        es5ClassCompat
      ], Breakpoint);
      SourceBreakpoint = class SourceBreakpoint2 extends Breakpoint {
        constructor(location, enabled, condition, hitCondition, logMessage) {
          super(enabled, condition, hitCondition, logMessage);
          if (location === null) {
            throw illegalArgument("location");
          }
          this.location = location;
        }
      };
      SourceBreakpoint = __decorate([
        es5ClassCompat
      ], SourceBreakpoint);
      FunctionBreakpoint = class FunctionBreakpoint2 extends Breakpoint {
        constructor(functionName, enabled, condition, hitCondition, logMessage) {
          super(enabled, condition, hitCondition, logMessage);
          this.functionName = functionName;
        }
      };
      FunctionBreakpoint = __decorate([
        es5ClassCompat
      ], FunctionBreakpoint);
      DataBreakpoint = class DataBreakpoint2 extends Breakpoint {
        constructor(label, dataId, canPersist, enabled, condition, hitCondition, logMessage) {
          super(enabled, condition, hitCondition, logMessage);
          if (!dataId) {
            throw illegalArgument("dataId");
          }
          this.label = label;
          this.dataId = dataId;
          this.canPersist = canPersist;
        }
      };
      DataBreakpoint = __decorate([
        es5ClassCompat
      ], DataBreakpoint);
      DebugAdapterExecutable = class DebugAdapterExecutable2 {
        constructor(command, args, options) {
          this.command = command;
          this.args = args || [];
          this.options = options;
        }
      };
      DebugAdapterExecutable = __decorate([
        es5ClassCompat
      ], DebugAdapterExecutable);
      DebugAdapterServer = class DebugAdapterServer2 {
        constructor(port, host) {
          this.port = port;
          this.host = host;
        }
      };
      DebugAdapterServer = __decorate([
        es5ClassCompat
      ], DebugAdapterServer);
      DebugAdapterNamedPipeServer = class DebugAdapterNamedPipeServer2 {
        constructor(path) {
          this.path = path;
        }
      };
      DebugAdapterNamedPipeServer = __decorate([
        es5ClassCompat
      ], DebugAdapterNamedPipeServer);
      DebugAdapterInlineImplementation = class DebugAdapterInlineImplementation2 {
        constructor(impl) {
          this.implementation = impl;
        }
      };
      DebugAdapterInlineImplementation = __decorate([
        es5ClassCompat
      ], DebugAdapterInlineImplementation);
      StackFrameFocus = class StackFrameFocus2 {
        constructor(session, threadId, frameId) {
          this.session = session;
          this.threadId = threadId;
          this.frameId = frameId;
        }
      };
      StackFrameFocus = __decorate([
        es5ClassCompat
      ], StackFrameFocus);
      ThreadFocus = class ThreadFocus2 {
        constructor(session, threadId) {
          this.session = session;
          this.threadId = threadId;
        }
      };
      ThreadFocus = __decorate([
        es5ClassCompat
      ], ThreadFocus);
      EvaluatableExpression = class EvaluatableExpression2 {
        constructor(range, expression) {
          this.range = range;
          this.expression = expression;
        }
      };
      EvaluatableExpression = __decorate([
        es5ClassCompat
      ], EvaluatableExpression);
      (function(InlineCompletionTriggerKind3) {
        InlineCompletionTriggerKind3[InlineCompletionTriggerKind3["Invoke"] = 0] = "Invoke";
        InlineCompletionTriggerKind3[InlineCompletionTriggerKind3["Automatic"] = 1] = "Automatic";
      })(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));
      InlineValueText = class InlineValueText2 {
        constructor(range, text) {
          this.range = range;
          this.text = text;
        }
      };
      InlineValueText = __decorate([
        es5ClassCompat
      ], InlineValueText);
      InlineValueVariableLookup = class InlineValueVariableLookup2 {
        constructor(range, variableName, caseSensitiveLookup = true) {
          this.range = range;
          this.variableName = variableName;
          this.caseSensitiveLookup = caseSensitiveLookup;
        }
      };
      InlineValueVariableLookup = __decorate([
        es5ClassCompat
      ], InlineValueVariableLookup);
      InlineValueEvaluatableExpression = class InlineValueEvaluatableExpression2 {
        constructor(range, expression) {
          this.range = range;
          this.expression = expression;
        }
      };
      InlineValueEvaluatableExpression = __decorate([
        es5ClassCompat
      ], InlineValueEvaluatableExpression);
      InlineValueContext = class InlineValueContext2 {
        constructor(frameId, range) {
          this.frameId = frameId;
          this.stoppedLocation = range;
        }
      };
      InlineValueContext = __decorate([
        es5ClassCompat
      ], InlineValueContext);
      (function(FileChangeType3) {
        FileChangeType3[FileChangeType3["Changed"] = 1] = "Changed";
        FileChangeType3[FileChangeType3["Created"] = 2] = "Created";
        FileChangeType3[FileChangeType3["Deleted"] = 3] = "Deleted";
      })(FileChangeType || (FileChangeType = {}));
      FileSystemError = FileSystemError_1 = class FileSystemError2 extends Error {
        static FileExists(messageOrUri) {
          return new FileSystemError_1(
            messageOrUri,
            FileSystemProviderErrorCode.FileExists,
            FileSystemError_1.FileExists
          );
        }
        static FileNotFound(messageOrUri) {
          return new FileSystemError_1(
            messageOrUri,
            FileSystemProviderErrorCode.FileNotFound,
            FileSystemError_1.FileNotFound
          );
        }
        static FileNotADirectory(messageOrUri) {
          return new FileSystemError_1(
            messageOrUri,
            FileSystemProviderErrorCode.FileNotADirectory,
            FileSystemError_1.FileNotADirectory
          );
        }
        static FileIsADirectory(messageOrUri) {
          return new FileSystemError_1(
            messageOrUri,
            FileSystemProviderErrorCode.FileIsADirectory,
            FileSystemError_1.FileIsADirectory
          );
        }
        static NoPermissions(messageOrUri) {
          return new FileSystemError_1(
            messageOrUri,
            FileSystemProviderErrorCode.NoPermissions,
            FileSystemError_1.NoPermissions
          );
        }
        static Unavailable(messageOrUri) {
          return new FileSystemError_1(
            messageOrUri,
            FileSystemProviderErrorCode.Unavailable,
            FileSystemError_1.Unavailable
          );
        }
        constructor(uriOrMessage, code = FileSystemProviderErrorCode.Unknown, terminator) {
          super(URI.isUri(uriOrMessage) ? uriOrMessage.toString(true) : uriOrMessage);
          this.code = terminator?.name ?? "Unknown";
          markAsFileSystemProviderError(this, code);
          Object.setPrototypeOf(this, FileSystemError_1.prototype);
          if (typeof Error.captureStackTrace === "function" && typeof terminator === "function") {
            Error.captureStackTrace(this, terminator);
          }
        }
      };
      FileSystemError = FileSystemError_1 = __decorate([
        es5ClassCompat
      ], FileSystemError);
      FoldingRange = class FoldingRange2 {
        constructor(start, end, kind) {
          this.start = start;
          this.end = end;
          this.kind = kind;
        }
      };
      FoldingRange = __decorate([
        es5ClassCompat
      ], FoldingRange);
      (function(FoldingRangeKind3) {
        FoldingRangeKind3[FoldingRangeKind3["Comment"] = 1] = "Comment";
        FoldingRangeKind3[FoldingRangeKind3["Imports"] = 2] = "Imports";
        FoldingRangeKind3[FoldingRangeKind3["Region"] = 3] = "Region";
      })(FoldingRangeKind || (FoldingRangeKind = {}));
      (function(CommentThreadCollapsibleState3) {
        CommentThreadCollapsibleState3[CommentThreadCollapsibleState3["Collapsed"] = 0] = "Collapsed";
        CommentThreadCollapsibleState3[CommentThreadCollapsibleState3["Expanded"] = 1] = "Expanded";
      })(CommentThreadCollapsibleState || (CommentThreadCollapsibleState = {}));
      (function(CommentMode3) {
        CommentMode3[CommentMode3["Editing"] = 0] = "Editing";
        CommentMode3[CommentMode3["Preview"] = 1] = "Preview";
      })(CommentMode || (CommentMode = {}));
      (function(CommentState2) {
        CommentState2[CommentState2["Published"] = 0] = "Published";
        CommentState2[CommentState2["Draft"] = 1] = "Draft";
      })(CommentState || (CommentState = {}));
      (function(CommentThreadState3) {
        CommentThreadState3[CommentThreadState3["Unresolved"] = 0] = "Unresolved";
        CommentThreadState3[CommentThreadState3["Resolved"] = 1] = "Resolved";
      })(CommentThreadState || (CommentThreadState = {}));
      SemanticTokensLegend = class {
        constructor(tokenTypes, tokenModifiers = []) {
          this.tokenTypes = tokenTypes;
          this.tokenModifiers = tokenModifiers;
        }
      };
      SemanticTokensBuilder = class {
        constructor(legend) {
          this._prevLine = 0;
          this._prevChar = 0;
          this._dataIsSortedAndDeltaEncoded = true;
          this._data = [];
          this._dataLen = 0;
          this._tokenTypeStrToInt = /* @__PURE__ */ new Map();
          this._tokenModifierStrToInt = /* @__PURE__ */ new Map();
          this._hasLegend = false;
          if (legend) {
            this._hasLegend = true;
            for (let i = 0, len = legend.tokenTypes.length; i < len; i++) {
              this._tokenTypeStrToInt.set(legend.tokenTypes[i], i);
            }
            for (let i = 0, len = legend.tokenModifiers.length; i < len; i++) {
              this._tokenModifierStrToInt.set(legend.tokenModifiers[i], i);
            }
          }
        }
        push(arg0, arg1, arg2, arg3, arg4) {
          if (typeof arg0 === "number" && typeof arg1 === "number" && typeof arg2 === "number" && typeof arg3 === "number" && (typeof arg4 === "number" || typeof arg4 === "undefined")) {
            if (typeof arg4 === "undefined") {
              arg4 = 0;
            }
            return this._pushEncoded(arg0, arg1, arg2, arg3, arg4);
          }
          if (Range.isRange(arg0) && typeof arg1 === "string" && isStrArrayOrUndefined(arg2)) {
            return this._push(arg0, arg1, arg2);
          }
          throw illegalArgument();
        }
        _push(range, tokenType, tokenModifiers) {
          if (!this._hasLegend) {
            throw new Error("Legend must be provided in constructor");
          }
          if (range.start.line !== range.end.line) {
            throw new Error("`range` cannot span multiple lines");
          }
          if (!this._tokenTypeStrToInt.has(tokenType)) {
            throw new Error("`tokenType` is not in the provided legend");
          }
          const line = range.start.line;
          const char = range.start.character;
          const length = range.end.character - range.start.character;
          const nTokenType = this._tokenTypeStrToInt.get(tokenType);
          let nTokenModifiers = 0;
          if (tokenModifiers) {
            for (const tokenModifier of tokenModifiers) {
              if (!this._tokenModifierStrToInt.has(tokenModifier)) {
                throw new Error("`tokenModifier` is not in the provided legend");
              }
              const nTokenModifier = this._tokenModifierStrToInt.get(tokenModifier);
              nTokenModifiers |= 1 << nTokenModifier >>> 0;
            }
          }
          this._pushEncoded(line, char, length, nTokenType, nTokenModifiers);
        }
        _pushEncoded(line, char, length, tokenType, tokenModifiers) {
          if (this._dataIsSortedAndDeltaEncoded && (line < this._prevLine || line === this._prevLine && char < this._prevChar)) {
            this._dataIsSortedAndDeltaEncoded = false;
            const tokenCount = this._data.length / 5 | 0;
            let prevLine = 0;
            let prevChar = 0;
            for (let i = 0; i < tokenCount; i++) {
              let line2 = this._data[5 * i];
              let char2 = this._data[5 * i + 1];
              if (line2 === 0) {
                line2 = prevLine;
                char2 += prevChar;
              } else {
                line2 += prevLine;
              }
              this._data[5 * i] = line2;
              this._data[5 * i + 1] = char2;
              prevLine = line2;
              prevChar = char2;
            }
          }
          let pushLine = line;
          let pushChar = char;
          if (this._dataIsSortedAndDeltaEncoded && this._dataLen > 0) {
            pushLine -= this._prevLine;
            if (pushLine === 0) {
              pushChar -= this._prevChar;
            }
          }
          this._data[this._dataLen++] = pushLine;
          this._data[this._dataLen++] = pushChar;
          this._data[this._dataLen++] = length;
          this._data[this._dataLen++] = tokenType;
          this._data[this._dataLen++] = tokenModifiers;
          this._prevLine = line;
          this._prevChar = char;
        }
        static _sortAndDeltaEncode(data) {
          const pos = [];
          const tokenCount = data.length / 5 | 0;
          for (let i = 0; i < tokenCount; i++) {
            pos[i] = i;
          }
          pos.sort((a, b) => {
            const aLine = data[5 * a];
            const bLine = data[5 * b];
            if (aLine === bLine) {
              const aChar = data[5 * a + 1];
              const bChar = data[5 * b + 1];
              return aChar - bChar;
            }
            return aLine - bLine;
          });
          const result = new Uint32Array(data.length);
          let prevLine = 0;
          let prevChar = 0;
          for (let i = 0; i < tokenCount; i++) {
            const srcOffset = 5 * pos[i];
            const line = data[srcOffset + 0];
            const char = data[srcOffset + 1];
            const length = data[srcOffset + 2];
            const tokenType = data[srcOffset + 3];
            const tokenModifiers = data[srcOffset + 4];
            const pushLine = line - prevLine;
            const pushChar = pushLine === 0 ? char - prevChar : char;
            const dstOffset = 5 * i;
            result[dstOffset + 0] = pushLine;
            result[dstOffset + 1] = pushChar;
            result[dstOffset + 2] = length;
            result[dstOffset + 3] = tokenType;
            result[dstOffset + 4] = tokenModifiers;
            prevLine = line;
            prevChar = char;
          }
          return result;
        }
        build(resultId) {
          if (!this._dataIsSortedAndDeltaEncoded) {
            return new SemanticTokens(SemanticTokensBuilder._sortAndDeltaEncode(this._data), resultId);
          }
          return new SemanticTokens(new Uint32Array(this._data), resultId);
        }
      };
      SemanticTokens = class {
        constructor(data, resultId) {
          this.resultId = resultId;
          this.data = data;
        }
      };
      SemanticTokensEdit = class {
        constructor(start, deleteCount, data) {
          this.start = start;
          this.deleteCount = deleteCount;
          this.data = data;
        }
      };
      SemanticTokensEdits = class {
        constructor(edits, resultId) {
          this.resultId = resultId;
          this.edits = edits;
        }
      };
      (function(DebugConsoleMode3) {
        DebugConsoleMode3[DebugConsoleMode3["Separate"] = 0] = "Separate";
        DebugConsoleMode3[DebugConsoleMode3["MergeWithParent"] = 1] = "MergeWithParent";
      })(DebugConsoleMode || (DebugConsoleMode = {}));
      QuickInputButtons = class QuickInputButtons2 {
        static {
          this.Back = { iconPath: new ThemeIcon2("arrow-left") };
        }
        constructor() {
        }
      };
      QuickInputButtons = __decorate([
        es5ClassCompat
      ], QuickInputButtons);
      (function(QuickPickItemKind3) {
        QuickPickItemKind3[QuickPickItemKind3["Separator"] = -1] = "Separator";
        QuickPickItemKind3[QuickPickItemKind3["Default"] = 0] = "Default";
      })(QuickPickItemKind || (QuickPickItemKind = {}));
      (function(InputBoxValidationSeverity3) {
        InputBoxValidationSeverity3[InputBoxValidationSeverity3["Info"] = 1] = "Info";
        InputBoxValidationSeverity3[InputBoxValidationSeverity3["Warning"] = 2] = "Warning";
        InputBoxValidationSeverity3[InputBoxValidationSeverity3["Error"] = 3] = "Error";
      })(InputBoxValidationSeverity || (InputBoxValidationSeverity = {}));
      (function(ExtensionKind3) {
        ExtensionKind3[ExtensionKind3["UI"] = 1] = "UI";
        ExtensionKind3[ExtensionKind3["Workspace"] = 2] = "Workspace";
      })(ExtensionKind || (ExtensionKind = {}));
      FileDecoration = class {
        static validate(d) {
          if (typeof d.badge === "string") {
            let len = nextCharLength(d.badge, 0);
            if (len < d.badge.length) {
              len += nextCharLength(d.badge, len);
            }
            if (d.badge.length > len) {
              throw new Error(`The 'badge'-property must be undefined or a short character`);
            }
          } else if (d.badge) {
            if (!ThemeIcon2.isThemeIcon(d.badge)) {
              throw new Error(`The 'badge'-property is not a valid ThemeIcon`);
            }
          }
          if (!d.color && !d.badge && !d.tooltip) {
            throw new Error(`The decoration is empty`);
          }
          return true;
        }
        constructor(badge, tooltip, color) {
          this.badge = badge;
          this.tooltip = tooltip;
          this.color = color;
        }
      };
      ColorTheme = class ColorTheme2 {
        constructor(kind) {
          this.kind = kind;
        }
      };
      ColorTheme = __decorate([
        es5ClassCompat
      ], ColorTheme);
      (function(ColorThemeKind3) {
        ColorThemeKind3[ColorThemeKind3["Light"] = 1] = "Light";
        ColorThemeKind3[ColorThemeKind3["Dark"] = 2] = "Dark";
        ColorThemeKind3[ColorThemeKind3["HighContrast"] = 3] = "HighContrast";
        ColorThemeKind3[ColorThemeKind3["HighContrastLight"] = 4] = "HighContrastLight";
      })(ColorThemeKind || (ColorThemeKind = {}));
      NotebookRange = class {
        static isNotebookRange(thing) {
          if (thing instanceof NotebookRange) {
            return true;
          }
          if (!thing) {
            return false;
          }
          return typeof thing.start === "number" && typeof thing.end === "number";
        }
        get start() {
          return this._start;
        }
        get end() {
          return this._end;
        }
        get isEmpty() {
          return this._start === this._end;
        }
        constructor(start, end) {
          if (start < 0) {
            throw illegalArgument("start must be positive");
          }
          if (end < 0) {
            throw illegalArgument("end must be positive");
          }
          if (start <= end) {
            this._start = start;
            this._end = end;
          } else {
            this._start = end;
            this._end = start;
          }
        }
        with(change) {
          let start = this._start;
          let end = this._end;
          if (change.start !== void 0) {
            start = change.start;
          }
          if (change.end !== void 0) {
            end = change.end;
          }
          if (start === this._start && end === this._end) {
            return this;
          }
          return new NotebookRange(start, end);
        }
      };
      _NotebookCellOutputItem = class {
        static isNotebookCellOutputItem(obj) {
          if (obj instanceof _NotebookCellOutputItem) {
            return true;
          }
          if (!obj) {
            return false;
          }
          return typeof obj.mime === "string" && obj.data instanceof Uint8Array;
        }
        static error(err) {
          const obj = {
            name: err.name,
            message: err.message,
            stack: err.stack
          };
          return _NotebookCellOutputItem.json(obj, "application/vnd.code.notebook.error");
        }
        static stdout(value) {
          return _NotebookCellOutputItem.text(value, "application/vnd.code.notebook.stdout");
        }
        static stderr(value) {
          return _NotebookCellOutputItem.text(value, "application/vnd.code.notebook.stderr");
        }
        static bytes(value, mime = "application/octet-stream") {
          return new _NotebookCellOutputItem(value, mime);
        }
        static text(value, mime = Mimes.text) {
          const bytes = __privateGet(_NotebookCellOutputItem, _encoder).encode(String(value));
          return new _NotebookCellOutputItem(bytes, mime);
        }
        static json(value, mime = "text/x-json") {
          const rawStr = JSON.stringify(value, void 0, "	");
          return _NotebookCellOutputItem.text(rawStr, mime);
        }
        constructor(data, mime) {
          this.data = data;
          this.mime = mime;
          const mimeNormalized = normalizeMimeType(mime, true);
          if (!mimeNormalized) {
            throw new Error(`INVALID mime type: ${mime}. Must be in the format "type/subtype[;optionalparameter]"`);
          }
          this.mime = mimeNormalized;
        }
      };
      NotebookCellOutputItem = _NotebookCellOutputItem;
      _encoder = new WeakMap();
      __privateAdd(NotebookCellOutputItem, _encoder, new TextEncoder());
      (function(NotebookCellKind3) {
        NotebookCellKind3[NotebookCellKind3["Markup"] = 1] = "Markup";
        NotebookCellKind3[NotebookCellKind3["Code"] = 2] = "Code";
      })(NotebookCellKind || (NotebookCellKind = {}));
      (function(NotebookCellExecutionState3) {
        NotebookCellExecutionState3[NotebookCellExecutionState3["Idle"] = 1] = "Idle";
        NotebookCellExecutionState3[NotebookCellExecutionState3["Pending"] = 2] = "Pending";
        NotebookCellExecutionState3[NotebookCellExecutionState3["Executing"] = 3] = "Executing";
      })(NotebookCellExecutionState2 || (NotebookCellExecutionState2 = {}));
      (function(NotebookCellStatusBarAlignment3) {
        NotebookCellStatusBarAlignment3[NotebookCellStatusBarAlignment3["Left"] = 1] = "Left";
        NotebookCellStatusBarAlignment3[NotebookCellStatusBarAlignment3["Right"] = 2] = "Right";
      })(NotebookCellStatusBarAlignment || (NotebookCellStatusBarAlignment = {}));
      (function(NotebookEditorRevealType3) {
        NotebookEditorRevealType3[NotebookEditorRevealType3["Default"] = 0] = "Default";
        NotebookEditorRevealType3[NotebookEditorRevealType3["InCenter"] = 1] = "InCenter";
        NotebookEditorRevealType3[NotebookEditorRevealType3["InCenterIfOutsideViewport"] = 2] = "InCenterIfOutsideViewport";
        NotebookEditorRevealType3[NotebookEditorRevealType3["AtTop"] = 3] = "AtTop";
      })(NotebookEditorRevealType || (NotebookEditorRevealType = {}));
      (function(NotebookControllerAffinity4) {
        NotebookControllerAffinity4[NotebookControllerAffinity4["Default"] = 1] = "Default";
        NotebookControllerAffinity4[NotebookControllerAffinity4["Preferred"] = 2] = "Preferred";
      })(NotebookControllerAffinity || (NotebookControllerAffinity = {}));
      (function(NotebookControllerAffinity22) {
        NotebookControllerAffinity22[NotebookControllerAffinity22["Default"] = 1] = "Default";
        NotebookControllerAffinity22[NotebookControllerAffinity22["Preferred"] = 2] = "Preferred";
        NotebookControllerAffinity22[NotebookControllerAffinity22["Hidden"] = -1] = "Hidden";
      })(NotebookControllerAffinity2 || (NotebookControllerAffinity2 = {}));
      TimelineItem = class TimelineItem2 {
        constructor(label, timestamp) {
          this.label = label;
          this.timestamp = timestamp;
        }
      };
      TimelineItem = __decorate([
        es5ClassCompat
      ], TimelineItem);
      (function(ExtensionMode3) {
        ExtensionMode3[ExtensionMode3["Production"] = 1] = "Production";
        ExtensionMode3[ExtensionMode3["Development"] = 2] = "Development";
        ExtensionMode3[ExtensionMode3["Test"] = 3] = "Test";
      })(ExtensionMode || (ExtensionMode = {}));
      (function(ExtensionRuntime2) {
        ExtensionRuntime2[ExtensionRuntime2["Node"] = 1] = "Node";
        ExtensionRuntime2[ExtensionRuntime2["Webworker"] = 2] = "Webworker";
      })(ExtensionRuntime || (ExtensionRuntime = {}));
      (function(StandardTokenType2) {
        StandardTokenType2[StandardTokenType2["Other"] = 0] = "Other";
        StandardTokenType2[StandardTokenType2["Comment"] = 1] = "Comment";
        StandardTokenType2[StandardTokenType2["String"] = 2] = "String";
        StandardTokenType2[StandardTokenType2["RegEx"] = 3] = "RegEx";
      })(StandardTokenType || (StandardTokenType = {}));
      LinkedEditingRanges = class {
        constructor(ranges, wordPattern) {
          this.ranges = ranges;
          this.wordPattern = wordPattern;
        }
      };
      (function(TestResultState2) {
        TestResultState2[TestResultState2["Queued"] = 1] = "Queued";
        TestResultState2[TestResultState2["Running"] = 2] = "Running";
        TestResultState2[TestResultState2["Passed"] = 3] = "Passed";
        TestResultState2[TestResultState2["Failed"] = 4] = "Failed";
        TestResultState2[TestResultState2["Skipped"] = 5] = "Skipped";
        TestResultState2[TestResultState2["Errored"] = 6] = "Errored";
      })(TestResultState || (TestResultState = {}));
      (function(TestRunProfileKind3) {
        TestRunProfileKind3[TestRunProfileKind3["Run"] = 1] = "Run";
        TestRunProfileKind3[TestRunProfileKind3["Debug"] = 2] = "Debug";
        TestRunProfileKind3[TestRunProfileKind3["Coverage"] = 3] = "Coverage";
      })(TestRunProfileKind || (TestRunProfileKind = {}));
      TestRunRequest = class TestRunRequest2 {
        constructor(include = void 0, exclude = void 0, profile = void 0, continuous = false) {
          this.include = include;
          this.exclude = exclude;
          this.profile = profile;
          this.continuous = continuous;
        }
      };
      TestRunRequest = __decorate([
        es5ClassCompat
      ], TestRunRequest);
      TestRunRequest22 = class TestRunRequest23 extends TestRunRequest {
      };
      TestRunRequest22 = __decorate([
        es5ClassCompat
      ], TestRunRequest22);
      TestMessage = TestMessage_1 = class TestMessage2 {
        static diff(message, expected, actual) {
          const msg = new TestMessage_1(message);
          msg.expectedOutput = expected;
          msg.actualOutput = actual;
          return msg;
        }
        constructor(message) {
          this.message = message;
        }
      };
      TestMessage = TestMessage_1 = __decorate([
        es5ClassCompat
      ], TestMessage);
      TestTag = class TestTag2 {
        constructor(id2) {
          this.id = id2;
        }
      };
      TestTag = __decorate([
        es5ClassCompat
      ], TestTag);
      CoveredCount = class CoveredCount2 {
        constructor(covered, total) {
          this.covered = covered;
          this.total = total;
        }
      };
      CoveredCount = __decorate([
        es5ClassCompat
      ], CoveredCount);
      FileCoverage = FileCoverage_1 = class FileCoverage2 {
        static fromDetails(uri, details) {
          const statements = new CoveredCount(0, 0);
          const branches = new CoveredCount(0, 0);
          const fn = new CoveredCount(0, 0);
          for (const detail of details) {
            if ("branches" in detail) {
              statements.total += 1;
              statements.covered += detail.executionCount > 0 ? 1 : 0;
              for (const branch of detail.branches) {
                branches.total += 1;
                branches.covered += branch.executionCount > 0 ? 1 : 0;
              }
            } else {
              fn.total += 1;
              fn.covered += detail.executionCount > 0 ? 1 : 0;
            }
          }
          const coverage = new FileCoverage_1(
            uri,
            statements,
            branches.total > 0 ? branches : void 0,
            fn.total > 0 ? fn : void 0
          );
          coverage.detailedCoverage = details;
          return coverage;
        }
        constructor(uri, statementCoverage, branchCoverage, functionCoverage) {
          this.uri = uri;
          this.statementCoverage = statementCoverage;
          this.branchCoverage = branchCoverage;
          this.functionCoverage = functionCoverage;
        }
      };
      FileCoverage = FileCoverage_1 = __decorate([
        es5ClassCompat
      ], FileCoverage);
      StatementCoverage = class StatementCoverage2 {
        constructor(executionCount, location, branches = []) {
          this.executionCount = executionCount;
          this.location = location;
          this.branches = branches;
        }
      };
      StatementCoverage = __decorate([
        es5ClassCompat
      ], StatementCoverage);
      BranchCoverage = class BranchCoverage2 {
        constructor(executionCount, location) {
          this.executionCount = executionCount;
          this.location = location;
        }
      };
      BranchCoverage = __decorate([
        es5ClassCompat
      ], BranchCoverage);
      FunctionCoverage = class FunctionCoverage2 {
        constructor(executionCount, location) {
          this.executionCount = executionCount;
          this.location = location;
        }
      };
      FunctionCoverage = __decorate([
        es5ClassCompat
      ], FunctionCoverage);
      (function(ExternalUriOpenerPriority3) {
        ExternalUriOpenerPriority3[ExternalUriOpenerPriority3["None"] = 0] = "None";
        ExternalUriOpenerPriority3[ExternalUriOpenerPriority3["Option"] = 1] = "Option";
        ExternalUriOpenerPriority3[ExternalUriOpenerPriority3["Default"] = 2] = "Default";
        ExternalUriOpenerPriority3[ExternalUriOpenerPriority3["Preferred"] = 3] = "Preferred";
      })(ExternalUriOpenerPriority || (ExternalUriOpenerPriority = {}));
      (function(WorkspaceTrustState2) {
        WorkspaceTrustState2[WorkspaceTrustState2["Untrusted"] = 0] = "Untrusted";
        WorkspaceTrustState2[WorkspaceTrustState2["Trusted"] = 1] = "Trusted";
        WorkspaceTrustState2[WorkspaceTrustState2["Unspecified"] = 2] = "Unspecified";
      })(WorkspaceTrustState || (WorkspaceTrustState = {}));
      (function(PortAutoForwardAction2) {
        PortAutoForwardAction2[PortAutoForwardAction2["Notify"] = 1] = "Notify";
        PortAutoForwardAction2[PortAutoForwardAction2["OpenBrowser"] = 2] = "OpenBrowser";
        PortAutoForwardAction2[PortAutoForwardAction2["OpenPreview"] = 3] = "OpenPreview";
        PortAutoForwardAction2[PortAutoForwardAction2["Silent"] = 4] = "Silent";
        PortAutoForwardAction2[PortAutoForwardAction2["Ignore"] = 5] = "Ignore";
        PortAutoForwardAction2[PortAutoForwardAction2["OpenBrowserOnce"] = 6] = "OpenBrowserOnce";
      })(PortAutoForwardAction || (PortAutoForwardAction = {}));
      TypeHierarchyItem = class {
        constructor(kind, name, detail, uri, range, selectionRange) {
          this.kind = kind;
          this.name = name;
          this.detail = detail;
          this.uri = uri;
          this.range = range;
          this.selectionRange = selectionRange;
        }
      };
      TextTabInput = class {
        constructor(uri) {
          this.uri = uri;
        }
      };
      TextDiffTabInput = class {
        constructor(original, modified) {
          this.original = original;
          this.modified = modified;
        }
      };
      CustomEditorTabInput = class {
        constructor(uri, viewType) {
          this.uri = uri;
          this.viewType = viewType;
        }
      };
      WebviewEditorTabInput = class {
        constructor(viewType) {
          this.viewType = viewType;
        }
      };
      NotebookEditorTabInput = class {
        constructor(uri, notebookType) {
          this.uri = uri;
          this.notebookType = notebookType;
        }
      };
      NotebookDiffEditorTabInput = class {
        constructor(original, modified, notebookType) {
          this.original = original;
          this.modified = modified;
          this.notebookType = notebookType;
        }
      };
      TerminalEditorTabInput = class {
        constructor() {
        }
      };
      (function(InteractiveSessionVoteDirection2) {
        InteractiveSessionVoteDirection2[InteractiveSessionVoteDirection2["Up"] = 1] = "Up";
        InteractiveSessionVoteDirection2[InteractiveSessionVoteDirection2["Down"] = 2] = "Down";
      })(InteractiveSessionVoteDirection || (InteractiveSessionVoteDirection = {}));
      (function(InteractiveSessionCopyKind2) {
        InteractiveSessionCopyKind2[InteractiveSessionCopyKind2["Action"] = 1] = "Action";
        InteractiveSessionCopyKind2[InteractiveSessionCopyKind2["Toolbar"] = 2] = "Toolbar";
      })(InteractiveSessionCopyKind || (InteractiveSessionCopyKind = {}));
      (function(InteractiveEditorResponseFeedbackKind2) {
        InteractiveEditorResponseFeedbackKind2[InteractiveEditorResponseFeedbackKind2["Unhelpful"] = 0] = "Unhelpful";
        InteractiveEditorResponseFeedbackKind2[InteractiveEditorResponseFeedbackKind2["Helpful"] = 1] = "Helpful";
        InteractiveEditorResponseFeedbackKind2[InteractiveEditorResponseFeedbackKind2["Undone"] = 2] = "Undone";
        InteractiveEditorResponseFeedbackKind2[InteractiveEditorResponseFeedbackKind2["Accepted"] = 3] = "Accepted";
      })(
        InteractiveEditorResponseFeedbackKind || (InteractiveEditorResponseFeedbackKind = {})
      );
    }
  });

  // node_modules/monaco-editor/esm/vs/platform/contextkey/common/scanner.js
  function hintDidYouMean(...meant) {
    switch (meant.length) {
      case 1:
        return localize("contextkey.scanner.hint.didYouMean1", "Did you mean {0}?", meant[0]);
      case 2:
        return localize("contextkey.scanner.hint.didYouMean2", "Did you mean {0} or {1}?", meant[0], meant[1]);
      case 3:
        return localize("contextkey.scanner.hint.didYouMean3", "Did you mean {0}, {1} or {2}?", meant[0], meant[1], meant[2]);
      default:
        return void 0;
    }
  }
  var hintDidYouForgetToOpenOrCloseQuote, hintDidYouForgetToEscapeSlash, Scanner;
  var init_scanner = __esm({
    "node_modules/monaco-editor/esm/vs/platform/contextkey/common/scanner.js"() {
      init_errors();
      init_nls();
      hintDidYouForgetToOpenOrCloseQuote = localize("contextkey.scanner.hint.didYouForgetToOpenOrCloseQuote", "Did you forget to open or close the quote?");
      hintDidYouForgetToEscapeSlash = localize("contextkey.scanner.hint.didYouForgetToEscapeSlash", "Did you forget to escape the '/' (slash) character? Put two backslashes before it to escape, e.g., '\\\\/'.");
      Scanner = class {
        constructor() {
          this._input = "";
          this._start = 0;
          this._current = 0;
          this._tokens = [];
          this._errors = [];
          this.stringRe = /[a-zA-Z0-9_<>\-\./\\:\*\?\+\[\]\^,#@;"%\$\p{L}-]+/uy;
        }
        static getLexeme(token) {
          switch (token.type) {
            case 0:
              return "(";
            case 1:
              return ")";
            case 2:
              return "!";
            case 3:
              return token.isTripleEq ? "===" : "==";
            case 4:
              return token.isTripleEq ? "!==" : "!=";
            case 5:
              return "<";
            case 6:
              return "<=";
            case 7:
              return ">=";
            case 8:
              return ">=";
            case 9:
              return "=~";
            case 10:
              return token.lexeme;
            case 11:
              return "true";
            case 12:
              return "false";
            case 13:
              return "in";
            case 14:
              return "not";
            case 15:
              return "&&";
            case 16:
              return "||";
            case 17:
              return token.lexeme;
            case 18:
              return token.lexeme;
            case 19:
              return token.lexeme;
            case 20:
              return "EOF";
            default:
              throw illegalState(`unhandled token type: ${JSON.stringify(token)}; have you forgotten to add a case?`);
          }
        }
        get errors() {
          return this._errors;
        }
        reset(value) {
          this._input = value;
          this._start = 0;
          this._current = 0;
          this._tokens = [];
          this._errors = [];
          return this;
        }
        scan() {
          while (!this._isAtEnd()) {
            this._start = this._current;
            const ch = this._advance();
            switch (ch) {
              case 40:
                this._addToken(
                  0
                  /* TokenType.LParen */
                );
                break;
              case 41:
                this._addToken(
                  1
                  /* TokenType.RParen */
                );
                break;
              case 33:
                if (this._match(
                  61
                  /* CharCode.Equals */
                )) {
                  const isTripleEq = this._match(
                    61
                    /* CharCode.Equals */
                  );
                  this._tokens.push({ type: 4, offset: this._start, isTripleEq });
                } else {
                  this._addToken(
                    2
                    /* TokenType.Neg */
                  );
                }
                break;
              case 39:
                this._quotedString();
                break;
              case 47:
                this._regex();
                break;
              case 61:
                if (this._match(
                  61
                  /* CharCode.Equals */
                )) {
                  const isTripleEq = this._match(
                    61
                    /* CharCode.Equals */
                  );
                  this._tokens.push({ type: 3, offset: this._start, isTripleEq });
                } else if (this._match(
                  126
                  /* CharCode.Tilde */
                )) {
                  this._addToken(
                    9
                    /* TokenType.RegexOp */
                  );
                } else {
                  this._error(hintDidYouMean("==", "=~"));
                }
                break;
              case 60:
                this._addToken(
                  this._match(
                    61
                    /* CharCode.Equals */
                  ) ? 6 : 5
                  /* TokenType.Lt */
                );
                break;
              case 62:
                this._addToken(
                  this._match(
                    61
                    /* CharCode.Equals */
                  ) ? 8 : 7
                  /* TokenType.Gt */
                );
                break;
              case 38:
                if (this._match(
                  38
                  /* CharCode.Ampersand */
                )) {
                  this._addToken(
                    15
                    /* TokenType.And */
                  );
                } else {
                  this._error(hintDidYouMean("&&"));
                }
                break;
              case 124:
                if (this._match(
                  124
                  /* CharCode.Pipe */
                )) {
                  this._addToken(
                    16
                    /* TokenType.Or */
                  );
                } else {
                  this._error(hintDidYouMean("||"));
                }
                break;
              case 32:
              case 13:
              case 9:
              case 10:
              case 160:
                break;
              default:
                this._string();
            }
          }
          this._start = this._current;
          this._addToken(
            20
            /* TokenType.EOF */
          );
          return Array.from(this._tokens);
        }
        _match(expected) {
          if (this._isAtEnd()) {
            return false;
          }
          if (this._input.charCodeAt(this._current) !== expected) {
            return false;
          }
          this._current++;
          return true;
        }
        _advance() {
          return this._input.charCodeAt(this._current++);
        }
        _peek() {
          return this._isAtEnd() ? 0 : this._input.charCodeAt(this._current);
        }
        _addToken(type) {
          this._tokens.push({ type, offset: this._start });
        }
        _error(additional) {
          const offset = this._start;
          const lexeme = this._input.substring(this._start, this._current);
          const errToken = { type: 19, offset: this._start, lexeme };
          this._errors.push({ offset, lexeme, additionalInfo: additional });
          this._tokens.push(errToken);
        }
        _string() {
          this.stringRe.lastIndex = this._start;
          const match = this.stringRe.exec(this._input);
          if (match) {
            this._current = this._start + match[0].length;
            const lexeme = this._input.substring(this._start, this._current);
            const keyword = Scanner._keywords.get(lexeme);
            if (keyword) {
              this._addToken(keyword);
            } else {
              this._tokens.push({ type: 17, lexeme, offset: this._start });
            }
          }
        }
        // captures the lexeme without the leading and trailing '
        _quotedString() {
          while (this._peek() !== 39 && !this._isAtEnd()) {
            this._advance();
          }
          if (this._isAtEnd()) {
            this._error(hintDidYouForgetToOpenOrCloseQuote);
            return;
          }
          this._advance();
          this._tokens.push({ type: 18, lexeme: this._input.substring(this._start + 1, this._current - 1), offset: this._start + 1 });
        }
        /*
         * Lexing a regex expression: /.../[igsmyu]*
         * Based on https://github.com/microsoft/TypeScript/blob/9247ef115e617805983740ba795d7a8164babf89/src/compiler/scanner.ts#L2129-L2181
         *
         * Note that we want slashes within a regex to be escaped, e.g., /file:\\/\\/\\// should match `file:///`
         */
        _regex() {
          let p = this._current;
          let inEscape = false;
          let inCharacterClass = false;
          while (true) {
            if (p >= this._input.length) {
              this._current = p;
              this._error(hintDidYouForgetToEscapeSlash);
              return;
            }
            const ch = this._input.charCodeAt(p);
            if (inEscape) {
              inEscape = false;
            } else if (ch === 47 && !inCharacterClass) {
              p++;
              break;
            } else if (ch === 91) {
              inCharacterClass = true;
            } else if (ch === 92) {
              inEscape = true;
            } else if (ch === 93) {
              inCharacterClass = false;
            }
            p++;
          }
          while (p < this._input.length && Scanner._regexFlags.has(this._input.charCodeAt(p))) {
            p++;
          }
          this._current = p;
          const lexeme = this._input.substring(this._start, this._current);
          this._tokens.push({ type: 10, lexeme, offset: this._start });
        }
        _isAtEnd() {
          return this._current >= this._input.length;
        }
      };
      Scanner._regexFlags = new Set(["i", "g", "s", "m", "y", "u"].map((ch) => ch.charCodeAt(0)));
      Scanner._keywords = /* @__PURE__ */ new Map([
        [
          "not",
          14
          /* TokenType.Not */
        ],
        [
          "in",
          13
          /* TokenType.In */
        ],
        [
          "false",
          12
          /* TokenType.False */
        ],
        [
          "true",
          11
          /* TokenType.True */
        ]
      ]);
    }
  });

  // node_modules/monaco-editor/esm/vs/platform/contextkey/common/contextkey.js
  function cmp(a, b) {
    return a.cmp(b);
  }
  function withFloatOrStr(value, callback) {
    if (typeof value === "string") {
      const n = parseFloat(value);
      if (!isNaN(n)) {
        value = n;
      }
    }
    if (typeof value === "string" || typeof value === "number") {
      return callback(value);
    }
    return ContextKeyFalseExpr.INSTANCE;
  }
  function eliminateConstantsInArray(arr) {
    let newArr = null;
    for (let i = 0, len = arr.length; i < len; i++) {
      const newExpr = arr[i].substituteConstants();
      if (arr[i] !== newExpr) {
        if (newArr === null) {
          newArr = [];
          for (let j = 0; j < i; j++) {
            newArr[j] = arr[j];
          }
        }
      }
      if (newArr !== null) {
        newArr[i] = newExpr;
      }
    }
    if (newArr === null) {
      return arr;
    }
    return newArr;
  }
  function cmp1(key1, key2) {
    if (key1 < key2) {
      return -1;
    }
    if (key1 > key2) {
      return 1;
    }
    return 0;
  }
  function cmp2(key1, value1, key2, value2) {
    if (key1 < key2) {
      return -1;
    }
    if (key1 > key2) {
      return 1;
    }
    if (value1 < value2) {
      return -1;
    }
    if (value1 > value2) {
      return 1;
    }
    return 0;
  }
  function getTerminals(node) {
    if (node.type === 9) {
      return node.expr;
    }
    return [node];
  }
  var CONSTANT_VALUES, hasOwnProperty, defaultConfig, errorEmptyString, hintEmptyString, errorNoInAfterNot, errorClosingParenthesis, errorUnexpectedToken, hintUnexpectedToken, errorUnexpectedEOF, hintUnexpectedEOF, Parser, ContextKeyExpr, ContextKeyFalseExpr, ContextKeyTrueExpr, ContextKeyDefinedExpr, ContextKeyEqualsExpr, ContextKeyInExpr, ContextKeyNotInExpr, ContextKeyNotEqualsExpr, ContextKeyNotExpr, ContextKeyGreaterExpr, ContextKeyGreaterEqualsExpr, ContextKeySmallerExpr, ContextKeySmallerEqualsExpr, ContextKeyRegexExpr, ContextKeyNotRegexExpr, ContextKeyAndExpr, ContextKeyOrExpr, RawContextKey, IContextKeyService;
  var init_contextkey = __esm({
    "node_modules/monaco-editor/esm/vs/platform/contextkey/common/contextkey.js"() {
      init_platform();
      init_strings();
      init_scanner();
      init_instantiation();
      init_nls();
      init_errors();
      CONSTANT_VALUES = /* @__PURE__ */ new Map();
      CONSTANT_VALUES.set("false", false);
      CONSTANT_VALUES.set("true", true);
      CONSTANT_VALUES.set("isMac", isMacintosh);
      CONSTANT_VALUES.set("isLinux", isLinux);
      CONSTANT_VALUES.set("isWindows", isWindows);
      CONSTANT_VALUES.set("isWeb", isWeb);
      CONSTANT_VALUES.set("isMacNative", isMacintosh && !isWeb);
      CONSTANT_VALUES.set("isEdge", isEdge);
      CONSTANT_VALUES.set("isFirefox", isFirefox);
      CONSTANT_VALUES.set("isChrome", isChrome);
      CONSTANT_VALUES.set("isSafari", isSafari);
      hasOwnProperty = Object.prototype.hasOwnProperty;
      defaultConfig = {
        regexParsingWithErrorRecovery: true
      };
      errorEmptyString = localize("contextkey.parser.error.emptyString", "Empty context key expression");
      hintEmptyString = localize("contextkey.parser.error.emptyString.hint", "Did you forget to write an expression? You can also put 'false' or 'true' to always evaluate to false or true, respectively.");
      errorNoInAfterNot = localize("contextkey.parser.error.noInAfterNot", "'in' after 'not'.");
      errorClosingParenthesis = localize("contextkey.parser.error.closingParenthesis", "closing parenthesis ')'");
      errorUnexpectedToken = localize("contextkey.parser.error.unexpectedToken", "Unexpected token");
      hintUnexpectedToken = localize("contextkey.parser.error.unexpectedToken.hint", "Did you forget to put && or || before the token?");
      errorUnexpectedEOF = localize("contextkey.parser.error.unexpectedEOF", "Unexpected end of expression");
      hintUnexpectedEOF = localize("contextkey.parser.error.unexpectedEOF.hint", "Did you forget to put a context key?");
      Parser = class {
        get lexingErrors() {
          return this._scanner.errors;
        }
        get parsingErrors() {
          return this._parsingErrors;
        }
        constructor(_config = defaultConfig) {
          this._config = _config;
          this._scanner = new Scanner();
          this._tokens = [];
          this._current = 0;
          this._parsingErrors = [];
          this._flagsGYRe = /g|y/g;
        }
        /**
         * Parse a context key expression.
         *
         * @param input the expression to parse
         * @returns the parsed expression or `undefined` if there's an error - call `lexingErrors` and `parsingErrors` to see the errors
         */
        parse(input) {
          if (input === "") {
            this._parsingErrors.push({ message: errorEmptyString, offset: 0, lexeme: "", additionalInfo: hintEmptyString });
            return void 0;
          }
          this._tokens = this._scanner.reset(input).scan();
          this._current = 0;
          this._parsingErrors = [];
          try {
            const expr = this._expr();
            if (!this._isAtEnd()) {
              const peek = this._peek();
              const additionalInfo = peek.type === 17 ? hintUnexpectedToken : void 0;
              this._parsingErrors.push({ message: errorUnexpectedToken, offset: peek.offset, lexeme: Scanner.getLexeme(peek), additionalInfo });
              throw Parser._parseError;
            }
            return expr;
          } catch (e) {
            if (!(e === Parser._parseError)) {
              throw e;
            }
            return void 0;
          }
        }
        _expr() {
          return this._or();
        }
        _or() {
          const expr = [this._and()];
          while (this._matchOne(
            16
            /* TokenType.Or */
          )) {
            const right = this._and();
            expr.push(right);
          }
          return expr.length === 1 ? expr[0] : ContextKeyExpr.or(...expr);
        }
        _and() {
          const expr = [this._term()];
          while (this._matchOne(
            15
            /* TokenType.And */
          )) {
            const right = this._term();
            expr.push(right);
          }
          return expr.length === 1 ? expr[0] : ContextKeyExpr.and(...expr);
        }
        _term() {
          if (this._matchOne(
            2
            /* TokenType.Neg */
          )) {
            const peek = this._peek();
            switch (peek.type) {
              case 11:
                this._advance();
                return ContextKeyFalseExpr.INSTANCE;
              case 12:
                this._advance();
                return ContextKeyTrueExpr.INSTANCE;
              case 0: {
                this._advance();
                const expr = this._expr();
                this._consume(1, errorClosingParenthesis);
                return expr === null || expr === void 0 ? void 0 : expr.negate();
              }
              case 17:
                this._advance();
                return ContextKeyNotExpr.create(peek.lexeme);
              default:
                throw this._errExpectedButGot(`KEY | true | false | '(' expression ')'`, peek);
            }
          }
          return this._primary();
        }
        _primary() {
          const peek = this._peek();
          switch (peek.type) {
            case 11:
              this._advance();
              return ContextKeyExpr.true();
            case 12:
              this._advance();
              return ContextKeyExpr.false();
            case 0: {
              this._advance();
              const expr = this._expr();
              this._consume(1, errorClosingParenthesis);
              return expr;
            }
            case 17: {
              const key = peek.lexeme;
              this._advance();
              if (this._matchOne(
                9
                /* TokenType.RegexOp */
              )) {
                const expr = this._peek();
                if (!this._config.regexParsingWithErrorRecovery) {
                  this._advance();
                  if (expr.type !== 10) {
                    throw this._errExpectedButGot(`REGEX`, expr);
                  }
                  const regexLexeme = expr.lexeme;
                  const closingSlashIndex = regexLexeme.lastIndexOf("/");
                  const flags = closingSlashIndex === regexLexeme.length - 1 ? void 0 : this._removeFlagsGY(regexLexeme.substring(closingSlashIndex + 1));
                  let regexp;
                  try {
                    regexp = new RegExp(regexLexeme.substring(1, closingSlashIndex), flags);
                  } catch (e) {
                    throw this._errExpectedButGot(`REGEX`, expr);
                  }
                  return ContextKeyRegexExpr.create(key, regexp);
                }
                switch (expr.type) {
                  case 10:
                  case 19: {
                    const lexemeReconstruction = [expr.lexeme];
                    this._advance();
                    let followingToken = this._peek();
                    let parenBalance = 0;
                    for (let i = 0; i < expr.lexeme.length; i++) {
                      if (expr.lexeme.charCodeAt(i) === 40) {
                        parenBalance++;
                      } else if (expr.lexeme.charCodeAt(i) === 41) {
                        parenBalance--;
                      }
                    }
                    while (!this._isAtEnd() && followingToken.type !== 15 && followingToken.type !== 16) {
                      switch (followingToken.type) {
                        case 0:
                          parenBalance++;
                          break;
                        case 1:
                          parenBalance--;
                          break;
                        case 10:
                        case 18:
                          for (let i = 0; i < followingToken.lexeme.length; i++) {
                            if (followingToken.lexeme.charCodeAt(i) === 40) {
                              parenBalance++;
                            } else if (expr.lexeme.charCodeAt(i) === 41) {
                              parenBalance--;
                            }
                          }
                      }
                      if (parenBalance < 0) {
                        break;
                      }
                      lexemeReconstruction.push(Scanner.getLexeme(followingToken));
                      this._advance();
                      followingToken = this._peek();
                    }
                    const regexLexeme = lexemeReconstruction.join("");
                    const closingSlashIndex = regexLexeme.lastIndexOf("/");
                    const flags = closingSlashIndex === regexLexeme.length - 1 ? void 0 : this._removeFlagsGY(regexLexeme.substring(closingSlashIndex + 1));
                    let regexp;
                    try {
                      regexp = new RegExp(regexLexeme.substring(1, closingSlashIndex), flags);
                    } catch (e) {
                      throw this._errExpectedButGot(`REGEX`, expr);
                    }
                    return ContextKeyExpr.regex(key, regexp);
                  }
                  case 18: {
                    const serializedValue = expr.lexeme;
                    this._advance();
                    let regex = null;
                    if (!isFalsyOrWhitespace(serializedValue)) {
                      const start = serializedValue.indexOf("/");
                      const end = serializedValue.lastIndexOf("/");
                      if (start !== end && start >= 0) {
                        const value = serializedValue.slice(start + 1, end);
                        const caseIgnoreFlag = serializedValue[end + 1] === "i" ? "i" : "";
                        try {
                          regex = new RegExp(value, caseIgnoreFlag);
                        } catch (_e) {
                          throw this._errExpectedButGot(`REGEX`, expr);
                        }
                      }
                    }
                    if (regex === null) {
                      throw this._errExpectedButGot("REGEX", expr);
                    }
                    return ContextKeyRegexExpr.create(key, regex);
                  }
                  default:
                    throw this._errExpectedButGot("REGEX", this._peek());
                }
              }
              if (this._matchOne(
                14
                /* TokenType.Not */
              )) {
                this._consume(13, errorNoInAfterNot);
                const right = this._value();
                return ContextKeyExpr.notIn(key, right);
              }
              const maybeOp = this._peek().type;
              switch (maybeOp) {
                case 3: {
                  this._advance();
                  const right = this._value();
                  if (this._previous().type === 18) {
                    return ContextKeyExpr.equals(key, right);
                  }
                  switch (right) {
                    case "true":
                      return ContextKeyExpr.has(key);
                    case "false":
                      return ContextKeyExpr.not(key);
                    default:
                      return ContextKeyExpr.equals(key, right);
                  }
                }
                case 4: {
                  this._advance();
                  const right = this._value();
                  if (this._previous().type === 18) {
                    return ContextKeyExpr.notEquals(key, right);
                  }
                  switch (right) {
                    case "true":
                      return ContextKeyExpr.not(key);
                    case "false":
                      return ContextKeyExpr.has(key);
                    default:
                      return ContextKeyExpr.notEquals(key, right);
                  }
                }
                case 5:
                  this._advance();
                  return ContextKeySmallerExpr.create(key, this._value());
                case 6:
                  this._advance();
                  return ContextKeySmallerEqualsExpr.create(key, this._value());
                case 7:
                  this._advance();
                  return ContextKeyGreaterExpr.create(key, this._value());
                case 8:
                  this._advance();
                  return ContextKeyGreaterEqualsExpr.create(key, this._value());
                case 13:
                  this._advance();
                  return ContextKeyExpr.in(key, this._value());
                default:
                  return ContextKeyExpr.has(key);
              }
            }
            case 20:
              this._parsingErrors.push({ message: errorUnexpectedEOF, offset: peek.offset, lexeme: "", additionalInfo: hintUnexpectedEOF });
              throw Parser._parseError;
            default:
              throw this._errExpectedButGot(`true | false | KEY 
	| KEY '=~' REGEX 
	| KEY ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in') value`, this._peek());
          }
        }
        _value() {
          const token = this._peek();
          switch (token.type) {
            case 17:
            case 18:
              this._advance();
              return token.lexeme;
            case 11:
              this._advance();
              return "true";
            case 12:
              this._advance();
              return "false";
            case 13:
              this._advance();
              return "in";
            default:
              return "";
          }
        }
        _removeFlagsGY(flags) {
          return flags.replaceAll(this._flagsGYRe, "");
        }
        // careful: this can throw if current token is the initial one (ie index = 0)
        _previous() {
          return this._tokens[this._current - 1];
        }
        _matchOne(token) {
          if (this._check(token)) {
            this._advance();
            return true;
          }
          return false;
        }
        _advance() {
          if (!this._isAtEnd()) {
            this._current++;
          }
          return this._previous();
        }
        _consume(type, message) {
          if (this._check(type)) {
            return this._advance();
          }
          throw this._errExpectedButGot(message, this._peek());
        }
        _errExpectedButGot(expected, got, additionalInfo) {
          const message = localize("contextkey.parser.error.expectedButGot", "Expected: {0}\nReceived: '{1}'.", expected, Scanner.getLexeme(got));
          const offset = got.offset;
          const lexeme = Scanner.getLexeme(got);
          this._parsingErrors.push({ message, offset, lexeme, additionalInfo });
          return Parser._parseError;
        }
        _check(type) {
          return this._peek().type === type;
        }
        _peek() {
          return this._tokens[this._current];
        }
        _isAtEnd() {
          return this._peek().type === 20;
        }
      };
      Parser._parseError = new Error();
      ContextKeyExpr = class {
        static false() {
          return ContextKeyFalseExpr.INSTANCE;
        }
        static true() {
          return ContextKeyTrueExpr.INSTANCE;
        }
        static has(key) {
          return ContextKeyDefinedExpr.create(key);
        }
        static equals(key, value) {
          return ContextKeyEqualsExpr.create(key, value);
        }
        static notEquals(key, value) {
          return ContextKeyNotEqualsExpr.create(key, value);
        }
        static regex(key, value) {
          return ContextKeyRegexExpr.create(key, value);
        }
        static in(key, value) {
          return ContextKeyInExpr.create(key, value);
        }
        static notIn(key, value) {
          return ContextKeyNotInExpr.create(key, value);
        }
        static not(key) {
          return ContextKeyNotExpr.create(key);
        }
        static and(...expr) {
          return ContextKeyAndExpr.create(expr, null, true);
        }
        static or(...expr) {
          return ContextKeyOrExpr.create(expr, null, true);
        }
        static greater(key, value) {
          return ContextKeyGreaterExpr.create(key, value);
        }
        static greaterEquals(key, value) {
          return ContextKeyGreaterEqualsExpr.create(key, value);
        }
        static smaller(key, value) {
          return ContextKeySmallerExpr.create(key, value);
        }
        static smallerEquals(key, value) {
          return ContextKeySmallerEqualsExpr.create(key, value);
        }
        static deserialize(serialized) {
          if (serialized === void 0 || serialized === null) {
            return void 0;
          }
          const expr = this._parser.parse(serialized);
          return expr;
        }
      };
      ContextKeyExpr._parser = new Parser({ regexParsingWithErrorRecovery: false });
      ContextKeyFalseExpr = class {
        constructor() {
          this.type = 0;
        }
        cmp(other) {
          return this.type - other.type;
        }
        equals(other) {
          return other.type === this.type;
        }
        substituteConstants() {
          return this;
        }
        evaluate(context) {
          return false;
        }
        serialize() {
          return "false";
        }
        keys() {
          return [];
        }
        map(mapFnc) {
          return this;
        }
        negate() {
          return ContextKeyTrueExpr.INSTANCE;
        }
      };
      ContextKeyFalseExpr.INSTANCE = new ContextKeyFalseExpr();
      ContextKeyTrueExpr = class {
        constructor() {
          this.type = 1;
        }
        cmp(other) {
          return this.type - other.type;
        }
        equals(other) {
          return other.type === this.type;
        }
        substituteConstants() {
          return this;
        }
        evaluate(context) {
          return true;
        }
        serialize() {
          return "true";
        }
        keys() {
          return [];
        }
        map(mapFnc) {
          return this;
        }
        negate() {
          return ContextKeyFalseExpr.INSTANCE;
        }
      };
      ContextKeyTrueExpr.INSTANCE = new ContextKeyTrueExpr();
      ContextKeyDefinedExpr = class {
        static create(key, negated = null) {
          const constantValue = CONSTANT_VALUES.get(key);
          if (typeof constantValue === "boolean") {
            return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;
          }
          return new ContextKeyDefinedExpr(key, negated);
        }
        constructor(key, negated) {
          this.key = key;
          this.negated = negated;
          this.type = 2;
        }
        cmp(other) {
          if (other.type !== this.type) {
            return this.type - other.type;
          }
          return cmp1(this.key, other.key);
        }
        equals(other) {
          if (other.type === this.type) {
            return this.key === other.key;
          }
          return false;
        }
        substituteConstants() {
          const constantValue = CONSTANT_VALUES.get(this.key);
          if (typeof constantValue === "boolean") {
            return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;
          }
          return this;
        }
        evaluate(context) {
          return !!context.getValue(this.key);
        }
        serialize() {
          return this.key;
        }
        keys() {
          return [this.key];
        }
        map(mapFnc) {
          return mapFnc.mapDefined(this.key);
        }
        negate() {
          if (!this.negated) {
            this.negated = ContextKeyNotExpr.create(this.key, this);
          }
          return this.negated;
        }
      };
      ContextKeyEqualsExpr = class {
        static create(key, value, negated = null) {
          if (typeof value === "boolean") {
            return value ? ContextKeyDefinedExpr.create(key, negated) : ContextKeyNotExpr.create(key, negated);
          }
          const constantValue = CONSTANT_VALUES.get(key);
          if (typeof constantValue === "boolean") {
            const trueValue = constantValue ? "true" : "false";
            return value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;
          }
          return new ContextKeyEqualsExpr(key, value, negated);
        }
        constructor(key, value, negated) {
          this.key = key;
          this.value = value;
          this.negated = negated;
          this.type = 4;
        }
        cmp(other) {
          if (other.type !== this.type) {
            return this.type - other.type;
          }
          return cmp2(this.key, this.value, other.key, other.value);
        }
        equals(other) {
          if (other.type === this.type) {
            return this.key === other.key && this.value === other.value;
          }
          return false;
        }
        substituteConstants() {
          const constantValue = CONSTANT_VALUES.get(this.key);
          if (typeof constantValue === "boolean") {
            const trueValue = constantValue ? "true" : "false";
            return this.value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;
          }
          return this;
        }
        evaluate(context) {
          return context.getValue(this.key) == this.value;
        }
        serialize() {
          return `${this.key} == '${this.value}'`;
        }
        keys() {
          return [this.key];
        }
        map(mapFnc) {
          return mapFnc.mapEquals(this.key, this.value);
        }
        negate() {
          if (!this.negated) {
            this.negated = ContextKeyNotEqualsExpr.create(this.key, this.value, this);
          }
          return this.negated;
        }
      };
      ContextKeyInExpr = class {
        static create(key, valueKey) {
          return new ContextKeyInExpr(key, valueKey);
        }
        constructor(key, valueKey) {
          this.key = key;
          this.valueKey = valueKey;
          this.type = 10;
          this.negated = null;
        }
        cmp(other) {
          if (other.type !== this.type) {
            return this.type - other.type;
          }
          return cmp2(this.key, this.valueKey, other.key, other.valueKey);
        }
        equals(other) {
          if (other.type === this.type) {
            return this.key === other.key && this.valueKey === other.valueKey;
          }
          return false;
        }
        substituteConstants() {
          return this;
        }
        evaluate(context) {
          const source = context.getValue(this.valueKey);
          const item = context.getValue(this.key);
          if (Array.isArray(source)) {
            return source.includes(item);
          }
          if (typeof item === "string" && typeof source === "object" && source !== null) {
            return hasOwnProperty.call(source, item);
          }
          return false;
        }
        serialize() {
          return `${this.key} in '${this.valueKey}'`;
        }
        keys() {
          return [this.key, this.valueKey];
        }
        map(mapFnc) {
          return mapFnc.mapIn(this.key, this.valueKey);
        }
        negate() {
          if (!this.negated) {
            this.negated = ContextKeyNotInExpr.create(this.key, this.valueKey);
          }
          return this.negated;
        }
      };
      ContextKeyNotInExpr = class {
        static create(key, valueKey) {
          return new ContextKeyNotInExpr(key, valueKey);
        }
        constructor(key, valueKey) {
          this.key = key;
          this.valueKey = valueKey;
          this.type = 11;
          this._negated = ContextKeyInExpr.create(key, valueKey);
        }
        cmp(other) {
          if (other.type !== this.type) {
            return this.type - other.type;
          }
          return this._negated.cmp(other._negated);
        }
        equals(other) {
          if (other.type === this.type) {
            return this._negated.equals(other._negated);
          }
          return false;
        }
        substituteConstants() {
          return this;
        }
        evaluate(context) {
          return !this._negated.evaluate(context);
        }
        serialize() {
          return `${this.key} not in '${this.valueKey}'`;
        }
        keys() {
          return this._negated.keys();
        }
        map(mapFnc) {
          return mapFnc.mapNotIn(this.key, this.valueKey);
        }
        negate() {
          return this._negated;
        }
      };
      ContextKeyNotEqualsExpr = class {
        static create(key, value, negated = null) {
          if (typeof value === "boolean") {
            if (value) {
              return ContextKeyNotExpr.create(key, negated);
            }
            return ContextKeyDefinedExpr.create(key, negated);
          }
          const constantValue = CONSTANT_VALUES.get(key);
          if (typeof constantValue === "boolean") {
            const falseValue = constantValue ? "true" : "false";
            return value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;
          }
          return new ContextKeyNotEqualsExpr(key, value, negated);
        }
        constructor(key, value, negated) {
          this.key = key;
          this.value = value;
          this.negated = negated;
          this.type = 5;
        }
        cmp(other) {
          if (other.type !== this.type) {
            return this.type - other.type;
          }
          return cmp2(this.key, this.value, other.key, other.value);
        }
        equals(other) {
          if (other.type === this.type) {
            return this.key === other.key && this.value === other.value;
          }
          return false;
        }
        substituteConstants() {
          const constantValue = CONSTANT_VALUES.get(this.key);
          if (typeof constantValue === "boolean") {
            const falseValue = constantValue ? "true" : "false";
            return this.value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;
          }
          return this;
        }
        evaluate(context) {
          return context.getValue(this.key) != this.value;
        }
        serialize() {
          return `${this.key} != '${this.value}'`;
        }
        keys() {
          return [this.key];
        }
        map(mapFnc) {
          return mapFnc.mapNotEquals(this.key, this.value);
        }
        negate() {
          if (!this.negated) {
            this.negated = ContextKeyEqualsExpr.create(this.key, this.value, this);
          }
          return this.negated;
        }
      };
      ContextKeyNotExpr = class {
        static create(key, negated = null) {
          const constantValue = CONSTANT_VALUES.get(key);
          if (typeof constantValue === "boolean") {
            return constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;
          }
          return new ContextKeyNotExpr(key, negated);
        }
        constructor(key, negated) {
          this.key = key;
          this.negated = negated;
          this.type = 3;
        }
        cmp(other) {
          if (other.type !== this.type) {
            return this.type - other.type;
          }
          return cmp1(this.key, other.key);
        }
        equals(other) {
          if (other.type === this.type) {
            return this.key === other.key;
          }
          return false;
        }
        substituteConstants() {
          const constantValue = CONSTANT_VALUES.get(this.key);
          if (typeof constantValue === "boolean") {
            return constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;
          }
          return this;
        }
        evaluate(context) {
          return !context.getValue(this.key);
        }
        serialize() {
          return `!${this.key}`;
        }
        keys() {
          return [this.key];
        }
        map(mapFnc) {
          return mapFnc.mapNot(this.key);
        }
        negate() {
          if (!this.negated) {
            this.negated = ContextKeyDefinedExpr.create(this.key, this);
          }
          return this.negated;
        }
      };
      ContextKeyGreaterExpr = class {
        static create(key, _value, negated = null) {
          return withFloatOrStr(_value, (value) => new ContextKeyGreaterExpr(key, value, negated));
        }
        constructor(key, value, negated) {
          this.key = key;
          this.value = value;
          this.negated = negated;
          this.type = 12;
        }
        cmp(other) {
          if (other.type !== this.type) {
            return this.type - other.type;
          }
          return cmp2(this.key, this.value, other.key, other.value);
        }
        equals(other) {
          if (other.type === this.type) {
            return this.key === other.key && this.value === other.value;
          }
          return false;
        }
        substituteConstants() {
          return this;
        }
        evaluate(context) {
          if (typeof this.value === "string") {
            return false;
          }
          return parseFloat(context.getValue(this.key)) > this.value;
        }
        serialize() {
          return `${this.key} > ${this.value}`;
        }
        keys() {
          return [this.key];
        }
        map(mapFnc) {
          return mapFnc.mapGreater(this.key, this.value);
        }
        negate() {
          if (!this.negated) {
            this.negated = ContextKeySmallerEqualsExpr.create(this.key, this.value, this);
          }
          return this.negated;
        }
      };
      ContextKeyGreaterEqualsExpr = class {
        static create(key, _value, negated = null) {
          return withFloatOrStr(_value, (value) => new ContextKeyGreaterEqualsExpr(key, value, negated));
        }
        constructor(key, value, negated) {
          this.key = key;
          this.value = value;
          this.negated = negated;
          this.type = 13;
        }
        cmp(other) {
          if (other.type !== this.type) {
            return this.type - other.type;
          }
          return cmp2(this.key, this.value, other.key, other.value);
        }
        equals(other) {
          if (other.type === this.type) {
            return this.key === other.key && this.value === other.value;
          }
          return false;
        }
        substituteConstants() {
          return this;
        }
        evaluate(context) {
          if (typeof this.value === "string") {
            return false;
          }
          return parseFloat(context.getValue(this.key)) >= this.value;
        }
        serialize() {
          return `${this.key} >= ${this.value}`;
        }
        keys() {
          return [this.key];
        }
        map(mapFnc) {
          return mapFnc.mapGreaterEquals(this.key, this.value);
        }
        negate() {
          if (!this.negated) {
            this.negated = ContextKeySmallerExpr.create(this.key, this.value, this);
          }
          return this.negated;
        }
      };
      ContextKeySmallerExpr = class {
        static create(key, _value, negated = null) {
          return withFloatOrStr(_value, (value) => new ContextKeySmallerExpr(key, value, negated));
        }
        constructor(key, value, negated) {
          this.key = key;
          this.value = value;
          this.negated = negated;
          this.type = 14;
        }
        cmp(other) {
          if (other.type !== this.type) {
            return this.type - other.type;
          }
          return cmp2(this.key, this.value, other.key, other.value);
        }
        equals(other) {
          if (other.type === this.type) {
            return this.key === other.key && this.value === other.value;
          }
          return false;
        }
        substituteConstants() {
          return this;
        }
        evaluate(context) {
          if (typeof this.value === "string") {
            return false;
          }
          return parseFloat(context.getValue(this.key)) < this.value;
        }
        serialize() {
          return `${this.key} < ${this.value}`;
        }
        keys() {
          return [this.key];
        }
        map(mapFnc) {
          return mapFnc.mapSmaller(this.key, this.value);
        }
        negate() {
          if (!this.negated) {
            this.negated = ContextKeyGreaterEqualsExpr.create(this.key, this.value, this);
          }
          return this.negated;
        }
      };
      ContextKeySmallerEqualsExpr = class {
        static create(key, _value, negated = null) {
          return withFloatOrStr(_value, (value) => new ContextKeySmallerEqualsExpr(key, value, negated));
        }
        constructor(key, value, negated) {
          this.key = key;
          this.value = value;
          this.negated = negated;
          this.type = 15;
        }
        cmp(other) {
          if (other.type !== this.type) {
            return this.type - other.type;
          }
          return cmp2(this.key, this.value, other.key, other.value);
        }
        equals(other) {
          if (other.type === this.type) {
            return this.key === other.key && this.value === other.value;
          }
          return false;
        }
        substituteConstants() {
          return this;
        }
        evaluate(context) {
          if (typeof this.value === "string") {
            return false;
          }
          return parseFloat(context.getValue(this.key)) <= this.value;
        }
        serialize() {
          return `${this.key} <= ${this.value}`;
        }
        keys() {
          return [this.key];
        }
        map(mapFnc) {
          return mapFnc.mapSmallerEquals(this.key, this.value);
        }
        negate() {
          if (!this.negated) {
            this.negated = ContextKeyGreaterExpr.create(this.key, this.value, this);
          }
          return this.negated;
        }
      };
      ContextKeyRegexExpr = class {
        static create(key, regexp) {
          return new ContextKeyRegexExpr(key, regexp);
        }
        constructor(key, regexp) {
          this.key = key;
          this.regexp = regexp;
          this.type = 7;
          this.negated = null;
        }
        cmp(other) {
          if (other.type !== this.type) {
            return this.type - other.type;
          }
          if (this.key < other.key) {
            return -1;
          }
          if (this.key > other.key) {
            return 1;
          }
          const thisSource = this.regexp ? this.regexp.source : "";
          const otherSource = other.regexp ? other.regexp.source : "";
          if (thisSource < otherSource) {
            return -1;
          }
          if (thisSource > otherSource) {
            return 1;
          }
          return 0;
        }
        equals(other) {
          if (other.type === this.type) {
            const thisSource = this.regexp ? this.regexp.source : "";
            const otherSource = other.regexp ? other.regexp.source : "";
            return this.key === other.key && thisSource === otherSource;
          }
          return false;
        }
        substituteConstants() {
          return this;
        }
        evaluate(context) {
          const value = context.getValue(this.key);
          return this.regexp ? this.regexp.test(value) : false;
        }
        serialize() {
          const value = this.regexp ? `/${this.regexp.source}/${this.regexp.flags}` : "/invalid/";
          return `${this.key} =~ ${value}`;
        }
        keys() {
          return [this.key];
        }
        map(mapFnc) {
          return mapFnc.mapRegex(this.key, this.regexp);
        }
        negate() {
          if (!this.negated) {
            this.negated = ContextKeyNotRegexExpr.create(this);
          }
          return this.negated;
        }
      };
      ContextKeyNotRegexExpr = class {
        static create(actual) {
          return new ContextKeyNotRegexExpr(actual);
        }
        constructor(_actual) {
          this._actual = _actual;
          this.type = 8;
        }
        cmp(other) {
          if (other.type !== this.type) {
            return this.type - other.type;
          }
          return this._actual.cmp(other._actual);
        }
        equals(other) {
          if (other.type === this.type) {
            return this._actual.equals(other._actual);
          }
          return false;
        }
        substituteConstants() {
          return this;
        }
        evaluate(context) {
          return !this._actual.evaluate(context);
        }
        serialize() {
          return `!(${this._actual.serialize()})`;
        }
        keys() {
          return this._actual.keys();
        }
        map(mapFnc) {
          return new ContextKeyNotRegexExpr(this._actual.map(mapFnc));
        }
        negate() {
          return this._actual;
        }
      };
      ContextKeyAndExpr = class {
        static create(_expr, negated, extraRedundantCheck) {
          return ContextKeyAndExpr._normalizeArr(_expr, negated, extraRedundantCheck);
        }
        constructor(expr, negated) {
          this.expr = expr;
          this.negated = negated;
          this.type = 6;
        }
        cmp(other) {
          if (other.type !== this.type) {
            return this.type - other.type;
          }
          if (this.expr.length < other.expr.length) {
            return -1;
          }
          if (this.expr.length > other.expr.length) {
            return 1;
          }
          for (let i = 0, len = this.expr.length; i < len; i++) {
            const r = cmp(this.expr[i], other.expr[i]);
            if (r !== 0) {
              return r;
            }
          }
          return 0;
        }
        equals(other) {
          if (other.type === this.type) {
            if (this.expr.length !== other.expr.length) {
              return false;
            }
            for (let i = 0, len = this.expr.length; i < len; i++) {
              if (!this.expr[i].equals(other.expr[i])) {
                return false;
              }
            }
            return true;
          }
          return false;
        }
        substituteConstants() {
          const exprArr = eliminateConstantsInArray(this.expr);
          if (exprArr === this.expr) {
            return this;
          }
          return ContextKeyAndExpr.create(exprArr, this.negated, false);
        }
        evaluate(context) {
          for (let i = 0, len = this.expr.length; i < len; i++) {
            if (!this.expr[i].evaluate(context)) {
              return false;
            }
          }
          return true;
        }
        static _normalizeArr(arr, negated, extraRedundantCheck) {
          const expr = [];
          let hasTrue = false;
          for (const e of arr) {
            if (!e) {
              continue;
            }
            if (e.type === 1) {
              hasTrue = true;
              continue;
            }
            if (e.type === 0) {
              return ContextKeyFalseExpr.INSTANCE;
            }
            if (e.type === 6) {
              expr.push(...e.expr);
              continue;
            }
            expr.push(e);
          }
          if (expr.length === 0 && hasTrue) {
            return ContextKeyTrueExpr.INSTANCE;
          }
          if (expr.length === 0) {
            return void 0;
          }
          if (expr.length === 1) {
            return expr[0];
          }
          expr.sort(cmp);
          for (let i = 1; i < expr.length; i++) {
            if (expr[i - 1].equals(expr[i])) {
              expr.splice(i, 1);
              i--;
            }
          }
          if (expr.length === 1) {
            return expr[0];
          }
          while (expr.length > 1) {
            const lastElement = expr[expr.length - 1];
            if (lastElement.type !== 9) {
              break;
            }
            expr.pop();
            const secondToLastElement = expr.pop();
            const isFinished = expr.length === 0;
            const resultElement = ContextKeyOrExpr.create(lastElement.expr.map((el) => ContextKeyAndExpr.create([el, secondToLastElement], null, extraRedundantCheck)), null, isFinished);
            if (resultElement) {
              expr.push(resultElement);
              expr.sort(cmp);
            }
          }
          if (expr.length === 1) {
            return expr[0];
          }
          if (extraRedundantCheck) {
            for (let i = 0; i < expr.length; i++) {
              for (let j = i + 1; j < expr.length; j++) {
                if (expr[i].negate().equals(expr[j])) {
                  return ContextKeyFalseExpr.INSTANCE;
                }
              }
            }
            if (expr.length === 1) {
              return expr[0];
            }
          }
          return new ContextKeyAndExpr(expr, negated);
        }
        serialize() {
          return this.expr.map((e) => e.serialize()).join(" && ");
        }
        keys() {
          const result = [];
          for (const expr of this.expr) {
            result.push(...expr.keys());
          }
          return result;
        }
        map(mapFnc) {
          return new ContextKeyAndExpr(this.expr.map((expr) => expr.map(mapFnc)), null);
        }
        negate() {
          if (!this.negated) {
            const result = [];
            for (const expr of this.expr) {
              result.push(expr.negate());
            }
            this.negated = ContextKeyOrExpr.create(result, this, true);
          }
          return this.negated;
        }
      };
      ContextKeyOrExpr = class {
        static create(_expr, negated, extraRedundantCheck) {
          return ContextKeyOrExpr._normalizeArr(_expr, negated, extraRedundantCheck);
        }
        constructor(expr, negated) {
          this.expr = expr;
          this.negated = negated;
          this.type = 9;
        }
        cmp(other) {
          if (other.type !== this.type) {
            return this.type - other.type;
          }
          if (this.expr.length < other.expr.length) {
            return -1;
          }
          if (this.expr.length > other.expr.length) {
            return 1;
          }
          for (let i = 0, len = this.expr.length; i < len; i++) {
            const r = cmp(this.expr[i], other.expr[i]);
            if (r !== 0) {
              return r;
            }
          }
          return 0;
        }
        equals(other) {
          if (other.type === this.type) {
            if (this.expr.length !== other.expr.length) {
              return false;
            }
            for (let i = 0, len = this.expr.length; i < len; i++) {
              if (!this.expr[i].equals(other.expr[i])) {
                return false;
              }
            }
            return true;
          }
          return false;
        }
        substituteConstants() {
          const exprArr = eliminateConstantsInArray(this.expr);
          if (exprArr === this.expr) {
            return this;
          }
          return ContextKeyOrExpr.create(exprArr, this.negated, false);
        }
        evaluate(context) {
          for (let i = 0, len = this.expr.length; i < len; i++) {
            if (this.expr[i].evaluate(context)) {
              return true;
            }
          }
          return false;
        }
        static _normalizeArr(arr, negated, extraRedundantCheck) {
          let expr = [];
          let hasFalse = false;
          if (arr) {
            for (let i = 0, len = arr.length; i < len; i++) {
              const e = arr[i];
              if (!e) {
                continue;
              }
              if (e.type === 0) {
                hasFalse = true;
                continue;
              }
              if (e.type === 1) {
                return ContextKeyTrueExpr.INSTANCE;
              }
              if (e.type === 9) {
                expr = expr.concat(e.expr);
                continue;
              }
              expr.push(e);
            }
            if (expr.length === 0 && hasFalse) {
              return ContextKeyFalseExpr.INSTANCE;
            }
            expr.sort(cmp);
          }
          if (expr.length === 0) {
            return void 0;
          }
          if (expr.length === 1) {
            return expr[0];
          }
          for (let i = 1; i < expr.length; i++) {
            if (expr[i - 1].equals(expr[i])) {
              expr.splice(i, 1);
              i--;
            }
          }
          if (expr.length === 1) {
            return expr[0];
          }
          if (extraRedundantCheck) {
            for (let i = 0; i < expr.length; i++) {
              for (let j = i + 1; j < expr.length; j++) {
                if (expr[i].negate().equals(expr[j])) {
                  return ContextKeyTrueExpr.INSTANCE;
                }
              }
            }
            if (expr.length === 1) {
              return expr[0];
            }
          }
          return new ContextKeyOrExpr(expr, negated);
        }
        serialize() {
          return this.expr.map((e) => e.serialize()).join(" || ");
        }
        keys() {
          const result = [];
          for (const expr of this.expr) {
            result.push(...expr.keys());
          }
          return result;
        }
        map(mapFnc) {
          return new ContextKeyOrExpr(this.expr.map((expr) => expr.map(mapFnc)), null);
        }
        negate() {
          if (!this.negated) {
            const result = [];
            for (const expr of this.expr) {
              result.push(expr.negate());
            }
            while (result.length > 1) {
              const LEFT = result.shift();
              const RIGHT = result.shift();
              const all = [];
              for (const left of getTerminals(LEFT)) {
                for (const right of getTerminals(RIGHT)) {
                  all.push(ContextKeyAndExpr.create([left, right], null, false));
                }
              }
              result.unshift(ContextKeyOrExpr.create(all, null, false));
            }
            this.negated = ContextKeyOrExpr.create(result, this, true);
          }
          return this.negated;
        }
      };
      RawContextKey = class extends ContextKeyDefinedExpr {
        static all() {
          return RawContextKey._info.values();
        }
        constructor(key, defaultValue, metaOrHide) {
          super(key, null);
          this._defaultValue = defaultValue;
          if (typeof metaOrHide === "object") {
            RawContextKey._info.push(Object.assign(Object.assign({}, metaOrHide), { key }));
          } else if (metaOrHide !== true) {
            RawContextKey._info.push({ key, description: metaOrHide, type: defaultValue !== null && defaultValue !== void 0 ? typeof defaultValue : void 0 });
          }
        }
        bindTo(target) {
          return target.createKey(this.key, this._defaultValue);
        }
        getValue(target) {
          return target.getContextKeyValue(this.key);
        }
        toNegated() {
          return this.negate();
        }
        isEqualTo(value) {
          return ContextKeyEqualsExpr.create(this.key, value);
        }
        notEqualsTo(value) {
          return ContextKeyNotEqualsExpr.create(this.key, value);
        }
      };
      RawContextKey._info = [];
      IContextKeyService = createDecorator("contextKeyService");
    }
  });

  // node_modules/vscode/dist/vscode/vs/workbench/contrib/debug/common/debug.js
  var CONTEXT_DEBUG_TYPE, CONTEXT_DEBUG_CONFIGURATION_TYPE, CONTEXT_DEBUG_STATE, CONTEXT_DEBUG_UX_KEY, CONTEXT_DEBUG_UX, CONTEXT_HAS_DEBUGGED, CONTEXT_IN_DEBUG_MODE, CONTEXT_IN_DEBUG_REPL, CONTEXT_BREAKPOINT_WIDGET_VISIBLE, CONTEXT_IN_BREAKPOINT_WIDGET, CONTEXT_BREAKPOINTS_FOCUSED, CONTEXT_WATCH_EXPRESSIONS_FOCUSED, CONTEXT_WATCH_EXPRESSIONS_EXIST, CONTEXT_VARIABLES_FOCUSED, CONTEXT_EXPRESSION_SELECTED, CONTEXT_BREAKPOINT_INPUT_FOCUSED, CONTEXT_CALLSTACK_ITEM_TYPE, CONTEXT_CALLSTACK_SESSION_IS_ATTACH, CONTEXT_CALLSTACK_ITEM_STOPPED, CONTEXT_CALLSTACK_SESSION_HAS_ONE_THREAD, CONTEXT_WATCH_ITEM_TYPE, CONTEXT_CAN_VIEW_MEMORY, CONTEXT_BREAKPOINT_ITEM_TYPE, CONTEXT_BREAKPOINT_SUPPORTS_CONDITION, CONTEXT_LOADED_SCRIPTS_SUPPORTED, CONTEXT_LOADED_SCRIPTS_ITEM_TYPE, CONTEXT_FOCUSED_SESSION_IS_ATTACH, CONTEXT_STEP_BACK_SUPPORTED, CONTEXT_RESTART_FRAME_SUPPORTED, CONTEXT_STACK_FRAME_SUPPORTS_RESTART, CONTEXT_JUMP_TO_CURSOR_SUPPORTED, CONTEXT_STEP_INTO_TARGETS_SUPPORTED, CONTEXT_BREAKPOINTS_EXIST, CONTEXT_DEBUGGERS_AVAILABLE, CONTEXT_DEBUG_EXTENSION_AVAILABLE, CONTEXT_DEBUG_PROTOCOL_VARIABLE_MENU_CONTEXT, CONTEXT_SET_VARIABLE_SUPPORTED, CONTEXT_SET_EXPRESSION_SUPPORTED, CONTEXT_BREAK_WHEN_VALUE_CHANGES_SUPPORTED, CONTEXT_BREAK_WHEN_VALUE_IS_ACCESSED_SUPPORTED, CONTEXT_BREAK_WHEN_VALUE_IS_READ_SUPPORTED, CONTEXT_TERMINATE_DEBUGGEE_SUPPORTED, CONTEXT_SUSPEND_DEBUGGEE_SUPPORTED, CONTEXT_VARIABLE_EVALUATE_NAME_PRESENT, CONTEXT_VARIABLE_IS_READONLY, CONTEXT_EXCEPTION_WIDGET_VISIBLE, CONTEXT_MULTI_SESSION_REPL, CONTEXT_MULTI_SESSION_DEBUG, CONTEXT_DISASSEMBLE_REQUEST_SUPPORTED, CONTEXT_DISASSEMBLY_VIEW_FOCUS, CONTEXT_LANGUAGE_SUPPORTS_DISASSEMBLE_REQUEST, CONTEXT_FOCUSED_STACK_FRAME_HAS_INSTRUCTION_POINTER_REFERENCE, INTERNAL_CONSOLE_OPTIONS_SCHEMA, DebugConfigurationProviderTriggerKind, DebuggerString, IDebugService;
  var init_debug = __esm({
    "node_modules/vscode/dist/vscode/vs/workbench/contrib/debug/common/debug.js"() {
      init_nls();
      init_contextkey();
      init_instantiation();
      CONTEXT_DEBUG_TYPE = new RawContextKey("debugType", void 0, { type: "string", description: localize(
        "debugType",
        "Debug type of the active debug session. For example 'python'."
      ) });
      CONTEXT_DEBUG_CONFIGURATION_TYPE = new RawContextKey(
        "debugConfigurationType",
        void 0,
        { type: "string", description: localize(
          "debugConfigurationType",
          "Debug type of the selected launch configuration. For example 'python'."
        ) }
      );
      CONTEXT_DEBUG_STATE = new RawContextKey("debugState", "inactive", { type: "string", description: localize(
        "debugState",
        "State that the focused debug session is in. One of the following: 'inactive', 'initializing', 'stopped' or 'running'."
      ) });
      CONTEXT_DEBUG_UX_KEY = "debugUx";
      CONTEXT_DEBUG_UX = new RawContextKey(
        CONTEXT_DEBUG_UX_KEY,
        "default",
        { type: "string", description: localize(
          "debugUX",
          "Debug UX state. When there are no debug configurations it is 'simple', otherwise 'default'. Used to decide when to show welcome views in the debug viewlet."
        ) }
      );
      CONTEXT_HAS_DEBUGGED = new RawContextKey("hasDebugged", false, { type: "boolean", description: localize(
        "hasDebugged",
        "True when a debug session has been started at least once, false otherwise."
      ) });
      CONTEXT_IN_DEBUG_MODE = new RawContextKey("inDebugMode", false, { type: "boolean", description: localize("inDebugMode", "True when debugging, false otherwise.") });
      CONTEXT_IN_DEBUG_REPL = new RawContextKey("inDebugRepl", false, { type: "boolean", description: localize("inDebugRepl", "True when focus is in the debug console, false otherwise.") });
      CONTEXT_BREAKPOINT_WIDGET_VISIBLE = new RawContextKey(
        "breakpointWidgetVisible",
        false,
        { type: "boolean", description: localize(
          "breakpointWidgetVisibile",
          "True when breakpoint editor zone widget is visible, false otherwise."
        ) }
      );
      CONTEXT_IN_BREAKPOINT_WIDGET = new RawContextKey(
        "inBreakpointWidget",
        false,
        { type: "boolean", description: localize(
          "inBreakpointWidget",
          "True when focus is in the breakpoint editor zone widget, false otherwise."
        ) }
      );
      CONTEXT_BREAKPOINTS_FOCUSED = new RawContextKey("breakpointsFocused", true, { type: "boolean", description: localize(
        "breakpointsFocused",
        "True when the BREAKPOINTS view is focused, false otherwise."
      ) });
      CONTEXT_WATCH_EXPRESSIONS_FOCUSED = new RawContextKey(
        "watchExpressionsFocused",
        true,
        { type: "boolean", description: localize(
          "watchExpressionsFocused",
          "True when the WATCH view is focused, false otherwsie."
        ) }
      );
      CONTEXT_WATCH_EXPRESSIONS_EXIST = new RawContextKey(
        "watchExpressionsExist",
        false,
        { type: "boolean", description: localize(
          "watchExpressionsExist",
          "True when at least one watch expression exists, false otherwise."
        ) }
      );
      CONTEXT_VARIABLES_FOCUSED = new RawContextKey("variablesFocused", true, { type: "boolean", description: localize(
        "variablesFocused",
        "True when the VARIABLES views is focused, false otherwsie"
      ) });
      CONTEXT_EXPRESSION_SELECTED = new RawContextKey(
        "expressionSelected",
        false,
        { type: "boolean", description: localize(
          "expressionSelected",
          "True when an expression input box is open in either the WATCH or the VARIABLES view, false otherwise."
        ) }
      );
      CONTEXT_BREAKPOINT_INPUT_FOCUSED = new RawContextKey(
        "breakpointInputFocused",
        false,
        { type: "boolean", description: localize(
          "breakpointInputFocused",
          "True when the input box has focus in the BREAKPOINTS view."
        ) }
      );
      CONTEXT_CALLSTACK_ITEM_TYPE = new RawContextKey(
        "callStackItemType",
        void 0,
        { type: "string", description: localize(
          "callStackItemType",
          "Represents the item type of the focused element in the CALL STACK view. For example: 'session', 'thread', 'stackFrame'"
        ) }
      );
      CONTEXT_CALLSTACK_SESSION_IS_ATTACH = new RawContextKey(
        "callStackSessionIsAttach",
        false,
        { type: "boolean", description: localize(
          "callStackSessionIsAttach",
          "True when the session in the CALL STACK view is attach, false otherwise. Used internally for inline menus in the CALL STACK view."
        ) }
      );
      CONTEXT_CALLSTACK_ITEM_STOPPED = new RawContextKey(
        "callStackItemStopped",
        false,
        { type: "boolean", description: localize(
          "callStackItemStopped",
          "True when the focused item in the CALL STACK is stopped. Used internaly for inline menus in the CALL STACK view."
        ) }
      );
      CONTEXT_CALLSTACK_SESSION_HAS_ONE_THREAD = new RawContextKey(
        "callStackSessionHasOneThread",
        false,
        { type: "boolean", description: localize(
          "callStackSessionHasOneThread",
          "True when the focused session in the CALL STACK view has exactly one thread. Used internally for inline menus in the CALL STACK view."
        ) }
      );
      CONTEXT_WATCH_ITEM_TYPE = new RawContextKey("watchItemType", void 0, { type: "string", description: localize(
        "watchItemType",
        "Represents the item type of the focused element in the WATCH view. For example: 'expression', 'variable'"
      ) });
      CONTEXT_CAN_VIEW_MEMORY = new RawContextKey("canViewMemory", void 0, { type: "boolean", description: localize(
        "canViewMemory",
        "Indicates whether the item in the view has an associated memory refrence."
      ) });
      CONTEXT_BREAKPOINT_ITEM_TYPE = new RawContextKey(
        "breakpointItemType",
        void 0,
        { type: "string", description: localize(
          "breakpointItemType",
          "Represents the item type of the focused element in the BREAKPOINTS view. For example: 'breakpoint', 'exceptionBreakppint', 'functionBreakpoint', 'dataBreakpoint'"
        ) }
      );
      CONTEXT_BREAKPOINT_SUPPORTS_CONDITION = new RawContextKey(
        "breakpointSupportsCondition",
        false,
        { type: "boolean", description: localize(
          "breakpointSupportsCondition",
          "True when the focused breakpoint supports conditions."
        ) }
      );
      CONTEXT_LOADED_SCRIPTS_SUPPORTED = new RawContextKey(
        "loadedScriptsSupported",
        false,
        { type: "boolean", description: localize(
          "loadedScriptsSupported",
          "True when the focused sessions supports the LOADED SCRIPTS view"
        ) }
      );
      CONTEXT_LOADED_SCRIPTS_ITEM_TYPE = new RawContextKey(
        "loadedScriptsItemType",
        void 0,
        { type: "string", description: localize(
          "loadedScriptsItemType",
          "Represents the item type of the focused element in the LOADED SCRIPTS view."
        ) }
      );
      CONTEXT_FOCUSED_SESSION_IS_ATTACH = new RawContextKey(
        "focusedSessionIsAttach",
        false,
        { type: "boolean", description: localize("focusedSessionIsAttach", "True when the focused session is 'attach'.") }
      );
      CONTEXT_STEP_BACK_SUPPORTED = new RawContextKey("stepBackSupported", false, { type: "boolean", description: localize(
        "stepBackSupported",
        "True when the focused session supports 'stepBack' requests."
      ) });
      CONTEXT_RESTART_FRAME_SUPPORTED = new RawContextKey(
        "restartFrameSupported",
        false,
        { type: "boolean", description: localize(
          "restartFrameSupported",
          "True when the focused session supports 'restartFrame' requests."
        ) }
      );
      CONTEXT_STACK_FRAME_SUPPORTS_RESTART = new RawContextKey(
        "stackFrameSupportsRestart",
        false,
        { type: "boolean", description: localize(
          "stackFrameSupportsRestart",
          "True when the focused stack frame suppots 'restartFrame'."
        ) }
      );
      CONTEXT_JUMP_TO_CURSOR_SUPPORTED = new RawContextKey(
        "jumpToCursorSupported",
        false,
        { type: "boolean", description: localize(
          "jumpToCursorSupported",
          "True when the focused session supports 'jumpToCursor' request."
        ) }
      );
      CONTEXT_STEP_INTO_TARGETS_SUPPORTED = new RawContextKey(
        "stepIntoTargetsSupported",
        false,
        { type: "boolean", description: localize(
          "stepIntoTargetsSupported",
          "True when the focused session supports 'stepIntoTargets' request."
        ) }
      );
      CONTEXT_BREAKPOINTS_EXIST = new RawContextKey("breakpointsExist", false, { type: "boolean", description: localize("breakpointsExist", "True when at least one breakpoint exists.") });
      CONTEXT_DEBUGGERS_AVAILABLE = new RawContextKey(
        "debuggersAvailable",
        false,
        { type: "boolean", description: localize(
          "debuggersAvailable",
          "True when there is at least one debug extensions active."
        ) }
      );
      CONTEXT_DEBUG_EXTENSION_AVAILABLE = new RawContextKey(
        "debugExtensionAvailable",
        true,
        { type: "boolean", description: localize(
          "debugExtensionsAvailable",
          "True when there is at least one debug extension installed and enabled."
        ) }
      );
      CONTEXT_DEBUG_PROTOCOL_VARIABLE_MENU_CONTEXT = new RawContextKey(
        "debugProtocolVariableMenuContext",
        void 0,
        { type: "string", description: localize(
          "debugProtocolVariableMenuContext",
          "Represents the context the debug adapter sets on the focused variable in the VARIABLES view."
        ) }
      );
      CONTEXT_SET_VARIABLE_SUPPORTED = new RawContextKey(
        "debugSetVariableSupported",
        false,
        { type: "boolean", description: localize(
          "debugSetVariableSupported",
          "True when the focused session supports 'setVariable' request."
        ) }
      );
      CONTEXT_SET_EXPRESSION_SUPPORTED = new RawContextKey(
        "debugSetExpressionSupported",
        false,
        { type: "boolean", description: localize(
          "debugSetExpressionSupported",
          "True when the focused session supports 'setExpression' request."
        ) }
      );
      CONTEXT_BREAK_WHEN_VALUE_CHANGES_SUPPORTED = new RawContextKey(
        "breakWhenValueChangesSupported",
        false,
        { type: "boolean", description: localize(
          "breakWhenValueChangesSupported",
          "True when the focused session supports to break when value changes."
        ) }
      );
      CONTEXT_BREAK_WHEN_VALUE_IS_ACCESSED_SUPPORTED = new RawContextKey(
        "breakWhenValueIsAccessedSupported",
        false,
        { type: "boolean", description: localize(
          "breakWhenValueIsAccessedSupported",
          "True when the focused breakpoint supports to break when value is accessed."
        ) }
      );
      CONTEXT_BREAK_WHEN_VALUE_IS_READ_SUPPORTED = new RawContextKey(
        "breakWhenValueIsReadSupported",
        false,
        { type: "boolean", description: localize(
          "breakWhenValueIsReadSupported",
          "True when the focused breakpoint supports to break when value is read."
        ) }
      );
      CONTEXT_TERMINATE_DEBUGGEE_SUPPORTED = new RawContextKey(
        "terminateDebuggeeSupported",
        false,
        { type: "boolean", description: localize(
          "terminateDebuggeeSupported",
          "True when the focused session supports the terminate debuggee capability."
        ) }
      );
      CONTEXT_SUSPEND_DEBUGGEE_SUPPORTED = new RawContextKey(
        "suspendDebuggeeSupported",
        false,
        { type: "boolean", description: localize(
          "suspendDebuggeeSupported",
          "True when the focused session supports the suspend debuggee capability."
        ) }
      );
      CONTEXT_VARIABLE_EVALUATE_NAME_PRESENT = new RawContextKey(
        "variableEvaluateNamePresent",
        false,
        { type: "boolean", description: localize(
          "variableEvaluateNamePresent",
          "True when the focused variable has an 'evalauteName' field set."
        ) }
      );
      CONTEXT_VARIABLE_IS_READONLY = new RawContextKey(
        "variableIsReadonly",
        false,
        { type: "boolean", description: localize("variableIsReadonly", "True when the focused variable is read-only.") }
      );
      CONTEXT_EXCEPTION_WIDGET_VISIBLE = new RawContextKey(
        "exceptionWidgetVisible",
        false,
        { type: "boolean", description: localize("exceptionWidgetVisible", "True when the exception widget is visible.") }
      );
      CONTEXT_MULTI_SESSION_REPL = new RawContextKey("multiSessionRepl", false, { type: "boolean", description: localize("multiSessionRepl", "True when there is more than 1 debug console.") });
      CONTEXT_MULTI_SESSION_DEBUG = new RawContextKey("multiSessionDebug", false, { type: "boolean", description: localize(
        "multiSessionDebug",
        "True when there is more than 1 active debug session."
      ) });
      CONTEXT_DISASSEMBLE_REQUEST_SUPPORTED = new RawContextKey(
        "disassembleRequestSupported",
        false,
        { type: "boolean", description: localize(
          "disassembleRequestSupported",
          "True when the focused sessions supports disassemble request."
        ) }
      );
      CONTEXT_DISASSEMBLY_VIEW_FOCUS = new RawContextKey(
        "disassemblyViewFocus",
        false,
        { type: "boolean", description: localize("disassemblyViewFocus", "True when the Disassembly View is focused.") }
      );
      CONTEXT_LANGUAGE_SUPPORTS_DISASSEMBLE_REQUEST = new RawContextKey(
        "languageSupportsDisassembleRequest",
        false,
        { type: "boolean", description: localize(
          "languageSupportsDisassembleRequest",
          "True when the language in the current editor supports disassemble request."
        ) }
      );
      CONTEXT_FOCUSED_STACK_FRAME_HAS_INSTRUCTION_POINTER_REFERENCE = new RawContextKey(
        "focusedStackFrameHasInstructionReference",
        false,
        { type: "boolean", description: localize(
          "focusedStackFrameHasInstructionReference",
          "True when the focused stack frame has instruction pointer reference."
        ) }
      );
      INTERNAL_CONSOLE_OPTIONS_SCHEMA = {
        enum: ["neverOpen", "openOnSessionStart", "openOnFirstSessionStart"],
        default: "openOnFirstSessionStart",
        description: localize(
          "internalConsoleOptions",
          "Controls when the internal Debug Console should open."
        )
      };
      (function(DebugConfigurationProviderTriggerKind3) {
        DebugConfigurationProviderTriggerKind3[DebugConfigurationProviderTriggerKind3["Initial"] = 1] = "Initial";
        DebugConfigurationProviderTriggerKind3[DebugConfigurationProviderTriggerKind3["Dynamic"] = 2] = "Dynamic";
      })(
        DebugConfigurationProviderTriggerKind || (DebugConfigurationProviderTriggerKind = {})
      );
      (function(DebuggerString2) {
        DebuggerString2["UnverifiedBreakpoints"] = "unverifiedBreakpoints";
      })(DebuggerString || (DebuggerString = {}));
      IDebugService = createDecorator("debugService");
    }
  });

  // node_modules/vscode/dist/vscode/vs/workbench/services/extensions/common/extensionHostProtocol.js
  var UIKind;
  var init_extensionHostProtocol = __esm({
    "node_modules/vscode/dist/vscode/vs/workbench/services/extensions/common/extensionHostProtocol.js"() {
      init_buffer();
      (function(UIKind3) {
        UIKind3[UIKind3["Desktop"] = 1] = "Desktop";
        UIKind3[UIKind3["Web"] = 2] = "Web";
      })(UIKind || (UIKind = {}));
    }
  });

  // node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfiguration.js
  var IndentAction;
  var init_languageConfiguration = __esm({
    "node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfiguration.js"() {
      (function(IndentAction3) {
        IndentAction3[IndentAction3["None"] = 0] = "None";
        IndentAction3[IndentAction3["Indent"] = 1] = "Indent";
        IndentAction3[IndentAction3["IndentOutdent"] = 2] = "IndentOutdent";
        IndentAction3[IndentAction3["Outdent"] = 3] = "Outdent";
      })(IndentAction || (IndentAction = {}));
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/objects.js
  function equals2(one, other) {
    if (one === other) {
      return true;
    }
    if (one === null || one === void 0 || other === null || other === void 0) {
      return false;
    }
    if (typeof one !== typeof other) {
      return false;
    }
    if (typeof one !== "object") {
      return false;
    }
    if (Array.isArray(one) !== Array.isArray(other)) {
      return false;
    }
    let i;
    let key;
    if (Array.isArray(one)) {
      if (one.length !== other.length) {
        return false;
      }
      for (i = 0; i < one.length; i++) {
        if (!equals2(one[i], other[i])) {
          return false;
        }
      }
    } else {
      const oneKeys = [];
      for (key in one) {
        oneKeys.push(key);
      }
      oneKeys.sort();
      const otherKeys = [];
      for (key in other) {
        otherKeys.push(key);
      }
      otherKeys.sort();
      if (!equals2(oneKeys, otherKeys)) {
        return false;
      }
      for (i = 0; i < oneKeys.length; i++) {
        if (!equals2(one[oneKeys[i]], other[oneKeys[i]])) {
          return false;
        }
      }
    }
    return true;
  }
  var init_objects = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/objects.js"() {
      init_types();
    }
  });

  // node_modules/monaco-editor/esm/vs/editor/common/model.js
  var OverviewRulerLane, GlyphMarginLane, MinimapPosition, InjectedTextCursorStops;
  var init_model = __esm({
    "node_modules/monaco-editor/esm/vs/editor/common/model.js"() {
      init_objects();
      (function(OverviewRulerLane3) {
        OverviewRulerLane3[OverviewRulerLane3["Left"] = 1] = "Left";
        OverviewRulerLane3[OverviewRulerLane3["Center"] = 2] = "Center";
        OverviewRulerLane3[OverviewRulerLane3["Right"] = 4] = "Right";
        OverviewRulerLane3[OverviewRulerLane3["Full"] = 7] = "Full";
      })(OverviewRulerLane || (OverviewRulerLane = {}));
      (function(GlyphMarginLane2) {
        GlyphMarginLane2[GlyphMarginLane2["Left"] = 1] = "Left";
        GlyphMarginLane2[GlyphMarginLane2["Right"] = 2] = "Right";
      })(GlyphMarginLane || (GlyphMarginLane = {}));
      (function(MinimapPosition2) {
        MinimapPosition2[MinimapPosition2["Inline"] = 1] = "Inline";
        MinimapPosition2[MinimapPosition2["Gutter"] = 2] = "Gutter";
      })(MinimapPosition || (MinimapPosition = {}));
      (function(InjectedTextCursorStops2) {
        InjectedTextCursorStops2[InjectedTextCursorStops2["Both"] = 0] = "Both";
        InjectedTextCursorStops2[InjectedTextCursorStops2["Right"] = 1] = "Right";
        InjectedTextCursorStops2[InjectedTextCursorStops2["Left"] = 2] = "Left";
        InjectedTextCursorStops2[InjectedTextCursorStops2["None"] = 3] = "None";
      })(InjectedTextCursorStops || (InjectedTextCursorStops = {}));
    }
  });

  // node_modules/monaco-editor/esm/vs/editor/common/core/textModelDefaults.js
  var EDITOR_MODEL_DEFAULTS;
  var init_textModelDefaults = __esm({
    "node_modules/monaco-editor/esm/vs/editor/common/core/textModelDefaults.js"() {
      EDITOR_MODEL_DEFAULTS = {
        tabSize: 4,
        indentSize: 4,
        insertSpaces: true,
        detectIndentation: true,
        trimAutoWhitespace: true,
        largeFileOptimizations: true,
        bracketPairColorizationOptions: {
          enabled: true,
          independentColorPoolPerBracketType: false
        }
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js
  function createWordRegExp(allowInWords = "") {
    let source = "(-?\\d*\\.\\d\\w*)|([^";
    for (const sep2 of USUAL_WORD_SEPARATORS) {
      if (allowInWords.indexOf(sep2) >= 0) {
        continue;
      }
      source += "\\" + sep2;
    }
    source += "\\s]+)";
    return new RegExp(source, "g");
  }
  var USUAL_WORD_SEPARATORS, DEFAULT_WORD_REGEXP, _defaultConfig;
  var init_wordHelper = __esm({
    "node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js"() {
      init_iterator();
      init_lifecycle();
      init_linkedList();
      USUAL_WORD_SEPARATORS = "`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?";
      DEFAULT_WORD_REGEXP = createWordRegExp();
      _defaultConfig = new LinkedList();
      _defaultConfig.unshift({
        maxLen: 1e3,
        windowSize: 15,
        timeBudget: 150
      });
    }
  });

  // node_modules/monaco-editor/esm/vs/editor/common/config/editorOptions.js
  function applyUpdate(value, update) {
    if (typeof value !== "object" || typeof update !== "object" || !value || !update) {
      return new ApplyUpdateResult(update, value !== update);
    }
    if (Array.isArray(value) || Array.isArray(update)) {
      const arrayEquals = Array.isArray(value) && Array.isArray(update) && equals(value, update);
      return new ApplyUpdateResult(update, !arrayEquals);
    }
    let didChange = false;
    for (const key in update) {
      if (update.hasOwnProperty(key)) {
        const result = applyUpdate(value[key], update[key]);
        if (result.didChange) {
          value[key] = result.newValue;
          didChange = true;
        }
      }
    }
    return new ApplyUpdateResult(value, didChange);
  }
  function boolean(value, defaultValue) {
    if (typeof value === "undefined") {
      return defaultValue;
    }
    if (value === "false") {
      return false;
    }
    return Boolean(value);
  }
  function clampedInt(value, defaultValue, minimum, maximum) {
    if (typeof value === "undefined") {
      return defaultValue;
    }
    let r = parseInt(value, 10);
    if (isNaN(r)) {
      return defaultValue;
    }
    r = Math.max(minimum, r);
    r = Math.min(maximum, r);
    return r | 0;
  }
  function stringSet(value, defaultValue, allowedValues, renamedValues) {
    if (typeof value !== "string") {
      return defaultValue;
    }
    if (renamedValues && value in renamedValues) {
      return renamedValues[value];
    }
    if (allowedValues.indexOf(value) === -1) {
      return defaultValue;
    }
    return value;
  }
  function _autoIndentFromString(autoIndent) {
    switch (autoIndent) {
      case "none":
        return 0;
      case "keep":
        return 1;
      case "brackets":
        return 2;
      case "advanced":
        return 3;
      case "full":
        return 4;
    }
  }
  function _cursorBlinkingStyleFromString(cursorBlinkingStyle) {
    switch (cursorBlinkingStyle) {
      case "blink":
        return 1;
      case "smooth":
        return 2;
      case "phase":
        return 3;
      case "expand":
        return 4;
      case "solid":
        return 5;
    }
  }
  function _cursorStyleFromString(cursorStyle) {
    switch (cursorStyle) {
      case "line":
        return TextEditorCursorStyle.Line;
      case "block":
        return TextEditorCursorStyle.Block;
      case "underline":
        return TextEditorCursorStyle.Underline;
      case "line-thin":
        return TextEditorCursorStyle.LineThin;
      case "block-outline":
        return TextEditorCursorStyle.BlockOutline;
      case "underline-thin":
        return TextEditorCursorStyle.UnderlineThin;
    }
  }
  function _multiCursorModifierFromString(multiCursorModifier) {
    if (multiCursorModifier === "ctrlCmd") {
      return isMacintosh ? "metaKey" : "ctrlKey";
    }
    return "altKey";
  }
  function _scrollbarVisibilityFromString(visibility, defaultValue) {
    if (typeof visibility !== "string") {
      return defaultValue;
    }
    switch (visibility) {
      case "hidden":
        return 2;
      case "visible":
        return 3;
      default:
        return 1;
    }
  }
  function primitiveSet(value, defaultValue, allowedValues) {
    const idx = allowedValues.indexOf(value);
    if (idx === -1) {
      return defaultValue;
    }
    return allowedValues[idx];
  }
  function register2(option) {
    editorOptionsRegistry[option.id] = option;
    return option;
  }
  var MINIMAP_GUTTER_WIDTH, ComputeOptionsMemory, BaseEditorOption, ApplyUpdateResult, ComputedEditorOption, SimpleEditorOption, EditorBooleanOption, EditorIntOption, EditorFloatOption, EditorStringOption, EditorStringEnumOption, EditorEnumOption, EditorAccessibilitySupport, EditorComments, TextEditorCursorStyle, EditorClassName, EditorEmptySelectionClipboard, EditorFind, EditorFontLigatures, EditorFontVariations, EditorFontInfo, EditorFontSize, EditorFontWeight, EditorGoToLocation, EditorHover, EditorLayoutInfoComputer, WrappingStrategy, EditorLightbulb, EditorStickyScroll, EditorInlayHints, EditorLineDecorationsWidth, EditorLineHeight, EditorMinimap, EditorPadding, EditorParameterHints, EditorPixelRatio, EditorQuickSuggestions, EditorRenderLineNumbersOption, EditorRulers, ReadonlyMessage, EditorScrollbar, inUntrustedWorkspace, unicodeHighlightConfigKeys, UnicodeHighlight, InlineEditorSuggest, BracketPairColorization, GuideOptions, EditorSuggest, SmartSelect, WrappingIndentOption, EditorWrappingInfoComputer, EditorDropIntoEditor, EditorPasteAs, DEFAULT_WINDOWS_FONT_FAMILY, DEFAULT_MAC_FONT_FAMILY, DEFAULT_LINUX_FONT_FAMILY, EDITOR_FONT_DEFAULTS, editorOptionsRegistry, EditorOptions;
  var init_editorOptions = __esm({
    "node_modules/monaco-editor/esm/vs/editor/common/config/editorOptions.js"() {
      init_arrays();
      init_objects();
      init_platform();
      init_textModelDefaults();
      init_wordHelper();
      init_nls();
      MINIMAP_GUTTER_WIDTH = 8;
      ComputeOptionsMemory = class {
        constructor() {
          this.stableMinimapLayoutInput = null;
          this.stableFitMaxMinimapScale = 0;
          this.stableFitRemainingWidth = 0;
        }
      };
      BaseEditorOption = class {
        constructor(id2, name, defaultValue, schema) {
          this.id = id2;
          this.name = name;
          this.defaultValue = defaultValue;
          this.schema = schema;
        }
        applyUpdate(value, update) {
          return applyUpdate(value, update);
        }
        compute(env3, options, value) {
          return value;
        }
      };
      ApplyUpdateResult = class {
        constructor(newValue, didChange) {
          this.newValue = newValue;
          this.didChange = didChange;
        }
      };
      ComputedEditorOption = class {
        constructor(id2) {
          this.schema = void 0;
          this.id = id2;
          this.name = "_never_";
          this.defaultValue = void 0;
        }
        applyUpdate(value, update) {
          return applyUpdate(value, update);
        }
        validate(input) {
          return this.defaultValue;
        }
      };
      SimpleEditorOption = class {
        constructor(id2, name, defaultValue, schema) {
          this.id = id2;
          this.name = name;
          this.defaultValue = defaultValue;
          this.schema = schema;
        }
        applyUpdate(value, update) {
          return applyUpdate(value, update);
        }
        validate(input) {
          if (typeof input === "undefined") {
            return this.defaultValue;
          }
          return input;
        }
        compute(env3, options, value) {
          return value;
        }
      };
      EditorBooleanOption = class extends SimpleEditorOption {
        constructor(id2, name, defaultValue, schema = void 0) {
          if (typeof schema !== "undefined") {
            schema.type = "boolean";
            schema.default = defaultValue;
          }
          super(id2, name, defaultValue, schema);
        }
        validate(input) {
          return boolean(input, this.defaultValue);
        }
      };
      EditorIntOption = class extends SimpleEditorOption {
        static clampedInt(value, defaultValue, minimum, maximum) {
          return clampedInt(value, defaultValue, minimum, maximum);
        }
        constructor(id2, name, defaultValue, minimum, maximum, schema = void 0) {
          if (typeof schema !== "undefined") {
            schema.type = "integer";
            schema.default = defaultValue;
            schema.minimum = minimum;
            schema.maximum = maximum;
          }
          super(id2, name, defaultValue, schema);
          this.minimum = minimum;
          this.maximum = maximum;
        }
        validate(input) {
          return EditorIntOption.clampedInt(input, this.defaultValue, this.minimum, this.maximum);
        }
      };
      EditorFloatOption = class extends SimpleEditorOption {
        static clamp(n, min, max) {
          if (n < min) {
            return min;
          }
          if (n > max) {
            return max;
          }
          return n;
        }
        static float(value, defaultValue) {
          if (typeof value === "number") {
            return value;
          }
          if (typeof value === "undefined") {
            return defaultValue;
          }
          const r = parseFloat(value);
          return isNaN(r) ? defaultValue : r;
        }
        constructor(id2, name, defaultValue, validationFn, schema) {
          if (typeof schema !== "undefined") {
            schema.type = "number";
            schema.default = defaultValue;
          }
          super(id2, name, defaultValue, schema);
          this.validationFn = validationFn;
        }
        validate(input) {
          return this.validationFn(EditorFloatOption.float(input, this.defaultValue));
        }
      };
      EditorStringOption = class extends SimpleEditorOption {
        static string(value, defaultValue) {
          if (typeof value !== "string") {
            return defaultValue;
          }
          return value;
        }
        constructor(id2, name, defaultValue, schema = void 0) {
          if (typeof schema !== "undefined") {
            schema.type = "string";
            schema.default = defaultValue;
          }
          super(id2, name, defaultValue, schema);
        }
        validate(input) {
          return EditorStringOption.string(input, this.defaultValue);
        }
      };
      EditorStringEnumOption = class extends SimpleEditorOption {
        constructor(id2, name, defaultValue, allowedValues, schema = void 0) {
          if (typeof schema !== "undefined") {
            schema.type = "string";
            schema.enum = allowedValues;
            schema.default = defaultValue;
          }
          super(id2, name, defaultValue, schema);
          this._allowedValues = allowedValues;
        }
        validate(input) {
          return stringSet(input, this.defaultValue, this._allowedValues);
        }
      };
      EditorEnumOption = class extends BaseEditorOption {
        constructor(id2, name, defaultValue, defaultStringValue, allowedValues, convert, schema = void 0) {
          if (typeof schema !== "undefined") {
            schema.type = "string";
            schema.enum = allowedValues;
            schema.default = defaultStringValue;
          }
          super(id2, name, defaultValue, schema);
          this._allowedValues = allowedValues;
          this._convert = convert;
        }
        validate(input) {
          if (typeof input !== "string") {
            return this.defaultValue;
          }
          if (this._allowedValues.indexOf(input) === -1) {
            return this.defaultValue;
          }
          return this._convert(input);
        }
      };
      EditorAccessibilitySupport = class extends BaseEditorOption {
        constructor() {
          super(2, "accessibilitySupport", 0, {
            type: "string",
            enum: ["auto", "on", "off"],
            enumDescriptions: [
              localize("accessibilitySupport.auto", "Use platform APIs to detect when a Screen Reader is attached"),
              localize("accessibilitySupport.on", "Optimize for usage with a Screen Reader"),
              localize("accessibilitySupport.off", "Assume a screen reader is not attached")
            ],
            default: "auto",
            tags: ["accessibility"],
            description: localize("accessibilitySupport", "Controls if the UI should run in a mode where it is optimized for screen readers.")
          });
        }
        validate(input) {
          switch (input) {
            case "auto":
              return 0;
            case "off":
              return 1;
            case "on":
              return 2;
          }
          return this.defaultValue;
        }
        compute(env3, options, value) {
          if (value === 0) {
            return env3.accessibilitySupport;
          }
          return value;
        }
      };
      EditorComments = class extends BaseEditorOption {
        constructor() {
          const defaults = {
            insertSpace: true,
            ignoreEmptyLines: true
          };
          super(22, "comments", defaults, {
            "editor.comments.insertSpace": {
              type: "boolean",
              default: defaults.insertSpace,
              description: localize("comments.insertSpace", "Controls whether a space character is inserted when commenting.")
            },
            "editor.comments.ignoreEmptyLines": {
              type: "boolean",
              default: defaults.ignoreEmptyLines,
              description: localize("comments.ignoreEmptyLines", "Controls if empty lines should be ignored with toggle, add or remove actions for line comments.")
            }
          });
        }
        validate(_input) {
          if (!_input || typeof _input !== "object") {
            return this.defaultValue;
          }
          const input = _input;
          return {
            insertSpace: boolean(input.insertSpace, this.defaultValue.insertSpace),
            ignoreEmptyLines: boolean(input.ignoreEmptyLines, this.defaultValue.ignoreEmptyLines)
          };
        }
      };
      (function(TextEditorCursorStyle3) {
        TextEditorCursorStyle3[TextEditorCursorStyle3["Line"] = 1] = "Line";
        TextEditorCursorStyle3[TextEditorCursorStyle3["Block"] = 2] = "Block";
        TextEditorCursorStyle3[TextEditorCursorStyle3["Underline"] = 3] = "Underline";
        TextEditorCursorStyle3[TextEditorCursorStyle3["LineThin"] = 4] = "LineThin";
        TextEditorCursorStyle3[TextEditorCursorStyle3["BlockOutline"] = 5] = "BlockOutline";
        TextEditorCursorStyle3[TextEditorCursorStyle3["UnderlineThin"] = 6] = "UnderlineThin";
      })(TextEditorCursorStyle || (TextEditorCursorStyle = {}));
      EditorClassName = class extends ComputedEditorOption {
        constructor() {
          super(
            139
            /* EditorOption.editorClassName */
          );
        }
        compute(env3, options, _) {
          const classNames = ["monaco-editor"];
          if (options.get(
            38
            /* EditorOption.extraEditorClassName */
          )) {
            classNames.push(options.get(
              38
              /* EditorOption.extraEditorClassName */
            ));
          }
          if (env3.extraEditorClassName) {
            classNames.push(env3.extraEditorClassName);
          }
          if (options.get(
            72
            /* EditorOption.mouseStyle */
          ) === "default") {
            classNames.push("mouse-default");
          } else if (options.get(
            72
            /* EditorOption.mouseStyle */
          ) === "copy") {
            classNames.push("mouse-copy");
          }
          if (options.get(
            109
            /* EditorOption.showUnused */
          )) {
            classNames.push("showUnused");
          }
          if (options.get(
            137
            /* EditorOption.showDeprecated */
          )) {
            classNames.push("showDeprecated");
          }
          return classNames.join(" ");
        }
      };
      EditorEmptySelectionClipboard = class extends EditorBooleanOption {
        constructor() {
          super(36, "emptySelectionClipboard", true, { description: localize("emptySelectionClipboard", "Controls whether copying without a selection copies the current line.") });
        }
        compute(env3, options, value) {
          return value && env3.emptySelectionClipboard;
        }
      };
      EditorFind = class extends BaseEditorOption {
        constructor() {
          const defaults = {
            cursorMoveOnType: true,
            seedSearchStringFromSelection: "always",
            autoFindInSelection: "never",
            globalFindClipboard: false,
            addExtraSpaceOnTop: true,
            loop: true
          };
          super(40, "find", defaults, {
            "editor.find.cursorMoveOnType": {
              type: "boolean",
              default: defaults.cursorMoveOnType,
              description: localize("find.cursorMoveOnType", "Controls whether the cursor should jump to find matches while typing.")
            },
            "editor.find.seedSearchStringFromSelection": {
              type: "string",
              enum: ["never", "always", "selection"],
              default: defaults.seedSearchStringFromSelection,
              enumDescriptions: [
                localize("editor.find.seedSearchStringFromSelection.never", "Never seed search string from the editor selection."),
                localize("editor.find.seedSearchStringFromSelection.always", "Always seed search string from the editor selection, including word at cursor position."),
                localize("editor.find.seedSearchStringFromSelection.selection", "Only seed search string from the editor selection.")
              ],
              description: localize("find.seedSearchStringFromSelection", "Controls whether the search string in the Find Widget is seeded from the editor selection.")
            },
            "editor.find.autoFindInSelection": {
              type: "string",
              enum: ["never", "always", "multiline"],
              default: defaults.autoFindInSelection,
              enumDescriptions: [
                localize("editor.find.autoFindInSelection.never", "Never turn on Find in Selection automatically (default)."),
                localize("editor.find.autoFindInSelection.always", "Always turn on Find in Selection automatically."),
                localize("editor.find.autoFindInSelection.multiline", "Turn on Find in Selection automatically when multiple lines of content are selected.")
              ],
              description: localize("find.autoFindInSelection", "Controls the condition for turning on Find in Selection automatically.")
            },
            "editor.find.globalFindClipboard": {
              type: "boolean",
              default: defaults.globalFindClipboard,
              description: localize("find.globalFindClipboard", "Controls whether the Find Widget should read or modify the shared find clipboard on macOS."),
              included: isMacintosh
            },
            "editor.find.addExtraSpaceOnTop": {
              type: "boolean",
              default: defaults.addExtraSpaceOnTop,
              description: localize("find.addExtraSpaceOnTop", "Controls whether the Find Widget should add extra lines on top of the editor. When true, you can scroll beyond the first line when the Find Widget is visible.")
            },
            "editor.find.loop": {
              type: "boolean",
              default: defaults.loop,
              description: localize("find.loop", "Controls whether the search automatically restarts from the beginning (or the end) when no further matches can be found.")
            }
          });
        }
        validate(_input) {
          if (!_input || typeof _input !== "object") {
            return this.defaultValue;
          }
          const input = _input;
          return {
            cursorMoveOnType: boolean(input.cursorMoveOnType, this.defaultValue.cursorMoveOnType),
            seedSearchStringFromSelection: typeof _input.seedSearchStringFromSelection === "boolean" ? _input.seedSearchStringFromSelection ? "always" : "never" : stringSet(input.seedSearchStringFromSelection, this.defaultValue.seedSearchStringFromSelection, ["never", "always", "selection"]),
            autoFindInSelection: typeof _input.autoFindInSelection === "boolean" ? _input.autoFindInSelection ? "always" : "never" : stringSet(input.autoFindInSelection, this.defaultValue.autoFindInSelection, ["never", "always", "multiline"]),
            globalFindClipboard: boolean(input.globalFindClipboard, this.defaultValue.globalFindClipboard),
            addExtraSpaceOnTop: boolean(input.addExtraSpaceOnTop, this.defaultValue.addExtraSpaceOnTop),
            loop: boolean(input.loop, this.defaultValue.loop)
          };
        }
      };
      EditorFontLigatures = class extends BaseEditorOption {
        constructor() {
          super(50, "fontLigatures", EditorFontLigatures.OFF, {
            anyOf: [
              {
                type: "boolean",
                description: localize("fontLigatures", "Enables/Disables font ligatures ('calt' and 'liga' font features). Change this to a string for fine-grained control of the 'font-feature-settings' CSS property.")
              },
              {
                type: "string",
                description: localize("fontFeatureSettings", "Explicit 'font-feature-settings' CSS property. A boolean can be passed instead if one only needs to turn on/off ligatures.")
              }
            ],
            description: localize("fontLigaturesGeneral", "Configures font ligatures or font features. Can be either a boolean to enable/disable ligatures or a string for the value of the CSS 'font-feature-settings' property."),
            default: false
          });
        }
        validate(input) {
          if (typeof input === "undefined") {
            return this.defaultValue;
          }
          if (typeof input === "string") {
            if (input === "false") {
              return EditorFontLigatures.OFF;
            }
            if (input === "true") {
              return EditorFontLigatures.ON;
            }
            return input;
          }
          if (Boolean(input)) {
            return EditorFontLigatures.ON;
          }
          return EditorFontLigatures.OFF;
        }
      };
      EditorFontLigatures.OFF = '"liga" off, "calt" off';
      EditorFontLigatures.ON = '"liga" on, "calt" on';
      EditorFontVariations = class extends BaseEditorOption {
        constructor() {
          super(53, "fontVariations", EditorFontVariations.OFF, {
            anyOf: [
              {
                type: "boolean",
                description: localize("fontVariations", "Enables/Disables the translation from font-weight to font-variation-settings. Change this to a string for fine-grained control of the 'font-variation-settings' CSS property.")
              },
              {
                type: "string",
                description: localize("fontVariationSettings", "Explicit 'font-variation-settings' CSS property. A boolean can be passed instead if one only needs to translate font-weight to font-variation-settings.")
              }
            ],
            description: localize("fontVariationsGeneral", "Configures font variations. Can be either a boolean to enable/disable the translation from font-weight to font-variation-settings or a string for the value of the CSS 'font-variation-settings' property."),
            default: false
          });
        }
        validate(input) {
          if (typeof input === "undefined") {
            return this.defaultValue;
          }
          if (typeof input === "string") {
            if (input === "false") {
              return EditorFontVariations.OFF;
            }
            if (input === "true") {
              return EditorFontVariations.TRANSLATE;
            }
            return input;
          }
          if (Boolean(input)) {
            return EditorFontVariations.TRANSLATE;
          }
          return EditorFontVariations.OFF;
        }
        compute(env3, options, value) {
          return env3.fontInfo.fontVariationSettings;
        }
      };
      EditorFontVariations.OFF = "normal";
      EditorFontVariations.TRANSLATE = "translate";
      EditorFontInfo = class extends ComputedEditorOption {
        constructor() {
          super(
            49
            /* EditorOption.fontInfo */
          );
        }
        compute(env3, options, _) {
          return env3.fontInfo;
        }
      };
      EditorFontSize = class extends SimpleEditorOption {
        constructor() {
          super(51, "fontSize", EDITOR_FONT_DEFAULTS.fontSize, {
            type: "number",
            minimum: 6,
            maximum: 100,
            default: EDITOR_FONT_DEFAULTS.fontSize,
            description: localize("fontSize", "Controls the font size in pixels.")
          });
        }
        validate(input) {
          const r = EditorFloatOption.float(input, this.defaultValue);
          if (r === 0) {
            return EDITOR_FONT_DEFAULTS.fontSize;
          }
          return EditorFloatOption.clamp(r, 6, 100);
        }
        compute(env3, options, value) {
          return env3.fontInfo.fontSize;
        }
      };
      EditorFontWeight = class extends BaseEditorOption {
        constructor() {
          super(52, "fontWeight", EDITOR_FONT_DEFAULTS.fontWeight, {
            anyOf: [
              {
                type: "number",
                minimum: EditorFontWeight.MINIMUM_VALUE,
                maximum: EditorFontWeight.MAXIMUM_VALUE,
                errorMessage: localize("fontWeightErrorMessage", 'Only "normal" and "bold" keywords or numbers between 1 and 1000 are allowed.')
              },
              {
                type: "string",
                pattern: "^(normal|bold|1000|[1-9][0-9]{0,2})$"
              },
              {
                enum: EditorFontWeight.SUGGESTION_VALUES
              }
            ],
            default: EDITOR_FONT_DEFAULTS.fontWeight,
            description: localize("fontWeight", 'Controls the font weight. Accepts "normal" and "bold" keywords or numbers between 1 and 1000.')
          });
        }
        validate(input) {
          if (input === "normal" || input === "bold") {
            return input;
          }
          return String(EditorIntOption.clampedInt(input, EDITOR_FONT_DEFAULTS.fontWeight, EditorFontWeight.MINIMUM_VALUE, EditorFontWeight.MAXIMUM_VALUE));
        }
      };
      EditorFontWeight.SUGGESTION_VALUES = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"];
      EditorFontWeight.MINIMUM_VALUE = 1;
      EditorFontWeight.MAXIMUM_VALUE = 1e3;
      EditorGoToLocation = class extends BaseEditorOption {
        constructor() {
          const defaults = {
            multiple: "peek",
            multipleDefinitions: "peek",
            multipleTypeDefinitions: "peek",
            multipleDeclarations: "peek",
            multipleImplementations: "peek",
            multipleReferences: "peek",
            alternativeDefinitionCommand: "editor.action.goToReferences",
            alternativeTypeDefinitionCommand: "editor.action.goToReferences",
            alternativeDeclarationCommand: "editor.action.goToReferences",
            alternativeImplementationCommand: "",
            alternativeReferenceCommand: ""
          };
          const jsonSubset = {
            type: "string",
            enum: ["peek", "gotoAndPeek", "goto"],
            default: defaults.multiple,
            enumDescriptions: [
              localize("editor.gotoLocation.multiple.peek", "Show Peek view of the results (default)"),
              localize("editor.gotoLocation.multiple.gotoAndPeek", "Go to the primary result and show a Peek view"),
              localize("editor.gotoLocation.multiple.goto", "Go to the primary result and enable Peek-less navigation to others")
            ]
          };
          const alternativeCommandOptions = ["", "editor.action.referenceSearch.trigger", "editor.action.goToReferences", "editor.action.peekImplementation", "editor.action.goToImplementation", "editor.action.peekTypeDefinition", "editor.action.goToTypeDefinition", "editor.action.peekDeclaration", "editor.action.revealDeclaration", "editor.action.peekDefinition", "editor.action.revealDefinitionAside", "editor.action.revealDefinition"];
          super(57, "gotoLocation", defaults, {
            "editor.gotoLocation.multiple": {
              deprecationMessage: localize("editor.gotoLocation.multiple.deprecated", "This setting is deprecated, please use separate settings like 'editor.editor.gotoLocation.multipleDefinitions' or 'editor.editor.gotoLocation.multipleImplementations' instead.")
            },
            "editor.gotoLocation.multipleDefinitions": Object.assign({ description: localize("editor.editor.gotoLocation.multipleDefinitions", "Controls the behavior the 'Go to Definition'-command when multiple target locations exist.") }, jsonSubset),
            "editor.gotoLocation.multipleTypeDefinitions": Object.assign({ description: localize("editor.editor.gotoLocation.multipleTypeDefinitions", "Controls the behavior the 'Go to Type Definition'-command when multiple target locations exist.") }, jsonSubset),
            "editor.gotoLocation.multipleDeclarations": Object.assign({ description: localize("editor.editor.gotoLocation.multipleDeclarations", "Controls the behavior the 'Go to Declaration'-command when multiple target locations exist.") }, jsonSubset),
            "editor.gotoLocation.multipleImplementations": Object.assign({ description: localize("editor.editor.gotoLocation.multipleImplemenattions", "Controls the behavior the 'Go to Implementations'-command when multiple target locations exist.") }, jsonSubset),
            "editor.gotoLocation.multipleReferences": Object.assign({ description: localize("editor.editor.gotoLocation.multipleReferences", "Controls the behavior the 'Go to References'-command when multiple target locations exist.") }, jsonSubset),
            "editor.gotoLocation.alternativeDefinitionCommand": {
              type: "string",
              default: defaults.alternativeDefinitionCommand,
              enum: alternativeCommandOptions,
              description: localize("alternativeDefinitionCommand", "Alternative command id that is being executed when the result of 'Go to Definition' is the current location.")
            },
            "editor.gotoLocation.alternativeTypeDefinitionCommand": {
              type: "string",
              default: defaults.alternativeTypeDefinitionCommand,
              enum: alternativeCommandOptions,
              description: localize("alternativeTypeDefinitionCommand", "Alternative command id that is being executed when the result of 'Go to Type Definition' is the current location.")
            },
            "editor.gotoLocation.alternativeDeclarationCommand": {
              type: "string",
              default: defaults.alternativeDeclarationCommand,
              enum: alternativeCommandOptions,
              description: localize("alternativeDeclarationCommand", "Alternative command id that is being executed when the result of 'Go to Declaration' is the current location.")
            },
            "editor.gotoLocation.alternativeImplementationCommand": {
              type: "string",
              default: defaults.alternativeImplementationCommand,
              enum: alternativeCommandOptions,
              description: localize("alternativeImplementationCommand", "Alternative command id that is being executed when the result of 'Go to Implementation' is the current location.")
            },
            "editor.gotoLocation.alternativeReferenceCommand": {
              type: "string",
              default: defaults.alternativeReferenceCommand,
              enum: alternativeCommandOptions,
              description: localize("alternativeReferenceCommand", "Alternative command id that is being executed when the result of 'Go to Reference' is the current location.")
            }
          });
        }
        validate(_input) {
          var _a4, _b2, _c2, _d, _e;
          if (!_input || typeof _input !== "object") {
            return this.defaultValue;
          }
          const input = _input;
          return {
            multiple: stringSet(input.multiple, this.defaultValue.multiple, ["peek", "gotoAndPeek", "goto"]),
            multipleDefinitions: (_a4 = input.multipleDefinitions) !== null && _a4 !== void 0 ? _a4 : stringSet(input.multipleDefinitions, "peek", ["peek", "gotoAndPeek", "goto"]),
            multipleTypeDefinitions: (_b2 = input.multipleTypeDefinitions) !== null && _b2 !== void 0 ? _b2 : stringSet(input.multipleTypeDefinitions, "peek", ["peek", "gotoAndPeek", "goto"]),
            multipleDeclarations: (_c2 = input.multipleDeclarations) !== null && _c2 !== void 0 ? _c2 : stringSet(input.multipleDeclarations, "peek", ["peek", "gotoAndPeek", "goto"]),
            multipleImplementations: (_d = input.multipleImplementations) !== null && _d !== void 0 ? _d : stringSet(input.multipleImplementations, "peek", ["peek", "gotoAndPeek", "goto"]),
            multipleReferences: (_e = input.multipleReferences) !== null && _e !== void 0 ? _e : stringSet(input.multipleReferences, "peek", ["peek", "gotoAndPeek", "goto"]),
            alternativeDefinitionCommand: EditorStringOption.string(input.alternativeDefinitionCommand, this.defaultValue.alternativeDefinitionCommand),
            alternativeTypeDefinitionCommand: EditorStringOption.string(input.alternativeTypeDefinitionCommand, this.defaultValue.alternativeTypeDefinitionCommand),
            alternativeDeclarationCommand: EditorStringOption.string(input.alternativeDeclarationCommand, this.defaultValue.alternativeDeclarationCommand),
            alternativeImplementationCommand: EditorStringOption.string(input.alternativeImplementationCommand, this.defaultValue.alternativeImplementationCommand),
            alternativeReferenceCommand: EditorStringOption.string(input.alternativeReferenceCommand, this.defaultValue.alternativeReferenceCommand)
          };
        }
      };
      EditorHover = class extends BaseEditorOption {
        constructor() {
          const defaults = {
            enabled: true,
            delay: 300,
            sticky: true,
            above: true
          };
          super(59, "hover", defaults, {
            "editor.hover.enabled": {
              type: "boolean",
              default: defaults.enabled,
              description: localize("hover.enabled", "Controls whether the hover is shown.")
            },
            "editor.hover.delay": {
              type: "number",
              default: defaults.delay,
              minimum: 0,
              maximum: 1e4,
              description: localize("hover.delay", "Controls the delay in milliseconds after which the hover is shown.")
            },
            "editor.hover.sticky": {
              type: "boolean",
              default: defaults.sticky,
              description: localize("hover.sticky", "Controls whether the hover should remain visible when mouse is moved over it.")
            },
            "editor.hover.above": {
              type: "boolean",
              default: defaults.above,
              description: localize("hover.above", "Prefer showing hovers above the line, if there's space.")
            }
          });
        }
        validate(_input) {
          if (!_input || typeof _input !== "object") {
            return this.defaultValue;
          }
          const input = _input;
          return {
            enabled: boolean(input.enabled, this.defaultValue.enabled),
            delay: EditorIntOption.clampedInt(input.delay, this.defaultValue.delay, 0, 1e4),
            sticky: boolean(input.sticky, this.defaultValue.sticky),
            above: boolean(input.above, this.defaultValue.above)
          };
        }
      };
      EditorLayoutInfoComputer = class extends ComputedEditorOption {
        constructor() {
          super(
            142
            /* EditorOption.layoutInfo */
          );
        }
        compute(env3, options, _) {
          return EditorLayoutInfoComputer.computeLayout(options, {
            memory: env3.memory,
            outerWidth: env3.outerWidth,
            outerHeight: env3.outerHeight,
            isDominatedByLongLines: env3.isDominatedByLongLines,
            lineHeight: env3.fontInfo.lineHeight,
            viewLineCount: env3.viewLineCount,
            lineNumbersDigitCount: env3.lineNumbersDigitCount,
            typicalHalfwidthCharacterWidth: env3.fontInfo.typicalHalfwidthCharacterWidth,
            maxDigitWidth: env3.fontInfo.maxDigitWidth,
            pixelRatio: env3.pixelRatio,
            glyphMarginDecorationLaneCount: env3.glyphMarginDecorationLaneCount
          });
        }
        static computeContainedMinimapLineCount(input) {
          const typicalViewportLineCount = input.height / input.lineHeight;
          const extraLinesBeforeFirstLine = Math.floor(input.paddingTop / input.lineHeight);
          let extraLinesBeyondLastLine = Math.floor(input.paddingBottom / input.lineHeight);
          if (input.scrollBeyondLastLine) {
            extraLinesBeyondLastLine = Math.max(extraLinesBeyondLastLine, typicalViewportLineCount - 1);
          }
          const desiredRatio = (extraLinesBeforeFirstLine + input.viewLineCount + extraLinesBeyondLastLine) / (input.pixelRatio * input.height);
          const minimapLineCount = Math.floor(input.viewLineCount / desiredRatio);
          return { typicalViewportLineCount, extraLinesBeforeFirstLine, extraLinesBeyondLastLine, desiredRatio, minimapLineCount };
        }
        static _computeMinimapLayout(input, memory) {
          const outerWidth = input.outerWidth;
          const outerHeight = input.outerHeight;
          const pixelRatio = input.pixelRatio;
          if (!input.minimap.enabled) {
            return {
              renderMinimap: 0,
              minimapLeft: 0,
              minimapWidth: 0,
              minimapHeightIsEditorHeight: false,
              minimapIsSampling: false,
              minimapScale: 1,
              minimapLineHeight: 1,
              minimapCanvasInnerWidth: 0,
              minimapCanvasInnerHeight: Math.floor(pixelRatio * outerHeight),
              minimapCanvasOuterWidth: 0,
              minimapCanvasOuterHeight: outerHeight
            };
          }
          const stableMinimapLayoutInput = memory.stableMinimapLayoutInput;
          const couldUseMemory = stableMinimapLayoutInput && input.outerHeight === stableMinimapLayoutInput.outerHeight && input.lineHeight === stableMinimapLayoutInput.lineHeight && input.typicalHalfwidthCharacterWidth === stableMinimapLayoutInput.typicalHalfwidthCharacterWidth && input.pixelRatio === stableMinimapLayoutInput.pixelRatio && input.scrollBeyondLastLine === stableMinimapLayoutInput.scrollBeyondLastLine && input.paddingTop === stableMinimapLayoutInput.paddingTop && input.paddingBottom === stableMinimapLayoutInput.paddingBottom && input.minimap.enabled === stableMinimapLayoutInput.minimap.enabled && input.minimap.side === stableMinimapLayoutInput.minimap.side && input.minimap.size === stableMinimapLayoutInput.minimap.size && input.minimap.showSlider === stableMinimapLayoutInput.minimap.showSlider && input.minimap.renderCharacters === stableMinimapLayoutInput.minimap.renderCharacters && input.minimap.maxColumn === stableMinimapLayoutInput.minimap.maxColumn && input.minimap.scale === stableMinimapLayoutInput.minimap.scale && input.verticalScrollbarWidth === stableMinimapLayoutInput.verticalScrollbarWidth && input.isViewportWrapping === stableMinimapLayoutInput.isViewportWrapping;
          const lineHeight = input.lineHeight;
          const typicalHalfwidthCharacterWidth = input.typicalHalfwidthCharacterWidth;
          const scrollBeyondLastLine = input.scrollBeyondLastLine;
          const minimapRenderCharacters = input.minimap.renderCharacters;
          let minimapScale = pixelRatio >= 2 ? Math.round(input.minimap.scale * 2) : input.minimap.scale;
          const minimapMaxColumn = input.minimap.maxColumn;
          const minimapSize = input.minimap.size;
          const minimapSide = input.minimap.side;
          const verticalScrollbarWidth = input.verticalScrollbarWidth;
          const viewLineCount = input.viewLineCount;
          const remainingWidth = input.remainingWidth;
          const isViewportWrapping = input.isViewportWrapping;
          const baseCharHeight = minimapRenderCharacters ? 2 : 3;
          let minimapCanvasInnerHeight = Math.floor(pixelRatio * outerHeight);
          const minimapCanvasOuterHeight = minimapCanvasInnerHeight / pixelRatio;
          let minimapHeightIsEditorHeight = false;
          let minimapIsSampling = false;
          let minimapLineHeight = baseCharHeight * minimapScale;
          let minimapCharWidth = minimapScale / pixelRatio;
          let minimapWidthMultiplier = 1;
          if (minimapSize === "fill" || minimapSize === "fit") {
            const { typicalViewportLineCount, extraLinesBeforeFirstLine, extraLinesBeyondLastLine, desiredRatio, minimapLineCount } = EditorLayoutInfoComputer.computeContainedMinimapLineCount({
              viewLineCount,
              scrollBeyondLastLine,
              paddingTop: input.paddingTop,
              paddingBottom: input.paddingBottom,
              height: outerHeight,
              lineHeight,
              pixelRatio
            });
            const ratio = viewLineCount / minimapLineCount;
            if (ratio > 1) {
              minimapHeightIsEditorHeight = true;
              minimapIsSampling = true;
              minimapScale = 1;
              minimapLineHeight = 1;
              minimapCharWidth = minimapScale / pixelRatio;
            } else {
              let fitBecomesFill = false;
              let maxMinimapScale = minimapScale + 1;
              if (minimapSize === "fit") {
                const effectiveMinimapHeight = Math.ceil((extraLinesBeforeFirstLine + viewLineCount + extraLinesBeyondLastLine) * minimapLineHeight);
                if (isViewportWrapping && couldUseMemory && remainingWidth <= memory.stableFitRemainingWidth) {
                  fitBecomesFill = true;
                  maxMinimapScale = memory.stableFitMaxMinimapScale;
                } else {
                  fitBecomesFill = effectiveMinimapHeight > minimapCanvasInnerHeight;
                }
              }
              if (minimapSize === "fill" || fitBecomesFill) {
                minimapHeightIsEditorHeight = true;
                const configuredMinimapScale = minimapScale;
                minimapLineHeight = Math.min(lineHeight * pixelRatio, Math.max(1, Math.floor(1 / desiredRatio)));
                if (isViewportWrapping && couldUseMemory && remainingWidth <= memory.stableFitRemainingWidth) {
                  maxMinimapScale = memory.stableFitMaxMinimapScale;
                }
                minimapScale = Math.min(maxMinimapScale, Math.max(1, Math.floor(minimapLineHeight / baseCharHeight)));
                if (minimapScale > configuredMinimapScale) {
                  minimapWidthMultiplier = Math.min(2, minimapScale / configuredMinimapScale);
                }
                minimapCharWidth = minimapScale / pixelRatio / minimapWidthMultiplier;
                minimapCanvasInnerHeight = Math.ceil(Math.max(typicalViewportLineCount, extraLinesBeforeFirstLine + viewLineCount + extraLinesBeyondLastLine) * minimapLineHeight);
                if (isViewportWrapping) {
                  memory.stableMinimapLayoutInput = input;
                  memory.stableFitRemainingWidth = remainingWidth;
                  memory.stableFitMaxMinimapScale = minimapScale;
                } else {
                  memory.stableMinimapLayoutInput = null;
                  memory.stableFitRemainingWidth = 0;
                }
              }
            }
          }
          const minimapMaxWidth = Math.floor(minimapMaxColumn * minimapCharWidth);
          const minimapWidth = Math.min(minimapMaxWidth, Math.max(0, Math.floor((remainingWidth - verticalScrollbarWidth - 2) * minimapCharWidth / (typicalHalfwidthCharacterWidth + minimapCharWidth))) + MINIMAP_GUTTER_WIDTH);
          let minimapCanvasInnerWidth = Math.floor(pixelRatio * minimapWidth);
          const minimapCanvasOuterWidth = minimapCanvasInnerWidth / pixelRatio;
          minimapCanvasInnerWidth = Math.floor(minimapCanvasInnerWidth * minimapWidthMultiplier);
          const renderMinimap = minimapRenderCharacters ? 1 : 2;
          const minimapLeft = minimapSide === "left" ? 0 : outerWidth - minimapWidth - verticalScrollbarWidth;
          return {
            renderMinimap,
            minimapLeft,
            minimapWidth,
            minimapHeightIsEditorHeight,
            minimapIsSampling,
            minimapScale,
            minimapLineHeight,
            minimapCanvasInnerWidth,
            minimapCanvasInnerHeight,
            minimapCanvasOuterWidth,
            minimapCanvasOuterHeight
          };
        }
        static computeLayout(options, env3) {
          const outerWidth = env3.outerWidth | 0;
          const outerHeight = env3.outerHeight | 0;
          const lineHeight = env3.lineHeight | 0;
          const lineNumbersDigitCount = env3.lineNumbersDigitCount | 0;
          const typicalHalfwidthCharacterWidth = env3.typicalHalfwidthCharacterWidth;
          const maxDigitWidth = env3.maxDigitWidth;
          const pixelRatio = env3.pixelRatio;
          const viewLineCount = env3.viewLineCount;
          const wordWrapOverride2 = options.get(
            134
            /* EditorOption.wordWrapOverride2 */
          );
          const wordWrapOverride1 = wordWrapOverride2 === "inherit" ? options.get(
            133
            /* EditorOption.wordWrapOverride1 */
          ) : wordWrapOverride2;
          const wordWrap = wordWrapOverride1 === "inherit" ? options.get(
            129
            /* EditorOption.wordWrap */
          ) : wordWrapOverride1;
          const wordWrapColumn = options.get(
            132
            /* EditorOption.wordWrapColumn */
          );
          const isDominatedByLongLines = env3.isDominatedByLongLines;
          const showGlyphMargin = options.get(
            56
            /* EditorOption.glyphMargin */
          );
          const showLineNumbers = options.get(
            66
            /* EditorOption.lineNumbers */
          ).renderType !== 0;
          const lineNumbersMinChars = options.get(
            67
            /* EditorOption.lineNumbersMinChars */
          );
          const scrollBeyondLastLine = options.get(
            103
            /* EditorOption.scrollBeyondLastLine */
          );
          const padding = options.get(
            82
            /* EditorOption.padding */
          );
          const minimap = options.get(
            71
            /* EditorOption.minimap */
          );
          const scrollbar = options.get(
            101
            /* EditorOption.scrollbar */
          );
          const verticalScrollbarWidth = scrollbar.verticalScrollbarSize;
          const verticalScrollbarHasArrows = scrollbar.verticalHasArrows;
          const scrollbarArrowSize = scrollbar.arrowSize;
          const horizontalScrollbarHeight = scrollbar.horizontalScrollbarSize;
          const folding = options.get(
            42
            /* EditorOption.folding */
          );
          const showFoldingDecoration = options.get(
            108
            /* EditorOption.showFoldingControls */
          ) !== "never";
          let lineDecorationsWidth = options.get(
            64
            /* EditorOption.lineDecorationsWidth */
          );
          if (folding && showFoldingDecoration) {
            lineDecorationsWidth += 16;
          }
          let lineNumbersWidth = 0;
          if (showLineNumbers) {
            const digitCount = Math.max(lineNumbersDigitCount, lineNumbersMinChars);
            lineNumbersWidth = Math.round(digitCount * maxDigitWidth);
          }
          let glyphMarginWidth = 0;
          if (showGlyphMargin) {
            glyphMarginWidth = lineHeight * env3.glyphMarginDecorationLaneCount;
          }
          let glyphMarginLeft = 0;
          let lineNumbersLeft = glyphMarginLeft + glyphMarginWidth;
          let decorationsLeft = lineNumbersLeft + lineNumbersWidth;
          let contentLeft = decorationsLeft + lineDecorationsWidth;
          const remainingWidth = outerWidth - glyphMarginWidth - lineNumbersWidth - lineDecorationsWidth;
          let isWordWrapMinified = false;
          let isViewportWrapping = false;
          let wrappingColumn = -1;
          if (wordWrapOverride1 === "inherit" && isDominatedByLongLines) {
            isWordWrapMinified = true;
            isViewportWrapping = true;
          } else if (wordWrap === "on" || wordWrap === "bounded") {
            isViewportWrapping = true;
          } else if (wordWrap === "wordWrapColumn") {
            wrappingColumn = wordWrapColumn;
          }
          const minimapLayout = EditorLayoutInfoComputer._computeMinimapLayout({
            outerWidth,
            outerHeight,
            lineHeight,
            typicalHalfwidthCharacterWidth,
            pixelRatio,
            scrollBeyondLastLine,
            paddingTop: padding.top,
            paddingBottom: padding.bottom,
            minimap,
            verticalScrollbarWidth,
            viewLineCount,
            remainingWidth,
            isViewportWrapping
          }, env3.memory || new ComputeOptionsMemory());
          if (minimapLayout.renderMinimap !== 0 && minimapLayout.minimapLeft === 0) {
            glyphMarginLeft += minimapLayout.minimapWidth;
            lineNumbersLeft += minimapLayout.minimapWidth;
            decorationsLeft += minimapLayout.minimapWidth;
            contentLeft += minimapLayout.minimapWidth;
          }
          const contentWidth = remainingWidth - minimapLayout.minimapWidth;
          const viewportColumn = Math.max(1, Math.floor((contentWidth - verticalScrollbarWidth - 2) / typicalHalfwidthCharacterWidth));
          const verticalArrowSize = verticalScrollbarHasArrows ? scrollbarArrowSize : 0;
          if (isViewportWrapping) {
            wrappingColumn = Math.max(1, viewportColumn);
            if (wordWrap === "bounded") {
              wrappingColumn = Math.min(wrappingColumn, wordWrapColumn);
            }
          }
          return {
            width: outerWidth,
            height: outerHeight,
            glyphMarginLeft,
            glyphMarginWidth,
            glyphMarginDecorationLaneCount: env3.glyphMarginDecorationLaneCount,
            lineNumbersLeft,
            lineNumbersWidth,
            decorationsLeft,
            decorationsWidth: lineDecorationsWidth,
            contentLeft,
            contentWidth,
            minimap: minimapLayout,
            viewportColumn,
            isWordWrapMinified,
            isViewportWrapping,
            wrappingColumn,
            verticalScrollbarWidth,
            horizontalScrollbarHeight,
            overviewRuler: {
              top: verticalArrowSize,
              width: verticalScrollbarWidth,
              height: outerHeight - 2 * verticalArrowSize,
              right: 0
            }
          };
        }
      };
      WrappingStrategy = class extends BaseEditorOption {
        constructor() {
          super(136, "wrappingStrategy", "simple", {
            "editor.wrappingStrategy": {
              enumDescriptions: [
                localize("wrappingStrategy.simple", "Assumes that all characters are of the same width. This is a fast algorithm that works correctly for monospace fonts and certain scripts (like Latin characters) where glyphs are of equal width."),
                localize("wrappingStrategy.advanced", "Delegates wrapping points computation to the browser. This is a slow algorithm, that might cause freezes for large files, but it works correctly in all cases.")
              ],
              type: "string",
              enum: ["simple", "advanced"],
              default: "simple",
              description: localize("wrappingStrategy", "Controls the algorithm that computes wrapping points. Note that when in accessibility mode, advanced will be used for the best experience.")
            }
          });
        }
        validate(input) {
          return stringSet(input, "simple", ["simple", "advanced"]);
        }
        compute(env3, options, value) {
          const accessibilitySupport = options.get(
            2
            /* EditorOption.accessibilitySupport */
          );
          if (accessibilitySupport === 2) {
            return "advanced";
          }
          return value;
        }
      };
      EditorLightbulb = class extends BaseEditorOption {
        constructor() {
          const defaults = { enabled: true };
          super(63, "lightbulb", defaults, {
            "editor.lightbulb.enabled": {
              type: "boolean",
              default: defaults.enabled,
              description: localize("codeActions", "Enables the Code Action lightbulb in the editor.")
            }
          });
        }
        validate(_input) {
          if (!_input || typeof _input !== "object") {
            return this.defaultValue;
          }
          const input = _input;
          return {
            enabled: boolean(input.enabled, this.defaultValue.enabled)
          };
        }
      };
      EditorStickyScroll = class extends BaseEditorOption {
        constructor() {
          const defaults = { enabled: false, maxLineCount: 5, defaultModel: "outlineModel" };
          super(113, "stickyScroll", defaults, {
            "editor.stickyScroll.enabled": {
              type: "boolean",
              default: defaults.enabled,
              description: localize("editor.stickyScroll.enabled", "Shows the nested current scopes during the scroll at the top of the editor.")
            },
            "editor.stickyScroll.maxLineCount": {
              type: "number",
              default: defaults.maxLineCount,
              minimum: 1,
              maximum: 10,
              description: localize("editor.stickyScroll.maxLineCount", "Defines the maximum number of sticky lines to show.")
            },
            "editor.stickyScroll.defaultModel": {
              type: "string",
              enum: ["outlineModel", "foldingProviderModel", "indentationModel"],
              default: defaults.defaultModel,
              description: localize("editor.stickyScroll.defaultModel", "Defines the model to use for determining which lines to stick. If the outline model does not exist, it will fall back on the folding provider model which falls back on the indentation model. This order is respected in all three cases.")
            }
          });
        }
        validate(_input) {
          if (!_input || typeof _input !== "object") {
            return this.defaultValue;
          }
          const input = _input;
          return {
            enabled: boolean(input.enabled, this.defaultValue.enabled),
            maxLineCount: EditorIntOption.clampedInt(input.maxLineCount, this.defaultValue.maxLineCount, 1, 10),
            defaultModel: stringSet(input.defaultModel, this.defaultValue.defaultModel, ["outlineModel", "foldingProviderModel", "indentationModel"])
          };
        }
      };
      EditorInlayHints = class extends BaseEditorOption {
        constructor() {
          const defaults = { enabled: "on", fontSize: 0, fontFamily: "", padding: false };
          super(138, "inlayHints", defaults, {
            "editor.inlayHints.enabled": {
              type: "string",
              default: defaults.enabled,
              description: localize("inlayHints.enable", "Enables the inlay hints in the editor."),
              enum: ["on", "onUnlessPressed", "offUnlessPressed", "off"],
              markdownEnumDescriptions: [
                localize("editor.inlayHints.on", "Inlay hints are enabled"),
                localize("editor.inlayHints.onUnlessPressed", "Inlay hints are showing by default and hide when holding {0}", isMacintosh ? `Ctrl+Option` : `Ctrl+Alt`),
                localize("editor.inlayHints.offUnlessPressed", "Inlay hints are hidden by default and show when holding {0}", isMacintosh ? `Ctrl+Option` : `Ctrl+Alt`),
                localize("editor.inlayHints.off", "Inlay hints are disabled")
              ]
            },
            "editor.inlayHints.fontSize": {
              type: "number",
              default: defaults.fontSize,
              markdownDescription: localize("inlayHints.fontSize", "Controls font size of inlay hints in the editor. As default the {0} is used when the configured value is less than {1} or greater than the editor font size.", "`#editor.fontSize#`", "`5`")
            },
            "editor.inlayHints.fontFamily": {
              type: "string",
              default: defaults.fontFamily,
              markdownDescription: localize("inlayHints.fontFamily", "Controls font family of inlay hints in the editor. When set to empty, the {0} is used.", "`#editor.fontFamily#`")
            },
            "editor.inlayHints.padding": {
              type: "boolean",
              default: defaults.padding,
              description: localize("inlayHints.padding", "Enables the padding around the inlay hints in the editor.")
            }
          });
        }
        validate(_input) {
          if (!_input || typeof _input !== "object") {
            return this.defaultValue;
          }
          const input = _input;
          if (typeof input.enabled === "boolean") {
            input.enabled = input.enabled ? "on" : "off";
          }
          return {
            enabled: stringSet(input.enabled, this.defaultValue.enabled, ["on", "off", "offUnlessPressed", "onUnlessPressed"]),
            fontSize: EditorIntOption.clampedInt(input.fontSize, this.defaultValue.fontSize, 0, 100),
            fontFamily: EditorStringOption.string(input.fontFamily, this.defaultValue.fontFamily),
            padding: boolean(input.padding, this.defaultValue.padding)
          };
        }
      };
      EditorLineDecorationsWidth = class extends BaseEditorOption {
        constructor() {
          super(64, "lineDecorationsWidth", 10);
        }
        validate(input) {
          if (typeof input === "string" && /^\d+(\.\d+)?ch$/.test(input)) {
            const multiple = parseFloat(input.substring(0, input.length - 2));
            return -multiple;
          } else {
            return EditorIntOption.clampedInt(input, this.defaultValue, 0, 1e3);
          }
        }
        compute(env3, options, value) {
          if (value < 0) {
            return EditorIntOption.clampedInt(-value * env3.fontInfo.typicalHalfwidthCharacterWidth, this.defaultValue, 0, 1e3);
          } else {
            return value;
          }
        }
      };
      EditorLineHeight = class extends EditorFloatOption {
        constructor() {
          super(65, "lineHeight", EDITOR_FONT_DEFAULTS.lineHeight, (x) => EditorFloatOption.clamp(x, 0, 150), { markdownDescription: localize("lineHeight", "Controls the line height. \n - Use 0 to automatically compute the line height from the font size.\n - Values between 0 and 8 will be used as a multiplier with the font size.\n - Values greater than or equal to 8 will be used as effective values.") });
        }
        compute(env3, options, value) {
          return env3.fontInfo.lineHeight;
        }
      };
      EditorMinimap = class extends BaseEditorOption {
        constructor() {
          const defaults = {
            enabled: true,
            size: "proportional",
            side: "right",
            showSlider: "mouseover",
            autohide: false,
            renderCharacters: true,
            maxColumn: 120,
            scale: 1
          };
          super(71, "minimap", defaults, {
            "editor.minimap.enabled": {
              type: "boolean",
              default: defaults.enabled,
              description: localize("minimap.enabled", "Controls whether the minimap is shown.")
            },
            "editor.minimap.autohide": {
              type: "boolean",
              default: defaults.autohide,
              description: localize("minimap.autohide", "Controls whether the minimap is hidden automatically.")
            },
            "editor.minimap.size": {
              type: "string",
              enum: ["proportional", "fill", "fit"],
              enumDescriptions: [
                localize("minimap.size.proportional", "The minimap has the same size as the editor contents (and might scroll)."),
                localize("minimap.size.fill", "The minimap will stretch or shrink as necessary to fill the height of the editor (no scrolling)."),
                localize("minimap.size.fit", "The minimap will shrink as necessary to never be larger than the editor (no scrolling).")
              ],
              default: defaults.size,
              description: localize("minimap.size", "Controls the size of the minimap.")
            },
            "editor.minimap.side": {
              type: "string",
              enum: ["left", "right"],
              default: defaults.side,
              description: localize("minimap.side", "Controls the side where to render the minimap.")
            },
            "editor.minimap.showSlider": {
              type: "string",
              enum: ["always", "mouseover"],
              default: defaults.showSlider,
              description: localize("minimap.showSlider", "Controls when the minimap slider is shown.")
            },
            "editor.minimap.scale": {
              type: "number",
              default: defaults.scale,
              minimum: 1,
              maximum: 3,
              enum: [1, 2, 3],
              description: localize("minimap.scale", "Scale of content drawn in the minimap: 1, 2 or 3.")
            },
            "editor.minimap.renderCharacters": {
              type: "boolean",
              default: defaults.renderCharacters,
              description: localize("minimap.renderCharacters", "Render the actual characters on a line as opposed to color blocks.")
            },
            "editor.minimap.maxColumn": {
              type: "number",
              default: defaults.maxColumn,
              description: localize("minimap.maxColumn", "Limit the width of the minimap to render at most a certain number of columns.")
            }
          });
        }
        validate(_input) {
          if (!_input || typeof _input !== "object") {
            return this.defaultValue;
          }
          const input = _input;
          return {
            enabled: boolean(input.enabled, this.defaultValue.enabled),
            autohide: boolean(input.autohide, this.defaultValue.autohide),
            size: stringSet(input.size, this.defaultValue.size, ["proportional", "fill", "fit"]),
            side: stringSet(input.side, this.defaultValue.side, ["right", "left"]),
            showSlider: stringSet(input.showSlider, this.defaultValue.showSlider, ["always", "mouseover"]),
            renderCharacters: boolean(input.renderCharacters, this.defaultValue.renderCharacters),
            scale: EditorIntOption.clampedInt(input.scale, 1, 1, 3),
            maxColumn: EditorIntOption.clampedInt(input.maxColumn, this.defaultValue.maxColumn, 1, 1e4)
          };
        }
      };
      EditorPadding = class extends BaseEditorOption {
        constructor() {
          super(82, "padding", { top: 0, bottom: 0 }, {
            "editor.padding.top": {
              type: "number",
              default: 0,
              minimum: 0,
              maximum: 1e3,
              description: localize("padding.top", "Controls the amount of space between the top edge of the editor and the first line.")
            },
            "editor.padding.bottom": {
              type: "number",
              default: 0,
              minimum: 0,
              maximum: 1e3,
              description: localize("padding.bottom", "Controls the amount of space between the bottom edge of the editor and the last line.")
            }
          });
        }
        validate(_input) {
          if (!_input || typeof _input !== "object") {
            return this.defaultValue;
          }
          const input = _input;
          return {
            top: EditorIntOption.clampedInt(input.top, 0, 0, 1e3),
            bottom: EditorIntOption.clampedInt(input.bottom, 0, 0, 1e3)
          };
        }
      };
      EditorParameterHints = class extends BaseEditorOption {
        constructor() {
          const defaults = {
            enabled: true,
            cycle: true
          };
          super(84, "parameterHints", defaults, {
            "editor.parameterHints.enabled": {
              type: "boolean",
              default: defaults.enabled,
              description: localize("parameterHints.enabled", "Enables a pop-up that shows parameter documentation and type information as you type.")
            },
            "editor.parameterHints.cycle": {
              type: "boolean",
              default: defaults.cycle,
              description: localize("parameterHints.cycle", "Controls whether the parameter hints menu cycles or closes when reaching the end of the list.")
            }
          });
        }
        validate(_input) {
          if (!_input || typeof _input !== "object") {
            return this.defaultValue;
          }
          const input = _input;
          return {
            enabled: boolean(input.enabled, this.defaultValue.enabled),
            cycle: boolean(input.cycle, this.defaultValue.cycle)
          };
        }
      };
      EditorPixelRatio = class extends ComputedEditorOption {
        constructor() {
          super(
            140
            /* EditorOption.pixelRatio */
          );
        }
        compute(env3, options, _) {
          return env3.pixelRatio;
        }
      };
      EditorQuickSuggestions = class extends BaseEditorOption {
        constructor() {
          const defaults = {
            other: "on",
            comments: "off",
            strings: "off"
          };
          const types = [
            { type: "boolean" },
            {
              type: "string",
              enum: ["on", "inline", "off"],
              enumDescriptions: [localize("on", "Quick suggestions show inside the suggest widget"), localize("inline", "Quick suggestions show as ghost text"), localize("off", "Quick suggestions are disabled")]
            }
          ];
          super(87, "quickSuggestions", defaults, {
            type: "object",
            additionalProperties: false,
            properties: {
              strings: {
                anyOf: types,
                default: defaults.strings,
                description: localize("quickSuggestions.strings", "Enable quick suggestions inside strings.")
              },
              comments: {
                anyOf: types,
                default: defaults.comments,
                description: localize("quickSuggestions.comments", "Enable quick suggestions inside comments.")
              },
              other: {
                anyOf: types,
                default: defaults.other,
                description: localize("quickSuggestions.other", "Enable quick suggestions outside of strings and comments.")
              }
            },
            default: defaults,
            markdownDescription: localize("quickSuggestions", "Controls whether suggestions should automatically show up while typing. This can be controlled for typing in comments, strings, and other code. Quick suggestion can be configured to show as ghost text or with the suggest widget. Also be aware of the '{0}'-setting which controls if suggestions are triggered by special characters.", `#editor.suggestOnTriggerCharacters#`)
          });
          this.defaultValue = defaults;
        }
        validate(input) {
          if (typeof input === "boolean") {
            const value = input ? "on" : "off";
            return { comments: value, strings: value, other: value };
          }
          if (!input || typeof input !== "object") {
            return this.defaultValue;
          }
          const { other, comments: comments2, strings } = input;
          const allowedValues = ["on", "inline", "off"];
          let validatedOther;
          let validatedComments;
          let validatedStrings;
          if (typeof other === "boolean") {
            validatedOther = other ? "on" : "off";
          } else {
            validatedOther = stringSet(other, this.defaultValue.other, allowedValues);
          }
          if (typeof comments2 === "boolean") {
            validatedComments = comments2 ? "on" : "off";
          } else {
            validatedComments = stringSet(comments2, this.defaultValue.comments, allowedValues);
          }
          if (typeof strings === "boolean") {
            validatedStrings = strings ? "on" : "off";
          } else {
            validatedStrings = stringSet(strings, this.defaultValue.strings, allowedValues);
          }
          return {
            other: validatedOther,
            comments: validatedComments,
            strings: validatedStrings
          };
        }
      };
      EditorRenderLineNumbersOption = class extends BaseEditorOption {
        constructor() {
          super(66, "lineNumbers", { renderType: 1, renderFn: null }, {
            type: "string",
            enum: ["off", "on", "relative", "interval"],
            enumDescriptions: [
              localize("lineNumbers.off", "Line numbers are not rendered."),
              localize("lineNumbers.on", "Line numbers are rendered as absolute number."),
              localize("lineNumbers.relative", "Line numbers are rendered as distance in lines to cursor position."),
              localize("lineNumbers.interval", "Line numbers are rendered every 10 lines.")
            ],
            default: "on",
            description: localize("lineNumbers", "Controls the display of line numbers.")
          });
        }
        validate(lineNumbers) {
          let renderType = this.defaultValue.renderType;
          let renderFn = this.defaultValue.renderFn;
          if (typeof lineNumbers !== "undefined") {
            if (typeof lineNumbers === "function") {
              renderType = 4;
              renderFn = lineNumbers;
            } else if (lineNumbers === "interval") {
              renderType = 3;
            } else if (lineNumbers === "relative") {
              renderType = 2;
            } else if (lineNumbers === "on") {
              renderType = 1;
            } else {
              renderType = 0;
            }
          }
          return {
            renderType,
            renderFn
          };
        }
      };
      EditorRulers = class extends BaseEditorOption {
        constructor() {
          const defaults = [];
          const columnSchema = { type: "number", description: localize("rulers.size", "Number of monospace characters at which this editor ruler will render.") };
          super(100, "rulers", defaults, {
            type: "array",
            items: {
              anyOf: [
                columnSchema,
                {
                  type: [
                    "object"
                  ],
                  properties: {
                    column: columnSchema,
                    color: {
                      type: "string",
                      description: localize("rulers.color", "Color of this editor ruler."),
                      format: "color-hex"
                    }
                  }
                }
              ]
            },
            default: defaults,
            description: localize("rulers", "Render vertical rulers after a certain number of monospace characters. Use multiple values for multiple rulers. No rulers are drawn if array is empty.")
          });
        }
        validate(input) {
          if (Array.isArray(input)) {
            const rulers = [];
            for (const _element of input) {
              if (typeof _element === "number") {
                rulers.push({
                  column: EditorIntOption.clampedInt(_element, 0, 0, 1e4),
                  color: null
                });
              } else if (_element && typeof _element === "object") {
                const element = _element;
                rulers.push({
                  column: EditorIntOption.clampedInt(element.column, 0, 0, 1e4),
                  color: element.color
                });
              }
            }
            rulers.sort((a, b) => a.column - b.column);
            return rulers;
          }
          return this.defaultValue;
        }
      };
      ReadonlyMessage = class extends BaseEditorOption {
        constructor() {
          const defaults = void 0;
          super(90, "readOnlyMessage", defaults);
        }
        validate(_input) {
          if (!_input || typeof _input !== "object") {
            return this.defaultValue;
          }
          return _input;
        }
      };
      EditorScrollbar = class extends BaseEditorOption {
        constructor() {
          const defaults = {
            vertical: 1,
            horizontal: 1,
            arrowSize: 11,
            useShadows: true,
            verticalHasArrows: false,
            horizontalHasArrows: false,
            horizontalScrollbarSize: 12,
            horizontalSliderSize: 12,
            verticalScrollbarSize: 14,
            verticalSliderSize: 14,
            handleMouseWheel: true,
            alwaysConsumeMouseWheel: true,
            scrollByPage: false
          };
          super(101, "scrollbar", defaults, {
            "editor.scrollbar.vertical": {
              type: "string",
              enum: ["auto", "visible", "hidden"],
              enumDescriptions: [
                localize("scrollbar.vertical.auto", "The vertical scrollbar will be visible only when necessary."),
                localize("scrollbar.vertical.visible", "The vertical scrollbar will always be visible."),
                localize("scrollbar.vertical.fit", "The vertical scrollbar will always be hidden.")
              ],
              default: "auto",
              description: localize("scrollbar.vertical", "Controls the visibility of the vertical scrollbar.")
            },
            "editor.scrollbar.horizontal": {
              type: "string",
              enum: ["auto", "visible", "hidden"],
              enumDescriptions: [
                localize("scrollbar.horizontal.auto", "The horizontal scrollbar will be visible only when necessary."),
                localize("scrollbar.horizontal.visible", "The horizontal scrollbar will always be visible."),
                localize("scrollbar.horizontal.fit", "The horizontal scrollbar will always be hidden.")
              ],
              default: "auto",
              description: localize("scrollbar.horizontal", "Controls the visibility of the horizontal scrollbar.")
            },
            "editor.scrollbar.verticalScrollbarSize": {
              type: "number",
              default: defaults.verticalScrollbarSize,
              description: localize("scrollbar.verticalScrollbarSize", "The width of the vertical scrollbar.")
            },
            "editor.scrollbar.horizontalScrollbarSize": {
              type: "number",
              default: defaults.horizontalScrollbarSize,
              description: localize("scrollbar.horizontalScrollbarSize", "The height of the horizontal scrollbar.")
            },
            "editor.scrollbar.scrollByPage": {
              type: "boolean",
              default: defaults.scrollByPage,
              description: localize("scrollbar.scrollByPage", "Controls whether clicks scroll by page or jump to click position.")
            }
          });
        }
        validate(_input) {
          if (!_input || typeof _input !== "object") {
            return this.defaultValue;
          }
          const input = _input;
          const horizontalScrollbarSize = EditorIntOption.clampedInt(input.horizontalScrollbarSize, this.defaultValue.horizontalScrollbarSize, 0, 1e3);
          const verticalScrollbarSize = EditorIntOption.clampedInt(input.verticalScrollbarSize, this.defaultValue.verticalScrollbarSize, 0, 1e3);
          return {
            arrowSize: EditorIntOption.clampedInt(input.arrowSize, this.defaultValue.arrowSize, 0, 1e3),
            vertical: _scrollbarVisibilityFromString(input.vertical, this.defaultValue.vertical),
            horizontal: _scrollbarVisibilityFromString(input.horizontal, this.defaultValue.horizontal),
            useShadows: boolean(input.useShadows, this.defaultValue.useShadows),
            verticalHasArrows: boolean(input.verticalHasArrows, this.defaultValue.verticalHasArrows),
            horizontalHasArrows: boolean(input.horizontalHasArrows, this.defaultValue.horizontalHasArrows),
            handleMouseWheel: boolean(input.handleMouseWheel, this.defaultValue.handleMouseWheel),
            alwaysConsumeMouseWheel: boolean(input.alwaysConsumeMouseWheel, this.defaultValue.alwaysConsumeMouseWheel),
            horizontalScrollbarSize,
            horizontalSliderSize: EditorIntOption.clampedInt(input.horizontalSliderSize, horizontalScrollbarSize, 0, 1e3),
            verticalScrollbarSize,
            verticalSliderSize: EditorIntOption.clampedInt(input.verticalSliderSize, verticalScrollbarSize, 0, 1e3),
            scrollByPage: boolean(input.scrollByPage, this.defaultValue.scrollByPage)
          };
        }
      };
      inUntrustedWorkspace = "inUntrustedWorkspace";
      unicodeHighlightConfigKeys = {
        allowedCharacters: "editor.unicodeHighlight.allowedCharacters",
        invisibleCharacters: "editor.unicodeHighlight.invisibleCharacters",
        nonBasicASCII: "editor.unicodeHighlight.nonBasicASCII",
        ambiguousCharacters: "editor.unicodeHighlight.ambiguousCharacters",
        includeComments: "editor.unicodeHighlight.includeComments",
        includeStrings: "editor.unicodeHighlight.includeStrings",
        allowedLocales: "editor.unicodeHighlight.allowedLocales"
      };
      UnicodeHighlight = class extends BaseEditorOption {
        constructor() {
          const defaults = {
            nonBasicASCII: inUntrustedWorkspace,
            invisibleCharacters: true,
            ambiguousCharacters: true,
            includeComments: inUntrustedWorkspace,
            includeStrings: true,
            allowedCharacters: {},
            allowedLocales: { _os: true, _vscode: true }
          };
          super(123, "unicodeHighlight", defaults, {
            [unicodeHighlightConfigKeys.nonBasicASCII]: {
              restricted: true,
              type: ["boolean", "string"],
              enum: [true, false, inUntrustedWorkspace],
              default: defaults.nonBasicASCII,
              description: localize("unicodeHighlight.nonBasicASCII", "Controls whether all non-basic ASCII characters are highlighted. Only characters between U+0020 and U+007E, tab, line-feed and carriage-return are considered basic ASCII.")
            },
            [unicodeHighlightConfigKeys.invisibleCharacters]: {
              restricted: true,
              type: "boolean",
              default: defaults.invisibleCharacters,
              description: localize("unicodeHighlight.invisibleCharacters", "Controls whether characters that just reserve space or have no width at all are highlighted.")
            },
            [unicodeHighlightConfigKeys.ambiguousCharacters]: {
              restricted: true,
              type: "boolean",
              default: defaults.ambiguousCharacters,
              description: localize("unicodeHighlight.ambiguousCharacters", "Controls whether characters are highlighted that can be confused with basic ASCII characters, except those that are common in the current user locale.")
            },
            [unicodeHighlightConfigKeys.includeComments]: {
              restricted: true,
              type: ["boolean", "string"],
              enum: [true, false, inUntrustedWorkspace],
              default: defaults.includeComments,
              description: localize("unicodeHighlight.includeComments", "Controls whether characters in comments should also be subject to Unicode highlighting.")
            },
            [unicodeHighlightConfigKeys.includeStrings]: {
              restricted: true,
              type: ["boolean", "string"],
              enum: [true, false, inUntrustedWorkspace],
              default: defaults.includeStrings,
              description: localize("unicodeHighlight.includeStrings", "Controls whether characters in strings should also be subject to Unicode highlighting.")
            },
            [unicodeHighlightConfigKeys.allowedCharacters]: {
              restricted: true,
              type: "object",
              default: defaults.allowedCharacters,
              description: localize("unicodeHighlight.allowedCharacters", "Defines allowed characters that are not being highlighted."),
              additionalProperties: {
                type: "boolean"
              }
            },
            [unicodeHighlightConfigKeys.allowedLocales]: {
              restricted: true,
              type: "object",
              additionalProperties: {
                type: "boolean"
              },
              default: defaults.allowedLocales,
              description: localize("unicodeHighlight.allowedLocales", "Unicode characters that are common in allowed locales are not being highlighted.")
            }
          });
        }
        applyUpdate(value, update) {
          let didChange = false;
          if (update.allowedCharacters && value) {
            if (!equals2(value.allowedCharacters, update.allowedCharacters)) {
              value = Object.assign(Object.assign({}, value), { allowedCharacters: update.allowedCharacters });
              didChange = true;
            }
          }
          if (update.allowedLocales && value) {
            if (!equals2(value.allowedLocales, update.allowedLocales)) {
              value = Object.assign(Object.assign({}, value), { allowedLocales: update.allowedLocales });
              didChange = true;
            }
          }
          const result = super.applyUpdate(value, update);
          if (didChange) {
            return new ApplyUpdateResult(result.newValue, true);
          }
          return result;
        }
        validate(_input) {
          if (!_input || typeof _input !== "object") {
            return this.defaultValue;
          }
          const input = _input;
          return {
            nonBasicASCII: primitiveSet(input.nonBasicASCII, inUntrustedWorkspace, [true, false, inUntrustedWorkspace]),
            invisibleCharacters: boolean(input.invisibleCharacters, this.defaultValue.invisibleCharacters),
            ambiguousCharacters: boolean(input.ambiguousCharacters, this.defaultValue.ambiguousCharacters),
            includeComments: primitiveSet(input.includeComments, inUntrustedWorkspace, [true, false, inUntrustedWorkspace]),
            includeStrings: primitiveSet(input.includeStrings, inUntrustedWorkspace, [true, false, inUntrustedWorkspace]),
            allowedCharacters: this.validateBooleanMap(_input.allowedCharacters, this.defaultValue.allowedCharacters),
            allowedLocales: this.validateBooleanMap(_input.allowedLocales, this.defaultValue.allowedLocales)
          };
        }
        validateBooleanMap(map, defaultValue) {
          if (typeof map !== "object" || !map) {
            return defaultValue;
          }
          const result = {};
          for (const [key, value] of Object.entries(map)) {
            if (value === true) {
              result[key] = true;
            }
          }
          return result;
        }
      };
      InlineEditorSuggest = class extends BaseEditorOption {
        constructor() {
          const defaults = {
            enabled: true,
            mode: "subwordSmart",
            showToolbar: "onHover",
            suppressSuggestions: false,
            keepOnBlur: false
          };
          super(61, "inlineSuggest", defaults, {
            "editor.inlineSuggest.enabled": {
              type: "boolean",
              default: defaults.enabled,
              description: localize("inlineSuggest.enabled", "Controls whether to automatically show inline suggestions in the editor.")
            },
            "editor.inlineSuggest.showToolbar": {
              type: "string",
              default: defaults.showToolbar,
              enum: ["always", "onHover"],
              enumDescriptions: [
                localize("inlineSuggest.showToolbar.always", "Show the inline suggestion toolbar whenever an inline suggestion is shown."),
                localize("inlineSuggest.showToolbar.onHover", "Show the inline suggestion toolbar when hovering over an inline suggestion.")
              ],
              description: localize("inlineSuggest.showToolbar", "Controls when to show the inline suggestion toolbar.")
            },
            "editor.inlineSuggest.suppressSuggestions": {
              type: "boolean",
              default: defaults.suppressSuggestions,
              description: localize("inlineSuggest.suppressSuggestions", "Controls how inline suggestions interact with the suggest widget. If enabled, the suggest widget is not shown automatically when inline suggestions are available.")
            }
          });
        }
        validate(_input) {
          if (!_input || typeof _input !== "object") {
            return this.defaultValue;
          }
          const input = _input;
          return {
            enabled: boolean(input.enabled, this.defaultValue.enabled),
            mode: stringSet(input.mode, this.defaultValue.mode, ["prefix", "subword", "subwordSmart"]),
            showToolbar: stringSet(input.showToolbar, this.defaultValue.showToolbar, ["always", "onHover"]),
            suppressSuggestions: boolean(input.suppressSuggestions, this.defaultValue.suppressSuggestions),
            keepOnBlur: boolean(input.keepOnBlur, this.defaultValue.keepOnBlur)
          };
        }
      };
      BracketPairColorization = class extends BaseEditorOption {
        constructor() {
          const defaults = {
            enabled: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions.enabled,
            independentColorPoolPerBracketType: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions.independentColorPoolPerBracketType
          };
          super(14, "bracketPairColorization", defaults, {
            "editor.bracketPairColorization.enabled": {
              type: "boolean",
              default: defaults.enabled,
              markdownDescription: localize("bracketPairColorization.enabled", "Controls whether bracket pair colorization is enabled or not. Use {0} to override the bracket highlight colors.", "`#workbench.colorCustomizations#`")
            },
            "editor.bracketPairColorization.independentColorPoolPerBracketType": {
              type: "boolean",
              default: defaults.independentColorPoolPerBracketType,
              description: localize("bracketPairColorization.independentColorPoolPerBracketType", "Controls whether each bracket type has its own independent color pool.")
            }
          });
        }
        validate(_input) {
          if (!_input || typeof _input !== "object") {
            return this.defaultValue;
          }
          const input = _input;
          return {
            enabled: boolean(input.enabled, this.defaultValue.enabled),
            independentColorPoolPerBracketType: boolean(input.independentColorPoolPerBracketType, this.defaultValue.independentColorPoolPerBracketType)
          };
        }
      };
      GuideOptions = class extends BaseEditorOption {
        constructor() {
          const defaults = {
            bracketPairs: false,
            bracketPairsHorizontal: "active",
            highlightActiveBracketPair: true,
            indentation: true,
            highlightActiveIndentation: true
          };
          super(15, "guides", defaults, {
            "editor.guides.bracketPairs": {
              type: ["boolean", "string"],
              enum: [true, "active", false],
              enumDescriptions: [
                localize("editor.guides.bracketPairs.true", "Enables bracket pair guides."),
                localize("editor.guides.bracketPairs.active", "Enables bracket pair guides only for the active bracket pair."),
                localize("editor.guides.bracketPairs.false", "Disables bracket pair guides.")
              ],
              default: defaults.bracketPairs,
              description: localize("editor.guides.bracketPairs", "Controls whether bracket pair guides are enabled or not.")
            },
            "editor.guides.bracketPairsHorizontal": {
              type: ["boolean", "string"],
              enum: [true, "active", false],
              enumDescriptions: [
                localize("editor.guides.bracketPairsHorizontal.true", "Enables horizontal guides as addition to vertical bracket pair guides."),
                localize("editor.guides.bracketPairsHorizontal.active", "Enables horizontal guides only for the active bracket pair."),
                localize("editor.guides.bracketPairsHorizontal.false", "Disables horizontal bracket pair guides.")
              ],
              default: defaults.bracketPairsHorizontal,
              description: localize("editor.guides.bracketPairsHorizontal", "Controls whether horizontal bracket pair guides are enabled or not.")
            },
            "editor.guides.highlightActiveBracketPair": {
              type: "boolean",
              default: defaults.highlightActiveBracketPair,
              description: localize("editor.guides.highlightActiveBracketPair", "Controls whether the editor should highlight the active bracket pair.")
            },
            "editor.guides.indentation": {
              type: "boolean",
              default: defaults.indentation,
              description: localize("editor.guides.indentation", "Controls whether the editor should render indent guides.")
            },
            "editor.guides.highlightActiveIndentation": {
              type: ["boolean", "string"],
              enum: [true, "always", false],
              enumDescriptions: [
                localize("editor.guides.highlightActiveIndentation.true", "Highlights the active indent guide."),
                localize("editor.guides.highlightActiveIndentation.always", "Highlights the active indent guide even if bracket guides are highlighted."),
                localize("editor.guides.highlightActiveIndentation.false", "Do not highlight the active indent guide.")
              ],
              default: defaults.highlightActiveIndentation,
              description: localize("editor.guides.highlightActiveIndentation", "Controls whether the editor should highlight the active indent guide.")
            }
          });
        }
        validate(_input) {
          if (!_input || typeof _input !== "object") {
            return this.defaultValue;
          }
          const input = _input;
          return {
            bracketPairs: primitiveSet(input.bracketPairs, this.defaultValue.bracketPairs, [true, false, "active"]),
            bracketPairsHorizontal: primitiveSet(input.bracketPairsHorizontal, this.defaultValue.bracketPairsHorizontal, [true, false, "active"]),
            highlightActiveBracketPair: boolean(input.highlightActiveBracketPair, this.defaultValue.highlightActiveBracketPair),
            indentation: boolean(input.indentation, this.defaultValue.indentation),
            highlightActiveIndentation: primitiveSet(input.highlightActiveIndentation, this.defaultValue.highlightActiveIndentation, [true, false, "always"])
          };
        }
      };
      EditorSuggest = class extends BaseEditorOption {
        constructor() {
          const defaults = {
            insertMode: "insert",
            filterGraceful: true,
            snippetsPreventQuickSuggestions: false,
            localityBonus: false,
            shareSuggestSelections: false,
            selectionMode: "always",
            showIcons: true,
            showStatusBar: false,
            preview: false,
            previewMode: "subwordSmart",
            showInlineDetails: true,
            showMethods: true,
            showFunctions: true,
            showConstructors: true,
            showDeprecated: true,
            matchOnWordStartOnly: true,
            showFields: true,
            showVariables: true,
            showClasses: true,
            showStructs: true,
            showInterfaces: true,
            showModules: true,
            showProperties: true,
            showEvents: true,
            showOperators: true,
            showUnits: true,
            showValues: true,
            showConstants: true,
            showEnums: true,
            showEnumMembers: true,
            showKeywords: true,
            showWords: true,
            showColors: true,
            showFiles: true,
            showReferences: true,
            showFolders: true,
            showTypeParameters: true,
            showSnippets: true,
            showUsers: true,
            showIssues: true
          };
          super(116, "suggest", defaults, {
            "editor.suggest.insertMode": {
              type: "string",
              enum: ["insert", "replace"],
              enumDescriptions: [
                localize("suggest.insertMode.insert", "Insert suggestion without overwriting text right of the cursor."),
                localize("suggest.insertMode.replace", "Insert suggestion and overwrite text right of the cursor.")
              ],
              default: defaults.insertMode,
              description: localize("suggest.insertMode", "Controls whether words are overwritten when accepting completions. Note that this depends on extensions opting into this feature.")
            },
            "editor.suggest.filterGraceful": {
              type: "boolean",
              default: defaults.filterGraceful,
              description: localize("suggest.filterGraceful", "Controls whether filtering and sorting suggestions accounts for small typos.")
            },
            "editor.suggest.localityBonus": {
              type: "boolean",
              default: defaults.localityBonus,
              description: localize("suggest.localityBonus", "Controls whether sorting favors words that appear close to the cursor.")
            },
            "editor.suggest.shareSuggestSelections": {
              type: "boolean",
              default: defaults.shareSuggestSelections,
              markdownDescription: localize("suggest.shareSuggestSelections", "Controls whether remembered suggestion selections are shared between multiple workspaces and windows (needs `#editor.suggestSelection#`).")
            },
            "editor.suggest.selectionMode": {
              type: "string",
              enum: ["always", "never", "whenTriggerCharacter", "whenQuickSuggestion"],
              enumDescriptions: [
                localize("suggest.insertMode.always", "Always select a suggestion when automatically triggering IntelliSense."),
                localize("suggest.insertMode.never", "Never select a suggestion when automatically triggering IntelliSense."),
                localize("suggest.insertMode.whenTriggerCharacter", "Select a suggestion only when triggering IntelliSense from a trigger character."),
                localize("suggest.insertMode.whenQuickSuggestion", "Select a suggestion only when triggering IntelliSense as you type.")
              ],
              default: defaults.selectionMode,
              markdownDescription: localize("suggest.selectionMode", "Controls whether a suggestion is selected when the widget shows. Note that this only applies to automatically triggered suggestions (`#editor.quickSuggestions#` and `#editor.suggestOnTriggerCharacters#`) and that a suggestion is always selected when explicitly invoked, e.g via `Ctrl+Space`.")
            },
            "editor.suggest.snippetsPreventQuickSuggestions": {
              type: "boolean",
              default: defaults.snippetsPreventQuickSuggestions,
              description: localize("suggest.snippetsPreventQuickSuggestions", "Controls whether an active snippet prevents quick suggestions.")
            },
            "editor.suggest.showIcons": {
              type: "boolean",
              default: defaults.showIcons,
              description: localize("suggest.showIcons", "Controls whether to show or hide icons in suggestions.")
            },
            "editor.suggest.showStatusBar": {
              type: "boolean",
              default: defaults.showStatusBar,
              description: localize("suggest.showStatusBar", "Controls the visibility of the status bar at the bottom of the suggest widget.")
            },
            "editor.suggest.preview": {
              type: "boolean",
              default: defaults.preview,
              description: localize("suggest.preview", "Controls whether to preview the suggestion outcome in the editor.")
            },
            "editor.suggest.showInlineDetails": {
              type: "boolean",
              default: defaults.showInlineDetails,
              description: localize("suggest.showInlineDetails", "Controls whether suggest details show inline with the label or only in the details widget.")
            },
            "editor.suggest.maxVisibleSuggestions": {
              type: "number",
              deprecationMessage: localize("suggest.maxVisibleSuggestions.dep", "This setting is deprecated. The suggest widget can now be resized.")
            },
            "editor.suggest.filteredTypes": {
              type: "object",
              deprecationMessage: localize("deprecated", "This setting is deprecated, please use separate settings like 'editor.suggest.showKeywords' or 'editor.suggest.showSnippets' instead.")
            },
            "editor.suggest.showMethods": {
              type: "boolean",
              default: true,
              markdownDescription: localize("editor.suggest.showMethods", "When enabled IntelliSense shows `method`-suggestions.")
            },
            "editor.suggest.showFunctions": {
              type: "boolean",
              default: true,
              markdownDescription: localize("editor.suggest.showFunctions", "When enabled IntelliSense shows `function`-suggestions.")
            },
            "editor.suggest.showConstructors": {
              type: "boolean",
              default: true,
              markdownDescription: localize("editor.suggest.showConstructors", "When enabled IntelliSense shows `constructor`-suggestions.")
            },
            "editor.suggest.showDeprecated": {
              type: "boolean",
              default: true,
              markdownDescription: localize("editor.suggest.showDeprecated", "When enabled IntelliSense shows `deprecated`-suggestions.")
            },
            "editor.suggest.matchOnWordStartOnly": {
              type: "boolean",
              default: true,
              markdownDescription: localize("editor.suggest.matchOnWordStartOnly", "When enabled IntelliSense filtering requires that the first character matches on a word start. For example, `c` on `Console` or `WebContext` but _not_ on `description`. When disabled IntelliSense will show more results but still sorts them by match quality.")
            },
            "editor.suggest.showFields": {
              type: "boolean",
              default: true,
              markdownDescription: localize("editor.suggest.showFields", "When enabled IntelliSense shows `field`-suggestions.")
            },
            "editor.suggest.showVariables": {
              type: "boolean",
              default: true,
              markdownDescription: localize("editor.suggest.showVariables", "When enabled IntelliSense shows `variable`-suggestions.")
            },
            "editor.suggest.showClasses": {
              type: "boolean",
              default: true,
              markdownDescription: localize("editor.suggest.showClasss", "When enabled IntelliSense shows `class`-suggestions.")
            },
            "editor.suggest.showStructs": {
              type: "boolean",
              default: true,
              markdownDescription: localize("editor.suggest.showStructs", "When enabled IntelliSense shows `struct`-suggestions.")
            },
            "editor.suggest.showInterfaces": {
              type: "boolean",
              default: true,
              markdownDescription: localize("editor.suggest.showInterfaces", "When enabled IntelliSense shows `interface`-suggestions.")
            },
            "editor.suggest.showModules": {
              type: "boolean",
              default: true,
              markdownDescription: localize("editor.suggest.showModules", "When enabled IntelliSense shows `module`-suggestions.")
            },
            "editor.suggest.showProperties": {
              type: "boolean",
              default: true,
              markdownDescription: localize("editor.suggest.showPropertys", "When enabled IntelliSense shows `property`-suggestions.")
            },
            "editor.suggest.showEvents": {
              type: "boolean",
              default: true,
              markdownDescription: localize("editor.suggest.showEvents", "When enabled IntelliSense shows `event`-suggestions.")
            },
            "editor.suggest.showOperators": {
              type: "boolean",
              default: true,
              markdownDescription: localize("editor.suggest.showOperators", "When enabled IntelliSense shows `operator`-suggestions.")
            },
            "editor.suggest.showUnits": {
              type: "boolean",
              default: true,
              markdownDescription: localize("editor.suggest.showUnits", "When enabled IntelliSense shows `unit`-suggestions.")
            },
            "editor.suggest.showValues": {
              type: "boolean",
              default: true,
              markdownDescription: localize("editor.suggest.showValues", "When enabled IntelliSense shows `value`-suggestions.")
            },
            "editor.suggest.showConstants": {
              type: "boolean",
              default: true,
              markdownDescription: localize("editor.suggest.showConstants", "When enabled IntelliSense shows `constant`-suggestions.")
            },
            "editor.suggest.showEnums": {
              type: "boolean",
              default: true,
              markdownDescription: localize("editor.suggest.showEnums", "When enabled IntelliSense shows `enum`-suggestions.")
            },
            "editor.suggest.showEnumMembers": {
              type: "boolean",
              default: true,
              markdownDescription: localize("editor.suggest.showEnumMembers", "When enabled IntelliSense shows `enumMember`-suggestions.")
            },
            "editor.suggest.showKeywords": {
              type: "boolean",
              default: true,
              markdownDescription: localize("editor.suggest.showKeywords", "When enabled IntelliSense shows `keyword`-suggestions.")
            },
            "editor.suggest.showWords": {
              type: "boolean",
              default: true,
              markdownDescription: localize("editor.suggest.showTexts", "When enabled IntelliSense shows `text`-suggestions.")
            },
            "editor.suggest.showColors": {
              type: "boolean",
              default: true,
              markdownDescription: localize("editor.suggest.showColors", "When enabled IntelliSense shows `color`-suggestions.")
            },
            "editor.suggest.showFiles": {
              type: "boolean",
              default: true,
              markdownDescription: localize("editor.suggest.showFiles", "When enabled IntelliSense shows `file`-suggestions.")
            },
            "editor.suggest.showReferences": {
              type: "boolean",
              default: true,
              markdownDescription: localize("editor.suggest.showReferences", "When enabled IntelliSense shows `reference`-suggestions.")
            },
            "editor.suggest.showCustomcolors": {
              type: "boolean",
              default: true,
              markdownDescription: localize("editor.suggest.showCustomcolors", "When enabled IntelliSense shows `customcolor`-suggestions.")
            },
            "editor.suggest.showFolders": {
              type: "boolean",
              default: true,
              markdownDescription: localize("editor.suggest.showFolders", "When enabled IntelliSense shows `folder`-suggestions.")
            },
            "editor.suggest.showTypeParameters": {
              type: "boolean",
              default: true,
              markdownDescription: localize("editor.suggest.showTypeParameters", "When enabled IntelliSense shows `typeParameter`-suggestions.")
            },
            "editor.suggest.showSnippets": {
              type: "boolean",
              default: true,
              markdownDescription: localize("editor.suggest.showSnippets", "When enabled IntelliSense shows `snippet`-suggestions.")
            },
            "editor.suggest.showUsers": {
              type: "boolean",
              default: true,
              markdownDescription: localize("editor.suggest.showUsers", "When enabled IntelliSense shows `user`-suggestions.")
            },
            "editor.suggest.showIssues": {
              type: "boolean",
              default: true,
              markdownDescription: localize("editor.suggest.showIssues", "When enabled IntelliSense shows `issues`-suggestions.")
            }
          });
        }
        validate(_input) {
          if (!_input || typeof _input !== "object") {
            return this.defaultValue;
          }
          const input = _input;
          return {
            insertMode: stringSet(input.insertMode, this.defaultValue.insertMode, ["insert", "replace"]),
            filterGraceful: boolean(input.filterGraceful, this.defaultValue.filterGraceful),
            snippetsPreventQuickSuggestions: boolean(input.snippetsPreventQuickSuggestions, this.defaultValue.filterGraceful),
            localityBonus: boolean(input.localityBonus, this.defaultValue.localityBonus),
            shareSuggestSelections: boolean(input.shareSuggestSelections, this.defaultValue.shareSuggestSelections),
            selectionMode: stringSet(input.selectionMode, this.defaultValue.selectionMode, ["always", "never", "whenQuickSuggestion", "whenTriggerCharacter"]),
            showIcons: boolean(input.showIcons, this.defaultValue.showIcons),
            showStatusBar: boolean(input.showStatusBar, this.defaultValue.showStatusBar),
            preview: boolean(input.preview, this.defaultValue.preview),
            previewMode: stringSet(input.previewMode, this.defaultValue.previewMode, ["prefix", "subword", "subwordSmart"]),
            showInlineDetails: boolean(input.showInlineDetails, this.defaultValue.showInlineDetails),
            showMethods: boolean(input.showMethods, this.defaultValue.showMethods),
            showFunctions: boolean(input.showFunctions, this.defaultValue.showFunctions),
            showConstructors: boolean(input.showConstructors, this.defaultValue.showConstructors),
            showDeprecated: boolean(input.showDeprecated, this.defaultValue.showDeprecated),
            matchOnWordStartOnly: boolean(input.matchOnWordStartOnly, this.defaultValue.matchOnWordStartOnly),
            showFields: boolean(input.showFields, this.defaultValue.showFields),
            showVariables: boolean(input.showVariables, this.defaultValue.showVariables),
            showClasses: boolean(input.showClasses, this.defaultValue.showClasses),
            showStructs: boolean(input.showStructs, this.defaultValue.showStructs),
            showInterfaces: boolean(input.showInterfaces, this.defaultValue.showInterfaces),
            showModules: boolean(input.showModules, this.defaultValue.showModules),
            showProperties: boolean(input.showProperties, this.defaultValue.showProperties),
            showEvents: boolean(input.showEvents, this.defaultValue.showEvents),
            showOperators: boolean(input.showOperators, this.defaultValue.showOperators),
            showUnits: boolean(input.showUnits, this.defaultValue.showUnits),
            showValues: boolean(input.showValues, this.defaultValue.showValues),
            showConstants: boolean(input.showConstants, this.defaultValue.showConstants),
            showEnums: boolean(input.showEnums, this.defaultValue.showEnums),
            showEnumMembers: boolean(input.showEnumMembers, this.defaultValue.showEnumMembers),
            showKeywords: boolean(input.showKeywords, this.defaultValue.showKeywords),
            showWords: boolean(input.showWords, this.defaultValue.showWords),
            showColors: boolean(input.showColors, this.defaultValue.showColors),
            showFiles: boolean(input.showFiles, this.defaultValue.showFiles),
            showReferences: boolean(input.showReferences, this.defaultValue.showReferences),
            showFolders: boolean(input.showFolders, this.defaultValue.showFolders),
            showTypeParameters: boolean(input.showTypeParameters, this.defaultValue.showTypeParameters),
            showSnippets: boolean(input.showSnippets, this.defaultValue.showSnippets),
            showUsers: boolean(input.showUsers, this.defaultValue.showUsers),
            showIssues: boolean(input.showIssues, this.defaultValue.showIssues)
          };
        }
      };
      SmartSelect = class extends BaseEditorOption {
        constructor() {
          super(111, "smartSelect", {
            selectLeadingAndTrailingWhitespace: true,
            selectSubwords: true
          }, {
            "editor.smartSelect.selectLeadingAndTrailingWhitespace": {
              description: localize("selectLeadingAndTrailingWhitespace", "Whether leading and trailing whitespace should always be selected."),
              default: true,
              type: "boolean"
            },
            "editor.smartSelect.selectSubwords": {
              description: localize("selectSubwords", "Whether subwords (like 'foo' in 'fooBar' or 'foo_bar') should be selected."),
              default: true,
              type: "boolean"
            }
          });
        }
        validate(input) {
          if (!input || typeof input !== "object") {
            return this.defaultValue;
          }
          return {
            selectLeadingAndTrailingWhitespace: boolean(input.selectLeadingAndTrailingWhitespace, this.defaultValue.selectLeadingAndTrailingWhitespace),
            selectSubwords: boolean(input.selectSubwords, this.defaultValue.selectSubwords)
          };
        }
      };
      WrappingIndentOption = class extends BaseEditorOption {
        constructor() {
          super(135, "wrappingIndent", 1, {
            "editor.wrappingIndent": {
              type: "string",
              enum: ["none", "same", "indent", "deepIndent"],
              enumDescriptions: [
                localize("wrappingIndent.none", "No indentation. Wrapped lines begin at column 1."),
                localize("wrappingIndent.same", "Wrapped lines get the same indentation as the parent."),
                localize("wrappingIndent.indent", "Wrapped lines get +1 indentation toward the parent."),
                localize("wrappingIndent.deepIndent", "Wrapped lines get +2 indentation toward the parent.")
              ],
              description: localize("wrappingIndent", "Controls the indentation of wrapped lines."),
              default: "same"
            }
          });
        }
        validate(input) {
          switch (input) {
            case "none":
              return 0;
            case "same":
              return 1;
            case "indent":
              return 2;
            case "deepIndent":
              return 3;
          }
          return 1;
        }
        compute(env3, options, value) {
          const accessibilitySupport = options.get(
            2
            /* EditorOption.accessibilitySupport */
          );
          if (accessibilitySupport === 2) {
            return 0;
          }
          return value;
        }
      };
      EditorWrappingInfoComputer = class extends ComputedEditorOption {
        constructor() {
          super(
            143
            /* EditorOption.wrappingInfo */
          );
        }
        compute(env3, options, _) {
          const layoutInfo = options.get(
            142
            /* EditorOption.layoutInfo */
          );
          return {
            isDominatedByLongLines: env3.isDominatedByLongLines,
            isWordWrapMinified: layoutInfo.isWordWrapMinified,
            isViewportWrapping: layoutInfo.isViewportWrapping,
            wrappingColumn: layoutInfo.wrappingColumn
          };
        }
      };
      EditorDropIntoEditor = class extends BaseEditorOption {
        constructor() {
          const defaults = { enabled: true, showDropSelector: "afterDrop" };
          super(35, "dropIntoEditor", defaults, {
            "editor.dropIntoEditor.enabled": {
              type: "boolean",
              default: defaults.enabled,
              markdownDescription: localize("dropIntoEditor.enabled", "Controls whether you can drag and drop a file into a text editor by holding down `shift` (instead of opening the file in an editor).")
            },
            "editor.dropIntoEditor.showDropSelector": {
              type: "string",
              markdownDescription: localize("dropIntoEditor.showDropSelector", "Controls if a widget is shown when dropping files into the editor. This widget lets you control how the file is dropped."),
              enum: [
                "afterDrop",
                "never"
              ],
              enumDescriptions: [
                localize("dropIntoEditor.showDropSelector.afterDrop", "Show the drop selector widget after a file is dropped into the editor."),
                localize("dropIntoEditor.showDropSelector.never", "Never show the drop selector widget. Instead the default drop provider is always used.")
              ],
              default: "afterDrop"
            }
          });
        }
        validate(_input) {
          if (!_input || typeof _input !== "object") {
            return this.defaultValue;
          }
          const input = _input;
          return {
            enabled: boolean(input.enabled, this.defaultValue.enabled),
            showDropSelector: stringSet(input.showDropSelector, this.defaultValue.showDropSelector, ["afterDrop", "never"])
          };
        }
      };
      EditorPasteAs = class extends BaseEditorOption {
        constructor() {
          const defaults = { enabled: true, showPasteSelector: "afterPaste" };
          super(83, "pasteAs", defaults, {
            "editor.pasteAs.enabled": {
              type: "boolean",
              default: defaults.enabled,
              markdownDescription: localize("pasteAs.enabled", "Controls whether you can paste content in different ways.")
            },
            "editor.pasteAs.showPasteSelector": {
              type: "string",
              markdownDescription: localize("pasteAs.showPasteSelector", "Controls if a widget is shown when pasting content in to the editor. This widget lets you control how the file is pasted."),
              enum: [
                "afterPaste",
                "never"
              ],
              enumDescriptions: [
                localize("pasteAs.showPasteSelector.afterPaste", "Show the paste selector widget after content is pasted into the editor."),
                localize("pasteAs.showPasteSelector.never", "Never show the paste selector widget. Instead the default pasting behavior is always used.")
              ],
              default: "afterPaste"
            }
          });
        }
        validate(_input) {
          if (!_input || typeof _input !== "object") {
            return this.defaultValue;
          }
          const input = _input;
          return {
            enabled: boolean(input.enabled, this.defaultValue.enabled),
            showPasteSelector: stringSet(input.showPasteSelector, this.defaultValue.showPasteSelector, ["afterPaste", "never"])
          };
        }
      };
      DEFAULT_WINDOWS_FONT_FAMILY = "Consolas, 'Courier New', monospace";
      DEFAULT_MAC_FONT_FAMILY = "Menlo, Monaco, 'Courier New', monospace";
      DEFAULT_LINUX_FONT_FAMILY = "'Droid Sans Mono', 'monospace', monospace";
      EDITOR_FONT_DEFAULTS = {
        fontFamily: isMacintosh ? DEFAULT_MAC_FONT_FAMILY : isLinux ? DEFAULT_LINUX_FONT_FAMILY : DEFAULT_WINDOWS_FONT_FAMILY,
        fontWeight: "normal",
        fontSize: isMacintosh ? 12 : 14,
        lineHeight: 0,
        letterSpacing: 0
      };
      editorOptionsRegistry = [];
      EditorOptions = {
        acceptSuggestionOnCommitCharacter: register2(new EditorBooleanOption(0, "acceptSuggestionOnCommitCharacter", true, { markdownDescription: localize("acceptSuggestionOnCommitCharacter", "Controls whether suggestions should be accepted on commit characters. For example, in JavaScript, the semi-colon (`;`) can be a commit character that accepts a suggestion and types that character.") })),
        acceptSuggestionOnEnter: register2(new EditorStringEnumOption(1, "acceptSuggestionOnEnter", "on", ["on", "smart", "off"], {
          markdownEnumDescriptions: [
            "",
            localize("acceptSuggestionOnEnterSmart", "Only accept a suggestion with `Enter` when it makes a textual change."),
            ""
          ],
          markdownDescription: localize("acceptSuggestionOnEnter", "Controls whether suggestions should be accepted on `Enter`, in addition to `Tab`. Helps to avoid ambiguity between inserting new lines or accepting suggestions.")
        })),
        accessibilitySupport: register2(new EditorAccessibilitySupport()),
        accessibilityPageSize: register2(new EditorIntOption(3, "accessibilityPageSize", 10, 1, 1073741824, {
          description: localize("accessibilityPageSize", "Controls the number of lines in the editor that can be read out by a screen reader at once. When we detect a screen reader we automatically set the default to be 500. Warning: this has a performance implication for numbers larger than the default."),
          tags: ["accessibility"]
        })),
        ariaLabel: register2(new EditorStringOption(4, "ariaLabel", localize("editorViewAccessibleLabel", "Editor content"))),
        ariaRequired: register2(new EditorBooleanOption(5, "ariaRequired", false, void 0)),
        screenReaderAnnounceInlineSuggestion: register2(new EditorBooleanOption(7, "screenReaderAnnounceInlineSuggestion", true, {
          description: localize("screenReaderAnnounceInlineSuggestion", "Control whether inline suggestions are announced by a screen reader."),
          tags: ["accessibility"]
        })),
        autoClosingBrackets: register2(new EditorStringEnumOption(6, "autoClosingBrackets", "languageDefined", ["always", "languageDefined", "beforeWhitespace", "never"], {
          enumDescriptions: [
            "",
            localize("editor.autoClosingBrackets.languageDefined", "Use language configurations to determine when to autoclose brackets."),
            localize("editor.autoClosingBrackets.beforeWhitespace", "Autoclose brackets only when the cursor is to the left of whitespace."),
            ""
          ],
          description: localize("autoClosingBrackets", "Controls whether the editor should automatically close brackets after the user adds an opening bracket.")
        })),
        autoClosingDelete: register2(new EditorStringEnumOption(8, "autoClosingDelete", "auto", ["always", "auto", "never"], {
          enumDescriptions: [
            "",
            localize("editor.autoClosingDelete.auto", "Remove adjacent closing quotes or brackets only if they were automatically inserted."),
            ""
          ],
          description: localize("autoClosingDelete", "Controls whether the editor should remove adjacent closing quotes or brackets when deleting.")
        })),
        autoClosingOvertype: register2(new EditorStringEnumOption(9, "autoClosingOvertype", "auto", ["always", "auto", "never"], {
          enumDescriptions: [
            "",
            localize("editor.autoClosingOvertype.auto", "Type over closing quotes or brackets only if they were automatically inserted."),
            ""
          ],
          description: localize("autoClosingOvertype", "Controls whether the editor should type over closing quotes or brackets.")
        })),
        autoClosingQuotes: register2(new EditorStringEnumOption(10, "autoClosingQuotes", "languageDefined", ["always", "languageDefined", "beforeWhitespace", "never"], {
          enumDescriptions: [
            "",
            localize("editor.autoClosingQuotes.languageDefined", "Use language configurations to determine when to autoclose quotes."),
            localize("editor.autoClosingQuotes.beforeWhitespace", "Autoclose quotes only when the cursor is to the left of whitespace."),
            ""
          ],
          description: localize("autoClosingQuotes", "Controls whether the editor should automatically close quotes after the user adds an opening quote.")
        })),
        autoIndent: register2(new EditorEnumOption(11, "autoIndent", 4, "full", ["none", "keep", "brackets", "advanced", "full"], _autoIndentFromString, {
          enumDescriptions: [
            localize("editor.autoIndent.none", "The editor will not insert indentation automatically."),
            localize("editor.autoIndent.keep", "The editor will keep the current line's indentation."),
            localize("editor.autoIndent.brackets", "The editor will keep the current line's indentation and honor language defined brackets."),
            localize("editor.autoIndent.advanced", "The editor will keep the current line's indentation, honor language defined brackets and invoke special onEnterRules defined by languages."),
            localize("editor.autoIndent.full", "The editor will keep the current line's indentation, honor language defined brackets, invoke special onEnterRules defined by languages, and honor indentationRules defined by languages.")
          ],
          description: localize("autoIndent", "Controls whether the editor should automatically adjust the indentation when users type, paste, move or indent lines.")
        })),
        automaticLayout: register2(new EditorBooleanOption(12, "automaticLayout", false)),
        autoSurround: register2(new EditorStringEnumOption(13, "autoSurround", "languageDefined", ["languageDefined", "quotes", "brackets", "never"], {
          enumDescriptions: [
            localize("editor.autoSurround.languageDefined", "Use language configurations to determine when to automatically surround selections."),
            localize("editor.autoSurround.quotes", "Surround with quotes but not brackets."),
            localize("editor.autoSurround.brackets", "Surround with brackets but not quotes."),
            ""
          ],
          description: localize("autoSurround", "Controls whether the editor should automatically surround selections when typing quotes or brackets.")
        })),
        bracketPairColorization: register2(new BracketPairColorization()),
        bracketPairGuides: register2(new GuideOptions()),
        stickyTabStops: register2(new EditorBooleanOption(114, "stickyTabStops", false, { description: localize("stickyTabStops", "Emulate selection behavior of tab characters when using spaces for indentation. Selection will stick to tab stops.") })),
        codeLens: register2(new EditorBooleanOption(16, "codeLens", true, { description: localize("codeLens", "Controls whether the editor shows CodeLens.") })),
        codeLensFontFamily: register2(new EditorStringOption(17, "codeLensFontFamily", "", { description: localize("codeLensFontFamily", "Controls the font family for CodeLens.") })),
        codeLensFontSize: register2(new EditorIntOption(18, "codeLensFontSize", 0, 0, 100, {
          type: "number",
          default: 0,
          minimum: 0,
          maximum: 100,
          markdownDescription: localize("codeLensFontSize", "Controls the font size in pixels for CodeLens. When set to 0, 90% of `#editor.fontSize#` is used.")
        })),
        colorDecorators: register2(new EditorBooleanOption(19, "colorDecorators", true, { description: localize("colorDecorators", "Controls whether the editor should render the inline color decorators and color picker.") })),
        colorDecoratorActivatedOn: register2(new EditorStringEnumOption(145, "colorDecoratorsActivatedOn", "clickAndHover", ["clickAndHover", "hover", "click"], {
          enumDescriptions: [
            localize("editor.colorDecoratorActivatedOn.clickAndHover", "Make the color picker appear both on click and hover of the color decorator"),
            localize("editor.colorDecoratorActivatedOn.hover", "Make the color picker appear on hover of the color decorator"),
            localize("editor.colorDecoratorActivatedOn.click", "Make the color picker appear on click of the color decorator")
          ],
          description: localize("colorDecoratorActivatedOn", "Controls the condition to make a color picker appear from a color decorator")
        })),
        colorDecoratorsLimit: register2(new EditorIntOption(20, "colorDecoratorsLimit", 500, 1, 1e6, {
          markdownDescription: localize("colorDecoratorsLimit", "Controls the max number of color decorators that can be rendered in an editor at once.")
        })),
        columnSelection: register2(new EditorBooleanOption(21, "columnSelection", false, { description: localize("columnSelection", "Enable that the selection with the mouse and keys is doing column selection.") })),
        comments: register2(new EditorComments()),
        contextmenu: register2(new EditorBooleanOption(23, "contextmenu", true)),
        copyWithSyntaxHighlighting: register2(new EditorBooleanOption(24, "copyWithSyntaxHighlighting", true, { description: localize("copyWithSyntaxHighlighting", "Controls whether syntax highlighting should be copied into the clipboard.") })),
        cursorBlinking: register2(new EditorEnumOption(25, "cursorBlinking", 1, "blink", ["blink", "smooth", "phase", "expand", "solid"], _cursorBlinkingStyleFromString, { description: localize("cursorBlinking", "Control the cursor animation style.") })),
        cursorSmoothCaretAnimation: register2(new EditorStringEnumOption(26, "cursorSmoothCaretAnimation", "off", ["off", "explicit", "on"], {
          enumDescriptions: [
            localize("cursorSmoothCaretAnimation.off", "Smooth caret animation is disabled."),
            localize("cursorSmoothCaretAnimation.explicit", "Smooth caret animation is enabled only when the user moves the cursor with an explicit gesture."),
            localize("cursorSmoothCaretAnimation.on", "Smooth caret animation is always enabled.")
          ],
          description: localize("cursorSmoothCaretAnimation", "Controls whether the smooth caret animation should be enabled.")
        })),
        cursorStyle: register2(new EditorEnumOption(27, "cursorStyle", TextEditorCursorStyle.Line, "line", ["line", "block", "underline", "line-thin", "block-outline", "underline-thin"], _cursorStyleFromString, { description: localize("cursorStyle", "Controls the cursor style.") })),
        cursorSurroundingLines: register2(new EditorIntOption(28, "cursorSurroundingLines", 0, 0, 1073741824, { description: localize("cursorSurroundingLines", "Controls the minimal number of visible leading lines (minimum 0) and trailing lines (minimum 1) surrounding the cursor. Known as 'scrollOff' or 'scrollOffset' in some other editors.") })),
        cursorSurroundingLinesStyle: register2(new EditorStringEnumOption(29, "cursorSurroundingLinesStyle", "default", ["default", "all"], {
          enumDescriptions: [
            localize("cursorSurroundingLinesStyle.default", "`cursorSurroundingLines` is enforced only when triggered via the keyboard or API."),
            localize("cursorSurroundingLinesStyle.all", "`cursorSurroundingLines` is enforced always.")
          ],
          description: localize("cursorSurroundingLinesStyle", "Controls when `cursorSurroundingLines` should be enforced.")
        })),
        cursorWidth: register2(new EditorIntOption(30, "cursorWidth", 0, 0, 1073741824, { markdownDescription: localize("cursorWidth", "Controls the width of the cursor when `#editor.cursorStyle#` is set to `line`.") })),
        disableLayerHinting: register2(new EditorBooleanOption(31, "disableLayerHinting", false)),
        disableMonospaceOptimizations: register2(new EditorBooleanOption(32, "disableMonospaceOptimizations", false)),
        domReadOnly: register2(new EditorBooleanOption(33, "domReadOnly", false)),
        dragAndDrop: register2(new EditorBooleanOption(34, "dragAndDrop", true, { description: localize("dragAndDrop", "Controls whether the editor should allow moving selections via drag and drop.") })),
        emptySelectionClipboard: register2(new EditorEmptySelectionClipboard()),
        dropIntoEditor: register2(new EditorDropIntoEditor()),
        stickyScroll: register2(new EditorStickyScroll()),
        experimentalWhitespaceRendering: register2(new EditorStringEnumOption(37, "experimentalWhitespaceRendering", "svg", ["svg", "font", "off"], {
          enumDescriptions: [
            localize("experimentalWhitespaceRendering.svg", "Use a new rendering method with svgs."),
            localize("experimentalWhitespaceRendering.font", "Use a new rendering method with font characters."),
            localize("experimentalWhitespaceRendering.off", "Use the stable rendering method.")
          ],
          description: localize("experimentalWhitespaceRendering", "Controls whether whitespace is rendered with a new, experimental method.")
        })),
        extraEditorClassName: register2(new EditorStringOption(38, "extraEditorClassName", "")),
        fastScrollSensitivity: register2(new EditorFloatOption(39, "fastScrollSensitivity", 5, (x) => x <= 0 ? 5 : x, { markdownDescription: localize("fastScrollSensitivity", "Scrolling speed multiplier when pressing `Alt`.") })),
        find: register2(new EditorFind()),
        fixedOverflowWidgets: register2(new EditorBooleanOption(41, "fixedOverflowWidgets", false)),
        folding: register2(new EditorBooleanOption(42, "folding", true, { description: localize("folding", "Controls whether the editor has code folding enabled.") })),
        foldingStrategy: register2(new EditorStringEnumOption(43, "foldingStrategy", "auto", ["auto", "indentation"], {
          enumDescriptions: [
            localize("foldingStrategy.auto", "Use a language-specific folding strategy if available, else the indentation-based one."),
            localize("foldingStrategy.indentation", "Use the indentation-based folding strategy.")
          ],
          description: localize("foldingStrategy", "Controls the strategy for computing folding ranges.")
        })),
        foldingHighlight: register2(new EditorBooleanOption(44, "foldingHighlight", true, { description: localize("foldingHighlight", "Controls whether the editor should highlight folded ranges.") })),
        foldingImportsByDefault: register2(new EditorBooleanOption(45, "foldingImportsByDefault", false, { description: localize("foldingImportsByDefault", "Controls whether the editor automatically collapses import ranges.") })),
        foldingMaximumRegions: register2(new EditorIntOption(
          46,
          "foldingMaximumRegions",
          5e3,
          10,
          65e3,
          // limit must be less than foldingRanges MAX_FOLDING_REGIONS
          { description: localize("foldingMaximumRegions", "The maximum number of foldable regions. Increasing this value may result in the editor becoming less responsive when the current source has a large number of foldable regions.") }
        )),
        unfoldOnClickAfterEndOfLine: register2(new EditorBooleanOption(47, "unfoldOnClickAfterEndOfLine", false, { description: localize("unfoldOnClickAfterEndOfLine", "Controls whether clicking on the empty content after a folded line will unfold the line.") })),
        fontFamily: register2(new EditorStringOption(48, "fontFamily", EDITOR_FONT_DEFAULTS.fontFamily, { description: localize("fontFamily", "Controls the font family.") })),
        fontInfo: register2(new EditorFontInfo()),
        fontLigatures2: register2(new EditorFontLigatures()),
        fontSize: register2(new EditorFontSize()),
        fontWeight: register2(new EditorFontWeight()),
        fontVariations: register2(new EditorFontVariations()),
        formatOnPaste: register2(new EditorBooleanOption(54, "formatOnPaste", false, { description: localize("formatOnPaste", "Controls whether the editor should automatically format the pasted content. A formatter must be available and the formatter should be able to format a range in a document.") })),
        formatOnType: register2(new EditorBooleanOption(55, "formatOnType", false, { description: localize("formatOnType", "Controls whether the editor should automatically format the line after typing.") })),
        glyphMargin: register2(new EditorBooleanOption(56, "glyphMargin", true, { description: localize("glyphMargin", "Controls whether the editor should render the vertical glyph margin. Glyph margin is mostly used for debugging.") })),
        gotoLocation: register2(new EditorGoToLocation()),
        hideCursorInOverviewRuler: register2(new EditorBooleanOption(58, "hideCursorInOverviewRuler", false, { description: localize("hideCursorInOverviewRuler", "Controls whether the cursor should be hidden in the overview ruler.") })),
        hover: register2(new EditorHover()),
        inDiffEditor: register2(new EditorBooleanOption(60, "inDiffEditor", false)),
        letterSpacing: register2(new EditorFloatOption(62, "letterSpacing", EDITOR_FONT_DEFAULTS.letterSpacing, (x) => EditorFloatOption.clamp(x, -5, 20), { description: localize("letterSpacing", "Controls the letter spacing in pixels.") })),
        lightbulb: register2(new EditorLightbulb()),
        lineDecorationsWidth: register2(new EditorLineDecorationsWidth()),
        lineHeight: register2(new EditorLineHeight()),
        lineNumbers: register2(new EditorRenderLineNumbersOption()),
        lineNumbersMinChars: register2(new EditorIntOption(67, "lineNumbersMinChars", 5, 1, 300)),
        linkedEditing: register2(new EditorBooleanOption(68, "linkedEditing", false, { description: localize("linkedEditing", "Controls whether the editor has linked editing enabled. Depending on the language, related symbols such as HTML tags, are updated while editing.") })),
        links: register2(new EditorBooleanOption(69, "links", true, { description: localize("links", "Controls whether the editor should detect links and make them clickable.") })),
        matchBrackets: register2(new EditorStringEnumOption(70, "matchBrackets", "always", ["always", "near", "never"], { description: localize("matchBrackets", "Highlight matching brackets.") })),
        minimap: register2(new EditorMinimap()),
        mouseStyle: register2(new EditorStringEnumOption(72, "mouseStyle", "text", ["text", "default", "copy"])),
        mouseWheelScrollSensitivity: register2(new EditorFloatOption(73, "mouseWheelScrollSensitivity", 1, (x) => x === 0 ? 1 : x, { markdownDescription: localize("mouseWheelScrollSensitivity", "A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.") })),
        mouseWheelZoom: register2(new EditorBooleanOption(74, "mouseWheelZoom", false, { markdownDescription: localize("mouseWheelZoom", "Zoom the font of the editor when using mouse wheel and holding `Ctrl`.") })),
        multiCursorMergeOverlapping: register2(new EditorBooleanOption(75, "multiCursorMergeOverlapping", true, { description: localize("multiCursorMergeOverlapping", "Merge multiple cursors when they are overlapping.") })),
        multiCursorModifier: register2(new EditorEnumOption(76, "multiCursorModifier", "altKey", "alt", ["ctrlCmd", "alt"], _multiCursorModifierFromString, {
          markdownEnumDescriptions: [
            localize("multiCursorModifier.ctrlCmd", "Maps to `Control` on Windows and Linux and to `Command` on macOS."),
            localize("multiCursorModifier.alt", "Maps to `Alt` on Windows and Linux and to `Option` on macOS.")
          ],
          markdownDescription: localize({
            key: "multiCursorModifier",
            comment: [
              "- `ctrlCmd` refers to a value the setting can take and should not be localized.",
              "- `Control` and `Command` refer to the modifier keys Ctrl or Cmd on the keyboard and can be localized."
            ]
          }, "The modifier to be used to add multiple cursors with the mouse. The Go to Definition and Open Link mouse gestures will adapt such that they do not conflict with the [multicursor modifier](https://code.visualstudio.com/docs/editor/codebasics#_multicursor-modifier).")
        })),
        multiCursorPaste: register2(new EditorStringEnumOption(77, "multiCursorPaste", "spread", ["spread", "full"], {
          markdownEnumDescriptions: [
            localize("multiCursorPaste.spread", "Each cursor pastes a single line of the text."),
            localize("multiCursorPaste.full", "Each cursor pastes the full text.")
          ],
          markdownDescription: localize("multiCursorPaste", "Controls pasting when the line count of the pasted text matches the cursor count.")
        })),
        multiCursorLimit: register2(new EditorIntOption(78, "multiCursorLimit", 1e4, 1, 1e5, {
          markdownDescription: localize("multiCursorLimit", "Controls the max number of cursors that can be in an active editor at once.")
        })),
        occurrencesHighlight: register2(new EditorBooleanOption(79, "occurrencesHighlight", true, { description: localize("occurrencesHighlight", "Controls whether the editor should highlight semantic symbol occurrences.") })),
        overviewRulerBorder: register2(new EditorBooleanOption(80, "overviewRulerBorder", true, { description: localize("overviewRulerBorder", "Controls whether a border should be drawn around the overview ruler.") })),
        overviewRulerLanes: register2(new EditorIntOption(81, "overviewRulerLanes", 3, 0, 3)),
        padding: register2(new EditorPadding()),
        pasteAs: register2(new EditorPasteAs()),
        parameterHints: register2(new EditorParameterHints()),
        peekWidgetDefaultFocus: register2(new EditorStringEnumOption(85, "peekWidgetDefaultFocus", "tree", ["tree", "editor"], {
          enumDescriptions: [
            localize("peekWidgetDefaultFocus.tree", "Focus the tree when opening peek"),
            localize("peekWidgetDefaultFocus.editor", "Focus the editor when opening peek")
          ],
          description: localize("peekWidgetDefaultFocus", "Controls whether to focus the inline editor or the tree in the peek widget.")
        })),
        definitionLinkOpensInPeek: register2(new EditorBooleanOption(86, "definitionLinkOpensInPeek", false, { description: localize("definitionLinkOpensInPeek", "Controls whether the Go to Definition mouse gesture always opens the peek widget.") })),
        quickSuggestions: register2(new EditorQuickSuggestions()),
        quickSuggestionsDelay: register2(new EditorIntOption(88, "quickSuggestionsDelay", 10, 0, 1073741824, { description: localize("quickSuggestionsDelay", "Controls the delay in milliseconds after which quick suggestions will show up.") })),
        readOnly: register2(new EditorBooleanOption(89, "readOnly", false)),
        readOnlyMessage: register2(new ReadonlyMessage()),
        renameOnType: register2(new EditorBooleanOption(91, "renameOnType", false, { description: localize("renameOnType", "Controls whether the editor auto renames on type."), markdownDeprecationMessage: localize("renameOnTypeDeprecate", "Deprecated, use `editor.linkedEditing` instead.") })),
        renderControlCharacters: register2(new EditorBooleanOption(92, "renderControlCharacters", true, { description: localize("renderControlCharacters", "Controls whether the editor should render control characters."), restricted: true })),
        renderFinalNewline: register2(new EditorStringEnumOption(93, "renderFinalNewline", isLinux ? "dimmed" : "on", ["off", "on", "dimmed"], { description: localize("renderFinalNewline", "Render last line number when the file ends with a newline.") })),
        renderLineHighlight: register2(new EditorStringEnumOption(94, "renderLineHighlight", "line", ["none", "gutter", "line", "all"], {
          enumDescriptions: [
            "",
            "",
            "",
            localize("renderLineHighlight.all", "Highlights both the gutter and the current line.")
          ],
          description: localize("renderLineHighlight", "Controls how the editor should render the current line highlight.")
        })),
        renderLineHighlightOnlyWhenFocus: register2(new EditorBooleanOption(95, "renderLineHighlightOnlyWhenFocus", false, { description: localize("renderLineHighlightOnlyWhenFocus", "Controls if the editor should render the current line highlight only when the editor is focused.") })),
        renderValidationDecorations: register2(new EditorStringEnumOption(96, "renderValidationDecorations", "editable", ["editable", "on", "off"])),
        renderWhitespace: register2(new EditorStringEnumOption(97, "renderWhitespace", "selection", ["none", "boundary", "selection", "trailing", "all"], {
          enumDescriptions: [
            "",
            localize("renderWhitespace.boundary", "Render whitespace characters except for single spaces between words."),
            localize("renderWhitespace.selection", "Render whitespace characters only on selected text."),
            localize("renderWhitespace.trailing", "Render only trailing whitespace characters."),
            ""
          ],
          description: localize("renderWhitespace", "Controls how the editor should render whitespace characters.")
        })),
        revealHorizontalRightPadding: register2(new EditorIntOption(98, "revealHorizontalRightPadding", 15, 0, 1e3)),
        roundedSelection: register2(new EditorBooleanOption(99, "roundedSelection", true, { description: localize("roundedSelection", "Controls whether selections should have rounded corners.") })),
        rulers: register2(new EditorRulers()),
        scrollbar: register2(new EditorScrollbar()),
        scrollBeyondLastColumn: register2(new EditorIntOption(102, "scrollBeyondLastColumn", 4, 0, 1073741824, { description: localize("scrollBeyondLastColumn", "Controls the number of extra characters beyond which the editor will scroll horizontally.") })),
        scrollBeyondLastLine: register2(new EditorBooleanOption(103, "scrollBeyondLastLine", true, { description: localize("scrollBeyondLastLine", "Controls whether the editor will scroll beyond the last line.") })),
        scrollPredominantAxis: register2(new EditorBooleanOption(104, "scrollPredominantAxis", true, { description: localize("scrollPredominantAxis", "Scroll only along the predominant axis when scrolling both vertically and horizontally at the same time. Prevents horizontal drift when scrolling vertically on a trackpad.") })),
        selectionClipboard: register2(new EditorBooleanOption(105, "selectionClipboard", true, {
          description: localize("selectionClipboard", "Controls whether the Linux primary clipboard should be supported."),
          included: isLinux
        })),
        selectionHighlight: register2(new EditorBooleanOption(106, "selectionHighlight", true, { description: localize("selectionHighlight", "Controls whether the editor should highlight matches similar to the selection.") })),
        selectOnLineNumbers: register2(new EditorBooleanOption(107, "selectOnLineNumbers", true)),
        showFoldingControls: register2(new EditorStringEnumOption(108, "showFoldingControls", "mouseover", ["always", "never", "mouseover"], {
          enumDescriptions: [
            localize("showFoldingControls.always", "Always show the folding controls."),
            localize("showFoldingControls.never", "Never show the folding controls and reduce the gutter size."),
            localize("showFoldingControls.mouseover", "Only show the folding controls when the mouse is over the gutter.")
          ],
          description: localize("showFoldingControls", "Controls when the folding controls on the gutter are shown.")
        })),
        showUnused: register2(new EditorBooleanOption(109, "showUnused", true, { description: localize("showUnused", "Controls fading out of unused code.") })),
        showDeprecated: register2(new EditorBooleanOption(137, "showDeprecated", true, { description: localize("showDeprecated", "Controls strikethrough deprecated variables.") })),
        inlayHints: register2(new EditorInlayHints()),
        snippetSuggestions: register2(new EditorStringEnumOption(110, "snippetSuggestions", "inline", ["top", "bottom", "inline", "none"], {
          enumDescriptions: [
            localize("snippetSuggestions.top", "Show snippet suggestions on top of other suggestions."),
            localize("snippetSuggestions.bottom", "Show snippet suggestions below other suggestions."),
            localize("snippetSuggestions.inline", "Show snippets suggestions with other suggestions."),
            localize("snippetSuggestions.none", "Do not show snippet suggestions.")
          ],
          description: localize("snippetSuggestions", "Controls whether snippets are shown with other suggestions and how they are sorted.")
        })),
        smartSelect: register2(new SmartSelect()),
        smoothScrolling: register2(new EditorBooleanOption(112, "smoothScrolling", false, { description: localize("smoothScrolling", "Controls whether the editor will scroll using an animation.") })),
        stopRenderingLineAfter: register2(new EditorIntOption(
          115,
          "stopRenderingLineAfter",
          1e4,
          -1,
          1073741824
          /* Constants.MAX_SAFE_SMALL_INTEGER */
        )),
        suggest: register2(new EditorSuggest()),
        inlineSuggest: register2(new InlineEditorSuggest()),
        suggestFontSize: register2(new EditorIntOption(117, "suggestFontSize", 0, 0, 1e3, { markdownDescription: localize("suggestFontSize", "Font size for the suggest widget. When set to {0}, the value of {1} is used.", "`0`", "`#editor.fontSize#`") })),
        suggestLineHeight: register2(new EditorIntOption(118, "suggestLineHeight", 0, 0, 1e3, { markdownDescription: localize("suggestLineHeight", "Line height for the suggest widget. When set to {0}, the value of {1} is used. The minimum value is 8.", "`0`", "`#editor.lineHeight#`") })),
        suggestOnTriggerCharacters: register2(new EditorBooleanOption(119, "suggestOnTriggerCharacters", true, { description: localize("suggestOnTriggerCharacters", "Controls whether suggestions should automatically show up when typing trigger characters.") })),
        suggestSelection: register2(new EditorStringEnumOption(120, "suggestSelection", "first", ["first", "recentlyUsed", "recentlyUsedByPrefix"], {
          markdownEnumDescriptions: [
            localize("suggestSelection.first", "Always select the first suggestion."),
            localize("suggestSelection.recentlyUsed", "Select recent suggestions unless further typing selects one, e.g. `console.| -> console.log` because `log` has been completed recently."),
            localize("suggestSelection.recentlyUsedByPrefix", "Select suggestions based on previous prefixes that have completed those suggestions, e.g. `co -> console` and `con -> const`.")
          ],
          description: localize("suggestSelection", "Controls how suggestions are pre-selected when showing the suggest list.")
        })),
        tabCompletion: register2(new EditorStringEnumOption(121, "tabCompletion", "off", ["on", "off", "onlySnippets"], {
          enumDescriptions: [
            localize("tabCompletion.on", "Tab complete will insert the best matching suggestion when pressing tab."),
            localize("tabCompletion.off", "Disable tab completions."),
            localize("tabCompletion.onlySnippets", "Tab complete snippets when their prefix match. Works best when 'quickSuggestions' aren't enabled.")
          ],
          description: localize("tabCompletion", "Enables tab completions.")
        })),
        tabIndex: register2(new EditorIntOption(
          122,
          "tabIndex",
          0,
          -1,
          1073741824
          /* Constants.MAX_SAFE_SMALL_INTEGER */
        )),
        unicodeHighlight: register2(new UnicodeHighlight()),
        unusualLineTerminators: register2(new EditorStringEnumOption(124, "unusualLineTerminators", "prompt", ["auto", "off", "prompt"], {
          enumDescriptions: [
            localize("unusualLineTerminators.auto", "Unusual line terminators are automatically removed."),
            localize("unusualLineTerminators.off", "Unusual line terminators are ignored."),
            localize("unusualLineTerminators.prompt", "Unusual line terminators prompt to be removed.")
          ],
          description: localize("unusualLineTerminators", "Remove unusual line terminators that might cause problems.")
        })),
        useShadowDOM: register2(new EditorBooleanOption(125, "useShadowDOM", true)),
        useTabStops: register2(new EditorBooleanOption(126, "useTabStops", true, { description: localize("useTabStops", "Inserting and deleting whitespace follows tab stops.") })),
        wordBreak: register2(new EditorStringEnumOption(127, "wordBreak", "normal", ["normal", "keepAll"], {
          markdownEnumDescriptions: [
            localize("wordBreak.normal", "Use the default line break rule."),
            localize("wordBreak.keepAll", "Word breaks should not be used for Chinese/Japanese/Korean (CJK) text. Non-CJK text behavior is the same as for normal.")
          ],
          description: localize("wordBreak", "Controls the word break rules used for Chinese/Japanese/Korean (CJK) text.")
        })),
        wordSeparators: register2(new EditorStringOption(128, "wordSeparators", USUAL_WORD_SEPARATORS, { description: localize("wordSeparators", "Characters that will be used as word separators when doing word related navigations or operations.") })),
        wordWrap: register2(new EditorStringEnumOption(129, "wordWrap", "off", ["off", "on", "wordWrapColumn", "bounded"], {
          markdownEnumDescriptions: [
            localize("wordWrap.off", "Lines will never wrap."),
            localize("wordWrap.on", "Lines will wrap at the viewport width."),
            localize({
              key: "wordWrap.wordWrapColumn",
              comment: [
                "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
              ]
            }, "Lines will wrap at `#editor.wordWrapColumn#`."),
            localize({
              key: "wordWrap.bounded",
              comment: [
                "- viewport means the edge of the visible window size.",
                "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
              ]
            }, "Lines will wrap at the minimum of viewport and `#editor.wordWrapColumn#`.")
          ],
          description: localize({
            key: "wordWrap",
            comment: [
              "- 'off', 'on', 'wordWrapColumn' and 'bounded' refer to values the setting can take and should not be localized.",
              "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
            ]
          }, "Controls how lines should wrap.")
        })),
        wordWrapBreakAfterCharacters: register2(new EditorStringOption(
          130,
          "wordWrapBreakAfterCharacters",
          // allow-any-unicode-next-line
          " 	})]?|/&.,;\xA2\xB0\u2032\u2033\u2030\u2103\u3001\u3002\uFF61\uFF64\uFFE0\uFF0C\uFF0E\uFF1A\uFF1B\uFF1F\uFF01\uFF05\u30FB\uFF65\u309D\u309E\u30FD\u30FE\u30FC\u30A1\u30A3\u30A5\u30A7\u30A9\u30C3\u30E3\u30E5\u30E7\u30EE\u30F5\u30F6\u3041\u3043\u3045\u3047\u3049\u3063\u3083\u3085\u3087\u308E\u3095\u3096\u31F0\u31F1\u31F2\u31F3\u31F4\u31F5\u31F6\u31F7\u31F8\u31F9\u31FA\u31FB\u31FC\u31FD\u31FE\u31FF\u3005\u303B\uFF67\uFF68\uFF69\uFF6A\uFF6B\uFF6C\uFF6D\uFF6E\uFF6F\uFF70\u201D\u3009\u300B\u300D\u300F\u3011\u3015\uFF09\uFF3D\uFF5D\uFF63"
        )),
        wordWrapBreakBeforeCharacters: register2(new EditorStringOption(
          131,
          "wordWrapBreakBeforeCharacters",
          // allow-any-unicode-next-line
          "([{\u2018\u201C\u3008\u300A\u300C\u300E\u3010\u3014\uFF08\uFF3B\uFF5B\uFF62\xA3\xA5\uFF04\uFFE1\uFFE5+\uFF0B"
        )),
        wordWrapColumn: register2(new EditorIntOption(132, "wordWrapColumn", 80, 1, 1073741824, {
          markdownDescription: localize({
            key: "wordWrapColumn",
            comment: [
              "- `editor.wordWrap` refers to a different setting and should not be localized.",
              "- 'wordWrapColumn' and 'bounded' refer to values the different setting can take and should not be localized."
            ]
          }, "Controls the wrapping column of the editor when `#editor.wordWrap#` is `wordWrapColumn` or `bounded`.")
        })),
        wordWrapOverride1: register2(new EditorStringEnumOption(133, "wordWrapOverride1", "inherit", ["off", "on", "inherit"])),
        wordWrapOverride2: register2(new EditorStringEnumOption(134, "wordWrapOverride2", "inherit", ["off", "on", "inherit"])),
        // Leave these at the end (because they have dependencies!)
        editorClassName: register2(new EditorClassName()),
        defaultColorDecorators: register2(new EditorBooleanOption(144, "defaultColorDecorators", false, { markdownDescription: localize("defaultColorDecorators", "Controls whether inline color decorations should be shown using the default document color provider") })),
        pixelRatio: register2(new EditorPixelRatio()),
        tabFocusMode: register2(new EditorBooleanOption(141, "tabFocusMode", false, { markdownDescription: localize("tabFocusMode", "Controls whether the editor receives tabs or defers them to the workbench for navigation.") })),
        layoutInfo: register2(new EditorLayoutInfoComputer()),
        wrappingInfo: register2(new EditorWrappingInfoComputer()),
        wrappingIndent: register2(new WrappingIndentOption()),
        wrappingStrategy: register2(new WrappingStrategy())
      };
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/errorMessage.js
  var init_errorMessage = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/errorMessage.js"() {
      init_arrays();
      init_types();
      init_nls();
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/hash.js
  function leftRotate(value, bits, totalBits = 32) {
    const delta = totalBits - bits;
    const mask = ~((1 << delta) - 1);
    return (value << bits | (mask & value) >>> delta) >>> 0;
  }
  function fill(dest, index = 0, count = dest.byteLength, value = 0) {
    for (let i = 0; i < count; i++) {
      dest[index + i] = value;
    }
  }
  function leftPad(value, length, char = "0") {
    while (value.length < length) {
      value = char + value;
    }
    return value;
  }
  function toHexString(bufferOrValue, bitsize = 32) {
    if (bufferOrValue instanceof ArrayBuffer) {
      return Array.from(new Uint8Array(bufferOrValue)).map((b) => b.toString(16).padStart(2, "0")).join("");
    }
    return leftPad((bufferOrValue >>> 0).toString(16), bitsize / 4);
  }
  var StringSHA1;
  var init_hash = __esm({
    "node_modules/monaco-editor/esm/vs/base/common/hash.js"() {
      init_strings();
      StringSHA1 = class {
        constructor() {
          this._h0 = 1732584193;
          this._h1 = 4023233417;
          this._h2 = 2562383102;
          this._h3 = 271733878;
          this._h4 = 3285377520;
          this._buff = new Uint8Array(
            64 + 3
            /* to fit any utf-8 */
          );
          this._buffDV = new DataView(this._buff.buffer);
          this._buffLen = 0;
          this._totalLen = 0;
          this._leftoverHighSurrogate = 0;
          this._finished = false;
        }
        update(str) {
          const strLen = str.length;
          if (strLen === 0) {
            return;
          }
          const buff = this._buff;
          let buffLen = this._buffLen;
          let leftoverHighSurrogate = this._leftoverHighSurrogate;
          let charCode;
          let offset;
          if (leftoverHighSurrogate !== 0) {
            charCode = leftoverHighSurrogate;
            offset = -1;
            leftoverHighSurrogate = 0;
          } else {
            charCode = str.charCodeAt(0);
            offset = 0;
          }
          while (true) {
            let codePoint = charCode;
            if (isHighSurrogate(charCode)) {
              if (offset + 1 < strLen) {
                const nextCharCode = str.charCodeAt(offset + 1);
                if (isLowSurrogate(nextCharCode)) {
                  offset++;
                  codePoint = computeCodePoint(charCode, nextCharCode);
                } else {
                  codePoint = 65533;
                }
              } else {
                leftoverHighSurrogate = charCode;
                break;
              }
            } else if (isLowSurrogate(charCode)) {
              codePoint = 65533;
            }
            buffLen = this._push(buff, buffLen, codePoint);
            offset++;
            if (offset < strLen) {
              charCode = str.charCodeAt(offset);
            } else {
              break;
            }
          }
          this._buffLen = buffLen;
          this._leftoverHighSurrogate = leftoverHighSurrogate;
        }
        _push(buff, buffLen, codePoint) {
          if (codePoint < 128) {
            buff[buffLen++] = codePoint;
          } else if (codePoint < 2048) {
            buff[buffLen++] = 192 | (codePoint & 1984) >>> 6;
            buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
          } else if (codePoint < 65536) {
            buff[buffLen++] = 224 | (codePoint & 61440) >>> 12;
            buff[buffLen++] = 128 | (codePoint & 4032) >>> 6;
            buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
          } else {
            buff[buffLen++] = 240 | (codePoint & 1835008) >>> 18;
            buff[buffLen++] = 128 | (codePoint & 258048) >>> 12;
            buff[buffLen++] = 128 | (codePoint & 4032) >>> 6;
            buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
          }
          if (buffLen >= 64) {
            this._step();
            buffLen -= 64;
            this._totalLen += 64;
            buff[0] = buff[64 + 0];
            buff[1] = buff[64 + 1];
            buff[2] = buff[64 + 2];
          }
          return buffLen;
        }
        digest() {
          if (!this._finished) {
            this._finished = true;
            if (this._leftoverHighSurrogate) {
              this._leftoverHighSurrogate = 0;
              this._buffLen = this._push(
                this._buff,
                this._buffLen,
                65533
                /* SHA1Constant.UNICODE_REPLACEMENT */
              );
            }
            this._totalLen += this._buffLen;
            this._wrapUp();
          }
          return toHexString(this._h0) + toHexString(this._h1) + toHexString(this._h2) + toHexString(this._h3) + toHexString(this._h4);
        }
        _wrapUp() {
          this._buff[this._buffLen++] = 128;
          fill(this._buff, this._buffLen);
          if (this._buffLen > 56) {
            this._step();
            fill(this._buff);
          }
          const ml = 8 * this._totalLen;
          this._buffDV.setUint32(56, Math.floor(ml / 4294967296), false);
          this._buffDV.setUint32(60, ml % 4294967296, false);
          this._step();
        }
        _step() {
          const bigBlock32 = StringSHA1._bigBlock32;
          const data = this._buffDV;
          for (let j = 0; j < 64; j += 4) {
            bigBlock32.setUint32(j, data.getUint32(j, false), false);
          }
          for (let j = 64; j < 320; j += 4) {
            bigBlock32.setUint32(j, leftRotate(bigBlock32.getUint32(j - 12, false) ^ bigBlock32.getUint32(j - 32, false) ^ bigBlock32.getUint32(j - 56, false) ^ bigBlock32.getUint32(j - 64, false), 1), false);
          }
          let a = this._h0;
          let b = this._h1;
          let c = this._h2;
          let d = this._h3;
          let e = this._h4;
          let f, k;
          let temp;
          for (let j = 0; j < 80; j++) {
            if (j < 20) {
              f = b & c | ~b & d;
              k = 1518500249;
            } else if (j < 40) {
              f = b ^ c ^ d;
              k = 1859775393;
            } else if (j < 60) {
              f = b & c | b & d | c & d;
              k = 2400959708;
            } else {
              f = b ^ c ^ d;
              k = 3395469782;
            }
            temp = leftRotate(a, 5) + f + e + k + bigBlock32.getUint32(j * 4, false) & 4294967295;
            e = d;
            d = c;
            c = leftRotate(b, 30);
            b = a;
            a = temp;
          }
          this._h0 = this._h0 + a & 4294967295;
          this._h1 = this._h1 + b & 4294967295;
          this._h2 = this._h2 + c & 4294967295;
          this._h3 = this._h3 + d & 4294967295;
          this._h4 = this._h4 + e & 4294967295;
        }
      };
      StringSHA1._bigBlock32 = new DataView(new ArrayBuffer(320));
    }
  });

  // node_modules/monaco-editor/esm/vs/platform/log/common/log.js
  function LogLevelToString(logLevel) {
    switch (logLevel) {
      case LogLevel.Trace:
        return "trace";
      case LogLevel.Debug:
        return "debug";
      case LogLevel.Info:
        return "info";
      case LogLevel.Warning:
        return "warn";
      case LogLevel.Error:
        return "error";
      case LogLevel.Off:
        return "off";
    }
  }
  var ILogService, ILoggerService, LogLevel, DEFAULT_LOG_LEVEL, CONTEXT_LOG_LEVEL;
  var init_log = __esm({
    "node_modules/monaco-editor/esm/vs/platform/log/common/log.js"() {
      init_errorMessage();
      init_event();
      init_hash();
      init_lifecycle();
      init_map();
      init_platform();
      init_resources();
      init_types();
      init_uri();
      init_contextkey();
      init_instantiation();
      ILogService = createDecorator("logService");
      ILoggerService = createDecorator("loggerService");
      (function(LogLevel3) {
        LogLevel3[LogLevel3["Off"] = 0] = "Off";
        LogLevel3[LogLevel3["Trace"] = 1] = "Trace";
        LogLevel3[LogLevel3["Debug"] = 2] = "Debug";
        LogLevel3[LogLevel3["Info"] = 3] = "Info";
        LogLevel3[LogLevel3["Warning"] = 4] = "Warning";
        LogLevel3[LogLevel3["Error"] = 5] = "Error";
      })(LogLevel || (LogLevel = {}));
      DEFAULT_LOG_LEVEL = LogLevel.Info;
      CONTEXT_LOG_LEVEL = new RawContextKey("logLevel", LogLevelToString(LogLevel.Info));
    }
  });

  // node_modules/monaco-editor/esm/vs/platform/telemetry/common/telemetry.js
  var ITelemetryService, ICustomEndpointTelemetryService;
  var init_telemetry = __esm({
    "node_modules/monaco-editor/esm/vs/platform/telemetry/common/telemetry.js"() {
      init_instantiation();
      ITelemetryService = createDecorator("telemetryService");
      ICustomEndpointTelemetryService = createDecorator("customEndpointTelemetryService");
    }
  });

  // node_modules/vscode/dist/vscode/vs/platform/telemetry/common/telemetryUtils.js
  var TelemetryTrustedValue;
  var init_telemetryUtils = __esm({
    "node_modules/vscode/dist/vscode/vs/platform/telemetry/common/telemetryUtils.js"() {
      init_objects();
      init_remoteHosts();
      init_telemetry();
      TelemetryTrustedValue = class {
        constructor(value) {
          this.value = value;
          this.isTrustedTelemetryValue = true;
        }
      };
    }
  });

  // node_modules/vscode/dist/vscode/vs/workbench/services/search/common/searchExtTypes.js
  var TextSearchCompleteMessageType;
  var init_searchExtTypes = __esm({
    "node_modules/vscode/dist/vscode/vs/workbench/services/search/common/searchExtTypes.js"() {
      (function(TextSearchCompleteMessageType3) {
        TextSearchCompleteMessageType3[TextSearchCompleteMessageType3["Information"] = 1] = "Information";
        TextSearchCompleteMessageType3[TextSearchCompleteMessageType3["Warning"] = 2] = "Warning";
      })(TextSearchCompleteMessageType || (TextSearchCompleteMessageType = {}));
    }
  });

  // node_modules/vscode/dist/api.js
  var api_exports = {};
  __export(api_exports, {
    Breakpoint: () => Breakpoint3,
    CallHierarchyIncomingCall: () => CallHierarchyIncomingCall2,
    CallHierarchyItem: () => CallHierarchyItem2,
    CallHierarchyOutgoingCall: () => CallHierarchyOutgoingCall2,
    CancellationError: () => CancellationError2,
    CancellationTokenSource: () => CancellationTokenSource2,
    CodeAction: () => CodeAction3,
    CodeActionKind: () => CodeActionKind3,
    CodeActionTriggerKind: () => CodeActionTriggerKind2,
    CodeLens: () => CodeLens3,
    Color: () => Color3,
    ColorInformation: () => ColorInformation3,
    ColorPresentation: () => ColorPresentation3,
    ColorThemeKind: () => ColorThemeKind2,
    CommentMode: () => CommentMode2,
    CommentThreadCollapsibleState: () => CommentThreadCollapsibleState2,
    CommentThreadState: () => CommentThreadState2,
    CompletionItem: () => CompletionItem3,
    CompletionItemKind: () => CompletionItemKind2,
    CompletionItemTag: () => CompletionItemTag2,
    CompletionList: () => CompletionList3,
    CompletionTriggerKind: () => CompletionTriggerKind2,
    ConfigurationTarget: () => ConfigurationTarget2,
    CustomExecution: () => CustomExecution2,
    DataTransfer: () => DataTransfer3,
    DataTransferItem: () => DataTransferItem3,
    DebugAdapterExecutable: () => DebugAdapterExecutable3,
    DebugAdapterInlineImplementation: () => DebugAdapterInlineImplementation3,
    DebugAdapterNamedPipeServer: () => DebugAdapterNamedPipeServer3,
    DebugAdapterServer: () => DebugAdapterServer3,
    DebugConfigurationProviderTriggerKind: () => DebugConfigurationProviderTriggerKind2,
    DebugConsoleMode: () => DebugConsoleMode2,
    DecorationRangeBehavior: () => DecorationRangeBehavior2,
    Diagnostic: () => Diagnostic3,
    DiagnosticRelatedInformation: () => DiagnosticRelatedInformation3,
    DiagnosticSeverity: () => DiagnosticSeverity2,
    DiagnosticTag: () => DiagnosticTag2,
    Disposable: () => Disposable4,
    DocumentDropEdit: () => DocumentDropEdit3,
    DocumentHighlight: () => DocumentHighlight3,
    DocumentHighlightKind: () => DocumentHighlightKind2,
    DocumentLink: () => DocumentLink3,
    DocumentPasteEdit: () => DocumentPasteEdit3,
    DocumentSymbol: () => DocumentSymbol3,
    EndOfLine: () => EndOfLine2,
    EnvironmentVariableMutatorType: () => EnvironmentVariableMutatorType2,
    EvaluatableExpression: () => EvaluatableExpression3,
    EventEmitter: () => EventEmitter,
    ExtensionKind: () => ExtensionKind2,
    ExtensionMode: () => ExtensionMode2,
    ExternalUriOpenerPriority: () => ExternalUriOpenerPriority2,
    FileChangeType: () => FileChangeType2,
    FileDecoration: () => FileDecoration2,
    FilePermission: () => FilePermission2,
    FileSystemError: () => FileSystemError3,
    FileType: () => FileType2,
    FoldingRange: () => FoldingRange3,
    FoldingRangeKind: () => FoldingRangeKind2,
    FunctionBreakpoint: () => FunctionBreakpoint3,
    Hover: () => Hover3,
    IndentAction: () => IndentAction2,
    InlayHint: () => InlayHint3,
    InlayHintKind: () => InlayHintKind2,
    InlayHintLabelPart: () => InlayHintLabelPart3,
    InlineCompletionItem: () => InlineCompletionItem,
    InlineCompletionList: () => InlineCompletionList,
    InlineCompletionTriggerKind: () => InlineCompletionTriggerKind2,
    InlineValueEvaluatableExpression: () => InlineValueEvaluatableExpression3,
    InlineValueText: () => InlineValueText3,
    InlineValueVariableLookup: () => InlineValueVariableLookup3,
    InputBoxValidationSeverity: () => InputBoxValidationSeverity2,
    LanguageStatusSeverity: () => LanguageStatusSeverity2,
    LinkedEditingRanges: () => LinkedEditingRanges2,
    Location: () => Location3,
    LogLevel: () => LogLevel2,
    MarkdownString: () => MarkdownString4,
    NotebookCellData: () => NotebookCellData,
    NotebookCellKind: () => NotebookCellKind2,
    NotebookCellOutput: () => NotebookCellOutput,
    NotebookCellOutputItem: () => NotebookCellOutputItem2,
    NotebookCellStatusBarAlignment: () => NotebookCellStatusBarAlignment2,
    NotebookCellStatusBarItem: () => NotebookCellStatusBarItem,
    NotebookControllerAffinity: () => NotebookControllerAffinity3,
    NotebookData: () => NotebookData,
    NotebookEdit: () => NotebookEdit3,
    NotebookEditorRevealType: () => NotebookEditorRevealType2,
    NotebookRange: () => NotebookRange2,
    OverviewRulerLane: () => OverviewRulerLane2,
    ParameterInformation: () => ParameterInformation3,
    Position: () => Position3,
    ProcessExecution: () => ProcessExecution3,
    ProgressLocation: () => ProgressLocation2,
    QuickInputButtons: () => QuickInputButtons3,
    QuickPickItemKind: () => QuickPickItemKind2,
    Range: () => Range3,
    RelativePattern: () => RelativePattern3,
    Selection: () => Selection3,
    SelectionRange: () => SelectionRange3,
    SemanticTokens: () => SemanticTokens2,
    SemanticTokensBuilder: () => SemanticTokensBuilder2,
    SemanticTokensEdit: () => SemanticTokensEdit2,
    SemanticTokensEdits: () => SemanticTokensEdits2,
    SemanticTokensLegend: () => SemanticTokensLegend2,
    ShellExecution: () => ShellExecution3,
    ShellQuoting: () => ShellQuoting2,
    SignatureHelp: () => SignatureHelp3,
    SignatureHelpTriggerKind: () => SignatureHelpTriggerKind2,
    SignatureInformation: () => SignatureInformation3,
    SnippetString: () => SnippetString3,
    SnippetTextEdit: () => SnippetTextEdit2,
    SourceBreakpoint: () => SourceBreakpoint3,
    StatusBarAlignment: () => StatusBarAlignment2,
    SymbolInformation: () => SymbolInformation3,
    SymbolKind: () => SymbolKind2,
    SymbolTag: () => SymbolTag2,
    TabInputCustom: () => TabInputCustom,
    TabInputNotebook: () => TabInputNotebook,
    TabInputNotebookDiff: () => TabInputNotebookDiff,
    TabInputTerminal: () => TabInputTerminal,
    TabInputText: () => TabInputText,
    TabInputTextDiff: () => TabInputTextDiff,
    TabInputWebview: () => TabInputWebview,
    Task: () => Task3,
    TaskGroup: () => TaskGroup3,
    TaskPanelKind: () => TaskPanelKind2,
    TaskRevealKind: () => TaskRevealKind2,
    TaskScope: () => TaskScope2,
    TelemetryTrustedValue: () => TelemetryTrustedValue2,
    TerminalExitReason: () => TerminalExitReason2,
    TerminalLink: () => TerminalLink2,
    TerminalLocation: () => TerminalLocation2,
    TerminalProfile: () => TerminalProfile2,
    TestMessage: () => TestMessage3,
    TestRunProfileKind: () => TestRunProfileKind2,
    TestRunRequest: () => TestRunRequest3,
    TestTag: () => TestTag3,
    TextDocumentChangeReason: () => TextDocumentChangeReason2,
    TextDocumentSaveReason: () => TextDocumentSaveReason2,
    TextEdit: () => TextEdit3,
    TextEditorCursorStyle: () => TextEditorCursorStyle2,
    TextEditorLineNumbersStyle: () => TextEditorLineNumbersStyle2,
    TextEditorRevealType: () => TextEditorRevealType2,
    TextEditorSelectionChangeKind: () => TextEditorSelectionChangeKind2,
    TextSearchCompleteMessageType: () => TextSearchCompleteMessageType2,
    ThemeColor: () => ThemeColor4,
    ThemeIcon: () => ThemeIcon4,
    TreeItem: () => TreeItem3,
    TreeItemCheckboxState: () => TreeItemCheckboxState2,
    TreeItemCollapsibleState: () => TreeItemCollapsibleState2,
    TypeHierarchyItem: () => TypeHierarchyItem2,
    UIKind: () => UIKind2,
    Uri: () => Uri2,
    ViewColumn: () => ViewColumn2,
    WorkspaceEdit: () => WorkspaceEdit3,
    authentication: () => authentication,
    commands: () => commands,
    comments: () => comments,
    debug: () => debug,
    env: () => env2,
    extensions: () => extensions,
    l10n: () => l10n,
    languages: () => languages,
    notebooks: () => notebooks,
    scm: () => scm,
    setDefaultApi: () => setDefaultApi,
    tasks: () => tasks,
    tests: () => tests,
    version: () => version,
    window: () => window2,
    workspace: () => workspace
  });
  function setDefaultApi(api2) {
    defaultApi = api2;
  }
  function createProxy(key) {
    return new Proxy({}, {
      get(target, p) {
        if (defaultApi == null) {
          throw new Error("Default api is not ready yet, do not forget to call `initialize` from 'vscode/extensions'");
        }
        return defaultApi[key][p];
      }
    });
  }
  var defaultApi, unsupported, api, version, tasks, notebooks, scm, comments, authentication, tests, extensions, debug, env2, commands, window2, workspace, languages, l10n, Breakpoint3, CallHierarchyIncomingCall2, CallHierarchyItem2, CallHierarchyOutgoingCall2, CancellationError2, CancellationTokenSource2, CodeAction3, CodeActionKind3, CodeActionTriggerKind2, CodeLens3, Color3, ColorInformation3, ColorPresentation3, ColorThemeKind2, CommentMode2, CommentThreadCollapsibleState2, CompletionItem3, CompletionItemKind2, CompletionItemTag2, CompletionList3, CompletionTriggerKind2, ConfigurationTarget2, CustomExecution2, DebugAdapterExecutable3, DebugAdapterInlineImplementation3, DebugAdapterNamedPipeServer3, DebugAdapterServer3, DebugConfigurationProviderTriggerKind2, DebugConsoleMode2, DecorationRangeBehavior2, Diagnostic3, DiagnosticRelatedInformation3, DiagnosticSeverity2, DiagnosticTag2, Disposable4, DocumentHighlight3, DocumentHighlightKind2, DocumentLink3, DocumentSymbol3, EndOfLine2, EnvironmentVariableMutatorType2, EvaluatableExpression3, InlineValueText3, InlineValueVariableLookup3, InlineValueEvaluatableExpression3, EventEmitter, ExtensionKind2, ExtensionMode2, FileChangeType2, FileDecoration2, FileSystemError3, FileType2, FilePermission2, FoldingRange3, FoldingRangeKind2, FunctionBreakpoint3, Hover3, IndentAction2, Location3, MarkdownString4, OverviewRulerLane2, ParameterInformation3, Position3, ProcessExecution3, ProgressLocation2, QuickInputButtons3, Range3, RelativePattern3, Selection3, SelectionRange3, SemanticTokens2, SemanticTokensBuilder2, SemanticTokensEdit2, SemanticTokensEdits2, SemanticTokensLegend2, ShellExecution3, ShellQuoting2, SignatureHelp3, SignatureHelpTriggerKind2, SignatureInformation3, SnippetString3, SourceBreakpoint3, StatusBarAlignment2, SymbolInformation3, SymbolKind2, SymbolTag2, Task3, TaskGroup3, TaskPanelKind2, TaskRevealKind2, TaskScope2, TerminalLink2, TerminalLocation2, TerminalProfile2, TextDocumentSaveReason2, TextEdit3, TextEditorCursorStyle2, TextEditorLineNumbersStyle2, TextEditorRevealType2, TextEditorSelectionChangeKind2, TextDocumentChangeReason2, ThemeColor4, ThemeIcon4, TreeItem3, TreeItemCollapsibleState2, TypeHierarchyItem2, UIKind2, Uri2, ViewColumn2, WorkspaceEdit3, InlayHint3, InlayHintLabelPart3, InlayHintKind2, NotebookRange2, NotebookCellKind2, NotebookCellData, NotebookData, NotebookCellStatusBarAlignment2, NotebookCellOutput, NotebookCellOutputItem2, NotebookCellStatusBarItem, NotebookControllerAffinity3, LinkedEditingRanges2, TestRunRequest3, TestMessage3, TestTag3, TestRunProfileKind2, DataTransfer3, DataTransferItem3, LanguageStatusSeverity2, QuickPickItemKind2, TabInputText, TabInputTextDiff, TabInputCustom, TabInputNotebook, TabInputNotebookDiff, TabInputWebview, TabInputTerminal, InputBoxValidationSeverity2, InlineCompletionList, InlineCompletionTriggerKind2, InlineCompletionItem, DocumentDropEdit3, NotebookEditorRevealType2, SnippetTextEdit2, NotebookEdit3, LogLevel2, TerminalExitReason2, CommentThreadState2, TelemetryTrustedValue2, TextSearchCompleteMessageType2, DocumentPasteEdit3, ExternalUriOpenerPriority2, TreeItemCheckboxState2;
  var init_api = __esm({
    "node_modules/vscode/dist/api.js"() {
      init_extHostTypes();
      init_errors();
      init_debug();
      init_files();
      init_extensionHostProtocol();
      init_cancellation();
      init_event();
      init_languageConfiguration();
      init_model();
      init_editorOptions();
      init_uri();
      init_log();
      init_telemetryUtils();
      init_searchExtTypes();
      unsupported = void 0;
      api = {
        version: "1.81.0",
        tasks: createProxy("tasks"),
        notebooks: createProxy("notebooks"),
        scm: createProxy("scm"),
        comments: createProxy("comments"),
        authentication: createProxy("authentication"),
        tests: createProxy("tests"),
        extensions: createProxy("extensions"),
        debug: createProxy("debug"),
        env: createProxy("env"),
        commands: createProxy("commands"),
        window: createProxy("window"),
        workspace: createProxy("workspace"),
        languages: createProxy("languages"),
        l10n: createProxy("l10n"),
        Breakpoint,
        CallHierarchyIncomingCall,
        CallHierarchyItem,
        CallHierarchyOutgoingCall,
        CancellationError,
        CancellationTokenSource,
        CodeAction,
        CodeActionKind,
        CodeActionTriggerKind,
        CodeLens,
        Color,
        ColorInformation,
        ColorPresentation,
        ColorThemeKind,
        CommentMode,
        CommentThreadCollapsibleState,
        CompletionItem,
        CompletionItemKind,
        CompletionItemTag,
        CompletionList,
        CompletionTriggerKind,
        ConfigurationTarget,
        CustomExecution,
        DebugAdapterExecutable,
        DebugAdapterInlineImplementation,
        DebugAdapterNamedPipeServer,
        DebugAdapterServer,
        DebugConfigurationProviderTriggerKind,
        DebugConsoleMode,
        DecorationRangeBehavior,
        Diagnostic,
        DiagnosticRelatedInformation,
        DiagnosticSeverity,
        DiagnosticTag,
        Disposable: Disposable2,
        DocumentHighlight,
        DocumentHighlightKind,
        DocumentLink,
        DocumentSymbol,
        EndOfLine,
        EnvironmentVariableMutatorType,
        EvaluatableExpression,
        InlineValueText,
        InlineValueVariableLookup,
        InlineValueEvaluatableExpression,
        EventEmitter: Emitter,
        ExtensionKind,
        ExtensionMode,
        FileChangeType,
        FileDecoration,
        FileSystemError,
        FileType,
        FilePermission,
        FoldingRange,
        FoldingRangeKind,
        FunctionBreakpoint,
        Hover,
        IndentAction,
        Location,
        MarkdownString: MarkdownString2,
        OverviewRulerLane,
        ParameterInformation,
        Position,
        ProcessExecution,
        ProgressLocation,
        QuickInputButtons,
        Range,
        RelativePattern,
        Selection,
        SelectionRange,
        SemanticTokens,
        SemanticTokensBuilder,
        SemanticTokensEdit,
        SemanticTokensEdits,
        SemanticTokensLegend,
        ShellExecution,
        ShellQuoting,
        SignatureHelp,
        SignatureHelpTriggerKind,
        SignatureInformation,
        SnippetString,
        SourceBreakpoint,
        StatusBarAlignment,
        SymbolInformation,
        SymbolKind,
        SymbolTag,
        Task: unsupported,
        TaskGroup: unsupported,
        TaskPanelKind: unsupported,
        TaskRevealKind: unsupported,
        TaskScope: unsupported,
        TerminalLink,
        TerminalLocation,
        TerminalProfile,
        TextDocumentSaveReason,
        TextEdit,
        TextEditorCursorStyle,
        TextEditorLineNumbersStyle,
        TextEditorRevealType,
        TextEditorSelectionChangeKind,
        TextDocumentChangeReason,
        ThemeColor: ThemeColor2,
        ThemeIcon: ThemeIcon2,
        TreeItem,
        TreeItemCollapsibleState,
        TypeHierarchyItem,
        UIKind,
        Uri: URI,
        ViewColumn,
        WorkspaceEdit,
        InlayHint,
        InlayHintLabelPart,
        InlayHintKind,
        NotebookRange: unsupported,
        NotebookCellKind: unsupported,
        NotebookCellData: unsupported,
        NotebookData: unsupported,
        NotebookCellStatusBarAlignment: unsupported,
        NotebookCellOutput: unsupported,
        NotebookCellOutputItem: unsupported,
        NotebookCellStatusBarItem: unsupported,
        NotebookControllerAffinity: unsupported,
        LinkedEditingRanges,
        TestRunRequest,
        TestMessage,
        TestTag,
        TestRunProfileKind,
        DataTransfer,
        DataTransferItem,
        LanguageStatusSeverity,
        QuickPickItemKind,
        TabInputText: TextTabInput,
        TabInputTextDiff: TextDiffTabInput,
        TabInputCustom: CustomEditorTabInput,
        TabInputNotebook: NotebookEditorTabInput,
        TabInputNotebookDiff: NotebookDiffEditorTabInput,
        TabInputWebview: WebviewEditorTabInput,
        TabInputTerminal: TerminalEditorTabInput,
        InputBoxValidationSeverity,
        InlineCompletionList: InlineSuggestionList,
        InlineCompletionTriggerKind,
        InlineCompletionItem: InlineSuggestion,
        DocumentDropEdit,
        NotebookEditorRevealType: unsupported,
        SnippetTextEdit,
        NotebookEdit: unsupported,
        LogLevel,
        TerminalExitReason,
        CommentThreadState: unsupported,
        TelemetryTrustedValue,
        TextSearchCompleteMessageType,
        DocumentPasteEdit,
        ExternalUriOpenerPriority,
        TreeItemCheckboxState
      };
      ({ version, tasks, notebooks, scm, comments, authentication, tests, extensions, debug, env: env2, commands, window: window2, workspace, languages, l10n, Breakpoint: Breakpoint3, CallHierarchyIncomingCall: CallHierarchyIncomingCall2, CallHierarchyItem: CallHierarchyItem2, CallHierarchyOutgoingCall: CallHierarchyOutgoingCall2, CancellationError: CancellationError2, CancellationTokenSource: CancellationTokenSource2, CodeAction: CodeAction3, CodeActionKind: CodeActionKind3, CodeActionTriggerKind: CodeActionTriggerKind2, CodeLens: CodeLens3, Color: Color3, ColorInformation: ColorInformation3, ColorPresentation: ColorPresentation3, ColorThemeKind: ColorThemeKind2, CommentMode: CommentMode2, CommentThreadCollapsibleState: CommentThreadCollapsibleState2, CompletionItem: CompletionItem3, CompletionItemKind: CompletionItemKind2, CompletionItemTag: CompletionItemTag2, CompletionList: CompletionList3, CompletionTriggerKind: CompletionTriggerKind2, ConfigurationTarget: ConfigurationTarget2, CustomExecution: CustomExecution2, DebugAdapterExecutable: DebugAdapterExecutable3, DebugAdapterInlineImplementation: DebugAdapterInlineImplementation3, DebugAdapterNamedPipeServer: DebugAdapterNamedPipeServer3, DebugAdapterServer: DebugAdapterServer3, DebugConfigurationProviderTriggerKind: DebugConfigurationProviderTriggerKind2, DebugConsoleMode: DebugConsoleMode2, DecorationRangeBehavior: DecorationRangeBehavior2, Diagnostic: Diagnostic3, DiagnosticRelatedInformation: DiagnosticRelatedInformation3, DiagnosticSeverity: DiagnosticSeverity2, DiagnosticTag: DiagnosticTag2, Disposable: Disposable4, DocumentHighlight: DocumentHighlight3, DocumentHighlightKind: DocumentHighlightKind2, DocumentLink: DocumentLink3, DocumentSymbol: DocumentSymbol3, EndOfLine: EndOfLine2, EnvironmentVariableMutatorType: EnvironmentVariableMutatorType2, EvaluatableExpression: EvaluatableExpression3, InlineValueText: InlineValueText3, InlineValueVariableLookup: InlineValueVariableLookup3, InlineValueEvaluatableExpression: InlineValueEvaluatableExpression3, EventEmitter, ExtensionKind: ExtensionKind2, ExtensionMode: ExtensionMode2, FileChangeType: FileChangeType2, FileDecoration: FileDecoration2, FileSystemError: FileSystemError3, FileType: FileType2, FilePermission: FilePermission2, FoldingRange: FoldingRange3, FoldingRangeKind: FoldingRangeKind2, FunctionBreakpoint: FunctionBreakpoint3, Hover: Hover3, IndentAction: IndentAction2, Location: Location3, MarkdownString: MarkdownString4, OverviewRulerLane: OverviewRulerLane2, ParameterInformation: ParameterInformation3, Position: Position3, ProcessExecution: ProcessExecution3, ProgressLocation: ProgressLocation2, QuickInputButtons: QuickInputButtons3, Range: Range3, RelativePattern: RelativePattern3, Selection: Selection3, SelectionRange: SelectionRange3, SemanticTokens: SemanticTokens2, SemanticTokensBuilder: SemanticTokensBuilder2, SemanticTokensEdit: SemanticTokensEdit2, SemanticTokensEdits: SemanticTokensEdits2, SemanticTokensLegend: SemanticTokensLegend2, ShellExecution: ShellExecution3, ShellQuoting: ShellQuoting2, SignatureHelp: SignatureHelp3, SignatureHelpTriggerKind: SignatureHelpTriggerKind2, SignatureInformation: SignatureInformation3, SnippetString: SnippetString3, SourceBreakpoint: SourceBreakpoint3, StatusBarAlignment: StatusBarAlignment2, SymbolInformation: SymbolInformation3, SymbolKind: SymbolKind2, SymbolTag: SymbolTag2, Task: Task3, TaskGroup: TaskGroup3, TaskPanelKind: TaskPanelKind2, TaskRevealKind: TaskRevealKind2, TaskScope: TaskScope2, TerminalLink: TerminalLink2, TerminalLocation: TerminalLocation2, TerminalProfile: TerminalProfile2, TextDocumentSaveReason: TextDocumentSaveReason2, TextEdit: TextEdit3, TextEditorCursorStyle: TextEditorCursorStyle2, TextEditorLineNumbersStyle: TextEditorLineNumbersStyle2, TextEditorRevealType: TextEditorRevealType2, TextEditorSelectionChangeKind: TextEditorSelectionChangeKind2, TextDocumentChangeReason: TextDocumentChangeReason2, ThemeColor: ThemeColor4, ThemeIcon: ThemeIcon4, TreeItem: TreeItem3, TreeItemCollapsibleState: TreeItemCollapsibleState2, TypeHierarchyItem: TypeHierarchyItem2, UIKind: UIKind2, Uri: Uri2, ViewColumn: ViewColumn2, WorkspaceEdit: WorkspaceEdit3, InlayHint: InlayHint3, InlayHintLabelPart: InlayHintLabelPart3, InlayHintKind: InlayHintKind2, NotebookRange: NotebookRange2, NotebookCellKind: NotebookCellKind2, NotebookCellData, NotebookData, NotebookCellStatusBarAlignment: NotebookCellStatusBarAlignment2, NotebookCellOutput, NotebookCellOutputItem: NotebookCellOutputItem2, NotebookCellStatusBarItem, NotebookControllerAffinity: NotebookControllerAffinity3, LinkedEditingRanges: LinkedEditingRanges2, TestRunRequest: TestRunRequest3, TestMessage: TestMessage3, TestTag: TestTag3, TestRunProfileKind: TestRunProfileKind2, DataTransfer: DataTransfer3, DataTransferItem: DataTransferItem3, LanguageStatusSeverity: LanguageStatusSeverity2, QuickPickItemKind: QuickPickItemKind2, TabInputText, TabInputTextDiff, TabInputCustom, TabInputNotebook, TabInputNotebookDiff, TabInputWebview, TabInputTerminal, InputBoxValidationSeverity: InputBoxValidationSeverity2, InlineCompletionList, InlineCompletionTriggerKind: InlineCompletionTriggerKind2, InlineCompletionItem, DocumentDropEdit: DocumentDropEdit3, NotebookEditorRevealType: NotebookEditorRevealType2, SnippetTextEdit: SnippetTextEdit2, NotebookEdit: NotebookEdit3, LogLevel: LogLevel2, TerminalExitReason: TerminalExitReason2, CommentThreadState: CommentThreadState2, TelemetryTrustedValue: TelemetryTrustedValue2, TextSearchCompleteMessageType: TextSearchCompleteMessageType2, DocumentPasteEdit: DocumentPasteEdit3, ExternalUriOpenerPriority: ExternalUriOpenerPriority2, TreeItemCheckboxState: TreeItemCheckboxState2 } = api);
    }
  });

  // node_modules/vscode-languageclient/lib/common/utils/is.js
  var require_is4 = __commonJS({
    "node_modules/vscode-languageclient/lib/common/utils/is.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.asPromise = exports2.thenable = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
      function boolean2(value) {
        return value === true || value === false;
      }
      exports2.boolean = boolean2;
      function string(value) {
        return typeof value === "string" || value instanceof String;
      }
      exports2.string = string;
      function number(value) {
        return typeof value === "number" || value instanceof Number;
      }
      exports2.number = number;
      function error(value) {
        return value instanceof Error;
      }
      exports2.error = error;
      function func(value) {
        return typeof value === "function";
      }
      exports2.func = func;
      function array(value) {
        return Array.isArray(value);
      }
      exports2.array = array;
      function stringArray(value) {
        return array(value) && value.every((elem) => string(elem));
      }
      exports2.stringArray = stringArray;
      function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
      }
      exports2.typedArray = typedArray;
      function thenable(value) {
        return value && func(value.then);
      }
      exports2.thenable = thenable;
      function asPromise(value) {
        if (value instanceof Promise) {
          return value;
        } else if (thenable(value)) {
          return new Promise((resolve2, reject) => {
            value.then((resolved) => resolve2(resolved), (error2) => reject(error2));
          });
        } else {
          return Promise.resolve(value);
        }
      }
      exports2.asPromise = asPromise;
    }
  });

  // node_modules/vscode-languageclient/lib/common/utils/uuid.js
  var require_uuid2 = __commonJS({
    "node_modules/vscode-languageclient/lib/common/utils/uuid.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.generateUuid = exports2.parse = exports2.isUUID = exports2.v4 = exports2.empty = void 0;
      var ValueUUID = class {
        constructor(_value) {
          this._value = _value;
        }
        asHex() {
          return this._value;
        }
        equals(other) {
          return this.asHex() === other.asHex();
        }
      };
      var V4UUID = class extends ValueUUID {
        constructor() {
          super([
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            "-",
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            "-",
            "4",
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            "-",
            V4UUID._oneOf(V4UUID._timeHighBits),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            "-",
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex()
          ].join(""));
        }
        static _oneOf(array) {
          return array[Math.floor(array.length * Math.random())];
        }
        static _randomHex() {
          return V4UUID._oneOf(V4UUID._chars);
        }
      };
      V4UUID._chars = ["0", "1", "2", "3", "4", "5", "6", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
      V4UUID._timeHighBits = ["8", "9", "a", "b"];
      exports2.empty = new ValueUUID("00000000-0000-0000-0000-000000000000");
      function v4() {
        return new V4UUID();
      }
      exports2.v4 = v4;
      var _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
      function isUUID(value) {
        return _UUIDPattern.test(value);
      }
      exports2.isUUID = isUUID;
      function parse2(value) {
        if (!isUUID(value)) {
          throw new Error("invalid uuid");
        }
        return new ValueUUID(value);
      }
      exports2.parse = parse2;
      function generateUuid2() {
        return v4().asHex();
      }
      exports2.generateUuid = generateUuid2;
    }
  });

  // node_modules/vscode-languageclient/lib/common/features.js
  var require_features = __commonJS({
    "node_modules/vscode-languageclient/lib/common/features.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.WorkspaceFeature = exports2.TextDocumentLanguageFeature = exports2.TextDocumentEventFeature = exports2.DynamicDocumentFeature = exports2.DynamicFeature = exports2.StaticFeature = exports2.ensure = exports2.LSPCancellationError = void 0;
      var vscode_1 = (init_api(), __toCommonJS(api_exports));
      var vscode_languageserver_protocol_1 = require_main3();
      var Is = require_is4();
      var UUID = require_uuid2();
      var LSPCancellationError = class extends vscode_1.CancellationError {
        constructor(data) {
          super();
          this.data = data;
        }
      };
      exports2.LSPCancellationError = LSPCancellationError;
      function ensure(target, key) {
        if (target[key] === void 0) {
          target[key] = {};
        }
        return target[key];
      }
      exports2.ensure = ensure;
      var StaticFeature;
      (function(StaticFeature2) {
        function is(value) {
          const candidate = value;
          return candidate !== void 0 && candidate !== null && Is.func(candidate.fillClientCapabilities) && Is.func(candidate.initialize) && Is.func(candidate.getState) && Is.func(candidate.dispose) && (candidate.fillInitializeParams === void 0 || Is.func(candidate.fillInitializeParams));
        }
        StaticFeature2.is = is;
      })(StaticFeature = exports2.StaticFeature || (exports2.StaticFeature = {}));
      var DynamicFeature;
      (function(DynamicFeature2) {
        function is(value) {
          const candidate = value;
          return candidate !== void 0 && candidate !== null && Is.func(candidate.fillClientCapabilities) && Is.func(candidate.initialize) && Is.func(candidate.getState) && Is.func(candidate.dispose) && (candidate.fillInitializeParams === void 0 || Is.func(candidate.fillInitializeParams)) && Is.func(candidate.register) && Is.func(candidate.unregister) && candidate.registrationType !== void 0;
        }
        DynamicFeature2.is = is;
      })(DynamicFeature = exports2.DynamicFeature || (exports2.DynamicFeature = {}));
      var DynamicDocumentFeature = class {
        constructor(client) {
          this._client = client;
        }
        /**
         * Returns the state the feature is in.
         */
        getState() {
          const selectors = this.getDocumentSelectors();
          let count = 0;
          for (const selector of selectors) {
            count++;
            for (const document2 of vscode_1.workspace.textDocuments) {
              if (vscode_1.languages.match(selector, document2) > 0) {
                return { kind: "document", id: this.registrationType.method, registrations: true, matches: true };
              }
            }
          }
          const registrations = count > 0;
          return { kind: "document", id: this.registrationType.method, registrations, matches: false };
        }
      };
      exports2.DynamicDocumentFeature = DynamicDocumentFeature;
      var TextDocumentEventFeature = class extends DynamicDocumentFeature {
        constructor(client, event, type, middleware, createParams, textDocument, selectorFilter) {
          super(client);
          this._event = event;
          this._type = type;
          this._middleware = middleware;
          this._createParams = createParams;
          this._textDocument = textDocument;
          this._selectorFilter = selectorFilter;
          this._selectors = /* @__PURE__ */ new Map();
          this._onNotificationSent = new vscode_1.EventEmitter();
        }
        static textDocumentFilter(selectors, textDocument) {
          for (const selector of selectors) {
            if (vscode_1.languages.match(selector, textDocument) > 0) {
              return true;
            }
          }
          return false;
        }
        getStateInfo() {
          return [this._selectors.values(), false];
        }
        getDocumentSelectors() {
          return this._selectors.values();
        }
        register(data) {
          if (!data.registerOptions.documentSelector) {
            return;
          }
          if (!this._listener) {
            this._listener = this._event((data2) => {
              this.callback(data2).catch((error) => {
                this._client.error(`Sending document notification ${this._type.method} failed.`, error);
              });
            });
          }
          this._selectors.set(data.id, this._client.protocol2CodeConverter.asDocumentSelector(data.registerOptions.documentSelector));
        }
        async callback(data) {
          const doSend = async (data2) => {
            const params = this._createParams(data2);
            await this._client.sendNotification(this._type, params).catch();
            this.notificationSent(data2, this._type, params);
          };
          if (this.matches(data)) {
            const middleware = this._middleware();
            return middleware ? middleware(data, (data2) => doSend(data2)) : doSend(data);
          }
        }
        matches(data) {
          if (this._client.hasDedicatedTextSynchronizationFeature(this._textDocument(data))) {
            return false;
          }
          return !this._selectorFilter || this._selectorFilter(this._selectors.values(), data);
        }
        get onNotificationSent() {
          return this._onNotificationSent.event;
        }
        notificationSent(data, type, params) {
          this._onNotificationSent.fire({ original: data, type, params });
        }
        unregister(id2) {
          this._selectors.delete(id2);
          if (this._selectors.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = void 0;
          }
        }
        dispose() {
          this._selectors.clear();
          this._onNotificationSent.dispose();
          if (this._listener) {
            this._listener.dispose();
            this._listener = void 0;
          }
        }
        getProvider(document2) {
          for (const selector of this._selectors.values()) {
            if (vscode_1.languages.match(selector, document2) > 0) {
              return {
                send: (data) => {
                  return this.callback(data);
                }
              };
            }
          }
          return void 0;
        }
      };
      exports2.TextDocumentEventFeature = TextDocumentEventFeature;
      var TextDocumentLanguageFeature = class extends DynamicDocumentFeature {
        constructor(client, registrationType) {
          super(client);
          this._registrationType = registrationType;
          this._registrations = /* @__PURE__ */ new Map();
        }
        *getDocumentSelectors() {
          for (const registration of this._registrations.values()) {
            const selector = registration.data.registerOptions.documentSelector;
            if (selector === null) {
              continue;
            }
            yield this._client.protocol2CodeConverter.asDocumentSelector(selector);
          }
        }
        get registrationType() {
          return this._registrationType;
        }
        register(data) {
          if (!data.registerOptions.documentSelector) {
            return;
          }
          let registration = this.registerLanguageProvider(data.registerOptions, data.id);
          this._registrations.set(data.id, { disposable: registration[0], data, provider: registration[1] });
        }
        unregister(id2) {
          let registration = this._registrations.get(id2);
          if (registration !== void 0) {
            registration.disposable.dispose();
          }
        }
        dispose() {
          this._registrations.forEach((value) => {
            value.disposable.dispose();
          });
          this._registrations.clear();
        }
        getRegistration(documentSelector, capability) {
          if (!capability) {
            return [void 0, void 0];
          } else if (vscode_languageserver_protocol_1.TextDocumentRegistrationOptions.is(capability)) {
            const id2 = vscode_languageserver_protocol_1.StaticRegistrationOptions.hasId(capability) ? capability.id : UUID.generateUuid();
            const selector = capability.documentSelector || documentSelector;
            if (selector) {
              return [id2, Object.assign({}, capability, { documentSelector: selector })];
            }
          } else if (Is.boolean(capability) && capability === true || vscode_languageserver_protocol_1.WorkDoneProgressOptions.is(capability)) {
            if (!documentSelector) {
              return [void 0, void 0];
            }
            let options = Is.boolean(capability) && capability === true ? { documentSelector } : Object.assign({}, capability, { documentSelector });
            return [UUID.generateUuid(), options];
          }
          return [void 0, void 0];
        }
        getRegistrationOptions(documentSelector, capability) {
          if (!documentSelector || !capability) {
            return void 0;
          }
          return Is.boolean(capability) && capability === true ? { documentSelector } : Object.assign({}, capability, { documentSelector });
        }
        getProvider(textDocument) {
          for (const registration of this._registrations.values()) {
            let selector = registration.data.registerOptions.documentSelector;
            if (selector !== null && vscode_1.languages.match(this._client.protocol2CodeConverter.asDocumentSelector(selector), textDocument) > 0) {
              return registration.provider;
            }
          }
          return void 0;
        }
        getAllProviders() {
          const result = [];
          for (const item of this._registrations.values()) {
            result.push(item.provider);
          }
          return result;
        }
      };
      exports2.TextDocumentLanguageFeature = TextDocumentLanguageFeature;
      var WorkspaceFeature = class {
        constructor(client, registrationType) {
          this._client = client;
          this._registrationType = registrationType;
          this._registrations = /* @__PURE__ */ new Map();
        }
        getState() {
          const registrations = this._registrations.size > 0;
          return { kind: "workspace", id: this._registrationType.method, registrations };
        }
        get registrationType() {
          return this._registrationType;
        }
        register(data) {
          const registration = this.registerLanguageProvider(data.registerOptions);
          this._registrations.set(data.id, { disposable: registration[0], provider: registration[1] });
        }
        unregister(id2) {
          let registration = this._registrations.get(id2);
          if (registration !== void 0) {
            registration.disposable.dispose();
          }
        }
        dispose() {
          this._registrations.forEach((registration) => {
            registration.disposable.dispose();
          });
          this._registrations.clear();
        }
        getProviders() {
          const result = [];
          for (const registration of this._registrations.values()) {
            result.push(registration.provider);
          }
          return result;
        }
      };
      exports2.WorkspaceFeature = WorkspaceFeature;
    }
  });

  // node_modules/concat-map/index.js
  var require_concat_map = __commonJS({
    "node_modules/concat-map/index.js"(exports2, module2) {
      module2.exports = function(xs, fn) {
        var res = [];
        for (var i = 0; i < xs.length; i++) {
          var x = fn(xs[i], i);
          if (isArray(x))
            res.push.apply(res, x);
          else
            res.push(x);
        }
        return res;
      };
      var isArray = Array.isArray || function(xs) {
        return Object.prototype.toString.call(xs) === "[object Array]";
      };
    }
  });

  // node_modules/balanced-match/index.js
  var require_balanced_match = __commonJS({
    "node_modules/balanced-match/index.js"(exports2, module2) {
      "use strict";
      module2.exports = balanced;
      function balanced(a, b, str) {
        if (a instanceof RegExp)
          a = maybeMatch(a, str);
        if (b instanceof RegExp)
          b = maybeMatch(b, str);
        var r = range(a, b, str);
        return r && {
          start: r[0],
          end: r[1],
          pre: str.slice(0, r[0]),
          body: str.slice(r[0] + a.length, r[1]),
          post: str.slice(r[1] + b.length)
        };
      }
      function maybeMatch(reg, str) {
        var m = str.match(reg);
        return m ? m[0] : null;
      }
      balanced.range = range;
      function range(a, b, str) {
        var begs, beg, left, right, result;
        var ai = str.indexOf(a);
        var bi = str.indexOf(b, ai + 1);
        var i = ai;
        if (ai >= 0 && bi > 0) {
          if (a === b) {
            return [ai, bi];
          }
          begs = [];
          left = str.length;
          while (i >= 0 && !result) {
            if (i == ai) {
              begs.push(i);
              ai = str.indexOf(a, i + 1);
            } else if (begs.length == 1) {
              result = [begs.pop(), bi];
            } else {
              beg = begs.pop();
              if (beg < left) {
                left = beg;
                right = bi;
              }
              bi = str.indexOf(b, i + 1);
            }
            i = ai < bi && ai >= 0 ? ai : bi;
          }
          if (begs.length) {
            result = [left, right];
          }
        }
        return result;
      }
    }
  });

  // node_modules/brace-expansion/index.js
  var require_brace_expansion = __commonJS({
    "node_modules/brace-expansion/index.js"(exports2, module2) {
      var concatMap = require_concat_map();
      var balanced = require_balanced_match();
      module2.exports = expandTop;
      var escSlash = "\0SLASH" + Math.random() + "\0";
      var escOpen = "\0OPEN" + Math.random() + "\0";
      var escClose = "\0CLOSE" + Math.random() + "\0";
      var escComma = "\0COMMA" + Math.random() + "\0";
      var escPeriod = "\0PERIOD" + Math.random() + "\0";
      function numeric(str) {
        return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
      }
      function escapeBraces(str) {
        return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
      }
      function unescapeBraces(str) {
        return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
      }
      function parseCommaParts(str) {
        if (!str)
          return [""];
        var parts = [];
        var m = balanced("{", "}", str);
        if (!m)
          return str.split(",");
        var pre = m.pre;
        var body = m.body;
        var post = m.post;
        var p = pre.split(",");
        p[p.length - 1] += "{" + body + "}";
        var postParts = parseCommaParts(post);
        if (post.length) {
          p[p.length - 1] += postParts.shift();
          p.push.apply(p, postParts);
        }
        parts.push.apply(parts, p);
        return parts;
      }
      function expandTop(str) {
        if (!str)
          return [];
        if (str.substr(0, 2) === "{}") {
          str = "\\{\\}" + str.substr(2);
        }
        return expand(escapeBraces(str), true).map(unescapeBraces);
      }
      function embrace(str) {
        return "{" + str + "}";
      }
      function isPadded(el) {
        return /^-?0\d/.test(el);
      }
      function lte(i, y) {
        return i <= y;
      }
      function gte(i, y) {
        return i >= y;
      }
      function expand(str, isTop) {
        var expansions = [];
        var m = balanced("{", "}", str);
        if (!m || /\$$/.test(m.pre))
          return [str];
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m.post.match(/,.*\}/)) {
            str = m.pre + "{" + m.body + escClose + m.post;
            return expand(str);
          }
          return [str];
        }
        var n;
        if (isSequence) {
          n = m.body.split(/\.\./);
        } else {
          n = parseCommaParts(m.body);
          if (n.length === 1) {
            n = expand(n[0], false).map(embrace);
            if (n.length === 1) {
              var post = m.post.length ? expand(m.post, false) : [""];
              return post.map(function(p) {
                return m.pre + n[0] + p;
              });
            }
          }
        }
        var pre = m.pre;
        var post = m.post.length ? expand(m.post, false) : [""];
        var N;
        if (isSequence) {
          var x = numeric(n[0]);
          var y = numeric(n[1]);
          var width = Math.max(n[0].length, n[1].length);
          var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
          var test = lte;
          var reverse = y < x;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad = n.some(isPadded);
          N = [];
          for (var i = x; test(i, y); i += incr) {
            var c;
            if (isAlphaSequence) {
              c = String.fromCharCode(i);
              if (c === "\\")
                c = "";
            } else {
              c = String(i);
              if (pad) {
                var need = width - c.length;
                if (need > 0) {
                  var z = new Array(need + 1).join("0");
                  if (i < 0)
                    c = "-" + z + c.slice(1);
                  else
                    c = z + c;
                }
              }
            }
            N.push(c);
          }
        } else {
          N = concatMap(n, function(el) {
            return expand(el, false);
          });
        }
        for (var j = 0; j < N.length; j++) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + N[j] + post[k];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
        return expansions;
      }
    }
  });

  // node_modules/minimatch/minimatch.js
  var require_minimatch = __commonJS({
    "node_modules/minimatch/minimatch.js"(exports2, module2) {
      module2.exports = minimatch;
      minimatch.Minimatch = Minimatch;
      var path = function() {
        try {
          return __require("path");
        } catch (e) {
        }
      }() || {
        sep: "/"
      };
      minimatch.sep = path.sep;
      var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
      var expand = require_brace_expansion();
      var plTypes = {
        "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
        "?": { open: "(?:", close: ")?" },
        "+": { open: "(?:", close: ")+" },
        "*": { open: "(?:", close: ")*" },
        "@": { open: "(?:", close: ")" }
      };
      var qmark = "[^/]";
      var star = qmark + "*?";
      var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
      var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
      var reSpecials = charSet("().*{}+?[]^$\\!");
      function charSet(s) {
        return s.split("").reduce(function(set, c) {
          set[c] = true;
          return set;
        }, {});
      }
      var slashSplit = /\/+/;
      minimatch.filter = filter;
      function filter(pattern, options) {
        options = options || {};
        return function(p, i, list) {
          return minimatch(p, pattern, options);
        };
      }
      function ext(a, b) {
        b = b || {};
        var t = {};
        Object.keys(a).forEach(function(k) {
          t[k] = a[k];
        });
        Object.keys(b).forEach(function(k) {
          t[k] = b[k];
        });
        return t;
      }
      minimatch.defaults = function(def) {
        if (!def || typeof def !== "object" || !Object.keys(def).length) {
          return minimatch;
        }
        var orig = minimatch;
        var m = function minimatch2(p, pattern, options) {
          return orig(p, pattern, ext(def, options));
        };
        m.Minimatch = function Minimatch2(pattern, options) {
          return new orig.Minimatch(pattern, ext(def, options));
        };
        m.Minimatch.defaults = function defaults(options) {
          return orig.defaults(ext(def, options)).Minimatch;
        };
        m.filter = function filter2(pattern, options) {
          return orig.filter(pattern, ext(def, options));
        };
        m.defaults = function defaults(options) {
          return orig.defaults(ext(def, options));
        };
        m.makeRe = function makeRe2(pattern, options) {
          return orig.makeRe(pattern, ext(def, options));
        };
        m.braceExpand = function braceExpand2(pattern, options) {
          return orig.braceExpand(pattern, ext(def, options));
        };
        m.match = function(list, pattern, options) {
          return orig.match(list, pattern, ext(def, options));
        };
        return m;
      };
      Minimatch.defaults = function(def) {
        return minimatch.defaults(def).Minimatch;
      };
      function minimatch(p, pattern, options) {
        assertValidPattern(pattern);
        if (!options)
          options = {};
        if (!options.nocomment && pattern.charAt(0) === "#") {
          return false;
        }
        return new Minimatch(pattern, options).match(p);
      }
      function Minimatch(pattern, options) {
        if (!(this instanceof Minimatch)) {
          return new Minimatch(pattern, options);
        }
        assertValidPattern(pattern);
        if (!options)
          options = {};
        pattern = pattern.trim();
        if (!options.allowWindowsEscape && path.sep !== "/") {
          pattern = pattern.split(path.sep).join("/");
        }
        this.options = options;
        this.set = [];
        this.pattern = pattern;
        this.regexp = null;
        this.negate = false;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.make();
      }
      Minimatch.prototype.debug = function() {
      };
      Minimatch.prototype.make = make;
      function make() {
        var pattern = this.pattern;
        var options = this.options;
        if (!options.nocomment && pattern.charAt(0) === "#") {
          this.comment = true;
          return;
        }
        if (!pattern) {
          this.empty = true;
          return;
        }
        this.parseNegate();
        var set = this.globSet = this.braceExpand();
        if (options.debug)
          this.debug = function debug2() {
            console.error.apply(console, arguments);
          };
        this.debug(this.pattern, set);
        set = this.globParts = set.map(function(s) {
          return s.split(slashSplit);
        });
        this.debug(this.pattern, set);
        set = set.map(function(s, si, set2) {
          return s.map(this.parse, this);
        }, this);
        this.debug(this.pattern, set);
        set = set.filter(function(s) {
          return s.indexOf(false) === -1;
        });
        this.debug(this.pattern, set);
        this.set = set;
      }
      Minimatch.prototype.parseNegate = parseNegate;
      function parseNegate() {
        var pattern = this.pattern;
        var negate = false;
        var options = this.options;
        var negateOffset = 0;
        if (options.nonegate)
          return;
        for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
          negate = !negate;
          negateOffset++;
        }
        if (negateOffset)
          this.pattern = pattern.substr(negateOffset);
        this.negate = negate;
      }
      minimatch.braceExpand = function(pattern, options) {
        return braceExpand(pattern, options);
      };
      Minimatch.prototype.braceExpand = braceExpand;
      function braceExpand(pattern, options) {
        if (!options) {
          if (this instanceof Minimatch) {
            options = this.options;
          } else {
            options = {};
          }
        }
        pattern = typeof pattern === "undefined" ? this.pattern : pattern;
        assertValidPattern(pattern);
        if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
          return [pattern];
        }
        return expand(pattern);
      }
      var MAX_PATTERN_LENGTH = 1024 * 64;
      var assertValidPattern = function(pattern) {
        if (typeof pattern !== "string") {
          throw new TypeError("invalid pattern");
        }
        if (pattern.length > MAX_PATTERN_LENGTH) {
          throw new TypeError("pattern is too long");
        }
      };
      Minimatch.prototype.parse = parse2;
      var SUBPARSE = {};
      function parse2(pattern, isSub) {
        assertValidPattern(pattern);
        var options = this.options;
        if (pattern === "**") {
          if (!options.noglobstar)
            return GLOBSTAR;
          else
            pattern = "*";
        }
        if (pattern === "")
          return "";
        var re = "";
        var hasMagic = !!options.nocase;
        var escaping = false;
        var patternListStack = [];
        var negativeLists = [];
        var stateChar;
        var inClass = false;
        var reClassStart = -1;
        var classStart = -1;
        var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
        var self2 = this;
        function clearStateChar() {
          if (stateChar) {
            switch (stateChar) {
              case "*":
                re += star;
                hasMagic = true;
                break;
              case "?":
                re += qmark;
                hasMagic = true;
                break;
              default:
                re += "\\" + stateChar;
                break;
            }
            self2.debug("clearStateChar %j %j", stateChar, re);
            stateChar = false;
          }
        }
        for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
          this.debug("%s	%s %s %j", pattern, i, re, c);
          if (escaping && reSpecials[c]) {
            re += "\\" + c;
            escaping = false;
            continue;
          }
          switch (c) {
            case "/": {
              return false;
            }
            case "\\":
              clearStateChar();
              escaping = true;
              continue;
            case "?":
            case "*":
            case "+":
            case "@":
            case "!":
              this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
              if (inClass) {
                this.debug("  in class");
                if (c === "!" && i === classStart + 1)
                  c = "^";
                re += c;
                continue;
              }
              self2.debug("call clearStateChar %j", stateChar);
              clearStateChar();
              stateChar = c;
              if (options.noext)
                clearStateChar();
              continue;
            case "(":
              if (inClass) {
                re += "(";
                continue;
              }
              if (!stateChar) {
                re += "\\(";
                continue;
              }
              patternListStack.push({
                type: stateChar,
                start: i - 1,
                reStart: re.length,
                open: plTypes[stateChar].open,
                close: plTypes[stateChar].close
              });
              re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
              this.debug("plType %j %j", stateChar, re);
              stateChar = false;
              continue;
            case ")":
              if (inClass || !patternListStack.length) {
                re += "\\)";
                continue;
              }
              clearStateChar();
              hasMagic = true;
              var pl = patternListStack.pop();
              re += pl.close;
              if (pl.type === "!") {
                negativeLists.push(pl);
              }
              pl.reEnd = re.length;
              continue;
            case "|":
              if (inClass || !patternListStack.length || escaping) {
                re += "\\|";
                escaping = false;
                continue;
              }
              clearStateChar();
              re += "|";
              continue;
            case "[":
              clearStateChar();
              if (inClass) {
                re += "\\" + c;
                continue;
              }
              inClass = true;
              classStart = i;
              reClassStart = re.length;
              re += c;
              continue;
            case "]":
              if (i === classStart + 1 || !inClass) {
                re += "\\" + c;
                escaping = false;
                continue;
              }
              var cs = pattern.substring(classStart + 1, i);
              try {
                RegExp("[" + cs + "]");
              } catch (er) {
                var sp = this.parse(cs, SUBPARSE);
                re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
                hasMagic = hasMagic || sp[1];
                inClass = false;
                continue;
              }
              hasMagic = true;
              inClass = false;
              re += c;
              continue;
            default:
              clearStateChar();
              if (escaping) {
                escaping = false;
              } else if (reSpecials[c] && !(c === "^" && inClass)) {
                re += "\\";
              }
              re += c;
          }
        }
        if (inClass) {
          cs = pattern.substr(classStart + 1);
          sp = this.parse(cs, SUBPARSE);
          re = re.substr(0, reClassStart) + "\\[" + sp[0];
          hasMagic = hasMagic || sp[1];
        }
        for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
          var tail = re.slice(pl.reStart + pl.open.length);
          this.debug("setting tail", re, pl);
          tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
            if (!$2) {
              $2 = "\\";
            }
            return $1 + $1 + $2 + "|";
          });
          this.debug("tail=%j\n   %s", tail, tail, pl, re);
          var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
          hasMagic = true;
          re = re.slice(0, pl.reStart) + t + "\\(" + tail;
        }
        clearStateChar();
        if (escaping) {
          re += "\\\\";
        }
        var addPatternStart = false;
        switch (re.charAt(0)) {
          case "[":
          case ".":
          case "(":
            addPatternStart = true;
        }
        for (var n = negativeLists.length - 1; n > -1; n--) {
          var nl = negativeLists[n];
          var nlBefore = re.slice(0, nl.reStart);
          var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
          var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
          var nlAfter = re.slice(nl.reEnd);
          nlLast += nlAfter;
          var openParensBefore = nlBefore.split("(").length - 1;
          var cleanAfter = nlAfter;
          for (i = 0; i < openParensBefore; i++) {
            cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
          }
          nlAfter = cleanAfter;
          var dollar = "";
          if (nlAfter === "" && isSub !== SUBPARSE) {
            dollar = "$";
          }
          var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
          re = newRe;
        }
        if (re !== "" && hasMagic) {
          re = "(?=.)" + re;
        }
        if (addPatternStart) {
          re = patternStart + re;
        }
        if (isSub === SUBPARSE) {
          return [re, hasMagic];
        }
        if (!hasMagic) {
          return globUnescape(pattern);
        }
        var flags = options.nocase ? "i" : "";
        try {
          var regExp = new RegExp("^" + re + "$", flags);
        } catch (er) {
          return new RegExp("$.");
        }
        regExp._glob = pattern;
        regExp._src = re;
        return regExp;
      }
      minimatch.makeRe = function(pattern, options) {
        return new Minimatch(pattern, options || {}).makeRe();
      };
      Minimatch.prototype.makeRe = makeRe;
      function makeRe() {
        if (this.regexp || this.regexp === false)
          return this.regexp;
        var set = this.set;
        if (!set.length) {
          this.regexp = false;
          return this.regexp;
        }
        var options = this.options;
        var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
        var flags = options.nocase ? "i" : "";
        var re = set.map(function(pattern) {
          return pattern.map(function(p) {
            return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
          }).join("\\/");
        }).join("|");
        re = "^(?:" + re + ")$";
        if (this.negate)
          re = "^(?!" + re + ").*$";
        try {
          this.regexp = new RegExp(re, flags);
        } catch (ex) {
          this.regexp = false;
        }
        return this.regexp;
      }
      minimatch.match = function(list, pattern, options) {
        options = options || {};
        var mm = new Minimatch(pattern, options);
        list = list.filter(function(f) {
          return mm.match(f);
        });
        if (mm.options.nonull && !list.length) {
          list.push(pattern);
        }
        return list;
      };
      Minimatch.prototype.match = function match(f, partial) {
        if (typeof partial === "undefined")
          partial = this.partial;
        this.debug("match", f, this.pattern);
        if (this.comment)
          return false;
        if (this.empty)
          return f === "";
        if (f === "/" && partial)
          return true;
        var options = this.options;
        if (path.sep !== "/") {
          f = f.split(path.sep).join("/");
        }
        f = f.split(slashSplit);
        this.debug(this.pattern, "split", f);
        var set = this.set;
        this.debug(this.pattern, "set", set);
        var filename;
        var i;
        for (i = f.length - 1; i >= 0; i--) {
          filename = f[i];
          if (filename)
            break;
        }
        for (i = 0; i < set.length; i++) {
          var pattern = set[i];
          var file = f;
          if (options.matchBase && pattern.length === 1) {
            file = [filename];
          }
          var hit = this.matchOne(file, pattern, partial);
          if (hit) {
            if (options.flipNegate)
              return true;
            return !this.negate;
          }
        }
        if (options.flipNegate)
          return false;
        return this.negate;
      };
      Minimatch.prototype.matchOne = function(file, pattern, partial) {
        var options = this.options;
        this.debug(
          "matchOne",
          { "this": this, file, pattern }
        );
        this.debug("matchOne", file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
          this.debug("matchOne loop");
          var p = pattern[pi];
          var f = file[fi];
          this.debug(pattern, p, f);
          if (p === false)
            return false;
          if (p === GLOBSTAR) {
            this.debug("GLOBSTAR", [pattern, p, f]);
            var fr = fi;
            var pr = pi + 1;
            if (pr === pl) {
              this.debug("** at the end");
              for (; fi < fl; fi++) {
                if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                  return false;
              }
              return true;
            }
            while (fr < fl) {
              var swallowee = file[fr];
              this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
              if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                this.debug("globstar found match!", fr, fl, swallowee);
                return true;
              } else {
                if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                  this.debug("dot detected!", file, fr, pattern, pr);
                  break;
                }
                this.debug("globstar swallow a segment, and continue");
                fr++;
              }
            }
            if (partial) {
              this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
              if (fr === fl)
                return true;
            }
            return false;
          }
          var hit;
          if (typeof p === "string") {
            hit = f === p;
            this.debug("string match", p, f, hit);
          } else {
            hit = f.match(p);
            this.debug("pattern match", p, f, hit);
          }
          if (!hit)
            return false;
        }
        if (fi === fl && pi === pl) {
          return true;
        } else if (fi === fl) {
          return partial;
        } else if (pi === pl) {
          return fi === fl - 1 && file[fi] === "";
        }
        throw new Error("wtf?");
      };
      function globUnescape(s) {
        return s.replace(/\\(.)/g, "$1");
      }
      function regExpEscape(s) {
        return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
      }
    }
  });

  // node_modules/vscode-languageclient/lib/common/diagnostic.js
  var require_diagnostic2 = __commonJS({
    "node_modules/vscode-languageclient/lib/common/diagnostic.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DiagnosticFeature = exports2.DiagnosticPullMode = exports2.vsdiag = void 0;
      var minimatch = require_minimatch();
      var vscode_1 = (init_api(), __toCommonJS(api_exports));
      var vscode_languageserver_protocol_1 = require_main3();
      var uuid_1 = require_uuid2();
      var features_1 = require_features();
      function ensure(target, key) {
        if (target[key] === void 0) {
          target[key] = {};
        }
        return target[key];
      }
      var vsdiag;
      (function(vsdiag2) {
        let DocumentDiagnosticReportKind;
        (function(DocumentDiagnosticReportKind2) {
          DocumentDiagnosticReportKind2["full"] = "full";
          DocumentDiagnosticReportKind2["unChanged"] = "unChanged";
        })(DocumentDiagnosticReportKind = vsdiag2.DocumentDiagnosticReportKind || (vsdiag2.DocumentDiagnosticReportKind = {}));
      })(vsdiag = exports2.vsdiag || (exports2.vsdiag = {}));
      var DiagnosticPullMode;
      (function(DiagnosticPullMode2) {
        DiagnosticPullMode2["onType"] = "onType";
        DiagnosticPullMode2["onSave"] = "onSave";
      })(DiagnosticPullMode = exports2.DiagnosticPullMode || (exports2.DiagnosticPullMode = {}));
      var RequestStateKind;
      (function(RequestStateKind2) {
        RequestStateKind2["active"] = "open";
        RequestStateKind2["reschedule"] = "reschedule";
        RequestStateKind2["outDated"] = "drop";
      })(RequestStateKind || (RequestStateKind = {}));
      var Tabs = class {
        constructor() {
          this.open = /* @__PURE__ */ new Set();
          this._onOpen = new vscode_1.EventEmitter();
          this._onClose = new vscode_1.EventEmitter();
          Tabs.fillTabResources(this.open);
          const openTabsHandler = (event) => {
            if (event.closed.length === 0 && event.opened.length === 0) {
              return;
            }
            const oldTabs = this.open;
            const currentTabs = /* @__PURE__ */ new Set();
            Tabs.fillTabResources(currentTabs);
            const closed = /* @__PURE__ */ new Set();
            const opened = new Set(currentTabs);
            for (const tab of oldTabs.values()) {
              if (currentTabs.has(tab)) {
                opened.delete(tab);
              } else {
                closed.add(tab);
              }
            }
            this.open = currentTabs;
            if (closed.size > 0) {
              const toFire = /* @__PURE__ */ new Set();
              for (const item of closed) {
                toFire.add(vscode_1.Uri.parse(item));
              }
              this._onClose.fire(toFire);
            }
            if (opened.size > 0) {
              const toFire = /* @__PURE__ */ new Set();
              for (const item of opened) {
                toFire.add(vscode_1.Uri.parse(item));
              }
              this._onOpen.fire(toFire);
            }
          };
          if (vscode_1.window.tabGroups.onDidChangeTabs !== void 0) {
            this.disposable = vscode_1.window.tabGroups.onDidChangeTabs(openTabsHandler);
          } else {
            this.disposable = { dispose: () => {
            } };
          }
        }
        get onClose() {
          return this._onClose.event;
        }
        get onOpen() {
          return this._onOpen.event;
        }
        dispose() {
          this.disposable.dispose();
        }
        isActive(document2) {
          return document2 instanceof vscode_1.Uri ? vscode_1.window.activeTextEditor?.document.uri === document2 : vscode_1.window.activeTextEditor?.document === document2;
        }
        isVisible(document2) {
          const uri = document2 instanceof vscode_1.Uri ? document2 : document2.uri;
          return this.open.has(uri.toString());
        }
        getTabResources() {
          const result = /* @__PURE__ */ new Set();
          Tabs.fillTabResources(/* @__PURE__ */ new Set(), result);
          return result;
        }
        static fillTabResources(strings, uris) {
          const seen = strings ?? /* @__PURE__ */ new Set();
          for (const group of vscode_1.window.tabGroups.all) {
            for (const tab of group.tabs) {
              const input = tab.input;
              let uri;
              if (input instanceof vscode_1.TabInputText) {
                uri = input.uri;
              } else if (input instanceof vscode_1.TabInputTextDiff) {
                uri = input.modified;
              }
              if (uri !== void 0 && !seen.has(uri.toString())) {
                seen.add(uri.toString());
                uris !== void 0 && uris.add(uri);
              }
            }
          }
        }
      };
      var PullState;
      (function(PullState2) {
        PullState2[PullState2["document"] = 1] = "document";
        PullState2[PullState2["workspace"] = 2] = "workspace";
      })(PullState || (PullState = {}));
      var DocumentPullStateTracker = class {
        constructor() {
          this.documentPullStates = /* @__PURE__ */ new Map();
          this.workspacePullStates = /* @__PURE__ */ new Map();
        }
        track(kind, document2, arg1) {
          const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
          const [key, uri, version2] = document2 instanceof vscode_1.Uri ? [document2.toString(), document2, arg1] : [document2.uri.toString(), document2.uri, document2.version];
          let state = states.get(key);
          if (state === void 0) {
            state = { document: uri, pulledVersion: version2, resultId: void 0 };
            states.set(key, state);
          }
          return state;
        }
        update(kind, document2, arg1, arg2) {
          const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
          const [key, uri, version2, resultId] = document2 instanceof vscode_1.Uri ? [document2.toString(), document2, arg1, arg2] : [document2.uri.toString(), document2.uri, document2.version, arg1];
          let state = states.get(key);
          if (state === void 0) {
            state = { document: uri, pulledVersion: version2, resultId };
            states.set(key, state);
          } else {
            state.pulledVersion = version2;
            state.resultId = resultId;
          }
        }
        unTrack(kind, document2) {
          const key = document2 instanceof vscode_1.Uri ? document2.toString() : document2.uri.toString();
          const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
          states.delete(key);
        }
        tracks(kind, document2) {
          const key = document2 instanceof vscode_1.Uri ? document2.toString() : document2.uri.toString();
          const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
          return states.has(key);
        }
        getResultId(kind, document2) {
          const key = document2 instanceof vscode_1.Uri ? document2.toString() : document2.uri.toString();
          const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
          return states.get(key)?.resultId;
        }
        getAllResultIds() {
          const result = [];
          for (let [uri, value] of this.workspacePullStates) {
            if (this.documentPullStates.has(uri)) {
              value = this.documentPullStates.get(uri);
            }
            if (value.resultId !== void 0) {
              result.push({ uri, value: value.resultId });
            }
          }
          return result;
        }
      };
      var DiagnosticRequestor = class {
        constructor(client, tabs, options) {
          this.client = client;
          this.tabs = tabs;
          this.options = options;
          this.isDisposed = false;
          this.onDidChangeDiagnosticsEmitter = new vscode_1.EventEmitter();
          this.provider = this.createProvider();
          this.diagnostics = vscode_1.languages.createDiagnosticCollection(options.identifier);
          this.openRequests = /* @__PURE__ */ new Map();
          this.documentStates = new DocumentPullStateTracker();
          this.workspaceErrorCounter = 0;
        }
        knows(kind, document2) {
          return this.documentStates.tracks(kind, document2);
        }
        forget(kind, document2) {
          this.documentStates.unTrack(kind, document2);
        }
        pull(document2, cb) {
          if (this.isDisposed) {
            return;
          }
          const uri = document2 instanceof vscode_1.Uri ? document2 : document2.uri;
          this.pullAsync(document2).then(() => {
            if (cb) {
              cb();
            }
          }, (error) => {
            this.client.error(`Document pull failed for text document ${uri.toString()}`, error, false);
          });
        }
        async pullAsync(document2, version2) {
          if (this.isDisposed) {
            return;
          }
          const isUri = document2 instanceof vscode_1.Uri;
          const uri = isUri ? document2 : document2.uri;
          const key = uri.toString();
          version2 = isUri ? version2 : document2.version;
          const currentRequestState = this.openRequests.get(key);
          const documentState = isUri ? this.documentStates.track(PullState.document, document2, version2) : this.documentStates.track(PullState.document, document2);
          if (currentRequestState === void 0) {
            const tokenSource = new vscode_1.CancellationTokenSource();
            this.openRequests.set(key, { state: RequestStateKind.active, document: document2, version: version2, tokenSource });
            let report;
            let afterState;
            try {
              report = await this.provider.provideDiagnostics(document2, documentState.resultId, tokenSource.token) ?? { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] };
            } catch (error) {
              if (error instanceof features_1.LSPCancellationError && vscode_languageserver_protocol_1.DiagnosticServerCancellationData.is(error.data) && error.data.retriggerRequest === false) {
                afterState = { state: RequestStateKind.outDated, document: document2 };
              }
              if (afterState === void 0 && error instanceof vscode_1.CancellationError) {
                afterState = { state: RequestStateKind.reschedule, document: document2 };
              } else {
                throw error;
              }
            }
            afterState = afterState ?? this.openRequests.get(key);
            if (afterState === void 0) {
              this.client.error(`Lost request state in diagnostic pull model. Clearing diagnostics for ${key}`);
              this.diagnostics.delete(uri);
              return;
            }
            this.openRequests.delete(key);
            if (!this.tabs.isVisible(document2)) {
              this.documentStates.unTrack(PullState.document, document2);
              return;
            }
            if (afterState.state === RequestStateKind.outDated) {
              return;
            }
            if (report !== void 0) {
              if (report.kind === vsdiag.DocumentDiagnosticReportKind.full) {
                this.diagnostics.set(uri, report.items);
              }
              documentState.pulledVersion = version2;
              documentState.resultId = report.resultId;
            }
            if (afterState.state === RequestStateKind.reschedule) {
              this.pull(document2);
            }
          } else {
            if (currentRequestState.state === RequestStateKind.active) {
              currentRequestState.tokenSource.cancel();
              this.openRequests.set(key, { state: RequestStateKind.reschedule, document: currentRequestState.document });
            } else if (currentRequestState.state === RequestStateKind.outDated) {
              this.openRequests.set(key, { state: RequestStateKind.reschedule, document: currentRequestState.document });
            }
          }
        }
        forgetDocument(document2) {
          const uri = document2 instanceof vscode_1.Uri ? document2 : document2.uri;
          const key = uri.toString();
          const request = this.openRequests.get(key);
          if (this.options.workspaceDiagnostics) {
            if (request !== void 0) {
              this.openRequests.set(key, { state: RequestStateKind.reschedule, document: document2 });
            } else {
              this.pull(document2, () => {
                this.forget(PullState.document, document2);
              });
            }
          } else {
            if (request !== void 0) {
              if (request.state === RequestStateKind.active) {
                request.tokenSource.cancel();
              }
              this.openRequests.set(key, { state: RequestStateKind.outDated, document: document2 });
            }
            this.diagnostics.delete(uri);
            this.forget(PullState.document, document2);
          }
        }
        pullWorkspace() {
          if (this.isDisposed) {
            return;
          }
          this.pullWorkspaceAsync().then(() => {
            this.workspaceTimeout = (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(() => {
              this.pullWorkspace();
            }, 2e3);
          }, (error) => {
            if (!(error instanceof features_1.LSPCancellationError) && !vscode_languageserver_protocol_1.DiagnosticServerCancellationData.is(error.data)) {
              this.client.error(`Workspace diagnostic pull failed.`, error, false);
              this.workspaceErrorCounter++;
            }
            if (this.workspaceErrorCounter <= 5) {
              this.workspaceTimeout = (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(() => {
                this.pullWorkspace();
              }, 2e3);
            }
          });
        }
        async pullWorkspaceAsync() {
          if (!this.provider.provideWorkspaceDiagnostics || this.isDisposed) {
            return;
          }
          if (this.workspaceCancellation !== void 0) {
            this.workspaceCancellation.cancel();
            this.workspaceCancellation = void 0;
          }
          this.workspaceCancellation = new vscode_1.CancellationTokenSource();
          const previousResultIds = this.documentStates.getAllResultIds().map((item) => {
            return {
              uri: this.client.protocol2CodeConverter.asUri(item.uri),
              value: item.value
            };
          });
          await this.provider.provideWorkspaceDiagnostics(previousResultIds, this.workspaceCancellation.token, (chunk) => {
            if (!chunk || this.isDisposed) {
              return;
            }
            for (const item of chunk.items) {
              if (item.kind === vsdiag.DocumentDiagnosticReportKind.full) {
                if (!this.documentStates.tracks(PullState.document, item.uri)) {
                  this.diagnostics.set(item.uri, item.items);
                }
              }
              this.documentStates.update(PullState.workspace, item.uri, item.version ?? void 0, item.resultId);
            }
          });
        }
        createProvider() {
          const result = {
            onDidChangeDiagnostics: this.onDidChangeDiagnosticsEmitter.event,
            provideDiagnostics: (document2, previousResultId, token) => {
              const provideDiagnostics = (document3, previousResultId2, token2) => {
                const params = {
                  identifier: this.options.identifier,
                  textDocument: { uri: this.client.code2ProtocolConverter.asUri(document3 instanceof vscode_1.Uri ? document3 : document3.uri) },
                  previousResultId: previousResultId2
                };
                if (this.isDisposed === true || !this.client.isRunning()) {
                  return { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] };
                }
                return this.client.sendRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, params, token2).then(async (result2) => {
                  if (result2 === void 0 || result2 === null || this.isDisposed || token2.isCancellationRequested) {
                    return { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] };
                  }
                  if (result2.kind === vscode_languageserver_protocol_1.DocumentDiagnosticReportKind.Full) {
                    return { kind: vsdiag.DocumentDiagnosticReportKind.full, resultId: result2.resultId, items: await this.client.protocol2CodeConverter.asDiagnostics(result2.items, token2) };
                  } else {
                    return { kind: vsdiag.DocumentDiagnosticReportKind.unChanged, resultId: result2.resultId };
                  }
                }, (error) => {
                  return this.client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, token2, error, { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] });
                });
              };
              const middleware = this.client.middleware;
              return middleware.provideDiagnostics ? middleware.provideDiagnostics(document2, previousResultId, token, provideDiagnostics) : provideDiagnostics(document2, previousResultId, token);
            }
          };
          if (this.options.workspaceDiagnostics) {
            result.provideWorkspaceDiagnostics = (resultIds, token, resultReporter) => {
              const convertReport = async (report) => {
                if (report.kind === vscode_languageserver_protocol_1.DocumentDiagnosticReportKind.Full) {
                  return {
                    kind: vsdiag.DocumentDiagnosticReportKind.full,
                    uri: this.client.protocol2CodeConverter.asUri(report.uri),
                    resultId: report.resultId,
                    version: report.version,
                    items: await this.client.protocol2CodeConverter.asDiagnostics(report.items, token)
                  };
                } else {
                  return {
                    kind: vsdiag.DocumentDiagnosticReportKind.unChanged,
                    uri: this.client.protocol2CodeConverter.asUri(report.uri),
                    resultId: report.resultId,
                    version: report.version
                  };
                }
              };
              const convertPreviousResultIds = (resultIds2) => {
                const converted = [];
                for (const item of resultIds2) {
                  converted.push({ uri: this.client.code2ProtocolConverter.asUri(item.uri), value: item.value });
                }
                return converted;
              };
              const provideDiagnostics = (resultIds2, token2) => {
                const partialResultToken = (0, uuid_1.generateUuid)();
                const disposable = this.client.onProgress(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.partialResult, partialResultToken, async (partialResult) => {
                  if (partialResult === void 0 || partialResult === null) {
                    resultReporter(null);
                    return;
                  }
                  const converted = {
                    items: []
                  };
                  for (const item of partialResult.items) {
                    try {
                      converted.items.push(await convertReport(item));
                    } catch (error) {
                      this.client.error(`Converting workspace diagnostics failed.`, error);
                    }
                  }
                  resultReporter(converted);
                });
                const params = {
                  identifier: this.options.identifier,
                  previousResultIds: convertPreviousResultIds(resultIds2),
                  partialResultToken
                };
                if (this.isDisposed === true || !this.client.isRunning()) {
                  return { items: [] };
                }
                return this.client.sendRequest(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.type, params, token2).then(async (result2) => {
                  if (token2.isCancellationRequested) {
                    return { items: [] };
                  }
                  const converted = {
                    items: []
                  };
                  for (const item of result2.items) {
                    converted.items.push(await convertReport(item));
                  }
                  disposable.dispose();
                  resultReporter(converted);
                  return { items: [] };
                }, (error) => {
                  disposable.dispose();
                  return this.client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, token2, error, { items: [] });
                });
              };
              const middleware = this.client.middleware;
              return middleware.provideWorkspaceDiagnostics ? middleware.provideWorkspaceDiagnostics(resultIds, token, resultReporter, provideDiagnostics) : provideDiagnostics(resultIds, token, resultReporter);
            };
          }
          return result;
        }
        dispose() {
          this.isDisposed = true;
          this.workspaceCancellation?.cancel();
          this.workspaceTimeout?.dispose();
          for (const [key, request] of this.openRequests) {
            if (request.state === RequestStateKind.active) {
              request.tokenSource.cancel();
            }
            this.openRequests.set(key, { state: RequestStateKind.outDated, document: request.document });
          }
          this.diagnostics.dispose();
        }
      };
      var BackgroundScheduler = class {
        constructor(diagnosticRequestor) {
          this.diagnosticRequestor = diagnosticRequestor;
          this.documents = new vscode_languageserver_protocol_1.LinkedMap();
          this.isDisposed = false;
        }
        add(document2) {
          if (this.isDisposed === true) {
            return;
          }
          const key = document2 instanceof vscode_1.Uri ? document2.toString() : document2.uri.toString();
          if (this.documents.has(key)) {
            return;
          }
          this.documents.set(key, document2, vscode_languageserver_protocol_1.Touch.Last);
          this.trigger();
        }
        remove(document2) {
          const key = document2 instanceof vscode_1.Uri ? document2.toString() : document2.uri.toString();
          if (this.documents.has(key)) {
            this.documents.delete(key);
            this.diagnosticRequestor.pull(document2);
          }
          if (this.documents.size === 0) {
            this.stop();
          } else if (document2 === this.endDocument) {
            this.endDocument = this.documents.last;
          }
        }
        trigger() {
          if (this.isDisposed === true) {
            return;
          }
          if (this.intervalHandle !== void 0) {
            this.endDocument = this.documents.last;
            return;
          }
          this.endDocument = this.documents.last;
          this.intervalHandle = (0, vscode_languageserver_protocol_1.RAL)().timer.setInterval(() => {
            const document2 = this.documents.first;
            if (document2 !== void 0) {
              const key = document2 instanceof vscode_1.Uri ? document2.toString() : document2.uri.toString();
              this.diagnosticRequestor.pull(document2);
              this.documents.set(key, document2, vscode_languageserver_protocol_1.Touch.Last);
              if (document2 === this.endDocument) {
                this.stop();
              }
            }
          }, 200);
        }
        dispose() {
          this.isDisposed = true;
          this.stop();
          this.documents.clear();
        }
        stop() {
          this.intervalHandle?.dispose();
          this.intervalHandle = void 0;
          this.endDocument = void 0;
        }
      };
      var DiagnosticFeatureProviderImpl = class {
        constructor(client, tabs, options) {
          const diagnosticPullOptions = client.clientOptions.diagnosticPullOptions ?? { onChange: true, onSave: false };
          const documentSelector = client.protocol2CodeConverter.asDocumentSelector(options.documentSelector);
          const disposables = [];
          const matchResource = (resource) => {
            const selector = options.documentSelector;
            if (diagnosticPullOptions.match !== void 0) {
              return diagnosticPullOptions.match(selector, resource);
            }
            for (const filter of selector) {
              if (!vscode_languageserver_protocol_1.TextDocumentFilter.is(filter)) {
                continue;
              }
              if (typeof filter === "string") {
                return false;
              }
              if (filter.language !== void 0 && filter.language !== "*") {
                return false;
              }
              if (filter.scheme !== void 0 && filter.scheme !== "*" && filter.scheme !== resource.scheme) {
                return false;
              }
              if (filter.pattern !== void 0) {
                const matcher = new minimatch.Minimatch(filter.pattern, { noext: true });
                if (!matcher.makeRe()) {
                  return false;
                }
                if (!matcher.match(resource.fsPath)) {
                  return false;
                }
              }
            }
            return true;
          };
          const matches = (document2) => {
            return document2 instanceof vscode_1.Uri ? matchResource(document2) : vscode_1.languages.match(documentSelector, document2) > 0 && tabs.isVisible(document2);
          };
          const isActiveDocument = (document2) => {
            return document2 instanceof vscode_1.Uri ? this.activeTextDocument?.uri.toString() === document2.toString() : this.activeTextDocument === document2;
          };
          this.diagnosticRequestor = new DiagnosticRequestor(client, tabs, options);
          this.backgroundScheduler = new BackgroundScheduler(this.diagnosticRequestor);
          const addToBackgroundIfNeeded = (document2) => {
            if (!matches(document2) || !options.interFileDependencies || isActiveDocument(document2)) {
              return;
            }
            this.backgroundScheduler.add(document2);
          };
          this.activeTextDocument = vscode_1.window.activeTextEditor?.document;
          vscode_1.window.onDidChangeActiveTextEditor((editor) => {
            const oldActive = this.activeTextDocument;
            this.activeTextDocument = editor?.document;
            if (oldActive !== void 0) {
              addToBackgroundIfNeeded(oldActive);
            }
            if (this.activeTextDocument !== void 0) {
              this.backgroundScheduler.remove(this.activeTextDocument);
            }
          });
          const openFeature = client.getFeature(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.method);
          disposables.push(openFeature.onNotificationSent((event) => {
            const textDocument = event.original;
            if (matches(textDocument)) {
              this.diagnosticRequestor.pull(textDocument, () => {
                addToBackgroundIfNeeded(textDocument);
              });
            }
          }));
          const pulledTextDocuments = /* @__PURE__ */ new Set();
          for (const textDocument of vscode_1.workspace.textDocuments) {
            if (matches(textDocument)) {
              this.diagnosticRequestor.pull(textDocument, () => {
                addToBackgroundIfNeeded(textDocument);
              });
              pulledTextDocuments.add(textDocument.uri.toString());
            }
          }
          if (diagnosticPullOptions.onTabs === true) {
            for (const resource of tabs.getTabResources()) {
              if (!pulledTextDocuments.has(resource.toString()) && matches(resource)) {
                this.diagnosticRequestor.pull(resource, () => {
                  addToBackgroundIfNeeded(resource);
                });
              }
            }
          }
          tabs.onOpen((opened) => {
            for (const document2 of opened) {
              if (matches(document2) && !this.diagnosticRequestor.knows(PullState.document, document2)) {
                this.diagnosticRequestor.pull(document2, () => {
                  addToBackgroundIfNeeded(document2);
                });
              }
            }
          });
          if (diagnosticPullOptions.onChange === true) {
            const changeFeature = client.getFeature(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.method);
            disposables.push(changeFeature.onNotificationSent(async (event) => {
              const textDocument = event.original.document;
              if ((diagnosticPullOptions.filter === void 0 || !diagnosticPullOptions.filter(textDocument, DiagnosticPullMode.onType)) && this.diagnosticRequestor.knows(PullState.document, textDocument) && event.original.contentChanges.length > 0) {
                this.diagnosticRequestor.pull(textDocument, () => {
                  this.backgroundScheduler.trigger();
                });
              }
            }));
          }
          if (diagnosticPullOptions.onSave === true) {
            const saveFeature = client.getFeature(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.method);
            disposables.push(saveFeature.onNotificationSent((event) => {
              const textDocument = event.original;
              if ((diagnosticPullOptions.filter === void 0 || !diagnosticPullOptions.filter(textDocument, DiagnosticPullMode.onSave)) && this.diagnosticRequestor.knows(PullState.document, textDocument)) {
                this.diagnosticRequestor.pull(event.original, () => {
                  this.backgroundScheduler.trigger();
                });
              }
            }));
          }
          const closeFeature = client.getFeature(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.method);
          disposables.push(closeFeature.onNotificationSent((event) => {
            this.cleanUpDocument(event.original);
          }));
          tabs.onClose((closed) => {
            for (const document2 of closed) {
              this.cleanUpDocument(document2);
            }
          });
          this.diagnosticRequestor.onDidChangeDiagnosticsEmitter.event(() => {
            for (const textDocument of vscode_1.workspace.textDocuments) {
              if (matches(textDocument)) {
                this.diagnosticRequestor.pull(textDocument);
              }
            }
          });
          if (options.workspaceDiagnostics === true && options.identifier !== "da348dc5-c30a-4515-9d98-31ff3be38d14") {
            this.diagnosticRequestor.pullWorkspace();
          }
          this.disposable = vscode_1.Disposable.from(...disposables, this.backgroundScheduler, this.diagnosticRequestor);
        }
        get onDidChangeDiagnosticsEmitter() {
          return this.diagnosticRequestor.onDidChangeDiagnosticsEmitter;
        }
        get diagnostics() {
          return this.diagnosticRequestor.provider;
        }
        cleanUpDocument(document2) {
          if (this.diagnosticRequestor.knows(PullState.document, document2)) {
            this.diagnosticRequestor.forgetDocument(document2);
            this.backgroundScheduler.remove(document2);
          }
        }
      };
      var DiagnosticFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type);
        }
        fillClientCapabilities(capabilities) {
          let capability = ensure(ensure(capabilities, "textDocument"), "diagnostic");
          capability.dynamicRegistration = true;
          capability.relatedDocumentSupport = false;
          ensure(ensure(capabilities, "workspace"), "diagnostics").refreshSupport = true;
        }
        initialize(capabilities, documentSelector) {
          const client = this._client;
          client.onRequest(vscode_languageserver_protocol_1.DiagnosticRefreshRequest.type, async () => {
            for (const provider of this.getAllProviders()) {
              provider.onDidChangeDiagnosticsEmitter.fire();
            }
          });
          let [id2, options] = this.getRegistration(documentSelector, capabilities.diagnosticProvider);
          if (!id2 || !options) {
            return;
          }
          this.register({ id: id2, registerOptions: options });
        }
        dispose() {
          if (this.tabs !== void 0) {
            this.tabs.dispose();
            this.tabs = void 0;
          }
          super.dispose();
        }
        registerLanguageProvider(options) {
          if (this.tabs === void 0) {
            this.tabs = new Tabs();
          }
          const provider = new DiagnosticFeatureProviderImpl(this._client, this.tabs, options);
          return [provider.disposable, provider];
        }
      };
      exports2.DiagnosticFeature = DiagnosticFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/utils/async.js
  var require_async = __commonJS({
    "node_modules/vscode-languageclient/lib/common/utils/async.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.forEach = exports2.mapAsync = exports2.map = exports2.clearTestMode = exports2.setTestMode = exports2.Semaphore = exports2.Delayer = void 0;
      var vscode_languageserver_protocol_1 = require_main3();
      var Delayer = class {
        constructor(defaultDelay) {
          this.defaultDelay = defaultDelay;
          this.timeout = void 0;
          this.completionPromise = void 0;
          this.onSuccess = void 0;
          this.task = void 0;
        }
        trigger(task, delay = this.defaultDelay) {
          this.task = task;
          if (delay >= 0) {
            this.cancelTimeout();
          }
          if (!this.completionPromise) {
            this.completionPromise = new Promise((resolve2) => {
              this.onSuccess = resolve2;
            }).then(() => {
              this.completionPromise = void 0;
              this.onSuccess = void 0;
              var result = this.task();
              this.task = void 0;
              return result;
            });
          }
          if (delay >= 0 || this.timeout === void 0) {
            this.timeout = (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(() => {
              this.timeout = void 0;
              this.onSuccess(void 0);
            }, delay >= 0 ? delay : this.defaultDelay);
          }
          return this.completionPromise;
        }
        forceDelivery() {
          if (!this.completionPromise) {
            return void 0;
          }
          this.cancelTimeout();
          let result = this.task();
          this.completionPromise = void 0;
          this.onSuccess = void 0;
          this.task = void 0;
          return result;
        }
        isTriggered() {
          return this.timeout !== void 0;
        }
        cancel() {
          this.cancelTimeout();
          this.completionPromise = void 0;
        }
        cancelTimeout() {
          if (this.timeout !== void 0) {
            this.timeout.dispose();
            this.timeout = void 0;
          }
        }
      };
      exports2.Delayer = Delayer;
      var Semaphore = class {
        constructor(capacity = 1) {
          if (capacity <= 0) {
            throw new Error("Capacity must be greater than 0");
          }
          this._capacity = capacity;
          this._active = 0;
          this._waiting = [];
        }
        lock(thunk) {
          return new Promise((resolve2, reject) => {
            this._waiting.push({ thunk, resolve: resolve2, reject });
            this.runNext();
          });
        }
        get active() {
          return this._active;
        }
        runNext() {
          if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
          }
          (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => this.doRunNext());
        }
        doRunNext() {
          if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
          }
          const next = this._waiting.shift();
          this._active++;
          if (this._active > this._capacity) {
            throw new Error(`To many thunks active`);
          }
          try {
            const result = next.thunk();
            if (result instanceof Promise) {
              result.then((value) => {
                this._active--;
                next.resolve(value);
                this.runNext();
              }, (err) => {
                this._active--;
                next.reject(err);
                this.runNext();
              });
            } else {
              this._active--;
              next.resolve(result);
              this.runNext();
            }
          } catch (err) {
            this._active--;
            next.reject(err);
            this.runNext();
          }
        }
      };
      exports2.Semaphore = Semaphore;
      var $test = false;
      function setTestMode() {
        $test = true;
      }
      exports2.setTestMode = setTestMode;
      function clearTestMode() {
        $test = false;
      }
      exports2.clearTestMode = clearTestMode;
      var defaultYieldTimeout = 15;
      var Timer = class {
        constructor(yieldAfter = defaultYieldTimeout) {
          this.yieldAfter = $test === true ? Math.max(yieldAfter, 2) : Math.max(yieldAfter, defaultYieldTimeout);
          this.startTime = Date.now();
          this.counter = 0;
          this.total = 0;
          this.counterInterval = 1;
        }
        start() {
          this.counter = 0;
          this.total = 0;
          this.counterInterval = 1;
          this.startTime = Date.now();
        }
        shouldYield() {
          if (++this.counter >= this.counterInterval) {
            const timeTaken = Date.now() - this.startTime;
            const timeLeft = Math.max(0, this.yieldAfter - timeTaken);
            this.total += this.counter;
            this.counter = 0;
            if (timeTaken >= this.yieldAfter || timeLeft <= 1) {
              this.counterInterval = 1;
              this.total = 0;
              return true;
            } else {
              switch (timeTaken) {
                case 0:
                case 1:
                  this.counterInterval = this.total * 2;
                  break;
              }
            }
          }
          return false;
        }
      };
      async function map(items, func, token, options) {
        if (items.length === 0) {
          return [];
        }
        const result = new Array(items.length);
        const timer = new Timer(options?.yieldAfter);
        function convertBatch(start) {
          timer.start();
          for (let i = start; i < items.length; i++) {
            result[i] = func(items[i]);
            if (timer.shouldYield()) {
              options?.yieldCallback && options.yieldCallback();
              return i + 1;
            }
          }
          return -1;
        }
        let index = convertBatch(0);
        while (index !== -1) {
          if (token !== void 0 && token.isCancellationRequested) {
            break;
          }
          index = await new Promise((resolve2) => {
            (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {
              resolve2(convertBatch(index));
            });
          });
        }
        return result;
      }
      exports2.map = map;
      async function mapAsync(items, func, token, options) {
        if (items.length === 0) {
          return [];
        }
        const result = new Array(items.length);
        const timer = new Timer(options?.yieldAfter);
        async function convertBatch(start) {
          timer.start();
          for (let i = start; i < items.length; i++) {
            result[i] = await func(items[i], token);
            if (timer.shouldYield()) {
              options?.yieldCallback && options.yieldCallback();
              return i + 1;
            }
          }
          return -1;
        }
        let index = await convertBatch(0);
        while (index !== -1) {
          if (token !== void 0 && token.isCancellationRequested) {
            break;
          }
          index = await new Promise((resolve2) => {
            (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {
              resolve2(convertBatch(index));
            });
          });
        }
        return result;
      }
      exports2.mapAsync = mapAsync;
      async function forEach(items, func, token, options) {
        if (items.length === 0) {
          return;
        }
        const timer = new Timer(options?.yieldAfter);
        function runBatch(start) {
          timer.start();
          for (let i = start; i < items.length; i++) {
            func(items[i]);
            if (timer.shouldYield()) {
              options?.yieldCallback && options.yieldCallback();
              return i + 1;
            }
          }
          return -1;
        }
        let index = runBatch(0);
        while (index !== -1) {
          if (token !== void 0 && token.isCancellationRequested) {
            break;
          }
          index = await new Promise((resolve2) => {
            (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {
              resolve2(runBatch(index));
            });
          });
        }
      }
      exports2.forEach = forEach;
    }
  });

  // node_modules/vscode-languageclient/lib/common/protocolCompletionItem.js
  var require_protocolCompletionItem = __commonJS({
    "node_modules/vscode-languageclient/lib/common/protocolCompletionItem.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var code = (init_api(), __toCommonJS(api_exports));
      var ProtocolCompletionItem = class extends code.CompletionItem {
        constructor(label) {
          super(label);
        }
      };
      exports2.default = ProtocolCompletionItem;
    }
  });

  // node_modules/vscode-languageclient/lib/common/protocolCodeLens.js
  var require_protocolCodeLens = __commonJS({
    "node_modules/vscode-languageclient/lib/common/protocolCodeLens.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var code = (init_api(), __toCommonJS(api_exports));
      var ProtocolCodeLens = class extends code.CodeLens {
        constructor(range) {
          super(range);
        }
      };
      exports2.default = ProtocolCodeLens;
    }
  });

  // node_modules/vscode-languageclient/lib/common/protocolDocumentLink.js
  var require_protocolDocumentLink = __commonJS({
    "node_modules/vscode-languageclient/lib/common/protocolDocumentLink.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var code = (init_api(), __toCommonJS(api_exports));
      var ProtocolDocumentLink = class extends code.DocumentLink {
        constructor(range, target) {
          super(range, target);
        }
      };
      exports2.default = ProtocolDocumentLink;
    }
  });

  // node_modules/vscode-languageclient/lib/common/protocolCodeAction.js
  var require_protocolCodeAction = __commonJS({
    "node_modules/vscode-languageclient/lib/common/protocolCodeAction.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var vscode = (init_api(), __toCommonJS(api_exports));
      var ProtocolCodeAction = class extends vscode.CodeAction {
        constructor(title, data) {
          super(title);
          this.data = data;
        }
      };
      exports2.default = ProtocolCodeAction;
    }
  });

  // node_modules/vscode-languageclient/lib/common/protocolDiagnostic.js
  var require_protocolDiagnostic = __commonJS({
    "node_modules/vscode-languageclient/lib/common/protocolDiagnostic.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ProtocolDiagnostic = exports2.DiagnosticCode = void 0;
      var vscode = (init_api(), __toCommonJS(api_exports));
      var Is = require_is4();
      var DiagnosticCode;
      (function(DiagnosticCode2) {
        function is(value) {
          const candidate = value;
          return candidate !== void 0 && candidate !== null && (Is.number(candidate.value) || Is.string(candidate.value)) && Is.string(candidate.target);
        }
        DiagnosticCode2.is = is;
      })(DiagnosticCode = exports2.DiagnosticCode || (exports2.DiagnosticCode = {}));
      var ProtocolDiagnostic = class extends vscode.Diagnostic {
        constructor(range, message, severity, data) {
          super(range, message, severity);
          this.data = data;
          this.hasDiagnosticCode = false;
        }
      };
      exports2.ProtocolDiagnostic = ProtocolDiagnostic;
    }
  });

  // node_modules/vscode-languageclient/lib/common/protocolCallHierarchyItem.js
  var require_protocolCallHierarchyItem = __commonJS({
    "node_modules/vscode-languageclient/lib/common/protocolCallHierarchyItem.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var code = (init_api(), __toCommonJS(api_exports));
      var ProtocolCallHierarchyItem = class extends code.CallHierarchyItem {
        constructor(kind, name, detail, uri, range, selectionRange, data) {
          super(kind, name, detail, uri, range, selectionRange);
          if (data !== void 0) {
            this.data = data;
          }
        }
      };
      exports2.default = ProtocolCallHierarchyItem;
    }
  });

  // node_modules/vscode-languageclient/lib/common/protocolTypeHierarchyItem.js
  var require_protocolTypeHierarchyItem = __commonJS({
    "node_modules/vscode-languageclient/lib/common/protocolTypeHierarchyItem.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var code = (init_api(), __toCommonJS(api_exports));
      var ProtocolTypeHierarchyItem = class extends code.TypeHierarchyItem {
        constructor(kind, name, detail, uri, range, selectionRange, data) {
          super(kind, name, detail, uri, range, selectionRange);
          if (data !== void 0) {
            this.data = data;
          }
        }
      };
      exports2.default = ProtocolTypeHierarchyItem;
    }
  });

  // node_modules/vscode-languageclient/lib/common/protocolWorkspaceSymbol.js
  var require_protocolWorkspaceSymbol = __commonJS({
    "node_modules/vscode-languageclient/lib/common/protocolWorkspaceSymbol.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var code = (init_api(), __toCommonJS(api_exports));
      var WorkspaceSymbol = class extends code.SymbolInformation {
        constructor(name, kind, containerName, locationOrUri, data) {
          const hasRange = !(locationOrUri instanceof code.Uri);
          super(name, kind, containerName, hasRange ? locationOrUri : new code.Location(locationOrUri, new code.Range(0, 0, 0, 0)));
          this.hasRange = hasRange;
          if (data !== void 0) {
            this.data = data;
          }
        }
      };
      exports2.default = WorkspaceSymbol;
    }
  });

  // node_modules/vscode-languageclient/lib/common/protocolInlayHint.js
  var require_protocolInlayHint = __commonJS({
    "node_modules/vscode-languageclient/lib/common/protocolInlayHint.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var code = (init_api(), __toCommonJS(api_exports));
      var ProtocolInlayHint = class extends code.InlayHint {
        constructor(position, label, kind) {
          super(position, label, kind);
        }
      };
      exports2.default = ProtocolInlayHint;
    }
  });

  // node_modules/vscode-languageclient/lib/common/codeConverter.js
  var require_codeConverter = __commonJS({
    "node_modules/vscode-languageclient/lib/common/codeConverter.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createConverter = void 0;
      var code = (init_api(), __toCommonJS(api_exports));
      var proto = require_main3();
      var Is = require_is4();
      var async = require_async();
      var protocolCompletionItem_1 = require_protocolCompletionItem();
      var protocolCodeLens_1 = require_protocolCodeLens();
      var protocolDocumentLink_1 = require_protocolDocumentLink();
      var protocolCodeAction_1 = require_protocolCodeAction();
      var protocolDiagnostic_1 = require_protocolDiagnostic();
      var protocolCallHierarchyItem_1 = require_protocolCallHierarchyItem();
      var protocolTypeHierarchyItem_1 = require_protocolTypeHierarchyItem();
      var protocolWorkspaceSymbol_1 = require_protocolWorkspaceSymbol();
      var protocolInlayHint_1 = require_protocolInlayHint();
      var InsertReplaceRange;
      (function(InsertReplaceRange2) {
        function is(value) {
          const candidate = value;
          return candidate && !!candidate.inserting && !!candidate.replacing;
        }
        InsertReplaceRange2.is = is;
      })(InsertReplaceRange || (InsertReplaceRange = {}));
      function createConverter(uriConverter) {
        const nullConverter = (value) => value.toString();
        const _uriConverter = uriConverter || nullConverter;
        function asUri(value) {
          return _uriConverter(value);
        }
        function asTextDocumentIdentifier(textDocument) {
          return {
            uri: _uriConverter(textDocument.uri)
          };
        }
        function asTextDocumentItem(textDocument) {
          return {
            uri: _uriConverter(textDocument.uri),
            languageId: textDocument.languageId,
            version: textDocument.version,
            text: textDocument.getText()
          };
        }
        function asVersionedTextDocumentIdentifier(textDocument) {
          return {
            uri: _uriConverter(textDocument.uri),
            version: textDocument.version
          };
        }
        function asOpenTextDocumentParams(textDocument) {
          return {
            textDocument: asTextDocumentItem(textDocument)
          };
        }
        function isTextDocumentChangeEvent(value) {
          let candidate = value;
          return !!candidate.document && !!candidate.contentChanges;
        }
        function isTextDocument(value) {
          let candidate = value;
          return !!candidate.uri && !!candidate.version;
        }
        function asChangeTextDocumentParams(arg) {
          if (isTextDocument(arg)) {
            let result = {
              textDocument: {
                uri: _uriConverter(arg.uri),
                version: arg.version
              },
              contentChanges: [{ text: arg.getText() }]
            };
            return result;
          } else if (isTextDocumentChangeEvent(arg)) {
            let document2 = arg.document;
            let result = {
              textDocument: {
                uri: _uriConverter(document2.uri),
                version: document2.version
              },
              contentChanges: arg.contentChanges.map((change) => {
                let range = change.range;
                return {
                  range: {
                    start: { line: range.start.line, character: range.start.character },
                    end: { line: range.end.line, character: range.end.character }
                  },
                  rangeLength: change.rangeLength,
                  text: change.text
                };
              })
            };
            return result;
          } else {
            throw Error("Unsupported text document change parameter");
          }
        }
        function asCloseTextDocumentParams(textDocument) {
          return {
            textDocument: asTextDocumentIdentifier(textDocument)
          };
        }
        function asSaveTextDocumentParams(textDocument, includeContent = false) {
          let result = {
            textDocument: asTextDocumentIdentifier(textDocument)
          };
          if (includeContent) {
            result.text = textDocument.getText();
          }
          return result;
        }
        function asTextDocumentSaveReason(reason) {
          switch (reason) {
            case code.TextDocumentSaveReason.Manual:
              return proto.TextDocumentSaveReason.Manual;
            case code.TextDocumentSaveReason.AfterDelay:
              return proto.TextDocumentSaveReason.AfterDelay;
            case code.TextDocumentSaveReason.FocusOut:
              return proto.TextDocumentSaveReason.FocusOut;
          }
          return proto.TextDocumentSaveReason.Manual;
        }
        function asWillSaveTextDocumentParams(event) {
          return {
            textDocument: asTextDocumentIdentifier(event.document),
            reason: asTextDocumentSaveReason(event.reason)
          };
        }
        function asDidCreateFilesParams(event) {
          return {
            files: event.files.map((fileUri) => ({
              uri: _uriConverter(fileUri)
            }))
          };
        }
        function asDidRenameFilesParams(event) {
          return {
            files: event.files.map((file) => ({
              oldUri: _uriConverter(file.oldUri),
              newUri: _uriConverter(file.newUri)
            }))
          };
        }
        function asDidDeleteFilesParams(event) {
          return {
            files: event.files.map((fileUri) => ({
              uri: _uriConverter(fileUri)
            }))
          };
        }
        function asWillCreateFilesParams(event) {
          return {
            files: event.files.map((fileUri) => ({
              uri: _uriConverter(fileUri)
            }))
          };
        }
        function asWillRenameFilesParams(event) {
          return {
            files: event.files.map((file) => ({
              oldUri: _uriConverter(file.oldUri),
              newUri: _uriConverter(file.newUri)
            }))
          };
        }
        function asWillDeleteFilesParams(event) {
          return {
            files: event.files.map((fileUri) => ({
              uri: _uriConverter(fileUri)
            }))
          };
        }
        function asTextDocumentPositionParams(textDocument, position) {
          return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position)
          };
        }
        function asCompletionTriggerKind(triggerKind) {
          switch (triggerKind) {
            case code.CompletionTriggerKind.TriggerCharacter:
              return proto.CompletionTriggerKind.TriggerCharacter;
            case code.CompletionTriggerKind.TriggerForIncompleteCompletions:
              return proto.CompletionTriggerKind.TriggerForIncompleteCompletions;
            default:
              return proto.CompletionTriggerKind.Invoked;
          }
        }
        function asCompletionParams(textDocument, position, context) {
          return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position),
            context: {
              triggerKind: asCompletionTriggerKind(context.triggerKind),
              triggerCharacter: context.triggerCharacter
            }
          };
        }
        function asSignatureHelpTriggerKind(triggerKind) {
          switch (triggerKind) {
            case code.SignatureHelpTriggerKind.Invoke:
              return proto.SignatureHelpTriggerKind.Invoked;
            case code.SignatureHelpTriggerKind.TriggerCharacter:
              return proto.SignatureHelpTriggerKind.TriggerCharacter;
            case code.SignatureHelpTriggerKind.ContentChange:
              return proto.SignatureHelpTriggerKind.ContentChange;
          }
        }
        function asParameterInformation(value) {
          return {
            label: value.label
          };
        }
        function asParameterInformations(values) {
          return values.map(asParameterInformation);
        }
        function asSignatureInformation(value) {
          return {
            label: value.label,
            parameters: asParameterInformations(value.parameters)
          };
        }
        function asSignatureInformations(values) {
          return values.map(asSignatureInformation);
        }
        function asSignatureHelp(value) {
          if (value === void 0) {
            return value;
          }
          return {
            signatures: asSignatureInformations(value.signatures),
            activeSignature: value.activeSignature,
            activeParameter: value.activeParameter
          };
        }
        function asSignatureHelpParams(textDocument, position, context) {
          return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position),
            context: {
              isRetrigger: context.isRetrigger,
              triggerCharacter: context.triggerCharacter,
              triggerKind: asSignatureHelpTriggerKind(context.triggerKind),
              activeSignatureHelp: asSignatureHelp(context.activeSignatureHelp)
            }
          };
        }
        function asWorkerPosition(position) {
          return { line: position.line, character: position.character };
        }
        function asPosition(value) {
          if (value === void 0 || value === null) {
            return value;
          }
          return { line: value.line > proto.uinteger.MAX_VALUE ? proto.uinteger.MAX_VALUE : value.line, character: value.character > proto.uinteger.MAX_VALUE ? proto.uinteger.MAX_VALUE : value.character };
        }
        function asPositions(value, token) {
          return async.map(value, asPosition, token);
        }
        function asRange(value) {
          if (value === void 0 || value === null) {
            return value;
          }
          return { start: asPosition(value.start), end: asPosition(value.end) };
        }
        function asLocation(value) {
          if (value === void 0 || value === null) {
            return value;
          }
          return proto.Location.create(asUri(value.uri), asRange(value.range));
        }
        function asDiagnosticSeverity(value) {
          switch (value) {
            case code.DiagnosticSeverity.Error:
              return proto.DiagnosticSeverity.Error;
            case code.DiagnosticSeverity.Warning:
              return proto.DiagnosticSeverity.Warning;
            case code.DiagnosticSeverity.Information:
              return proto.DiagnosticSeverity.Information;
            case code.DiagnosticSeverity.Hint:
              return proto.DiagnosticSeverity.Hint;
          }
        }
        function asDiagnosticTags(tags) {
          if (!tags) {
            return void 0;
          }
          let result = [];
          for (let tag of tags) {
            let converted = asDiagnosticTag(tag);
            if (converted !== void 0) {
              result.push(converted);
            }
          }
          return result.length > 0 ? result : void 0;
        }
        function asDiagnosticTag(tag) {
          switch (tag) {
            case code.DiagnosticTag.Unnecessary:
              return proto.DiagnosticTag.Unnecessary;
            case code.DiagnosticTag.Deprecated:
              return proto.DiagnosticTag.Deprecated;
            default:
              return void 0;
          }
        }
        function asRelatedInformation(item) {
          return {
            message: item.message,
            location: asLocation(item.location)
          };
        }
        function asRelatedInformations(items) {
          return items.map(asRelatedInformation);
        }
        function asDiagnosticCode(value) {
          if (value === void 0 || value === null) {
            return void 0;
          }
          if (Is.number(value) || Is.string(value)) {
            return value;
          }
          return { value: value.value, target: asUri(value.target) };
        }
        function asDiagnostic(item) {
          const result = proto.Diagnostic.create(asRange(item.range), item.message);
          const protocolDiagnostic = item instanceof protocolDiagnostic_1.ProtocolDiagnostic ? item : void 0;
          if (protocolDiagnostic !== void 0 && protocolDiagnostic.data !== void 0) {
            result.data = protocolDiagnostic.data;
          }
          const code2 = asDiagnosticCode(item.code);
          if (protocolDiagnostic_1.DiagnosticCode.is(code2)) {
            if (protocolDiagnostic !== void 0 && protocolDiagnostic.hasDiagnosticCode) {
              result.code = code2;
            } else {
              result.code = code2.value;
              result.codeDescription = { href: code2.target };
            }
          } else {
            result.code = code2;
          }
          if (Is.number(item.severity)) {
            result.severity = asDiagnosticSeverity(item.severity);
          }
          if (Array.isArray(item.tags)) {
            result.tags = asDiagnosticTags(item.tags);
          }
          if (item.relatedInformation) {
            result.relatedInformation = asRelatedInformations(item.relatedInformation);
          }
          if (item.source) {
            result.source = item.source;
          }
          return result;
        }
        function asDiagnostics(items, token) {
          if (items === void 0 || items === null) {
            return items;
          }
          return async.map(items, asDiagnostic, token);
        }
        function asDocumentation(format2, documentation) {
          switch (format2) {
            case "$string":
              return documentation;
            case proto.MarkupKind.PlainText:
              return { kind: format2, value: documentation };
            case proto.MarkupKind.Markdown:
              return { kind: format2, value: documentation.value };
            default:
              return `Unsupported Markup content received. Kind is: ${format2}`;
          }
        }
        function asCompletionItemTag(tag) {
          switch (tag) {
            case code.CompletionItemTag.Deprecated:
              return proto.CompletionItemTag.Deprecated;
          }
          return void 0;
        }
        function asCompletionItemTags(tags) {
          if (tags === void 0) {
            return tags;
          }
          const result = [];
          for (let tag of tags) {
            const converted = asCompletionItemTag(tag);
            if (converted !== void 0) {
              result.push(converted);
            }
          }
          return result;
        }
        function asCompletionItemKind(value, original) {
          if (original !== void 0) {
            return original;
          }
          return value + 1;
        }
        function asCompletionItem(item, labelDetailsSupport = false) {
          let label;
          let labelDetails;
          if (Is.string(item.label)) {
            label = item.label;
          } else {
            label = item.label.label;
            if (labelDetailsSupport && (item.label.detail !== void 0 || item.label.description !== void 0)) {
              labelDetails = { detail: item.label.detail, description: item.label.description };
            }
          }
          let result = { label };
          if (labelDetails !== void 0) {
            result.labelDetails = labelDetails;
          }
          let protocolItem = item instanceof protocolCompletionItem_1.default ? item : void 0;
          if (item.detail) {
            result.detail = item.detail;
          }
          if (item.documentation) {
            if (!protocolItem || protocolItem.documentationFormat === "$string") {
              result.documentation = item.documentation;
            } else {
              result.documentation = asDocumentation(protocolItem.documentationFormat, item.documentation);
            }
          }
          if (item.filterText) {
            result.filterText = item.filterText;
          }
          fillPrimaryInsertText(result, item);
          if (Is.number(item.kind)) {
            result.kind = asCompletionItemKind(item.kind, protocolItem && protocolItem.originalItemKind);
          }
          if (item.sortText) {
            result.sortText = item.sortText;
          }
          if (item.additionalTextEdits) {
            result.additionalTextEdits = asTextEdits(item.additionalTextEdits);
          }
          if (item.commitCharacters) {
            result.commitCharacters = item.commitCharacters.slice();
          }
          if (item.command) {
            result.command = asCommand(item.command);
          }
          if (item.preselect === true || item.preselect === false) {
            result.preselect = item.preselect;
          }
          const tags = asCompletionItemTags(item.tags);
          if (protocolItem) {
            if (protocolItem.data !== void 0) {
              result.data = protocolItem.data;
            }
            if (protocolItem.deprecated === true || protocolItem.deprecated === false) {
              if (protocolItem.deprecated === true && tags !== void 0 && tags.length > 0) {
                const index = tags.indexOf(code.CompletionItemTag.Deprecated);
                if (index !== -1) {
                  tags.splice(index, 1);
                }
              }
              result.deprecated = protocolItem.deprecated;
            }
            if (protocolItem.insertTextMode !== void 0) {
              result.insertTextMode = protocolItem.insertTextMode;
            }
          }
          if (tags !== void 0 && tags.length > 0) {
            result.tags = tags;
          }
          if (result.insertTextMode === void 0 && item.keepWhitespace === true) {
            result.insertTextMode = proto.InsertTextMode.adjustIndentation;
          }
          return result;
        }
        function fillPrimaryInsertText(target, source) {
          let format2 = proto.InsertTextFormat.PlainText;
          let text = void 0;
          let range = void 0;
          if (source.textEdit) {
            text = source.textEdit.newText;
            range = source.textEdit.range;
          } else if (source.insertText instanceof code.SnippetString) {
            format2 = proto.InsertTextFormat.Snippet;
            text = source.insertText.value;
          } else {
            text = source.insertText;
          }
          if (source.range) {
            range = source.range;
          }
          target.insertTextFormat = format2;
          if (source.fromEdit && text !== void 0 && range !== void 0) {
            target.textEdit = asCompletionTextEdit(text, range);
          } else {
            target.insertText = text;
          }
        }
        function asCompletionTextEdit(newText, range) {
          if (InsertReplaceRange.is(range)) {
            return proto.InsertReplaceEdit.create(newText, asRange(range.inserting), asRange(range.replacing));
          } else {
            return { newText, range: asRange(range) };
          }
        }
        function asTextEdit(edit) {
          return { range: asRange(edit.range), newText: edit.newText };
        }
        function asTextEdits(edits) {
          if (edits === void 0 || edits === null) {
            return edits;
          }
          return edits.map(asTextEdit);
        }
        function asSymbolKind(item) {
          if (item <= code.SymbolKind.TypeParameter) {
            return item + 1;
          }
          return proto.SymbolKind.Property;
        }
        function asSymbolTag(item) {
          return item;
        }
        function asSymbolTags(items) {
          return items.map(asSymbolTag);
        }
        function asReferenceParams(textDocument, position, options) {
          return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position),
            context: { includeDeclaration: options.includeDeclaration }
          };
        }
        async function asCodeAction(item, token) {
          let result = proto.CodeAction.create(item.title);
          if (item instanceof protocolCodeAction_1.default && item.data !== void 0) {
            result.data = item.data;
          }
          if (item.kind !== void 0) {
            result.kind = asCodeActionKind(item.kind);
          }
          if (item.diagnostics !== void 0) {
            result.diagnostics = await asDiagnostics(item.diagnostics, token);
          }
          if (item.edit !== void 0) {
            throw new Error(`VS Code code actions can only be converted to a protocol code action without an edit.`);
          }
          if (item.command !== void 0) {
            result.command = asCommand(item.command);
          }
          if (item.isPreferred !== void 0) {
            result.isPreferred = item.isPreferred;
          }
          if (item.disabled !== void 0) {
            result.disabled = { reason: item.disabled.reason };
          }
          return result;
        }
        async function asCodeActionContext(context, token) {
          if (context === void 0 || context === null) {
            return context;
          }
          let only;
          if (context.only && Is.string(context.only.value)) {
            only = [context.only.value];
          }
          return proto.CodeActionContext.create(await asDiagnostics(context.diagnostics, token), only, asCodeActionTriggerKind(context.triggerKind));
        }
        function asCodeActionTriggerKind(kind) {
          switch (kind) {
            case code.CodeActionTriggerKind.Invoke:
              return proto.CodeActionTriggerKind.Invoked;
            case code.CodeActionTriggerKind.Automatic:
              return proto.CodeActionTriggerKind.Automatic;
            default:
              return void 0;
          }
        }
        function asCodeActionKind(item) {
          if (item === void 0 || item === null) {
            return void 0;
          }
          return item.value;
        }
        function asInlineValueContext(context) {
          if (context === void 0 || context === null) {
            return context;
          }
          return proto.InlineValueContext.create(context.frameId, asRange(context.stoppedLocation));
        }
        function asCommand(item) {
          let result = proto.Command.create(item.title, item.command);
          if (item.arguments) {
            result.arguments = item.arguments;
          }
          return result;
        }
        function asCodeLens(item) {
          let result = proto.CodeLens.create(asRange(item.range));
          if (item.command) {
            result.command = asCommand(item.command);
          }
          if (item instanceof protocolCodeLens_1.default) {
            if (item.data) {
              result.data = item.data;
            }
          }
          return result;
        }
        function asFormattingOptions(options, fileOptions) {
          const result = { tabSize: options.tabSize, insertSpaces: options.insertSpaces };
          if (fileOptions.trimTrailingWhitespace) {
            result.trimTrailingWhitespace = true;
          }
          if (fileOptions.trimFinalNewlines) {
            result.trimFinalNewlines = true;
          }
          if (fileOptions.insertFinalNewline) {
            result.insertFinalNewline = true;
          }
          return result;
        }
        function asDocumentSymbolParams(textDocument) {
          return {
            textDocument: asTextDocumentIdentifier(textDocument)
          };
        }
        function asCodeLensParams(textDocument) {
          return {
            textDocument: asTextDocumentIdentifier(textDocument)
          };
        }
        function asDocumentLink(item) {
          let result = proto.DocumentLink.create(asRange(item.range));
          if (item.target) {
            result.target = asUri(item.target);
          }
          if (item.tooltip !== void 0) {
            result.tooltip = item.tooltip;
          }
          let protocolItem = item instanceof protocolDocumentLink_1.default ? item : void 0;
          if (protocolItem && protocolItem.data) {
            result.data = protocolItem.data;
          }
          return result;
        }
        function asDocumentLinkParams(textDocument) {
          return {
            textDocument: asTextDocumentIdentifier(textDocument)
          };
        }
        function asCallHierarchyItem(value) {
          const result = {
            name: value.name,
            kind: asSymbolKind(value.kind),
            uri: asUri(value.uri),
            range: asRange(value.range),
            selectionRange: asRange(value.selectionRange)
          };
          if (value.detail !== void 0 && value.detail.length > 0) {
            result.detail = value.detail;
          }
          if (value.tags !== void 0) {
            result.tags = asSymbolTags(value.tags);
          }
          if (value instanceof protocolCallHierarchyItem_1.default && value.data !== void 0) {
            result.data = value.data;
          }
          return result;
        }
        function asTypeHierarchyItem(value) {
          const result = {
            name: value.name,
            kind: asSymbolKind(value.kind),
            uri: asUri(value.uri),
            range: asRange(value.range),
            selectionRange: asRange(value.selectionRange)
          };
          if (value.detail !== void 0 && value.detail.length > 0) {
            result.detail = value.detail;
          }
          if (value.tags !== void 0) {
            result.tags = asSymbolTags(value.tags);
          }
          if (value instanceof protocolTypeHierarchyItem_1.default && value.data !== void 0) {
            result.data = value.data;
          }
          return result;
        }
        function asWorkspaceSymbol(item) {
          const result = item instanceof protocolWorkspaceSymbol_1.default ? { name: item.name, kind: asSymbolKind(item.kind), location: item.hasRange ? asLocation(item.location) : { uri: _uriConverter(item.location.uri) }, data: item.data } : { name: item.name, kind: asSymbolKind(item.kind), location: asLocation(item.location) };
          if (item.tags !== void 0) {
            result.tags = asSymbolTags(item.tags);
          }
          if (item.containerName !== "") {
            result.containerName = item.containerName;
          }
          return result;
        }
        function asInlayHint(item) {
          const label = typeof item.label === "string" ? item.label : item.label.map(asInlayHintLabelPart);
          const result = proto.InlayHint.create(asPosition(item.position), label);
          if (item.kind !== void 0) {
            result.kind = item.kind;
          }
          if (item.textEdits !== void 0) {
            result.textEdits = asTextEdits(item.textEdits);
          }
          if (item.tooltip !== void 0) {
            result.tooltip = asTooltip(item.tooltip);
          }
          if (item.paddingLeft !== void 0) {
            result.paddingLeft = item.paddingLeft;
          }
          if (item.paddingRight !== void 0) {
            result.paddingRight = item.paddingRight;
          }
          if (item instanceof protocolInlayHint_1.default && item.data !== void 0) {
            result.data = item.data;
          }
          return result;
        }
        function asInlayHintLabelPart(item) {
          const result = proto.InlayHintLabelPart.create(item.value);
          if (item.location !== void 0) {
            result.location = asLocation(item.location);
          }
          if (item.command !== void 0) {
            result.command = asCommand(item.command);
          }
          if (item.tooltip !== void 0) {
            result.tooltip = asTooltip(item.tooltip);
          }
          return result;
        }
        function asTooltip(value) {
          if (typeof value === "string") {
            return value;
          }
          const result = {
            kind: proto.MarkupKind.Markdown,
            value: value.value
          };
          return result;
        }
        return {
          asUri,
          asTextDocumentIdentifier,
          asTextDocumentItem,
          asVersionedTextDocumentIdentifier,
          asOpenTextDocumentParams,
          asChangeTextDocumentParams,
          asCloseTextDocumentParams,
          asSaveTextDocumentParams,
          asWillSaveTextDocumentParams,
          asDidCreateFilesParams,
          asDidRenameFilesParams,
          asDidDeleteFilesParams,
          asWillCreateFilesParams,
          asWillRenameFilesParams,
          asWillDeleteFilesParams,
          asTextDocumentPositionParams,
          asCompletionParams,
          asSignatureHelpParams,
          asWorkerPosition,
          asRange,
          asPosition,
          asPositions,
          asLocation,
          asDiagnosticSeverity,
          asDiagnosticTag,
          asDiagnostic,
          asDiagnostics,
          asCompletionItem,
          asTextEdit,
          asSymbolKind,
          asSymbolTag,
          asSymbolTags,
          asReferenceParams,
          asCodeAction,
          asCodeActionContext,
          asInlineValueContext,
          asCommand,
          asCodeLens,
          asFormattingOptions,
          asDocumentSymbolParams,
          asCodeLensParams,
          asDocumentLink,
          asDocumentLinkParams,
          asCallHierarchyItem,
          asTypeHierarchyItem,
          asInlayHint,
          asWorkspaceSymbol
        };
      }
      exports2.createConverter = createConverter;
    }
  });

  // node_modules/vscode-languageclient/lib/common/protocolConverter.js
  var require_protocolConverter = __commonJS({
    "node_modules/vscode-languageclient/lib/common/protocolConverter.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createConverter = void 0;
      var code = (init_api(), __toCommonJS(api_exports));
      var ls = require_main3();
      var Is = require_is4();
      var async = require_async();
      var protocolCompletionItem_1 = require_protocolCompletionItem();
      var protocolCodeLens_1 = require_protocolCodeLens();
      var protocolDocumentLink_1 = require_protocolDocumentLink();
      var protocolCodeAction_1 = require_protocolCodeAction();
      var protocolDiagnostic_1 = require_protocolDiagnostic();
      var protocolCallHierarchyItem_1 = require_protocolCallHierarchyItem();
      var protocolTypeHierarchyItem_1 = require_protocolTypeHierarchyItem();
      var protocolWorkspaceSymbol_1 = require_protocolWorkspaceSymbol();
      var protocolInlayHint_1 = require_protocolInlayHint();
      var vscode_languageserver_protocol_1 = require_main3();
      var CodeBlock;
      (function(CodeBlock2) {
        function is(value) {
          let candidate = value;
          return candidate && Is.string(candidate.language) && Is.string(candidate.value);
        }
        CodeBlock2.is = is;
      })(CodeBlock || (CodeBlock = {}));
      function createConverter(uriConverter, trustMarkdown, supportHtml) {
        const nullConverter = (value) => code.Uri.parse(value);
        const _uriConverter = uriConverter || nullConverter;
        function asUri(value) {
          return _uriConverter(value);
        }
        function asDocumentSelector(selector) {
          const result = [];
          for (const filter of selector) {
            if (typeof filter === "string") {
              result.push(filter);
            } else if (vscode_languageserver_protocol_1.NotebookCellTextDocumentFilter.is(filter)) {
              if (typeof filter.notebook === "string") {
                result.push({ notebookType: filter.notebook, language: filter.language });
              } else {
                const notebookType = filter.notebook.notebookType ?? "*";
                result.push({ notebookType, scheme: filter.notebook.scheme, pattern: filter.notebook.pattern, language: filter.language });
              }
            } else if (vscode_languageserver_protocol_1.TextDocumentFilter.is(filter)) {
              result.push({ language: filter.language, scheme: filter.scheme, pattern: filter.pattern });
            }
          }
          return result;
        }
        async function asDiagnostics(diagnostics, token) {
          return async.map(diagnostics, asDiagnostic, token);
        }
        function asDiagnosticsSync(diagnostics) {
          const result = new Array(diagnostics.length);
          for (let i = 0; i < diagnostics.length; i++) {
            result[i] = asDiagnostic(diagnostics[i]);
          }
          return result;
        }
        function asDiagnostic(diagnostic) {
          let result = new protocolDiagnostic_1.ProtocolDiagnostic(asRange(diagnostic.range), diagnostic.message, asDiagnosticSeverity(diagnostic.severity), diagnostic.data);
          if (diagnostic.code !== void 0) {
            if (typeof diagnostic.code === "string" || typeof diagnostic.code === "number") {
              if (ls.CodeDescription.is(diagnostic.codeDescription)) {
                result.code = {
                  value: diagnostic.code,
                  target: asUri(diagnostic.codeDescription.href)
                };
              } else {
                result.code = diagnostic.code;
              }
            } else if (protocolDiagnostic_1.DiagnosticCode.is(diagnostic.code)) {
              result.hasDiagnosticCode = true;
              const diagnosticCode = diagnostic.code;
              result.code = {
                value: diagnosticCode.value,
                target: asUri(diagnosticCode.target)
              };
            }
          }
          if (diagnostic.source) {
            result.source = diagnostic.source;
          }
          if (diagnostic.relatedInformation) {
            result.relatedInformation = asRelatedInformation(diagnostic.relatedInformation);
          }
          if (Array.isArray(diagnostic.tags)) {
            result.tags = asDiagnosticTags(diagnostic.tags);
          }
          return result;
        }
        function asRelatedInformation(relatedInformation) {
          const result = new Array(relatedInformation.length);
          for (let i = 0; i < relatedInformation.length; i++) {
            const info = relatedInformation[i];
            result[i] = new code.DiagnosticRelatedInformation(asLocation(info.location), info.message);
          }
          return result;
        }
        function asDiagnosticTags(tags) {
          if (!tags) {
            return void 0;
          }
          let result = [];
          for (let tag of tags) {
            let converted = asDiagnosticTag(tag);
            if (converted !== void 0) {
              result.push(converted);
            }
          }
          return result.length > 0 ? result : void 0;
        }
        function asDiagnosticTag(tag) {
          switch (tag) {
            case ls.DiagnosticTag.Unnecessary:
              return code.DiagnosticTag.Unnecessary;
            case ls.DiagnosticTag.Deprecated:
              return code.DiagnosticTag.Deprecated;
            default:
              return void 0;
          }
        }
        function asPosition(value) {
          return value ? new code.Position(value.line, value.character) : void 0;
        }
        function asRange(value) {
          return value ? new code.Range(value.start.line, value.start.character, value.end.line, value.end.character) : void 0;
        }
        async function asRanges(items, token) {
          return async.map(items, (range) => {
            return new code.Range(range.start.line, range.start.character, range.end.line, range.end.character);
          }, token);
        }
        function asDiagnosticSeverity(value) {
          if (value === void 0 || value === null) {
            return code.DiagnosticSeverity.Error;
          }
          switch (value) {
            case ls.DiagnosticSeverity.Error:
              return code.DiagnosticSeverity.Error;
            case ls.DiagnosticSeverity.Warning:
              return code.DiagnosticSeverity.Warning;
            case ls.DiagnosticSeverity.Information:
              return code.DiagnosticSeverity.Information;
            case ls.DiagnosticSeverity.Hint:
              return code.DiagnosticSeverity.Hint;
          }
          return code.DiagnosticSeverity.Error;
        }
        function asHoverContent(value) {
          if (Is.string(value)) {
            return asMarkdownString(value);
          } else if (CodeBlock.is(value)) {
            let result = asMarkdownString();
            return result.appendCodeblock(value.value, value.language);
          } else if (Array.isArray(value)) {
            let result = [];
            for (let element of value) {
              let item = asMarkdownString();
              if (CodeBlock.is(element)) {
                item.appendCodeblock(element.value, element.language);
              } else {
                item.appendMarkdown(element);
              }
              result.push(item);
            }
            return result;
          } else {
            return asMarkdownString(value);
          }
        }
        function asDocumentation(value) {
          if (Is.string(value)) {
            return value;
          } else {
            switch (value.kind) {
              case ls.MarkupKind.Markdown:
                return asMarkdownString(value.value);
              case ls.MarkupKind.PlainText:
                return value.value;
              default:
                return `Unsupported Markup content received. Kind is: ${value.kind}`;
            }
          }
        }
        function asMarkdownString(value) {
          let result;
          if (value === void 0 || typeof value === "string") {
            result = new code.MarkdownString(value);
          } else {
            switch (value.kind) {
              case ls.MarkupKind.Markdown:
                result = new code.MarkdownString(value.value);
                break;
              case ls.MarkupKind.PlainText:
                result = new code.MarkdownString();
                result.appendText(value.value);
                break;
              default:
                result = new code.MarkdownString();
                result.appendText(`Unsupported Markup content received. Kind is: ${value.kind}`);
                break;
            }
          }
          result.isTrusted = trustMarkdown;
          result.supportHtml = supportHtml;
          return result;
        }
        function asHover(hover) {
          if (!hover) {
            return void 0;
          }
          return new code.Hover(asHoverContent(hover.contents), asRange(hover.range));
        }
        async function asCompletionResult(value, allCommitCharacters, token) {
          if (!value) {
            return void 0;
          }
          if (Array.isArray(value)) {
            return async.map(value, (item) => asCompletionItem(item, allCommitCharacters), token);
          }
          const list = value;
          const { defaultRange, commitCharacters } = getCompletionItemDefaults(list, allCommitCharacters);
          const converted = await async.map(list.items, (item) => {
            return asCompletionItem(item, commitCharacters, defaultRange, list.itemDefaults?.insertTextMode, list.itemDefaults?.insertTextFormat, list.itemDefaults?.data);
          }, token);
          return new code.CompletionList(converted, list.isIncomplete);
        }
        function getCompletionItemDefaults(list, allCommitCharacters) {
          const rangeDefaults = list.itemDefaults?.editRange;
          const commitCharacters = list.itemDefaults?.commitCharacters ?? allCommitCharacters;
          return ls.Range.is(rangeDefaults) ? { defaultRange: asRange(rangeDefaults), commitCharacters } : rangeDefaults !== void 0 ? { defaultRange: { inserting: asRange(rangeDefaults.insert), replacing: asRange(rangeDefaults.replace) }, commitCharacters } : { defaultRange: void 0, commitCharacters };
        }
        function asCompletionItemKind(value) {
          if (ls.CompletionItemKind.Text <= value && value <= ls.CompletionItemKind.TypeParameter) {
            return [value - 1, void 0];
          }
          return [code.CompletionItemKind.Text, value];
        }
        function asCompletionItemTag(tag) {
          switch (tag) {
            case ls.CompletionItemTag.Deprecated:
              return code.CompletionItemTag.Deprecated;
          }
          return void 0;
        }
        function asCompletionItemTags(tags) {
          if (tags === void 0 || tags === null) {
            return [];
          }
          const result = [];
          for (const tag of tags) {
            const converted = asCompletionItemTag(tag);
            if (converted !== void 0) {
              result.push(converted);
            }
          }
          return result;
        }
        function asCompletionItem(item, defaultCommitCharacters, defaultRange, defaultInsertTextMode, defaultInsertTextFormat, defaultData) {
          const tags = asCompletionItemTags(item.tags);
          const label = asCompletionItemLabel(item);
          const result = new protocolCompletionItem_1.default(label);
          if (item.detail) {
            result.detail = item.detail;
          }
          if (item.documentation) {
            result.documentation = asDocumentation(item.documentation);
            result.documentationFormat = Is.string(item.documentation) ? "$string" : item.documentation.kind;
          }
          if (item.filterText) {
            result.filterText = item.filterText;
          }
          const insertText = asCompletionInsertText(item, defaultRange, defaultInsertTextFormat);
          if (insertText) {
            result.insertText = insertText.text;
            result.range = insertText.range;
            result.fromEdit = insertText.fromEdit;
          }
          if (Is.number(item.kind)) {
            let [itemKind, original] = asCompletionItemKind(item.kind);
            result.kind = itemKind;
            if (original) {
              result.originalItemKind = original;
            }
          }
          if (item.sortText) {
            result.sortText = item.sortText;
          }
          if (item.additionalTextEdits) {
            result.additionalTextEdits = asTextEditsSync(item.additionalTextEdits);
          }
          const commitCharacters = item.commitCharacters !== void 0 ? Is.stringArray(item.commitCharacters) ? item.commitCharacters : void 0 : defaultCommitCharacters;
          if (commitCharacters) {
            result.commitCharacters = commitCharacters.slice();
          }
          if (item.command) {
            result.command = asCommand(item.command);
          }
          if (item.deprecated === true || item.deprecated === false) {
            result.deprecated = item.deprecated;
            if (item.deprecated === true) {
              tags.push(code.CompletionItemTag.Deprecated);
            }
          }
          if (item.preselect === true || item.preselect === false) {
            result.preselect = item.preselect;
          }
          const data = item.data ?? defaultData;
          if (data !== void 0) {
            result.data = data;
          }
          if (tags.length > 0) {
            result.tags = tags;
          }
          const insertTextMode = item.insertTextMode ?? defaultInsertTextMode;
          if (insertTextMode !== void 0) {
            result.insertTextMode = insertTextMode;
            if (insertTextMode === ls.InsertTextMode.asIs) {
              result.keepWhitespace = true;
            }
          }
          return result;
        }
        function asCompletionItemLabel(item) {
          if (ls.CompletionItemLabelDetails.is(item.labelDetails)) {
            return {
              label: item.label,
              detail: item.labelDetails.detail,
              description: item.labelDetails.description
            };
          } else {
            return item.label;
          }
        }
        function asCompletionInsertText(item, defaultRange, defaultInsertTextFormat) {
          const insertTextFormat = item.insertTextFormat ?? defaultInsertTextFormat;
          if (item.textEdit !== void 0 || defaultRange !== void 0) {
            const [range, newText] = item.textEdit !== void 0 ? getCompletionRangeAndText(item.textEdit) : [defaultRange, item.textEditText ?? item.label];
            if (insertTextFormat === ls.InsertTextFormat.Snippet) {
              return { text: new code.SnippetString(newText), range, fromEdit: true };
            } else {
              return { text: newText, range, fromEdit: true };
            }
          } else if (item.insertText) {
            if (insertTextFormat === ls.InsertTextFormat.Snippet) {
              return { text: new code.SnippetString(item.insertText), fromEdit: false };
            } else {
              return { text: item.insertText, fromEdit: false };
            }
          } else {
            return void 0;
          }
        }
        function getCompletionRangeAndText(value) {
          if (ls.InsertReplaceEdit.is(value)) {
            return [{ inserting: asRange(value.insert), replacing: asRange(value.replace) }, value.newText];
          } else {
            return [asRange(value.range), value.newText];
          }
        }
        function asTextEdit(edit) {
          if (!edit) {
            return void 0;
          }
          return new code.TextEdit(asRange(edit.range), edit.newText);
        }
        async function asTextEdits(items, token) {
          if (!items) {
            return void 0;
          }
          return async.map(items, asTextEdit, token);
        }
        function asTextEditsSync(items) {
          if (!items) {
            return void 0;
          }
          const result = new Array(items.length);
          for (let i = 0; i < items.length; i++) {
            result[i] = asTextEdit(items[i]);
          }
          return result;
        }
        async function asSignatureHelp(item, token) {
          if (!item) {
            return void 0;
          }
          let result = new code.SignatureHelp();
          if (Is.number(item.activeSignature)) {
            result.activeSignature = item.activeSignature;
          } else {
            result.activeSignature = 0;
          }
          if (Is.number(item.activeParameter)) {
            result.activeParameter = item.activeParameter;
          } else {
            result.activeParameter = 0;
          }
          if (item.signatures) {
            result.signatures = await asSignatureInformations(item.signatures, token);
          }
          return result;
        }
        async function asSignatureInformations(items, token) {
          return async.mapAsync(items, asSignatureInformation, token);
        }
        async function asSignatureInformation(item, token) {
          let result = new code.SignatureInformation(item.label);
          if (item.documentation !== void 0) {
            result.documentation = asDocumentation(item.documentation);
          }
          if (item.parameters !== void 0) {
            result.parameters = await asParameterInformations(item.parameters, token);
          }
          if (item.activeParameter !== void 0) {
            result.activeParameter = item.activeParameter;
          }
          {
            return result;
          }
        }
        function asParameterInformations(items, token) {
          return async.map(items, asParameterInformation, token);
        }
        function asParameterInformation(item) {
          let result = new code.ParameterInformation(item.label);
          if (item.documentation) {
            result.documentation = asDocumentation(item.documentation);
          }
          return result;
        }
        function asLocation(item) {
          return item ? new code.Location(_uriConverter(item.uri), asRange(item.range)) : void 0;
        }
        async function asDeclarationResult(item, token) {
          if (!item) {
            return void 0;
          }
          return asLocationResult(item, token);
        }
        async function asDefinitionResult(item, token) {
          if (!item) {
            return void 0;
          }
          return asLocationResult(item, token);
        }
        function asLocationLink(item) {
          if (!item) {
            return void 0;
          }
          let result = {
            targetUri: _uriConverter(item.targetUri),
            targetRange: asRange(item.targetRange),
            originSelectionRange: asRange(item.originSelectionRange),
            targetSelectionRange: asRange(item.targetSelectionRange)
          };
          if (!result.targetSelectionRange) {
            throw new Error(`targetSelectionRange must not be undefined or null`);
          }
          return result;
        }
        async function asLocationResult(item, token) {
          if (!item) {
            return void 0;
          }
          if (Is.array(item)) {
            if (item.length === 0) {
              return [];
            } else if (ls.LocationLink.is(item[0])) {
              const links = item;
              return async.map(links, asLocationLink, token);
            } else {
              const locations = item;
              return async.map(locations, asLocation, token);
            }
          } else if (ls.LocationLink.is(item)) {
            return [asLocationLink(item)];
          } else {
            return asLocation(item);
          }
        }
        async function asReferences(values, token) {
          if (!values) {
            return void 0;
          }
          return async.map(values, asLocation, token);
        }
        async function asDocumentHighlights(values, token) {
          if (!values) {
            return void 0;
          }
          return async.map(values, asDocumentHighlight, token);
        }
        function asDocumentHighlight(item) {
          let result = new code.DocumentHighlight(asRange(item.range));
          if (Is.number(item.kind)) {
            result.kind = asDocumentHighlightKind(item.kind);
          }
          return result;
        }
        function asDocumentHighlightKind(item) {
          switch (item) {
            case ls.DocumentHighlightKind.Text:
              return code.DocumentHighlightKind.Text;
            case ls.DocumentHighlightKind.Read:
              return code.DocumentHighlightKind.Read;
            case ls.DocumentHighlightKind.Write:
              return code.DocumentHighlightKind.Write;
          }
          return code.DocumentHighlightKind.Text;
        }
        async function asSymbolInformations(values, token) {
          if (!values) {
            return void 0;
          }
          return async.map(values, asSymbolInformation, token);
        }
        function asSymbolKind(item) {
          if (item <= ls.SymbolKind.TypeParameter) {
            return item - 1;
          }
          return code.SymbolKind.Property;
        }
        function asSymbolTag(value) {
          switch (value) {
            case ls.SymbolTag.Deprecated:
              return code.SymbolTag.Deprecated;
            default:
              return void 0;
          }
        }
        function asSymbolTags(items) {
          if (items === void 0 || items === null) {
            return void 0;
          }
          const result = [];
          for (const item of items) {
            const converted = asSymbolTag(item);
            if (converted !== void 0) {
              result.push(converted);
            }
          }
          return result.length === 0 ? void 0 : result;
        }
        function asSymbolInformation(item) {
          const data = item.data;
          const location = item.location;
          const result = location.range === void 0 || data !== void 0 ? new protocolWorkspaceSymbol_1.default(item.name, asSymbolKind(item.kind), item.containerName ?? "", location.range === void 0 ? _uriConverter(location.uri) : new code.Location(_uriConverter(item.location.uri), asRange(location.range)), data) : new code.SymbolInformation(item.name, asSymbolKind(item.kind), item.containerName ?? "", new code.Location(_uriConverter(item.location.uri), asRange(location.range)));
          fillTags(result, item);
          return result;
        }
        async function asDocumentSymbols(values, token) {
          if (values === void 0 || values === null) {
            return void 0;
          }
          return async.map(values, asDocumentSymbol, token);
        }
        function asDocumentSymbol(value) {
          let result = new code.DocumentSymbol(value.name, value.detail || "", asSymbolKind(value.kind), asRange(value.range), asRange(value.selectionRange));
          fillTags(result, value);
          if (value.children !== void 0 && value.children.length > 0) {
            let children = [];
            for (let child of value.children) {
              children.push(asDocumentSymbol(child));
            }
            result.children = children;
          }
          return result;
        }
        function fillTags(result, value) {
          result.tags = asSymbolTags(value.tags);
          if (value.deprecated) {
            if (!result.tags) {
              result.tags = [code.SymbolTag.Deprecated];
            } else {
              if (!result.tags.includes(code.SymbolTag.Deprecated)) {
                result.tags = result.tags.concat(code.SymbolTag.Deprecated);
              }
            }
          }
        }
        function asCommand(item) {
          let result = { title: item.title, command: item.command };
          if (item.arguments) {
            result.arguments = item.arguments;
          }
          return result;
        }
        async function asCommands(items, token) {
          if (!items) {
            return void 0;
          }
          return async.map(items, asCommand, token);
        }
        const kindMapping = /* @__PURE__ */ new Map();
        kindMapping.set(ls.CodeActionKind.Empty, code.CodeActionKind.Empty);
        kindMapping.set(ls.CodeActionKind.QuickFix, code.CodeActionKind.QuickFix);
        kindMapping.set(ls.CodeActionKind.Refactor, code.CodeActionKind.Refactor);
        kindMapping.set(ls.CodeActionKind.RefactorExtract, code.CodeActionKind.RefactorExtract);
        kindMapping.set(ls.CodeActionKind.RefactorInline, code.CodeActionKind.RefactorInline);
        kindMapping.set(ls.CodeActionKind.RefactorRewrite, code.CodeActionKind.RefactorRewrite);
        kindMapping.set(ls.CodeActionKind.Source, code.CodeActionKind.Source);
        kindMapping.set(ls.CodeActionKind.SourceOrganizeImports, code.CodeActionKind.SourceOrganizeImports);
        function asCodeActionKind(item) {
          if (item === void 0 || item === null) {
            return void 0;
          }
          let result = kindMapping.get(item);
          if (result) {
            return result;
          }
          let parts = item.split(".");
          result = code.CodeActionKind.Empty;
          for (let part of parts) {
            result = result.append(part);
          }
          return result;
        }
        function asCodeActionKinds(items) {
          if (items === void 0 || items === null) {
            return void 0;
          }
          return items.map((kind) => asCodeActionKind(kind));
        }
        async function asCodeAction(item, token) {
          if (item === void 0 || item === null) {
            return void 0;
          }
          let result = new protocolCodeAction_1.default(item.title, item.data);
          if (item.kind !== void 0) {
            result.kind = asCodeActionKind(item.kind);
          }
          if (item.diagnostics !== void 0) {
            result.diagnostics = asDiagnosticsSync(item.diagnostics);
          }
          if (item.edit !== void 0) {
            result.edit = await asWorkspaceEdit(item.edit, token);
          }
          if (item.command !== void 0) {
            result.command = asCommand(item.command);
          }
          if (item.isPreferred !== void 0) {
            result.isPreferred = item.isPreferred;
          }
          if (item.disabled !== void 0) {
            result.disabled = { reason: item.disabled.reason };
          }
          return result;
        }
        function asCodeActionResult(items, token) {
          return async.mapAsync(items, async (item) => {
            if (ls.Command.is(item)) {
              return asCommand(item);
            } else {
              return asCodeAction(item, token);
            }
          }, token);
        }
        function asCodeLens(item) {
          if (!item) {
            return void 0;
          }
          let result = new protocolCodeLens_1.default(asRange(item.range));
          if (item.command) {
            result.command = asCommand(item.command);
          }
          if (item.data !== void 0 && item.data !== null) {
            result.data = item.data;
          }
          return result;
        }
        async function asCodeLenses(items, token) {
          if (!items) {
            return void 0;
          }
          return async.map(items, asCodeLens, token);
        }
        async function asWorkspaceEdit(item, token) {
          if (!item) {
            return void 0;
          }
          const sharedMetadata = /* @__PURE__ */ new Map();
          if (item.changeAnnotations !== void 0) {
            const changeAnnotations = item.changeAnnotations;
            await async.forEach(Object.keys(changeAnnotations), (key) => {
              const metaData = asWorkspaceEditEntryMetadata(changeAnnotations[key]);
              sharedMetadata.set(key, metaData);
            }, token);
          }
          const asMetadata = (annotation) => {
            if (annotation === void 0) {
              return void 0;
            } else {
              return sharedMetadata.get(annotation);
            }
          };
          const result = new code.WorkspaceEdit();
          if (item.documentChanges) {
            const documentChanges = item.documentChanges;
            await async.forEach(documentChanges, (change) => {
              if (ls.CreateFile.is(change)) {
                result.createFile(_uriConverter(change.uri), change.options, asMetadata(change.annotationId));
              } else if (ls.RenameFile.is(change)) {
                result.renameFile(_uriConverter(change.oldUri), _uriConverter(change.newUri), change.options, asMetadata(change.annotationId));
              } else if (ls.DeleteFile.is(change)) {
                result.deleteFile(_uriConverter(change.uri), change.options, asMetadata(change.annotationId));
              } else if (ls.TextDocumentEdit.is(change)) {
                const uri = _uriConverter(change.textDocument.uri);
                for (const edit of change.edits) {
                  if (ls.AnnotatedTextEdit.is(edit)) {
                    result.replace(uri, asRange(edit.range), edit.newText, asMetadata(edit.annotationId));
                  } else {
                    result.replace(uri, asRange(edit.range), edit.newText);
                  }
                }
              } else {
                throw new Error(`Unknown workspace edit change received:
${JSON.stringify(change, void 0, 4)}`);
              }
            }, token);
          } else if (item.changes) {
            const changes = item.changes;
            await async.forEach(Object.keys(changes), (key) => {
              result.set(_uriConverter(key), asTextEditsSync(changes[key]));
            }, token);
          }
          return result;
        }
        function asWorkspaceEditEntryMetadata(annotation) {
          if (annotation === void 0) {
            return void 0;
          }
          return { label: annotation.label, needsConfirmation: !!annotation.needsConfirmation, description: annotation.description };
        }
        function asDocumentLink(item) {
          let range = asRange(item.range);
          let target = item.target ? asUri(item.target) : void 0;
          let link = new protocolDocumentLink_1.default(range, target);
          if (item.tooltip !== void 0) {
            link.tooltip = item.tooltip;
          }
          if (item.data !== void 0 && item.data !== null) {
            link.data = item.data;
          }
          return link;
        }
        async function asDocumentLinks(items, token) {
          if (!items) {
            return void 0;
          }
          return async.map(items, asDocumentLink, token);
        }
        function asColor(color) {
          return new code.Color(color.red, color.green, color.blue, color.alpha);
        }
        function asColorInformation(ci) {
          return new code.ColorInformation(asRange(ci.range), asColor(ci.color));
        }
        async function asColorInformations(colorInformation, token) {
          if (!colorInformation) {
            return void 0;
          }
          return async.map(colorInformation, asColorInformation, token);
        }
        function asColorPresentation(cp) {
          let presentation = new code.ColorPresentation(cp.label);
          presentation.additionalTextEdits = asTextEditsSync(cp.additionalTextEdits);
          if (cp.textEdit) {
            presentation.textEdit = asTextEdit(cp.textEdit);
          }
          return presentation;
        }
        async function asColorPresentations(colorPresentations, token) {
          if (!colorPresentations) {
            return void 0;
          }
          return async.map(colorPresentations, asColorPresentation, token);
        }
        function asFoldingRangeKind(kind) {
          if (kind) {
            switch (kind) {
              case ls.FoldingRangeKind.Comment:
                return code.FoldingRangeKind.Comment;
              case ls.FoldingRangeKind.Imports:
                return code.FoldingRangeKind.Imports;
              case ls.FoldingRangeKind.Region:
                return code.FoldingRangeKind.Region;
            }
          }
          return void 0;
        }
        function asFoldingRange(r) {
          return new code.FoldingRange(r.startLine, r.endLine, asFoldingRangeKind(r.kind));
        }
        async function asFoldingRanges(foldingRanges, token) {
          if (!foldingRanges) {
            return void 0;
          }
          return async.map(foldingRanges, asFoldingRange, token);
        }
        function asSelectionRange(selectionRange) {
          return new code.SelectionRange(asRange(selectionRange.range), selectionRange.parent ? asSelectionRange(selectionRange.parent) : void 0);
        }
        async function asSelectionRanges(selectionRanges, token) {
          if (!Array.isArray(selectionRanges)) {
            return [];
          }
          return async.map(selectionRanges, asSelectionRange, token);
        }
        function asInlineValue(inlineValue) {
          if (ls.InlineValueText.is(inlineValue)) {
            return new code.InlineValueText(asRange(inlineValue.range), inlineValue.text);
          } else if (ls.InlineValueVariableLookup.is(inlineValue)) {
            return new code.InlineValueVariableLookup(asRange(inlineValue.range), inlineValue.variableName, inlineValue.caseSensitiveLookup);
          } else {
            return new code.InlineValueEvaluatableExpression(asRange(inlineValue.range), inlineValue.expression);
          }
        }
        async function asInlineValues(inlineValues, token) {
          if (!Array.isArray(inlineValues)) {
            return [];
          }
          return async.map(inlineValues, asInlineValue, token);
        }
        async function asInlayHint(value, token) {
          const label = typeof value.label === "string" ? value.label : await async.map(value.label, asInlayHintLabelPart, token);
          const result = new protocolInlayHint_1.default(asPosition(value.position), label);
          if (value.kind !== void 0) {
            result.kind = value.kind;
          }
          if (value.textEdits !== void 0) {
            result.textEdits = await asTextEdits(value.textEdits, token);
          }
          if (value.tooltip !== void 0) {
            result.tooltip = asTooltip(value.tooltip);
          }
          if (value.paddingLeft !== void 0) {
            result.paddingLeft = value.paddingLeft;
          }
          if (value.paddingRight !== void 0) {
            result.paddingRight = value.paddingRight;
          }
          if (value.data !== void 0) {
            result.data = value.data;
          }
          return result;
        }
        function asInlayHintLabelPart(part) {
          const result = new code.InlayHintLabelPart(part.value);
          if (part.location !== void 0) {
            result.location = asLocation(part.location);
          }
          if (part.tooltip !== void 0) {
            result.tooltip = asTooltip(part.tooltip);
          }
          if (part.command !== void 0) {
            result.command = asCommand(part.command);
          }
          return result;
        }
        function asTooltip(value) {
          if (typeof value === "string") {
            return value;
          }
          return asMarkdownString(value);
        }
        async function asInlayHints(values, token) {
          if (!Array.isArray(values)) {
            return void 0;
          }
          return async.mapAsync(values, asInlayHint, token);
        }
        function asCallHierarchyItem(item) {
          if (item === null) {
            return void 0;
          }
          const result = new protocolCallHierarchyItem_1.default(asSymbolKind(item.kind), item.name, item.detail || "", asUri(item.uri), asRange(item.range), asRange(item.selectionRange), item.data);
          if (item.tags !== void 0) {
            result.tags = asSymbolTags(item.tags);
          }
          return result;
        }
        async function asCallHierarchyItems(items, token) {
          if (items === null) {
            return void 0;
          }
          return async.map(items, asCallHierarchyItem, token);
        }
        async function asCallHierarchyIncomingCall(item, token) {
          return new code.CallHierarchyIncomingCall(asCallHierarchyItem(item.from), await asRanges(item.fromRanges, token));
        }
        async function asCallHierarchyIncomingCalls(items, token) {
          if (items === null) {
            return void 0;
          }
          return async.mapAsync(items, asCallHierarchyIncomingCall, token);
        }
        async function asCallHierarchyOutgoingCall(item, token) {
          return new code.CallHierarchyOutgoingCall(asCallHierarchyItem(item.to), await asRanges(item.fromRanges, token));
        }
        async function asCallHierarchyOutgoingCalls(items, token) {
          if (items === null) {
            return void 0;
          }
          return async.mapAsync(items, asCallHierarchyOutgoingCall, token);
        }
        async function asSemanticTokens(value, _token) {
          if (value === void 0 || value === null) {
            return void 0;
          }
          return new code.SemanticTokens(new Uint32Array(value.data), value.resultId);
        }
        function asSemanticTokensEdit(value) {
          return new code.SemanticTokensEdit(value.start, value.deleteCount, value.data !== void 0 ? new Uint32Array(value.data) : void 0);
        }
        async function asSemanticTokensEdits(value, _token) {
          if (value === void 0 || value === null) {
            return void 0;
          }
          return new code.SemanticTokensEdits(value.edits.map(asSemanticTokensEdit), value.resultId);
        }
        function asSemanticTokensLegend(value) {
          return value;
        }
        async function asLinkedEditingRanges(value, token) {
          if (value === null || value === void 0) {
            return void 0;
          }
          return new code.LinkedEditingRanges(await asRanges(value.ranges, token), asRegularExpression(value.wordPattern));
        }
        function asRegularExpression(value) {
          if (value === null || value === void 0) {
            return void 0;
          }
          return new RegExp(value);
        }
        function asTypeHierarchyItem(item) {
          if (item === null) {
            return void 0;
          }
          let result = new protocolTypeHierarchyItem_1.default(asSymbolKind(item.kind), item.name, item.detail || "", asUri(item.uri), asRange(item.range), asRange(item.selectionRange), item.data);
          if (item.tags !== void 0) {
            result.tags = asSymbolTags(item.tags);
          }
          return result;
        }
        async function asTypeHierarchyItems(items, token) {
          if (items === null) {
            return void 0;
          }
          return async.map(items, asTypeHierarchyItem, token);
        }
        function asGlobPattern(pattern) {
          if (Is.string(pattern)) {
            return pattern;
          }
          if (ls.RelativePattern.is(pattern)) {
            if (ls.URI.is(pattern.baseUri)) {
              return new code.RelativePattern(asUri(pattern.baseUri), pattern.pattern);
            } else if (ls.WorkspaceFolder.is(pattern.baseUri)) {
              const workspaceFolder = code.workspace.getWorkspaceFolder(asUri(pattern.baseUri.uri));
              return workspaceFolder !== void 0 ? new code.RelativePattern(workspaceFolder, pattern.pattern) : void 0;
            }
          }
          return void 0;
        }
        return {
          asUri,
          asDocumentSelector,
          asDiagnostics,
          asDiagnostic,
          asRange,
          asRanges,
          asPosition,
          asDiagnosticSeverity,
          asDiagnosticTag,
          asHover,
          asCompletionResult,
          asCompletionItem,
          asTextEdit,
          asTextEdits,
          asSignatureHelp,
          asSignatureInformations,
          asSignatureInformation,
          asParameterInformations,
          asParameterInformation,
          asDeclarationResult,
          asDefinitionResult,
          asLocation,
          asReferences,
          asDocumentHighlights,
          asDocumentHighlight,
          asDocumentHighlightKind,
          asSymbolKind,
          asSymbolTag,
          asSymbolTags,
          asSymbolInformations,
          asSymbolInformation,
          asDocumentSymbols,
          asDocumentSymbol,
          asCommand,
          asCommands,
          asCodeAction,
          asCodeActionKind,
          asCodeActionKinds,
          asCodeActionResult,
          asCodeLens,
          asCodeLenses,
          asWorkspaceEdit,
          asDocumentLink,
          asDocumentLinks,
          asFoldingRangeKind,
          asFoldingRange,
          asFoldingRanges,
          asColor,
          asColorInformation,
          asColorInformations,
          asColorPresentation,
          asColorPresentations,
          asSelectionRange,
          asSelectionRanges,
          asInlineValue,
          asInlineValues,
          asInlayHint,
          asInlayHints,
          asSemanticTokensLegend,
          asSemanticTokens,
          asSemanticTokensEdit,
          asSemanticTokensEdits,
          asCallHierarchyItem,
          asCallHierarchyItems,
          asCallHierarchyIncomingCall,
          asCallHierarchyIncomingCalls,
          asCallHierarchyOutgoingCall,
          asCallHierarchyOutgoingCalls,
          asLinkedEditingRanges,
          asTypeHierarchyItem,
          asTypeHierarchyItems,
          asGlobPattern
        };
      }
      exports2.createConverter = createConverter;
    }
  });

  // node_modules/vscode-languageclient/lib/common/progressPart.js
  var require_progressPart = __commonJS({
    "node_modules/vscode-languageclient/lib/common/progressPart.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ProgressPart = void 0;
      var vscode_1 = (init_api(), __toCommonJS(api_exports));
      var vscode_languageserver_protocol_1 = require_main3();
      var Is = require_is4();
      var ProgressPart = class {
        constructor(_client, _token, done) {
          this._client = _client;
          this._token = _token;
          this._reported = 0;
          this._infinite = false;
          this._lspProgressDisposable = this._client.onProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, (value) => {
            switch (value.kind) {
              case "begin":
                this.begin(value);
                break;
              case "report":
                this.report(value);
                break;
              case "end":
                this.done();
                done && done(this);
                break;
            }
          });
        }
        begin(params) {
          this._infinite = params.percentage === void 0;
          if (this._lspProgressDisposable === void 0) {
            return;
          }
          void vscode_1.window.withProgress({ location: vscode_1.ProgressLocation.Window, cancellable: params.cancellable, title: params.title }, async (progress, cancellationToken) => {
            if (this._lspProgressDisposable === void 0) {
              return;
            }
            this._progress = progress;
            this._cancellationToken = cancellationToken;
            this._tokenDisposable = this._cancellationToken.onCancellationRequested(() => {
              this._client.sendNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, { token: this._token });
            });
            this.report(params);
            return new Promise((resolve2, reject) => {
              this._resolve = resolve2;
              this._reject = reject;
            });
          });
        }
        report(params) {
          if (this._infinite && Is.string(params.message)) {
            this._progress !== void 0 && this._progress.report({ message: params.message });
          } else if (Is.number(params.percentage)) {
            const percentage = Math.max(0, Math.min(params.percentage, 100));
            const delta = Math.max(0, percentage - this._reported);
            this._reported += delta;
            this._progress !== void 0 && this._progress.report({ message: params.message, increment: delta });
          }
        }
        cancel() {
          this.cleanup();
          if (this._reject !== void 0) {
            this._reject();
            this._resolve = void 0;
            this._reject = void 0;
          }
        }
        done() {
          this.cleanup();
          if (this._resolve !== void 0) {
            this._resolve();
            this._resolve = void 0;
            this._reject = void 0;
          }
        }
        cleanup() {
          if (this._lspProgressDisposable !== void 0) {
            this._lspProgressDisposable.dispose();
            this._lspProgressDisposable = void 0;
          }
          if (this._tokenDisposable !== void 0) {
            this._tokenDisposable.dispose();
            this._tokenDisposable = void 0;
          }
          this._progress = void 0;
          this._cancellationToken = void 0;
        }
      };
      exports2.ProgressPart = ProgressPart;
    }
  });

  // node_modules/vscode-languageclient/lib/common/notebook.js
  var require_notebook2 = __commonJS({
    "node_modules/vscode-languageclient/lib/common/notebook.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.NotebookDocumentSyncFeature = void 0;
      var vscode = (init_api(), __toCommonJS(api_exports));
      var minimatch = require_minimatch();
      var proto = require_main3();
      var UUID = require_uuid2();
      var Is = require_is4();
      function ensure(target, key) {
        if (target[key] === void 0) {
          target[key] = {};
        }
        return target[key];
      }
      var Converter;
      (function(Converter2) {
        let c2p;
        (function(c2p2) {
          function asVersionedNotebookDocumentIdentifier(notebookDocument, base) {
            return {
              version: notebookDocument.version,
              uri: base.asUri(notebookDocument.uri)
            };
          }
          c2p2.asVersionedNotebookDocumentIdentifier = asVersionedNotebookDocumentIdentifier;
          function asNotebookDocument(notebookDocument, cells, base) {
            const result = proto.NotebookDocument.create(base.asUri(notebookDocument.uri), notebookDocument.notebookType, notebookDocument.version, asNotebookCells(cells, base));
            if (Object.keys(notebookDocument.metadata).length > 0) {
              result.metadata = asMetadata(notebookDocument.metadata);
            }
            return result;
          }
          c2p2.asNotebookDocument = asNotebookDocument;
          function asNotebookCells(cells, base) {
            return cells.map((cell) => asNotebookCell(cell, base));
          }
          c2p2.asNotebookCells = asNotebookCells;
          function asMetadata(metadata) {
            const seen = /* @__PURE__ */ new Set();
            return deepCopy(seen, metadata);
          }
          c2p2.asMetadata = asMetadata;
          function asNotebookCell(cell, base) {
            const result = proto.NotebookCell.create(asNotebookCellKind(cell.kind), base.asUri(cell.document.uri));
            if (Object.keys(cell.metadata).length > 0) {
              result.metadata = asMetadata(cell.metadata);
            }
            if (cell.executionSummary !== void 0 && (Is.number(cell.executionSummary.executionOrder) && Is.boolean(cell.executionSummary.success))) {
              result.executionSummary = {
                executionOrder: cell.executionSummary.executionOrder,
                success: cell.executionSummary.success
              };
            }
            return result;
          }
          c2p2.asNotebookCell = asNotebookCell;
          function asNotebookCellKind(kind) {
            switch (kind) {
              case vscode.NotebookCellKind.Markup:
                return proto.NotebookCellKind.Markup;
              case vscode.NotebookCellKind.Code:
                return proto.NotebookCellKind.Code;
            }
          }
          function deepCopy(seen, value) {
            if (seen.has(value)) {
              throw new Error(`Can't deep copy cyclic structures.`);
            }
            if (Array.isArray(value)) {
              const result = [];
              for (const elem of value) {
                if (elem !== null && typeof elem === "object" || Array.isArray(elem)) {
                  result.push(deepCopy(seen, elem));
                } else {
                  if (elem instanceof RegExp) {
                    throw new Error(`Can't transfer regular expressions to the server`);
                  }
                  result.push(elem);
                }
              }
              return result;
            } else {
              const props = Object.keys(value);
              const result = /* @__PURE__ */ Object.create(null);
              for (const prop of props) {
                const elem = value[prop];
                if (elem !== null && typeof elem === "object" || Array.isArray(elem)) {
                  result[prop] = deepCopy(seen, elem);
                } else {
                  if (elem instanceof RegExp) {
                    throw new Error(`Can't transfer regular expressions to the server`);
                  }
                  result[prop] = elem;
                }
              }
              return result;
            }
          }
          function asTextContentChange(event, base) {
            const params = base.asChangeTextDocumentParams(event);
            return { document: params.textDocument, changes: params.contentChanges };
          }
          c2p2.asTextContentChange = asTextContentChange;
          function asNotebookDocumentChangeEvent(event, base) {
            const result = /* @__PURE__ */ Object.create(null);
            if (event.metadata) {
              result.metadata = Converter2.c2p.asMetadata(event.metadata);
            }
            if (event.cells !== void 0) {
              const cells = /* @__PURE__ */ Object.create(null);
              const changedCells = event.cells;
              if (changedCells.structure) {
                cells.structure = {
                  array: {
                    start: changedCells.structure.array.start,
                    deleteCount: changedCells.structure.array.deleteCount,
                    cells: changedCells.structure.array.cells !== void 0 ? changedCells.structure.array.cells.map((cell) => Converter2.c2p.asNotebookCell(cell, base)) : void 0
                  },
                  didOpen: changedCells.structure.didOpen !== void 0 ? changedCells.structure.didOpen.map((cell) => base.asOpenTextDocumentParams(cell.document).textDocument) : void 0,
                  didClose: changedCells.structure.didClose !== void 0 ? changedCells.structure.didClose.map((cell) => base.asCloseTextDocumentParams(cell.document).textDocument) : void 0
                };
              }
              if (changedCells.data !== void 0) {
                cells.data = changedCells.data.map((cell) => Converter2.c2p.asNotebookCell(cell, base));
              }
              if (changedCells.textContent !== void 0) {
                cells.textContent = changedCells.textContent.map((event2) => Converter2.c2p.asTextContentChange(event2, base));
              }
              if (Object.keys(cells).length > 0) {
                result.cells = cells;
              }
            }
            return result;
          }
          c2p2.asNotebookDocumentChangeEvent = asNotebookDocumentChangeEvent;
        })(c2p = Converter2.c2p || (Converter2.c2p = {}));
      })(Converter || (Converter = {}));
      var $NotebookCell;
      (function($NotebookCell2) {
        function computeDiff(originalCells, modifiedCells, compareMetadata) {
          const originalLength = originalCells.length;
          const modifiedLength = modifiedCells.length;
          let startIndex = 0;
          while (startIndex < modifiedLength && startIndex < originalLength && equals3(originalCells[startIndex], modifiedCells[startIndex], compareMetadata)) {
            startIndex++;
          }
          if (startIndex < modifiedLength && startIndex < originalLength) {
            let originalEndIndex = originalLength - 1;
            let modifiedEndIndex = modifiedLength - 1;
            while (originalEndIndex >= 0 && modifiedEndIndex >= 0 && equals3(originalCells[originalEndIndex], modifiedCells[modifiedEndIndex], compareMetadata)) {
              originalEndIndex--;
              modifiedEndIndex--;
            }
            const deleteCount = originalEndIndex + 1 - startIndex;
            const newCells = startIndex === modifiedEndIndex + 1 ? void 0 : modifiedCells.slice(startIndex, modifiedEndIndex + 1);
            return newCells !== void 0 ? { start: startIndex, deleteCount, cells: newCells } : { start: startIndex, deleteCount };
          } else if (startIndex < modifiedLength) {
            return { start: startIndex, deleteCount: 0, cells: modifiedCells.slice(startIndex) };
          } else if (startIndex < originalLength) {
            return { start: startIndex, deleteCount: originalLength - startIndex };
          } else {
            return void 0;
          }
        }
        $NotebookCell2.computeDiff = computeDiff;
        function equals3(one, other, compareMetaData = true) {
          if (one.kind !== other.kind || one.document.uri.toString() !== other.document.uri.toString() || one.document.languageId !== other.document.languageId || !equalsExecution(one.executionSummary, other.executionSummary)) {
            return false;
          }
          return !compareMetaData || compareMetaData && equalsMetadata(one.metadata, other.metadata);
        }
        function equalsExecution(one, other) {
          if (one === other) {
            return true;
          }
          if (one === void 0 || other === void 0) {
            return false;
          }
          return one.executionOrder === other.executionOrder && one.success === other.success && equalsTiming(one.timing, other.timing);
        }
        function equalsTiming(one, other) {
          if (one === other) {
            return true;
          }
          if (one === void 0 || other === void 0) {
            return false;
          }
          return one.startTime === other.startTime && one.endTime === other.endTime;
        }
        function equalsMetadata(one, other) {
          if (one === other) {
            return true;
          }
          if (one === null || one === void 0 || other === null || other === void 0) {
            return false;
          }
          if (typeof one !== typeof other) {
            return false;
          }
          if (typeof one !== "object") {
            return false;
          }
          const oneArray = Array.isArray(one);
          const otherArray = Array.isArray(other);
          if (oneArray !== otherArray) {
            return false;
          }
          if (oneArray && otherArray) {
            if (one.length !== other.length) {
              return false;
            }
            for (let i = 0; i < one.length; i++) {
              if (!equalsMetadata(one[i], other[i])) {
                return false;
              }
            }
          }
          if (isObjectLiteral(one) && isObjectLiteral(other)) {
            const oneKeys = Object.keys(one);
            const otherKeys = Object.keys(other);
            if (oneKeys.length !== otherKeys.length) {
              return false;
            }
            oneKeys.sort();
            otherKeys.sort();
            if (!equalsMetadata(oneKeys, otherKeys)) {
              return false;
            }
            for (let i = 0; i < oneKeys.length; i++) {
              const prop = oneKeys[i];
              if (!equalsMetadata(one[prop], other[prop])) {
                return false;
              }
            }
            return true;
          }
          return false;
        }
        function isObjectLiteral(value) {
          return value !== null && typeof value === "object";
        }
        $NotebookCell2.isObjectLiteral = isObjectLiteral;
      })($NotebookCell || ($NotebookCell = {}));
      var $NotebookDocumentFilter;
      (function($NotebookDocumentFilter2) {
        function matchNotebook(filter, notebookDocument) {
          if (typeof filter === "string") {
            return filter === "*" || notebookDocument.notebookType === filter;
          }
          if (filter.notebookType !== void 0 && filter.notebookType !== "*" && notebookDocument.notebookType !== filter.notebookType) {
            return false;
          }
          const uri = notebookDocument.uri;
          if (filter.scheme !== void 0 && filter.scheme !== "*" && uri.scheme !== filter.scheme) {
            return false;
          }
          if (filter.pattern !== void 0) {
            const matcher = new minimatch.Minimatch(filter.pattern, { noext: true });
            if (!matcher.makeRe()) {
              return false;
            }
            if (!matcher.match(uri.fsPath)) {
              return false;
            }
          }
          return true;
        }
        $NotebookDocumentFilter2.matchNotebook = matchNotebook;
      })($NotebookDocumentFilter || ($NotebookDocumentFilter = {}));
      var $NotebookDocumentSyncOptions;
      (function($NotebookDocumentSyncOptions2) {
        function asDocumentSelector(options) {
          const selector = options.notebookSelector;
          const result = [];
          for (const element of selector) {
            const notebookType = (typeof element.notebook === "string" ? element.notebook : element.notebook?.notebookType) ?? "*";
            const scheme = typeof element.notebook === "string" ? void 0 : element.notebook?.scheme;
            const pattern = typeof element.notebook === "string" ? void 0 : element.notebook?.pattern;
            if (element.cells !== void 0) {
              for (const cell of element.cells) {
                result.push(asDocumentFilter(notebookType, scheme, pattern, cell.language));
              }
            } else {
              result.push(asDocumentFilter(notebookType, scheme, pattern, void 0));
            }
          }
          return result;
        }
        $NotebookDocumentSyncOptions2.asDocumentSelector = asDocumentSelector;
        function asDocumentFilter(notebookType, scheme, pattern, language2) {
          return scheme === void 0 && pattern === void 0 ? { notebook: notebookType, language: language2 } : { notebook: { notebookType, scheme, pattern }, language: language2 };
        }
      })($NotebookDocumentSyncOptions || ($NotebookDocumentSyncOptions = {}));
      var SyncInfo;
      (function(SyncInfo2) {
        function create(cells) {
          return {
            cells,
            uris: new Set(cells.map((cell) => cell.document.uri.toString()))
          };
        }
        SyncInfo2.create = create;
      })(SyncInfo || (SyncInfo = {}));
      var NotebookDocumentSyncFeatureProvider = class {
        constructor(client, options) {
          this.client = client;
          this.options = options;
          this.notebookSyncInfo = /* @__PURE__ */ new Map();
          this.notebookDidOpen = /* @__PURE__ */ new Set();
          this.disposables = [];
          this.selector = client.protocol2CodeConverter.asDocumentSelector($NotebookDocumentSyncOptions.asDocumentSelector(options));
          vscode.workspace.onDidOpenNotebookDocument((notebookDocument) => {
            this.notebookDidOpen.add(notebookDocument.uri.toString());
            this.didOpen(notebookDocument);
          }, void 0, this.disposables);
          for (const notebookDocument of vscode.workspace.notebookDocuments) {
            this.notebookDidOpen.add(notebookDocument.uri.toString());
            this.didOpen(notebookDocument);
          }
          vscode.workspace.onDidChangeNotebookDocument((event) => this.didChangeNotebookDocument(event), void 0, this.disposables);
          if (this.options.save === true) {
            vscode.workspace.onDidSaveNotebookDocument((notebookDocument) => this.didSave(notebookDocument), void 0, this.disposables);
          }
          vscode.workspace.onDidCloseNotebookDocument((notebookDocument) => {
            this.didClose(notebookDocument);
            this.notebookDidOpen.delete(notebookDocument.uri.toString());
          }, void 0, this.disposables);
        }
        getState() {
          for (const notebook of vscode.workspace.notebookDocuments) {
            const matchingCells = this.getMatchingCells(notebook);
            if (matchingCells !== void 0) {
              return { kind: "document", id: "$internal", registrations: true, matches: true };
            }
          }
          return { kind: "document", id: "$internal", registrations: true, matches: false };
        }
        get mode() {
          return "notebook";
        }
        handles(textDocument) {
          return vscode.languages.match(this.selector, textDocument) > 0;
        }
        didOpenNotebookCellTextDocument(notebookDocument, cell) {
          if (vscode.languages.match(this.selector, cell.document) === 0) {
            return;
          }
          if (!this.notebookDidOpen.has(notebookDocument.uri.toString())) {
            return;
          }
          const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
          const cellMatches = this.cellMatches(notebookDocument, cell);
          if (syncInfo !== void 0) {
            const cellIsSynced = syncInfo.uris.has(cell.document.uri.toString());
            if (cellMatches && cellIsSynced || !cellMatches && !cellIsSynced) {
              return;
            }
            if (cellMatches) {
              const matchingCells = this.getMatchingCells(notebookDocument);
              if (matchingCells !== void 0) {
                const event = this.asNotebookDocumentChangeEvent(notebookDocument, void 0, syncInfo, matchingCells);
                if (event !== void 0) {
                  this.doSendChange(event, matchingCells).catch(() => {
                  });
                }
              }
            }
          } else {
            if (cellMatches) {
              this.doSendOpen(notebookDocument, [cell]).catch(() => {
              });
            }
          }
        }
        didChangeNotebookCellTextDocument(notebookDocument, event) {
          if (vscode.languages.match(this.selector, event.document) === 0) {
            return;
          }
          this.doSendChange({
            notebook: notebookDocument,
            cells: { textContent: [event] }
          }, void 0).catch(() => {
          });
        }
        didCloseNotebookCellTextDocument(notebookDocument, cell) {
          const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
          if (syncInfo === void 0) {
            return;
          }
          const cellUri = cell.document.uri;
          const index = syncInfo.cells.findIndex((item) => item.document.uri.toString() === cellUri.toString());
          if (index === -1) {
            return;
          }
          if (index === 0 && syncInfo.cells.length === 1) {
            this.doSendClose(notebookDocument, syncInfo.cells).catch(() => {
            });
          } else {
            const newCells = syncInfo.cells.slice();
            const deleted = newCells.splice(index, 1);
            this.doSendChange({
              notebook: notebookDocument,
              cells: {
                structure: {
                  array: { start: index, deleteCount: 1 },
                  didClose: deleted
                }
              }
            }, newCells).catch(() => {
            });
          }
        }
        dispose() {
          for (const disposable of this.disposables) {
            disposable.dispose();
          }
        }
        didOpen(notebookDocument, matchingCells = this.getMatchingCells(notebookDocument), syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString())) {
          if (syncInfo !== void 0) {
            if (matchingCells !== void 0) {
              const event = this.asNotebookDocumentChangeEvent(notebookDocument, void 0, syncInfo, matchingCells);
              if (event !== void 0) {
                this.doSendChange(event, matchingCells).catch(() => {
                });
              }
            } else {
              this.doSendClose(notebookDocument, []).catch(() => {
              });
            }
          } else {
            if (matchingCells === void 0) {
              return;
            }
            this.doSendOpen(notebookDocument, matchingCells).catch(() => {
            });
          }
        }
        didChangeNotebookDocument(event) {
          const notebookDocument = event.notebook;
          const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
          if (syncInfo === void 0) {
            if (event.contentChanges.length === 0) {
              return;
            }
            const cells = this.getMatchingCells(notebookDocument);
            if (cells === void 0) {
              return;
            }
            this.didOpen(notebookDocument, cells, syncInfo);
          } else {
            const cells = this.getMatchingCells(notebookDocument);
            if (cells === void 0) {
              this.didClose(notebookDocument, syncInfo);
              return;
            }
            const newEvent = this.asNotebookDocumentChangeEvent(event.notebook, event, syncInfo, cells);
            if (newEvent !== void 0) {
              this.doSendChange(newEvent, cells).catch(() => {
              });
            }
          }
        }
        didSave(notebookDocument) {
          const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
          if (syncInfo === void 0) {
            return;
          }
          this.doSendSave(notebookDocument).catch(() => {
          });
        }
        didClose(notebookDocument, syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString())) {
          if (syncInfo === void 0) {
            return;
          }
          const syncedCells = notebookDocument.getCells().filter((cell) => syncInfo.uris.has(cell.document.uri.toString()));
          this.doSendClose(notebookDocument, syncedCells).catch(() => {
          });
        }
        async sendDidOpenNotebookDocument(notebookDocument) {
          const cells = this.getMatchingCells(notebookDocument);
          if (cells === void 0) {
            return;
          }
          return this.doSendOpen(notebookDocument, cells);
        }
        async doSendOpen(notebookDocument, cells) {
          const send = async (notebookDocument2, cells2) => {
            const nb = Converter.c2p.asNotebookDocument(notebookDocument2, cells2, this.client.code2ProtocolConverter);
            const cellDocuments = cells2.map((cell) => this.client.code2ProtocolConverter.asTextDocumentItem(cell.document));
            try {
              await this.client.sendNotification(proto.DidOpenNotebookDocumentNotification.type, {
                notebookDocument: nb,
                cellTextDocuments: cellDocuments
              });
            } catch (error) {
              this.client.error("Sending DidOpenNotebookDocumentNotification failed", error);
              throw error;
            }
          };
          const middleware = this.client.middleware?.notebooks;
          this.notebookSyncInfo.set(notebookDocument.uri.toString(), SyncInfo.create(cells));
          return middleware?.didOpen !== void 0 ? middleware.didOpen(notebookDocument, cells, send) : send(notebookDocument, cells);
        }
        async sendDidChangeNotebookDocument(event) {
          return this.doSendChange(event, void 0);
        }
        async doSendChange(event, cells = this.getMatchingCells(event.notebook)) {
          const send = async (event2) => {
            try {
              await this.client.sendNotification(proto.DidChangeNotebookDocumentNotification.type, {
                notebookDocument: Converter.c2p.asVersionedNotebookDocumentIdentifier(event2.notebook, this.client.code2ProtocolConverter),
                change: Converter.c2p.asNotebookDocumentChangeEvent(event2, this.client.code2ProtocolConverter)
              });
            } catch (error) {
              this.client.error("Sending DidChangeNotebookDocumentNotification failed", error);
              throw error;
            }
          };
          const middleware = this.client.middleware?.notebooks;
          if (event.cells?.structure !== void 0) {
            this.notebookSyncInfo.set(event.notebook.uri.toString(), SyncInfo.create(cells ?? []));
          }
          return middleware?.didChange !== void 0 ? middleware?.didChange(event, send) : send(event);
        }
        async sendDidSaveNotebookDocument(notebookDocument) {
          return this.doSendSave(notebookDocument);
        }
        async doSendSave(notebookDocument) {
          const send = async (notebookDocument2) => {
            try {
              await this.client.sendNotification(proto.DidSaveNotebookDocumentNotification.type, {
                notebookDocument: { uri: this.client.code2ProtocolConverter.asUri(notebookDocument2.uri) }
              });
            } catch (error) {
              this.client.error("Sending DidSaveNotebookDocumentNotification failed", error);
              throw error;
            }
          };
          const middleware = this.client.middleware?.notebooks;
          return middleware?.didSave !== void 0 ? middleware.didSave(notebookDocument, send) : send(notebookDocument);
        }
        async sendDidCloseNotebookDocument(notebookDocument) {
          return this.doSendClose(notebookDocument, this.getMatchingCells(notebookDocument) ?? []);
        }
        async doSendClose(notebookDocument, cells) {
          const send = async (notebookDocument2, cells2) => {
            try {
              await this.client.sendNotification(proto.DidCloseNotebookDocumentNotification.type, {
                notebookDocument: { uri: this.client.code2ProtocolConverter.asUri(notebookDocument2.uri) },
                cellTextDocuments: cells2.map((cell) => this.client.code2ProtocolConverter.asTextDocumentIdentifier(cell.document))
              });
            } catch (error) {
              this.client.error("Sending DidCloseNotebookDocumentNotification failed", error);
              throw error;
            }
          };
          const middleware = this.client.middleware?.notebooks;
          this.notebookSyncInfo.delete(notebookDocument.uri.toString());
          return middleware?.didClose !== void 0 ? middleware.didClose(notebookDocument, cells, send) : send(notebookDocument, cells);
        }
        asNotebookDocumentChangeEvent(notebook, event, syncInfo, matchingCells) {
          if (event !== void 0 && event.notebook !== notebook) {
            throw new Error("Notebook must be identical");
          }
          const result = {
            notebook
          };
          if (event?.metadata !== void 0) {
            result.metadata = Converter.c2p.asMetadata(event.metadata);
          }
          let matchingCellsSet;
          if (event?.cellChanges !== void 0 && event.cellChanges.length > 0) {
            const data = [];
            matchingCellsSet = new Set(matchingCells.map((cell) => cell.document.uri.toString()));
            for (const cellChange of event.cellChanges) {
              if (matchingCellsSet.has(cellChange.cell.document.uri.toString()) && (cellChange.executionSummary !== void 0 || cellChange.metadata !== void 0)) {
                data.push(cellChange.cell);
              }
            }
            if (data.length > 0) {
              result.cells = result.cells ?? {};
              result.cells.data = data;
            }
          }
          if ((event?.contentChanges !== void 0 && event.contentChanges.length > 0 || event === void 0) && syncInfo !== void 0 && matchingCells !== void 0) {
            const oldCells = syncInfo.cells;
            const newCells = matchingCells;
            const diff = $NotebookCell.computeDiff(oldCells, newCells, false);
            let addedCells;
            let removedCells;
            if (diff !== void 0) {
              addedCells = diff.cells === void 0 ? /* @__PURE__ */ new Map() : new Map(diff.cells.map((cell) => [cell.document.uri.toString(), cell]));
              removedCells = diff.deleteCount === 0 ? /* @__PURE__ */ new Map() : new Map(oldCells.slice(diff.start, diff.start + diff.deleteCount).map((cell) => [cell.document.uri.toString(), cell]));
              for (const key of Array.from(removedCells.keys())) {
                if (addedCells.has(key)) {
                  removedCells.delete(key);
                  addedCells.delete(key);
                }
              }
              result.cells = result.cells ?? {};
              const didOpen = [];
              const didClose = [];
              if (addedCells.size > 0 || removedCells.size > 0) {
                for (const cell of addedCells.values()) {
                  didOpen.push(cell);
                }
                for (const cell of removedCells.values()) {
                  didClose.push(cell);
                }
              }
              result.cells.structure = {
                array: diff,
                didOpen,
                didClose
              };
            }
          }
          return Object.keys(result).length > 1 ? result : void 0;
        }
        getMatchingCells(notebookDocument, cells = notebookDocument.getCells()) {
          if (this.options.notebookSelector === void 0) {
            return void 0;
          }
          for (const item of this.options.notebookSelector) {
            if (item.notebook === void 0 || $NotebookDocumentFilter.matchNotebook(item.notebook, notebookDocument)) {
              const filtered = this.filterCells(notebookDocument, cells, item.cells);
              return filtered.length === 0 ? void 0 : filtered;
            }
          }
          return void 0;
        }
        cellMatches(notebookDocument, cell) {
          const cells = this.getMatchingCells(notebookDocument, [cell]);
          return cells !== void 0 && cells[0] === cell;
        }
        filterCells(notebookDocument, cells, cellSelector) {
          const filtered = cellSelector !== void 0 ? cells.filter((cell) => {
            const cellLanguage = cell.document.languageId;
            return cellSelector.some((filter) => filter.language === "*" || cellLanguage === filter.language);
          }) : cells;
          return typeof this.client.clientOptions.notebookDocumentOptions?.filterCells === "function" ? this.client.clientOptions.notebookDocumentOptions.filterCells(notebookDocument, filtered) : filtered;
        }
      };
      var NotebookDocumentSyncFeature = class {
        constructor(client) {
          this.client = client;
          this.registrations = /* @__PURE__ */ new Map();
          this.registrationType = proto.NotebookDocumentSyncRegistrationType.type;
          vscode.workspace.onDidOpenTextDocument((textDocument) => {
            if (textDocument.uri.scheme !== NotebookDocumentSyncFeature.CellScheme) {
              return;
            }
            const [notebookDocument, notebookCell] = this.findNotebookDocumentAndCell(textDocument);
            if (notebookDocument === void 0 || notebookCell === void 0) {
              return;
            }
            for (const provider of this.registrations.values()) {
              if (provider instanceof NotebookDocumentSyncFeatureProvider) {
                provider.didOpenNotebookCellTextDocument(notebookDocument, notebookCell);
              }
            }
          });
          vscode.workspace.onDidChangeTextDocument((event) => {
            if (event.contentChanges.length === 0) {
              return;
            }
            const textDocument = event.document;
            if (textDocument.uri.scheme !== NotebookDocumentSyncFeature.CellScheme) {
              return;
            }
            const [notebookDocument] = this.findNotebookDocumentAndCell(textDocument);
            if (notebookDocument === void 0) {
              return;
            }
            for (const provider of this.registrations.values()) {
              if (provider instanceof NotebookDocumentSyncFeatureProvider) {
                provider.didChangeNotebookCellTextDocument(notebookDocument, event);
              }
            }
          });
          vscode.workspace.onDidCloseTextDocument((textDocument) => {
            if (textDocument.uri.scheme !== NotebookDocumentSyncFeature.CellScheme) {
              return;
            }
            const [notebookDocument, notebookCell] = this.findNotebookDocumentAndCell(textDocument);
            if (notebookDocument === void 0 || notebookCell === void 0) {
              return;
            }
            for (const provider of this.registrations.values()) {
              if (provider instanceof NotebookDocumentSyncFeatureProvider) {
                provider.didCloseNotebookCellTextDocument(notebookDocument, notebookCell);
              }
            }
          });
        }
        getState() {
          if (this.registrations.size === 0) {
            return { kind: "document", id: this.registrationType.method, registrations: false, matches: false };
          }
          for (const provider of this.registrations.values()) {
            const state = provider.getState();
            if (state.kind === "document" && state.registrations === true && state.matches === true) {
              return { kind: "document", id: this.registrationType.method, registrations: true, matches: true };
            }
          }
          return { kind: "document", id: this.registrationType.method, registrations: true, matches: false };
        }
        fillClientCapabilities(capabilities) {
          const synchronization = ensure(ensure(capabilities, "notebookDocument"), "synchronization");
          synchronization.dynamicRegistration = true;
          synchronization.executionSummarySupport = true;
        }
        preInitialize(capabilities) {
          const options = capabilities.notebookDocumentSync;
          if (options === void 0) {
            return;
          }
          this.dedicatedChannel = this.client.protocol2CodeConverter.asDocumentSelector($NotebookDocumentSyncOptions.asDocumentSelector(options));
        }
        initialize(capabilities) {
          const options = capabilities.notebookDocumentSync;
          if (options === void 0) {
            return;
          }
          const id2 = options.id ?? UUID.generateUuid();
          this.register({ id: id2, registerOptions: options });
        }
        register(data) {
          const provider = new NotebookDocumentSyncFeatureProvider(this.client, data.registerOptions);
          this.registrations.set(data.id, provider);
        }
        unregister(id2) {
          const provider = this.registrations.get(id2);
          provider && provider.dispose();
        }
        dispose() {
          for (const provider of this.registrations.values()) {
            provider.dispose();
          }
          this.registrations.clear();
        }
        handles(textDocument) {
          if (textDocument.uri.scheme !== NotebookDocumentSyncFeature.CellScheme) {
            return false;
          }
          if (this.dedicatedChannel !== void 0 && vscode.languages.match(this.dedicatedChannel, textDocument) > 0) {
            return true;
          }
          for (const provider of this.registrations.values()) {
            if (provider.handles(textDocument)) {
              return true;
            }
          }
          return false;
        }
        getProvider(notebookCell) {
          for (const provider of this.registrations.values()) {
            if (provider.handles(notebookCell.document)) {
              return provider;
            }
          }
          return void 0;
        }
        findNotebookDocumentAndCell(textDocument) {
          const uri = textDocument.uri.toString();
          for (const notebookDocument of vscode.workspace.notebookDocuments) {
            for (const cell of notebookDocument.getCells()) {
              if (cell.document.uri.toString() === uri) {
                return [notebookDocument, cell];
              }
            }
          }
          return [void 0, void 0];
        }
      };
      exports2.NotebookDocumentSyncFeature = NotebookDocumentSyncFeature;
      NotebookDocumentSyncFeature.CellScheme = "vscode-notebook-cell";
    }
  });

  // node_modules/vscode-languageclient/lib/common/configuration.js
  var require_configuration3 = __commonJS({
    "node_modules/vscode-languageclient/lib/common/configuration.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SyncConfigurationFeature = exports2.toJSONObject = exports2.ConfigurationFeature = void 0;
      var vscode_1 = (init_api(), __toCommonJS(api_exports));
      var vscode_languageserver_protocol_1 = require_main3();
      var Is = require_is4();
      var UUID = require_uuid2();
      var features_1 = require_features();
      var ConfigurationFeature = class {
        constructor(client) {
          this._client = client;
        }
        getState() {
          return { kind: "static" };
        }
        fillClientCapabilities(capabilities) {
          capabilities.workspace = capabilities.workspace || {};
          capabilities.workspace.configuration = true;
        }
        initialize() {
          let client = this._client;
          client.onRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, (params, token) => {
            let configuration = (params2) => {
              let result = [];
              for (let item of params2.items) {
                let resource = item.scopeUri !== void 0 && item.scopeUri !== null ? this._client.protocol2CodeConverter.asUri(item.scopeUri) : void 0;
                result.push(this.getConfiguration(resource, item.section !== null ? item.section : void 0));
              }
              return result;
            };
            let middleware = client.middleware.workspace;
            return middleware && middleware.configuration ? middleware.configuration(params, token, configuration) : configuration(params, token);
          });
        }
        getConfiguration(resource, section) {
          let result = null;
          if (section) {
            let index = section.lastIndexOf(".");
            if (index === -1) {
              result = toJSONObject(vscode_1.workspace.getConfiguration(void 0, resource).get(section));
            } else {
              let config = vscode_1.workspace.getConfiguration(section.substr(0, index), resource);
              if (config) {
                result = toJSONObject(config.get(section.substr(index + 1)));
              }
            }
          } else {
            let config = vscode_1.workspace.getConfiguration(void 0, resource);
            result = {};
            for (let key of Object.keys(config)) {
              if (config.has(key)) {
                result[key] = toJSONObject(config.get(key));
              }
            }
          }
          if (result === void 0) {
            result = null;
          }
          return result;
        }
        dispose() {
        }
      };
      exports2.ConfigurationFeature = ConfigurationFeature;
      function toJSONObject(obj) {
        if (obj) {
          if (Array.isArray(obj)) {
            return obj.map(toJSONObject);
          } else if (typeof obj === "object") {
            const res = /* @__PURE__ */ Object.create(null);
            for (const key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) {
                res[key] = toJSONObject(obj[key]);
              }
            }
            return res;
          }
        }
        return obj;
      }
      exports2.toJSONObject = toJSONObject;
      var SyncConfigurationFeature = class {
        constructor(_client) {
          this._client = _client;
          this._listeners = /* @__PURE__ */ new Map();
        }
        getState() {
          return { kind: "workspace", id: this.registrationType.method, registrations: this._listeners.size > 0 };
        }
        get registrationType() {
          return vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type;
        }
        fillClientCapabilities(capabilities) {
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "didChangeConfiguration").dynamicRegistration = true;
        }
        initialize() {
          let section = this._client.clientOptions.synchronize?.configurationSection;
          if (section !== void 0) {
            this.register({
              id: UUID.generateUuid(),
              registerOptions: {
                section
              }
            });
          }
        }
        register(data) {
          let disposable = vscode_1.workspace.onDidChangeConfiguration((event) => {
            this.onDidChangeConfiguration(data.registerOptions.section, event);
          });
          this._listeners.set(data.id, disposable);
          if (data.registerOptions.section !== void 0) {
            this.onDidChangeConfiguration(data.registerOptions.section, void 0);
          }
        }
        unregister(id2) {
          let disposable = this._listeners.get(id2);
          if (disposable) {
            this._listeners.delete(id2);
            disposable.dispose();
          }
        }
        dispose() {
          for (const disposable of this._listeners.values()) {
            disposable.dispose();
          }
          this._listeners.clear();
        }
        onDidChangeConfiguration(configurationSection, event) {
          let sections;
          if (Is.string(configurationSection)) {
            sections = [configurationSection];
          } else {
            sections = configurationSection;
          }
          if (sections !== void 0 && event !== void 0) {
            let affected = sections.some((section) => event.affectsConfiguration(section));
            if (!affected) {
              return;
            }
          }
          const didChangeConfiguration = async (sections2) => {
            if (sections2 === void 0) {
              return this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, { settings: null });
            } else {
              return this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, { settings: this.extractSettingsInformation(sections2) });
            }
          };
          let middleware = this._client.middleware.workspace?.didChangeConfiguration;
          (middleware ? middleware(sections, didChangeConfiguration) : didChangeConfiguration(sections)).catch((error) => {
            this._client.error(`Sending notification ${vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type.method} failed`, error);
          });
        }
        extractSettingsInformation(keys) {
          function ensurePath(config, path) {
            let current = config;
            for (let i = 0; i < path.length - 1; i++) {
              let obj = current[path[i]];
              if (!obj) {
                obj = /* @__PURE__ */ Object.create(null);
                current[path[i]] = obj;
              }
              current = obj;
            }
            return current;
          }
          let resource = this._client.clientOptions.workspaceFolder ? this._client.clientOptions.workspaceFolder.uri : void 0;
          let result = /* @__PURE__ */ Object.create(null);
          for (let i = 0; i < keys.length; i++) {
            let key = keys[i];
            let index = key.indexOf(".");
            let config = null;
            if (index >= 0) {
              config = vscode_1.workspace.getConfiguration(key.substr(0, index), resource).get(key.substr(index + 1));
            } else {
              config = vscode_1.workspace.getConfiguration(void 0, resource).get(key);
            }
            if (config) {
              let path = keys[i].split(".");
              ensurePath(result, path)[path[path.length - 1]] = toJSONObject(config);
            }
          }
          return result;
        }
      };
      exports2.SyncConfigurationFeature = SyncConfigurationFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/textSynchronization.js
  var require_textSynchronization = __commonJS({
    "node_modules/vscode-languageclient/lib/common/textSynchronization.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DidSaveTextDocumentFeature = exports2.WillSaveWaitUntilFeature = exports2.WillSaveFeature = exports2.DidChangeTextDocumentFeature = exports2.DidCloseTextDocumentFeature = exports2.DidOpenTextDocumentFeature = void 0;
      var vscode_1 = (init_api(), __toCommonJS(api_exports));
      var vscode_languageserver_protocol_1 = require_main3();
      var features_1 = require_features();
      var async_1 = require_async();
      var UUID = require_uuid2();
      var DidOpenTextDocumentFeature = class extends features_1.TextDocumentEventFeature {
        constructor(client, syncedDocuments) {
          super(client, vscode_1.workspace.onDidOpenTextDocument, vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, () => client.middleware.didOpen, (textDocument) => client.code2ProtocolConverter.asOpenTextDocumentParams(textDocument), (data) => data, features_1.TextDocumentEventFeature.textDocumentFilter);
          this._syncedDocuments = syncedDocuments;
        }
        get openDocuments() {
          return this._syncedDocuments.values();
        }
        fillClientCapabilities(capabilities) {
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "synchronization").dynamicRegistration = true;
        }
        initialize(capabilities, documentSelector) {
          const textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
          if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
            this.register({ id: UUID.generateUuid(), registerOptions: { documentSelector } });
          }
        }
        get registrationType() {
          return vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type;
        }
        register(data) {
          super.register(data);
          if (!data.registerOptions.documentSelector) {
            return;
          }
          const documentSelector = this._client.protocol2CodeConverter.asDocumentSelector(data.registerOptions.documentSelector);
          vscode_1.workspace.textDocuments.forEach((textDocument) => {
            const uri = textDocument.uri.toString();
            if (this._syncedDocuments.has(uri)) {
              return;
            }
            if (vscode_1.languages.match(documentSelector, textDocument) > 0 && !this._client.hasDedicatedTextSynchronizationFeature(textDocument)) {
              const middleware = this._client.middleware;
              const didOpen = (textDocument2) => {
                return this._client.sendNotification(this._type, this._createParams(textDocument2));
              };
              (middleware.didOpen ? middleware.didOpen(textDocument, didOpen) : didOpen(textDocument)).catch((error) => {
                this._client.error(`Sending document notification ${this._type.method} failed`, error);
              });
              this._syncedDocuments.set(uri, textDocument);
            }
          });
        }
        notificationSent(textDocument, type, params) {
          super.notificationSent(textDocument, type, params);
          this._syncedDocuments.set(textDocument.uri.toString(), textDocument);
        }
      };
      exports2.DidOpenTextDocumentFeature = DidOpenTextDocumentFeature;
      var DidCloseTextDocumentFeature = class extends features_1.TextDocumentEventFeature {
        constructor(client, syncedDocuments) {
          super(client, vscode_1.workspace.onDidCloseTextDocument, vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, () => client.middleware.didClose, (textDocument) => client.code2ProtocolConverter.asCloseTextDocumentParams(textDocument), (data) => data, features_1.TextDocumentEventFeature.textDocumentFilter);
          this._syncedDocuments = syncedDocuments;
        }
        get registrationType() {
          return vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type;
        }
        fillClientCapabilities(capabilities) {
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "synchronization").dynamicRegistration = true;
        }
        initialize(capabilities, documentSelector) {
          let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
          if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
            this.register({ id: UUID.generateUuid(), registerOptions: { documentSelector } });
          }
        }
        notificationSent(textDocument, type, params) {
          super.notificationSent(textDocument, type, params);
          this._syncedDocuments.delete(textDocument.uri.toString());
        }
        unregister(id2) {
          const selector = this._selectors.get(id2);
          super.unregister(id2);
          const selectors = this._selectors.values();
          this._syncedDocuments.forEach((textDocument) => {
            if (vscode_1.languages.match(selector, textDocument) > 0 && !this._selectorFilter(selectors, textDocument) && !this._client.hasDedicatedTextSynchronizationFeature(textDocument)) {
              let middleware = this._client.middleware;
              let didClose = (textDocument2) => {
                return this._client.sendNotification(this._type, this._createParams(textDocument2));
              };
              this._syncedDocuments.delete(textDocument.uri.toString());
              (middleware.didClose ? middleware.didClose(textDocument, didClose) : didClose(textDocument)).catch((error) => {
                this._client.error(`Sending document notification ${this._type.method} failed`, error);
              });
            }
          });
        }
      };
      exports2.DidCloseTextDocumentFeature = DidCloseTextDocumentFeature;
      var DidChangeTextDocumentFeature = class extends features_1.DynamicDocumentFeature {
        constructor(client) {
          super(client);
          this._forcingDelivery = false;
          this._changeData = /* @__PURE__ */ new Map();
          this._onNotificationSent = new vscode_1.EventEmitter();
        }
        get registrationType() {
          return vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type;
        }
        fillClientCapabilities(capabilities) {
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "synchronization").dynamicRegistration = true;
        }
        initialize(capabilities, documentSelector) {
          let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
          if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.change !== void 0 && textDocumentSyncOptions.change !== vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {
            this.register({
              id: UUID.generateUuid(),
              registerOptions: Object.assign({}, { documentSelector }, { syncKind: textDocumentSyncOptions.change })
            });
          }
        }
        register(data) {
          if (!data.registerOptions.documentSelector) {
            return;
          }
          if (!this._listener) {
            this._listener = vscode_1.workspace.onDidChangeTextDocument(this.callback, this);
          }
          this._changeData.set(data.id, {
            syncKind: data.registerOptions.syncKind,
            documentSelector: this._client.protocol2CodeConverter.asDocumentSelector(data.registerOptions.documentSelector)
          });
        }
        *getDocumentSelectors() {
          for (const data of this._changeData.values()) {
            yield data.documentSelector;
          }
        }
        async callback(event) {
          if (event.contentChanges.length === 0) {
            return;
          }
          const promises = [];
          for (const changeData of this._changeData.values()) {
            if (vscode_1.languages.match(changeData.documentSelector, event.document) > 0 && !this._client.hasDedicatedTextSynchronizationFeature(event.document)) {
              const middleware = this._client.middleware;
              if (changeData.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental) {
                const didChange = async (event2) => {
                  const params = this._client.code2ProtocolConverter.asChangeTextDocumentParams(event2);
                  await this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
                  this.notificationSent(event2, vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
                };
                promises.push(middleware.didChange ? middleware.didChange(event, (event2) => didChange(event2)) : didChange(event));
              } else if (changeData.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Full) {
                const didChange = async (event2) => {
                  const doSend = async (event3) => {
                    const params = this._client.code2ProtocolConverter.asChangeTextDocumentParams(event3.document);
                    await this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
                    this.notificationSent(event3, vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
                  };
                  if (this._changeDelayer) {
                    if (this._changeDelayer.uri !== event2.document.uri.toString()) {
                      await this.forceDelivery();
                      this._changeDelayer.uri = event2.document.uri.toString();
                    }
                    return this._changeDelayer.delayer.trigger(() => doSend(event2));
                  } else {
                    this._changeDelayer = {
                      uri: event2.document.uri.toString(),
                      delayer: new async_1.Delayer(200)
                    };
                    return this._changeDelayer.delayer.trigger(() => doSend(event2), -1);
                  }
                };
                promises.push(middleware.didChange ? middleware.didChange(event, (event2) => didChange(event2)) : didChange(event));
              }
            }
          }
          return Promise.all(promises).then(void 0, (error) => {
            this._client.error(`Sending document notification ${vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type.method} failed`, error);
            throw error;
          });
        }
        get onNotificationSent() {
          return this._onNotificationSent.event;
        }
        notificationSent(changeEvent, type, params) {
          this._onNotificationSent.fire({ original: changeEvent, type, params });
        }
        unregister(id2) {
          this._changeData.delete(id2);
          if (this._changeData.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = void 0;
          }
        }
        dispose() {
          if (this._changeDelayer !== void 0) {
            this._changeDelayer.delayer.cancel();
          }
          this._changeDelayer = void 0;
          this._forcingDelivery = false;
          this._changeData.clear();
          if (this._listener) {
            this._listener.dispose();
            this._listener = void 0;
          }
        }
        async forceDelivery() {
          if (this._forcingDelivery || !this._changeDelayer) {
            return;
          }
          try {
            this._forcingDelivery = true;
            return this._changeDelayer.delayer.forceDelivery();
          } finally {
            this._forcingDelivery = false;
          }
        }
        getProvider(document2) {
          for (const changeData of this._changeData.values()) {
            if (vscode_1.languages.match(changeData.documentSelector, document2) > 0) {
              return {
                send: (event) => {
                  return this.callback(event);
                }
              };
            }
          }
          return void 0;
        }
      };
      exports2.DidChangeTextDocumentFeature = DidChangeTextDocumentFeature;
      var WillSaveFeature = class extends features_1.TextDocumentEventFeature {
        constructor(client) {
          super(client, vscode_1.workspace.onWillSaveTextDocument, vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, () => client.middleware.willSave, (willSaveEvent) => client.code2ProtocolConverter.asWillSaveTextDocumentParams(willSaveEvent), (event) => event.document, (selectors, willSaveEvent) => features_1.TextDocumentEventFeature.textDocumentFilter(selectors, willSaveEvent.document));
        }
        get registrationType() {
          return vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type;
        }
        fillClientCapabilities(capabilities) {
          let value = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "synchronization");
          value.willSave = true;
        }
        initialize(capabilities, documentSelector) {
          let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
          if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSave) {
            this.register({
              id: UUID.generateUuid(),
              registerOptions: { documentSelector }
            });
          }
        }
      };
      exports2.WillSaveFeature = WillSaveFeature;
      var WillSaveWaitUntilFeature = class extends features_1.DynamicDocumentFeature {
        constructor(client) {
          super(client);
          this._selectors = /* @__PURE__ */ new Map();
        }
        getDocumentSelectors() {
          return this._selectors.values();
        }
        get registrationType() {
          return vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type;
        }
        fillClientCapabilities(capabilities) {
          let value = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "synchronization");
          value.willSaveWaitUntil = true;
        }
        initialize(capabilities, documentSelector) {
          let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
          if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSaveWaitUntil) {
            this.register({
              id: UUID.generateUuid(),
              registerOptions: { documentSelector }
            });
          }
        }
        register(data) {
          if (!data.registerOptions.documentSelector) {
            return;
          }
          if (!this._listener) {
            this._listener = vscode_1.workspace.onWillSaveTextDocument(this.callback, this);
          }
          this._selectors.set(data.id, this._client.protocol2CodeConverter.asDocumentSelector(data.registerOptions.documentSelector));
        }
        callback(event) {
          if (features_1.TextDocumentEventFeature.textDocumentFilter(this._selectors.values(), event.document) && !this._client.hasDedicatedTextSynchronizationFeature(event.document)) {
            let middleware = this._client.middleware;
            let willSaveWaitUntil = (event2) => {
              return this._client.sendRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, this._client.code2ProtocolConverter.asWillSaveTextDocumentParams(event2)).then(async (edits) => {
                let vEdits = await this._client.protocol2CodeConverter.asTextEdits(edits);
                return vEdits === void 0 ? [] : vEdits;
              });
            };
            event.waitUntil(middleware.willSaveWaitUntil ? middleware.willSaveWaitUntil(event, willSaveWaitUntil) : willSaveWaitUntil(event));
          }
        }
        unregister(id2) {
          this._selectors.delete(id2);
          if (this._selectors.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = void 0;
          }
        }
        dispose() {
          this._selectors.clear();
          if (this._listener) {
            this._listener.dispose();
            this._listener = void 0;
          }
        }
      };
      exports2.WillSaveWaitUntilFeature = WillSaveWaitUntilFeature;
      var DidSaveTextDocumentFeature = class extends features_1.TextDocumentEventFeature {
        constructor(client) {
          super(client, vscode_1.workspace.onDidSaveTextDocument, vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, () => client.middleware.didSave, (textDocument) => client.code2ProtocolConverter.asSaveTextDocumentParams(textDocument, this._includeText), (data) => data, features_1.TextDocumentEventFeature.textDocumentFilter);
          this._includeText = false;
        }
        get registrationType() {
          return vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type;
        }
        fillClientCapabilities(capabilities) {
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "synchronization").didSave = true;
        }
        initialize(capabilities, documentSelector) {
          const textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
          if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.save) {
            const saveOptions = typeof textDocumentSyncOptions.save === "boolean" ? { includeText: false } : { includeText: !!textDocumentSyncOptions.save.includeText };
            this.register({
              id: UUID.generateUuid(),
              registerOptions: Object.assign({}, { documentSelector }, saveOptions)
            });
          }
        }
        register(data) {
          this._includeText = !!data.registerOptions.includeText;
          super.register(data);
        }
      };
      exports2.DidSaveTextDocumentFeature = DidSaveTextDocumentFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/completion.js
  var require_completion = __commonJS({
    "node_modules/vscode-languageclient/lib/common/completion.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.CompletionItemFeature = void 0;
      var vscode_1 = (init_api(), __toCommonJS(api_exports));
      var vscode_languageserver_protocol_1 = require_main3();
      var features_1 = require_features();
      var UUID = require_uuid2();
      var SupportedCompletionItemKinds = [
        vscode_languageserver_protocol_1.CompletionItemKind.Text,
        vscode_languageserver_protocol_1.CompletionItemKind.Method,
        vscode_languageserver_protocol_1.CompletionItemKind.Function,
        vscode_languageserver_protocol_1.CompletionItemKind.Constructor,
        vscode_languageserver_protocol_1.CompletionItemKind.Field,
        vscode_languageserver_protocol_1.CompletionItemKind.Variable,
        vscode_languageserver_protocol_1.CompletionItemKind.Class,
        vscode_languageserver_protocol_1.CompletionItemKind.Interface,
        vscode_languageserver_protocol_1.CompletionItemKind.Module,
        vscode_languageserver_protocol_1.CompletionItemKind.Property,
        vscode_languageserver_protocol_1.CompletionItemKind.Unit,
        vscode_languageserver_protocol_1.CompletionItemKind.Value,
        vscode_languageserver_protocol_1.CompletionItemKind.Enum,
        vscode_languageserver_protocol_1.CompletionItemKind.Keyword,
        vscode_languageserver_protocol_1.CompletionItemKind.Snippet,
        vscode_languageserver_protocol_1.CompletionItemKind.Color,
        vscode_languageserver_protocol_1.CompletionItemKind.File,
        vscode_languageserver_protocol_1.CompletionItemKind.Reference,
        vscode_languageserver_protocol_1.CompletionItemKind.Folder,
        vscode_languageserver_protocol_1.CompletionItemKind.EnumMember,
        vscode_languageserver_protocol_1.CompletionItemKind.Constant,
        vscode_languageserver_protocol_1.CompletionItemKind.Struct,
        vscode_languageserver_protocol_1.CompletionItemKind.Event,
        vscode_languageserver_protocol_1.CompletionItemKind.Operator,
        vscode_languageserver_protocol_1.CompletionItemKind.TypeParameter
      ];
      var CompletionItemFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.CompletionRequest.type);
          this.labelDetailsSupport = /* @__PURE__ */ new Map();
        }
        fillClientCapabilities(capabilities) {
          let completion = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "completion");
          completion.dynamicRegistration = true;
          completion.contextSupport = true;
          completion.completionItem = {
            snippetSupport: true,
            commitCharactersSupport: true,
            documentationFormat: [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText],
            deprecatedSupport: true,
            preselectSupport: true,
            tagSupport: { valueSet: [vscode_languageserver_protocol_1.CompletionItemTag.Deprecated] },
            insertReplaceSupport: true,
            resolveSupport: {
              properties: ["documentation", "detail", "additionalTextEdits"]
            },
            insertTextModeSupport: { valueSet: [vscode_languageserver_protocol_1.InsertTextMode.asIs, vscode_languageserver_protocol_1.InsertTextMode.adjustIndentation] },
            labelDetailsSupport: true
          };
          completion.insertTextMode = vscode_languageserver_protocol_1.InsertTextMode.adjustIndentation;
          completion.completionItemKind = { valueSet: SupportedCompletionItemKinds };
          completion.completionList = {
            itemDefaults: [
              "commitCharacters",
              "editRange",
              "insertTextFormat",
              "insertTextMode"
            ]
          };
        }
        initialize(capabilities, documentSelector) {
          const options = this.getRegistrationOptions(documentSelector, capabilities.completionProvider);
          if (!options) {
            return;
          }
          this.register({
            id: UUID.generateUuid(),
            registerOptions: options
          });
        }
        registerLanguageProvider(options, id2) {
          this.labelDetailsSupport.set(id2, !!options.completionItem?.labelDetailsSupport);
          const triggerCharacters = options.triggerCharacters ?? [];
          const defaultCommitCharacters = options.allCommitCharacters;
          const selector = options.documentSelector;
          const provider = {
            provideCompletionItems: (document2, position, token, context) => {
              const client = this._client;
              const middleware = this._client.middleware;
              const provideCompletionItems = (document3, position2, context2, token2) => {
                return client.sendRequest(vscode_languageserver_protocol_1.CompletionRequest.type, client.code2ProtocolConverter.asCompletionParams(document3, position2, context2), token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asCompletionResult(result, defaultCommitCharacters, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.CompletionRequest.type, token2, error, null);
                });
              };
              return middleware.provideCompletionItem ? middleware.provideCompletionItem(document2, position, context, token, provideCompletionItems) : provideCompletionItems(document2, position, context, token);
            },
            resolveCompletionItem: options.resolveProvider ? (item, token) => {
              const client = this._client;
              const middleware = this._client.middleware;
              const resolveCompletionItem = (item2, token2) => {
                return client.sendRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, client.code2ProtocolConverter.asCompletionItem(item2, !!this.labelDetailsSupport.get(id2)), token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asCompletionItem(result);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, token2, error, item2);
                });
              };
              return middleware.resolveCompletionItem ? middleware.resolveCompletionItem(item, token, resolveCompletionItem) : resolveCompletionItem(item, token);
            } : void 0
          };
          return [vscode_1.languages.registerCompletionItemProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider, ...triggerCharacters), provider];
        }
      };
      exports2.CompletionItemFeature = CompletionItemFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/hover.js
  var require_hover = __commonJS({
    "node_modules/vscode-languageclient/lib/common/hover.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.HoverFeature = void 0;
      var vscode_1 = (init_api(), __toCommonJS(api_exports));
      var vscode_languageserver_protocol_1 = require_main3();
      var features_1 = require_features();
      var UUID = require_uuid2();
      var HoverFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.HoverRequest.type);
        }
        fillClientCapabilities(capabilities) {
          const hoverCapability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "hover");
          hoverCapability.dynamicRegistration = true;
          hoverCapability.contentFormat = [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText];
        }
        initialize(capabilities, documentSelector) {
          const options = this.getRegistrationOptions(documentSelector, capabilities.hoverProvider);
          if (!options) {
            return;
          }
          this.register({
            id: UUID.generateUuid(),
            registerOptions: options
          });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const provider = {
            provideHover: (document2, position, token) => {
              const client = this._client;
              const provideHover = (document3, position2, token2) => {
                return client.sendRequest(vscode_languageserver_protocol_1.HoverRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2), token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asHover(result);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.HoverRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideHover ? middleware.provideHover(document2, position, token, provideHover) : provideHover(document2, position, token);
            }
          };
          return [this.registerProvider(selector, provider), provider];
        }
        registerProvider(selector, provider) {
          return vscode_1.languages.registerHoverProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
        }
      };
      exports2.HoverFeature = HoverFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/definition.js
  var require_definition = __commonJS({
    "node_modules/vscode-languageclient/lib/common/definition.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DefinitionFeature = void 0;
      var vscode_1 = (init_api(), __toCommonJS(api_exports));
      var vscode_languageserver_protocol_1 = require_main3();
      var features_1 = require_features();
      var UUID = require_uuid2();
      var DefinitionFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.DefinitionRequest.type);
        }
        fillClientCapabilities(capabilities) {
          let definitionSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "definition");
          definitionSupport.dynamicRegistration = true;
          definitionSupport.linkSupport = true;
        }
        initialize(capabilities, documentSelector) {
          const options = this.getRegistrationOptions(documentSelector, capabilities.definitionProvider);
          if (!options) {
            return;
          }
          this.register({ id: UUID.generateUuid(), registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const provider = {
            provideDefinition: (document2, position, token) => {
              const client = this._client;
              const provideDefinition = (document3, position2, token2) => {
                return client.sendRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2), token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asDefinitionResult(result, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideDefinition ? middleware.provideDefinition(document2, position, token, provideDefinition) : provideDefinition(document2, position, token);
            }
          };
          return [this.registerProvider(selector, provider), provider];
        }
        registerProvider(selector, provider) {
          return vscode_1.languages.registerDefinitionProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
        }
      };
      exports2.DefinitionFeature = DefinitionFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/signatureHelp.js
  var require_signatureHelp = __commonJS({
    "node_modules/vscode-languageclient/lib/common/signatureHelp.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SignatureHelpFeature = void 0;
      var vscode_1 = (init_api(), __toCommonJS(api_exports));
      var vscode_languageserver_protocol_1 = require_main3();
      var features_1 = require_features();
      var UUID = require_uuid2();
      var SignatureHelpFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.SignatureHelpRequest.type);
        }
        fillClientCapabilities(capabilities) {
          let config = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "signatureHelp");
          config.dynamicRegistration = true;
          config.signatureInformation = { documentationFormat: [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText] };
          config.signatureInformation.parameterInformation = { labelOffsetSupport: true };
          config.signatureInformation.activeParameterSupport = true;
          config.contextSupport = true;
        }
        initialize(capabilities, documentSelector) {
          const options = this.getRegistrationOptions(documentSelector, capabilities.signatureHelpProvider);
          if (!options) {
            return;
          }
          this.register({
            id: UUID.generateUuid(),
            registerOptions: options
          });
        }
        registerLanguageProvider(options) {
          const provider = {
            provideSignatureHelp: (document2, position, token, context) => {
              const client = this._client;
              const providerSignatureHelp = (document3, position2, context2, token2) => {
                return client.sendRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, client.code2ProtocolConverter.asSignatureHelpParams(document3, position2, context2), token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asSignatureHelp(result, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideSignatureHelp ? middleware.provideSignatureHelp(document2, position, context, token, providerSignatureHelp) : providerSignatureHelp(document2, position, context, token);
            }
          };
          return [this.registerProvider(options, provider), provider];
        }
        registerProvider(options, provider) {
          const selector = this._client.protocol2CodeConverter.asDocumentSelector(options.documentSelector);
          if (options.retriggerCharacters === void 0) {
            const triggerCharacters = options.triggerCharacters || [];
            return vscode_1.languages.registerSignatureHelpProvider(selector, provider, ...triggerCharacters);
          } else {
            const metaData = {
              triggerCharacters: options.triggerCharacters || [],
              retriggerCharacters: options.retriggerCharacters || []
            };
            return vscode_1.languages.registerSignatureHelpProvider(selector, provider, metaData);
          }
        }
      };
      exports2.SignatureHelpFeature = SignatureHelpFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/documentHighlight.js
  var require_documentHighlight = __commonJS({
    "node_modules/vscode-languageclient/lib/common/documentHighlight.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DocumentHighlightFeature = void 0;
      var vscode_1 = (init_api(), __toCommonJS(api_exports));
      var vscode_languageserver_protocol_1 = require_main3();
      var features_1 = require_features();
      var UUID = require_uuid2();
      var DocumentHighlightFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.DocumentHighlightRequest.type);
        }
        fillClientCapabilities(capabilities) {
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "documentHighlight").dynamicRegistration = true;
        }
        initialize(capabilities, documentSelector) {
          const options = this.getRegistrationOptions(documentSelector, capabilities.documentHighlightProvider);
          if (!options) {
            return;
          }
          this.register({ id: UUID.generateUuid(), registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const provider = {
            provideDocumentHighlights: (document2, position, token) => {
              const client = this._client;
              const _provideDocumentHighlights = (document3, position2, token2) => {
                return client.sendRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2), token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asDocumentHighlights(result, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideDocumentHighlights ? middleware.provideDocumentHighlights(document2, position, token, _provideDocumentHighlights) : _provideDocumentHighlights(document2, position, token);
            }
          };
          return [vscode_1.languages.registerDocumentHighlightProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
        }
      };
      exports2.DocumentHighlightFeature = DocumentHighlightFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/documentSymbol.js
  var require_documentSymbol = __commonJS({
    "node_modules/vscode-languageclient/lib/common/documentSymbol.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DocumentSymbolFeature = exports2.SupportedSymbolTags = exports2.SupportedSymbolKinds = void 0;
      var vscode_1 = (init_api(), __toCommonJS(api_exports));
      var vscode_languageserver_protocol_1 = require_main3();
      var features_1 = require_features();
      var UUID = require_uuid2();
      exports2.SupportedSymbolKinds = [
        vscode_languageserver_protocol_1.SymbolKind.File,
        vscode_languageserver_protocol_1.SymbolKind.Module,
        vscode_languageserver_protocol_1.SymbolKind.Namespace,
        vscode_languageserver_protocol_1.SymbolKind.Package,
        vscode_languageserver_protocol_1.SymbolKind.Class,
        vscode_languageserver_protocol_1.SymbolKind.Method,
        vscode_languageserver_protocol_1.SymbolKind.Property,
        vscode_languageserver_protocol_1.SymbolKind.Field,
        vscode_languageserver_protocol_1.SymbolKind.Constructor,
        vscode_languageserver_protocol_1.SymbolKind.Enum,
        vscode_languageserver_protocol_1.SymbolKind.Interface,
        vscode_languageserver_protocol_1.SymbolKind.Function,
        vscode_languageserver_protocol_1.SymbolKind.Variable,
        vscode_languageserver_protocol_1.SymbolKind.Constant,
        vscode_languageserver_protocol_1.SymbolKind.String,
        vscode_languageserver_protocol_1.SymbolKind.Number,
        vscode_languageserver_protocol_1.SymbolKind.Boolean,
        vscode_languageserver_protocol_1.SymbolKind.Array,
        vscode_languageserver_protocol_1.SymbolKind.Object,
        vscode_languageserver_protocol_1.SymbolKind.Key,
        vscode_languageserver_protocol_1.SymbolKind.Null,
        vscode_languageserver_protocol_1.SymbolKind.EnumMember,
        vscode_languageserver_protocol_1.SymbolKind.Struct,
        vscode_languageserver_protocol_1.SymbolKind.Event,
        vscode_languageserver_protocol_1.SymbolKind.Operator,
        vscode_languageserver_protocol_1.SymbolKind.TypeParameter
      ];
      exports2.SupportedSymbolTags = [
        vscode_languageserver_protocol_1.SymbolTag.Deprecated
      ];
      var DocumentSymbolFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.DocumentSymbolRequest.type);
        }
        fillClientCapabilities(capabilities) {
          let symbolCapabilities = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "documentSymbol");
          symbolCapabilities.dynamicRegistration = true;
          symbolCapabilities.symbolKind = {
            valueSet: exports2.SupportedSymbolKinds
          };
          symbolCapabilities.hierarchicalDocumentSymbolSupport = true;
          symbolCapabilities.tagSupport = {
            valueSet: exports2.SupportedSymbolTags
          };
          symbolCapabilities.labelSupport = true;
        }
        initialize(capabilities, documentSelector) {
          const options = this.getRegistrationOptions(documentSelector, capabilities.documentSymbolProvider);
          if (!options) {
            return;
          }
          this.register({ id: UUID.generateUuid(), registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const provider = {
            provideDocumentSymbols: (document2, token) => {
              const client = this._client;
              const _provideDocumentSymbols = (document3, token2) => {
                return client.sendRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, client.code2ProtocolConverter.asDocumentSymbolParams(document3), token2).then(async (data) => {
                  if (token2.isCancellationRequested || data === void 0 || data === null) {
                    return null;
                  }
                  if (data.length === 0) {
                    return [];
                  } else {
                    const first = data[0];
                    if (vscode_languageserver_protocol_1.DocumentSymbol.is(first)) {
                      return await client.protocol2CodeConverter.asDocumentSymbols(data, token2);
                    } else {
                      return await client.protocol2CodeConverter.asSymbolInformations(data, token2);
                    }
                  }
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideDocumentSymbols ? middleware.provideDocumentSymbols(document2, token, _provideDocumentSymbols) : _provideDocumentSymbols(document2, token);
            }
          };
          const metaData = options.label !== void 0 ? { label: options.label } : void 0;
          return [vscode_1.languages.registerDocumentSymbolProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider, metaData), provider];
        }
      };
      exports2.DocumentSymbolFeature = DocumentSymbolFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/workspaceSymbol.js
  var require_workspaceSymbol = __commonJS({
    "node_modules/vscode-languageclient/lib/common/workspaceSymbol.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.WorkspaceSymbolFeature = void 0;
      var vscode_1 = (init_api(), __toCommonJS(api_exports));
      var vscode_languageserver_protocol_1 = require_main3();
      var features_1 = require_features();
      var documentSymbol_1 = require_documentSymbol();
      var UUID = require_uuid2();
      var WorkspaceSymbolFeature = class extends features_1.WorkspaceFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type);
        }
        fillClientCapabilities(capabilities) {
          let symbolCapabilities = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "symbol");
          symbolCapabilities.dynamicRegistration = true;
          symbolCapabilities.symbolKind = {
            valueSet: documentSymbol_1.SupportedSymbolKinds
          };
          symbolCapabilities.tagSupport = {
            valueSet: documentSymbol_1.SupportedSymbolTags
          };
          symbolCapabilities.resolveSupport = { properties: ["location.range"] };
        }
        initialize(capabilities) {
          if (!capabilities.workspaceSymbolProvider) {
            return;
          }
          this.register({
            id: UUID.generateUuid(),
            registerOptions: capabilities.workspaceSymbolProvider === true ? { workDoneProgress: false } : capabilities.workspaceSymbolProvider
          });
        }
        registerLanguageProvider(options) {
          const provider = {
            provideWorkspaceSymbols: (query, token) => {
              const client = this._client;
              const provideWorkspaceSymbols = (query2, token2) => {
                return client.sendRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, { query: query2 }, token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asSymbolInformations(result, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideWorkspaceSymbols ? middleware.provideWorkspaceSymbols(query, token, provideWorkspaceSymbols) : provideWorkspaceSymbols(query, token);
            },
            resolveWorkspaceSymbol: options.resolveProvider === true ? (item, token) => {
              const client = this._client;
              const resolveWorkspaceSymbol = (item2, token2) => {
                return client.sendRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, client.code2ProtocolConverter.asWorkspaceSymbol(item2), token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asSymbolInformation(result);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.resolveWorkspaceSymbol ? middleware.resolveWorkspaceSymbol(item, token, resolveWorkspaceSymbol) : resolveWorkspaceSymbol(item, token);
            } : void 0
          };
          return [vscode_1.languages.registerWorkspaceSymbolProvider(provider), provider];
        }
      };
      exports2.WorkspaceSymbolFeature = WorkspaceSymbolFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/reference.js
  var require_reference = __commonJS({
    "node_modules/vscode-languageclient/lib/common/reference.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ReferencesFeature = void 0;
      var vscode_1 = (init_api(), __toCommonJS(api_exports));
      var vscode_languageserver_protocol_1 = require_main3();
      var features_1 = require_features();
      var UUID = require_uuid2();
      var ReferencesFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.ReferencesRequest.type);
        }
        fillClientCapabilities(capabilities) {
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "references").dynamicRegistration = true;
        }
        initialize(capabilities, documentSelector) {
          const options = this.getRegistrationOptions(documentSelector, capabilities.referencesProvider);
          if (!options) {
            return;
          }
          this.register({ id: UUID.generateUuid(), registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const provider = {
            provideReferences: (document2, position, options2, token) => {
              const client = this._client;
              const _providerReferences = (document3, position2, options3, token2) => {
                return client.sendRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, client.code2ProtocolConverter.asReferenceParams(document3, position2, options3), token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asReferences(result, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideReferences ? middleware.provideReferences(document2, position, options2, token, _providerReferences) : _providerReferences(document2, position, options2, token);
            }
          };
          return [this.registerProvider(selector, provider), provider];
        }
        registerProvider(selector, provider) {
          return vscode_1.languages.registerReferenceProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
        }
      };
      exports2.ReferencesFeature = ReferencesFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/codeAction.js
  var require_codeAction = __commonJS({
    "node_modules/vscode-languageclient/lib/common/codeAction.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.CodeActionFeature = void 0;
      var vscode_1 = (init_api(), __toCommonJS(api_exports));
      var vscode_languageserver_protocol_1 = require_main3();
      var UUID = require_uuid2();
      var features_1 = require_features();
      var CodeActionFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.CodeActionRequest.type);
        }
        fillClientCapabilities(capabilities) {
          const cap = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "codeAction");
          cap.dynamicRegistration = true;
          cap.isPreferredSupport = true;
          cap.disabledSupport = true;
          cap.dataSupport = true;
          cap.resolveSupport = {
            properties: ["edit"]
          };
          cap.codeActionLiteralSupport = {
            codeActionKind: {
              valueSet: [
                vscode_languageserver_protocol_1.CodeActionKind.Empty,
                vscode_languageserver_protocol_1.CodeActionKind.QuickFix,
                vscode_languageserver_protocol_1.CodeActionKind.Refactor,
                vscode_languageserver_protocol_1.CodeActionKind.RefactorExtract,
                vscode_languageserver_protocol_1.CodeActionKind.RefactorInline,
                vscode_languageserver_protocol_1.CodeActionKind.RefactorRewrite,
                vscode_languageserver_protocol_1.CodeActionKind.Source,
                vscode_languageserver_protocol_1.CodeActionKind.SourceOrganizeImports
              ]
            }
          };
          cap.honorsChangeAnnotations = false;
        }
        initialize(capabilities, documentSelector) {
          const options = this.getRegistrationOptions(documentSelector, capabilities.codeActionProvider);
          if (!options) {
            return;
          }
          this.register({ id: UUID.generateUuid(), registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const provider = {
            provideCodeActions: (document2, range, context, token) => {
              const client = this._client;
              const _provideCodeActions = async (document3, range2, context2, token2) => {
                const params = {
                  textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                  range: client.code2ProtocolConverter.asRange(range2),
                  context: await client.code2ProtocolConverter.asCodeActionContext(context2, token2)
                };
                return client.sendRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, params, token2).then((values) => {
                  if (token2.isCancellationRequested || values === null || values === void 0) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asCodeActionResult(values, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideCodeActions ? middleware.provideCodeActions(document2, range, context, token, _provideCodeActions) : _provideCodeActions(document2, range, context, token);
            },
            resolveCodeAction: options.resolveProvider ? (item, token) => {
              const client = this._client;
              const middleware = this._client.middleware;
              const resolveCodeAction = async (item2, token2) => {
                return client.sendRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, await client.code2ProtocolConverter.asCodeAction(item2, token2), token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return item2;
                  }
                  return client.protocol2CodeConverter.asCodeAction(result, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, token2, error, item2);
                });
              };
              return middleware.resolveCodeAction ? middleware.resolveCodeAction(item, token, resolveCodeAction) : resolveCodeAction(item, token);
            } : void 0
          };
          return [vscode_1.languages.registerCodeActionsProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider, options.codeActionKinds ? { providedCodeActionKinds: this._client.protocol2CodeConverter.asCodeActionKinds(options.codeActionKinds) } : void 0), provider];
        }
      };
      exports2.CodeActionFeature = CodeActionFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/codeLens.js
  var require_codeLens = __commonJS({
    "node_modules/vscode-languageclient/lib/common/codeLens.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.CodeLensFeature = void 0;
      var vscode_1 = (init_api(), __toCommonJS(api_exports));
      var vscode_languageserver_protocol_1 = require_main3();
      var UUID = require_uuid2();
      var features_1 = require_features();
      var CodeLensFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.CodeLensRequest.type);
        }
        fillClientCapabilities(capabilities) {
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "codeLens").dynamicRegistration = true;
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "codeLens").refreshSupport = true;
        }
        initialize(capabilities, documentSelector) {
          const client = this._client;
          client.onRequest(vscode_languageserver_protocol_1.CodeLensRefreshRequest.type, async () => {
            for (const provider of this.getAllProviders()) {
              provider.onDidChangeCodeLensEmitter.fire();
            }
          });
          const options = this.getRegistrationOptions(documentSelector, capabilities.codeLensProvider);
          if (!options) {
            return;
          }
          this.register({ id: UUID.generateUuid(), registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const eventEmitter = new vscode_1.EventEmitter();
          const provider = {
            onDidChangeCodeLenses: eventEmitter.event,
            provideCodeLenses: (document2, token) => {
              const client = this._client;
              const provideCodeLenses = (document3, token2) => {
                return client.sendRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, client.code2ProtocolConverter.asCodeLensParams(document3), token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asCodeLenses(result, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideCodeLenses ? middleware.provideCodeLenses(document2, token, provideCodeLenses) : provideCodeLenses(document2, token);
            },
            resolveCodeLens: options.resolveProvider ? (codeLens, token) => {
              const client = this._client;
              const resolveCodeLens = (codeLens2, token2) => {
                return client.sendRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, client.code2ProtocolConverter.asCodeLens(codeLens2), token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return codeLens2;
                  }
                  return client.protocol2CodeConverter.asCodeLens(result);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, token2, error, codeLens2);
                });
              };
              const middleware = client.middleware;
              return middleware.resolveCodeLens ? middleware.resolveCodeLens(codeLens, token, resolveCodeLens) : resolveCodeLens(codeLens, token);
            } : void 0
          };
          return [vscode_1.languages.registerCodeLensProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), { provider, onDidChangeCodeLensEmitter: eventEmitter }];
        }
      };
      exports2.CodeLensFeature = CodeLensFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/formatting.js
  var require_formatting = __commonJS({
    "node_modules/vscode-languageclient/lib/common/formatting.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DocumentOnTypeFormattingFeature = exports2.DocumentRangeFormattingFeature = exports2.DocumentFormattingFeature = void 0;
      var vscode_1 = (init_api(), __toCommonJS(api_exports));
      var vscode_languageserver_protocol_1 = require_main3();
      var UUID = require_uuid2();
      var features_1 = require_features();
      var FileFormattingOptions;
      (function(FileFormattingOptions2) {
        function fromConfiguration(document2) {
          const filesConfig = vscode_1.workspace.getConfiguration("files", document2);
          return {
            trimTrailingWhitespace: filesConfig.get("trimTrailingWhitespace"),
            trimFinalNewlines: filesConfig.get("trimFinalNewlines"),
            insertFinalNewline: filesConfig.get("insertFinalNewline")
          };
        }
        FileFormattingOptions2.fromConfiguration = fromConfiguration;
      })(FileFormattingOptions || (FileFormattingOptions = {}));
      var DocumentFormattingFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.DocumentFormattingRequest.type);
        }
        fillClientCapabilities(capabilities) {
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "formatting").dynamicRegistration = true;
        }
        initialize(capabilities, documentSelector) {
          const options = this.getRegistrationOptions(documentSelector, capabilities.documentFormattingProvider);
          if (!options) {
            return;
          }
          this.register({ id: UUID.generateUuid(), registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const provider = {
            provideDocumentFormattingEdits: (document2, options2, token) => {
              const client = this._client;
              const provideDocumentFormattingEdits = (document3, options3, token2) => {
                const params = {
                  textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                  options: client.code2ProtocolConverter.asFormattingOptions(options3, FileFormattingOptions.fromConfiguration(document3))
                };
                return client.sendRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, params, token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asTextEdits(result, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideDocumentFormattingEdits ? middleware.provideDocumentFormattingEdits(document2, options2, token, provideDocumentFormattingEdits) : provideDocumentFormattingEdits(document2, options2, token);
            }
          };
          return [vscode_1.languages.registerDocumentFormattingEditProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
        }
      };
      exports2.DocumentFormattingFeature = DocumentFormattingFeature;
      var DocumentRangeFormattingFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type);
        }
        fillClientCapabilities(capabilities) {
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "rangeFormatting").dynamicRegistration = true;
        }
        initialize(capabilities, documentSelector) {
          const options = this.getRegistrationOptions(documentSelector, capabilities.documentRangeFormattingProvider);
          if (!options) {
            return;
          }
          this.register({ id: UUID.generateUuid(), registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const provider = {
            provideDocumentRangeFormattingEdits: (document2, range, options2, token) => {
              const client = this._client;
              const provideDocumentRangeFormattingEdits = (document3, range2, options3, token2) => {
                const params = {
                  textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                  range: client.code2ProtocolConverter.asRange(range2),
                  options: client.code2ProtocolConverter.asFormattingOptions(options3, FileFormattingOptions.fromConfiguration(document3))
                };
                return client.sendRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, params, token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asTextEdits(result, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideDocumentRangeFormattingEdits ? middleware.provideDocumentRangeFormattingEdits(document2, range, options2, token, provideDocumentRangeFormattingEdits) : provideDocumentRangeFormattingEdits(document2, range, options2, token);
            }
          };
          return [vscode_1.languages.registerDocumentRangeFormattingEditProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
        }
      };
      exports2.DocumentRangeFormattingFeature = DocumentRangeFormattingFeature;
      var DocumentOnTypeFormattingFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type);
        }
        fillClientCapabilities(capabilities) {
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "onTypeFormatting").dynamicRegistration = true;
        }
        initialize(capabilities, documentSelector) {
          const options = this.getRegistrationOptions(documentSelector, capabilities.documentOnTypeFormattingProvider);
          if (!options) {
            return;
          }
          this.register({ id: UUID.generateUuid(), registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const provider = {
            provideOnTypeFormattingEdits: (document2, position, ch, options2, token) => {
              const client = this._client;
              const provideOnTypeFormattingEdits = (document3, position2, ch2, options3, token2) => {
                let params = {
                  textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                  position: client.code2ProtocolConverter.asPosition(position2),
                  ch: ch2,
                  options: client.code2ProtocolConverter.asFormattingOptions(options3, FileFormattingOptions.fromConfiguration(document3))
                };
                return client.sendRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, params, token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asTextEdits(result, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideOnTypeFormattingEdits ? middleware.provideOnTypeFormattingEdits(document2, position, ch, options2, token, provideOnTypeFormattingEdits) : provideOnTypeFormattingEdits(document2, position, ch, options2, token);
            }
          };
          const moreTriggerCharacter = options.moreTriggerCharacter || [];
          return [vscode_1.languages.registerOnTypeFormattingEditProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider, options.firstTriggerCharacter, ...moreTriggerCharacter), provider];
        }
      };
      exports2.DocumentOnTypeFormattingFeature = DocumentOnTypeFormattingFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/rename.js
  var require_rename = __commonJS({
    "node_modules/vscode-languageclient/lib/common/rename.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.RenameFeature = void 0;
      var vscode_1 = (init_api(), __toCommonJS(api_exports));
      var vscode_languageserver_protocol_1 = require_main3();
      var UUID = require_uuid2();
      var Is = require_is4();
      var features_1 = require_features();
      var RenameFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.RenameRequest.type);
        }
        fillClientCapabilities(capabilities) {
          let rename = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "rename");
          rename.dynamicRegistration = true;
          rename.prepareSupport = true;
          rename.prepareSupportDefaultBehavior = vscode_languageserver_protocol_1.PrepareSupportDefaultBehavior.Identifier;
          rename.honorsChangeAnnotations = true;
        }
        initialize(capabilities, documentSelector) {
          const options = this.getRegistrationOptions(documentSelector, capabilities.renameProvider);
          if (!options) {
            return;
          }
          if (Is.boolean(capabilities.renameProvider)) {
            options.prepareProvider = false;
          }
          this.register({ id: UUID.generateUuid(), registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const provider = {
            provideRenameEdits: (document2, position, newName, token) => {
              const client = this._client;
              const provideRenameEdits = (document3, position2, newName2, token2) => {
                let params = {
                  textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                  position: client.code2ProtocolConverter.asPosition(position2),
                  newName: newName2
                };
                return client.sendRequest(vscode_languageserver_protocol_1.RenameRequest.type, params, token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asWorkspaceEdit(result, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.RenameRequest.type, token2, error, null, false);
                });
              };
              const middleware = client.middleware;
              return middleware.provideRenameEdits ? middleware.provideRenameEdits(document2, position, newName, token, provideRenameEdits) : provideRenameEdits(document2, position, newName, token);
            },
            prepareRename: options.prepareProvider ? (document2, position, token) => {
              const client = this._client;
              const prepareRename = (document3, position2, token2) => {
                let params = {
                  textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                  position: client.code2ProtocolConverter.asPosition(position2)
                };
                return client.sendRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, params, token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  if (vscode_languageserver_protocol_1.Range.is(result)) {
                    return client.protocol2CodeConverter.asRange(result);
                  } else if (this.isDefaultBehavior(result)) {
                    return result.defaultBehavior === true ? null : Promise.reject(new Error(`The element can't be renamed.`));
                  } else if (result && vscode_languageserver_protocol_1.Range.is(result.range)) {
                    return {
                      range: client.protocol2CodeConverter.asRange(result.range),
                      placeholder: result.placeholder
                    };
                  }
                  return Promise.reject(new Error(`The element can't be renamed.`));
                }, (error) => {
                  if (typeof error.message === "string") {
                    throw new Error(error.message);
                  } else {
                    throw new Error(`The element can't be renamed.`);
                  }
                });
              };
              const middleware = client.middleware;
              return middleware.prepareRename ? middleware.prepareRename(document2, position, token, prepareRename) : prepareRename(document2, position, token);
            } : void 0
          };
          return [this.registerProvider(selector, provider), provider];
        }
        registerProvider(selector, provider) {
          return vscode_1.languages.registerRenameProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
        }
        isDefaultBehavior(value) {
          const candidate = value;
          return candidate && Is.boolean(candidate.defaultBehavior);
        }
      };
      exports2.RenameFeature = RenameFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/documentLink.js
  var require_documentLink = __commonJS({
    "node_modules/vscode-languageclient/lib/common/documentLink.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DocumentLinkFeature = void 0;
      var vscode_1 = (init_api(), __toCommonJS(api_exports));
      var vscode_languageserver_protocol_1 = require_main3();
      var features_1 = require_features();
      var UUID = require_uuid2();
      var DocumentLinkFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.DocumentLinkRequest.type);
        }
        fillClientCapabilities(capabilities) {
          const documentLinkCapabilities = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "documentLink");
          documentLinkCapabilities.dynamicRegistration = true;
          documentLinkCapabilities.tooltipSupport = true;
        }
        initialize(capabilities, documentSelector) {
          const options = this.getRegistrationOptions(documentSelector, capabilities.documentLinkProvider);
          if (!options) {
            return;
          }
          this.register({ id: UUID.generateUuid(), registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const provider = {
            provideDocumentLinks: (document2, token) => {
              const client = this._client;
              const provideDocumentLinks = (document3, token2) => {
                return client.sendRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, client.code2ProtocolConverter.asDocumentLinkParams(document3), token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asDocumentLinks(result, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideDocumentLinks ? middleware.provideDocumentLinks(document2, token, provideDocumentLinks) : provideDocumentLinks(document2, token);
            },
            resolveDocumentLink: options.resolveProvider ? (link, token) => {
              const client = this._client;
              let resolveDocumentLink = (link2, token2) => {
                return client.sendRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, client.code2ProtocolConverter.asDocumentLink(link2), token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return link2;
                  }
                  return client.protocol2CodeConverter.asDocumentLink(result);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, token2, error, link2);
                });
              };
              const middleware = client.middleware;
              return middleware.resolveDocumentLink ? middleware.resolveDocumentLink(link, token, resolveDocumentLink) : resolveDocumentLink(link, token);
            } : void 0
          };
          return [vscode_1.languages.registerDocumentLinkProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
        }
      };
      exports2.DocumentLinkFeature = DocumentLinkFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/executeCommand.js
  var require_executeCommand = __commonJS({
    "node_modules/vscode-languageclient/lib/common/executeCommand.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ExecuteCommandFeature = void 0;
      var vscode_1 = (init_api(), __toCommonJS(api_exports));
      var vscode_languageserver_protocol_1 = require_main3();
      var UUID = require_uuid2();
      var features_1 = require_features();
      var ExecuteCommandFeature = class {
        constructor(client) {
          this._client = client;
          this._commands = /* @__PURE__ */ new Map();
        }
        getState() {
          return { kind: "workspace", id: this.registrationType.method, registrations: this._commands.size > 0 };
        }
        get registrationType() {
          return vscode_languageserver_protocol_1.ExecuteCommandRequest.type;
        }
        fillClientCapabilities(capabilities) {
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "executeCommand").dynamicRegistration = true;
        }
        initialize(capabilities) {
          if (!capabilities.executeCommandProvider) {
            return;
          }
          this.register({
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, capabilities.executeCommandProvider)
          });
        }
        register(data) {
          const client = this._client;
          const middleware = client.middleware;
          const executeCommand = (command, args) => {
            let params = {
              command,
              arguments: args
            };
            return client.sendRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, params).then(void 0, (error) => {
              return client.handleFailedRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, void 0, error, void 0);
            });
          };
          if (data.registerOptions.commands) {
            const disposables = [];
            for (const command of data.registerOptions.commands) {
              disposables.push(vscode_1.commands.registerCommand(command, (...args) => {
                return middleware.executeCommand ? middleware.executeCommand(command, args, executeCommand) : executeCommand(command, args);
              }));
            }
            this._commands.set(data.id, disposables);
          }
        }
        unregister(id2) {
          let disposables = this._commands.get(id2);
          if (disposables) {
            disposables.forEach((disposable) => disposable.dispose());
          }
        }
        dispose() {
          this._commands.forEach((value) => {
            value.forEach((disposable) => disposable.dispose());
          });
          this._commands.clear();
        }
      };
      exports2.ExecuteCommandFeature = ExecuteCommandFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/fileSystemWatcher.js
  var require_fileSystemWatcher = __commonJS({
    "node_modules/vscode-languageclient/lib/common/fileSystemWatcher.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FileSystemWatcherFeature = void 0;
      var vscode_1 = (init_api(), __toCommonJS(api_exports));
      var vscode_languageserver_protocol_1 = require_main3();
      var features_1 = require_features();
      var FileSystemWatcherFeature = class {
        constructor(client, notifyFileEvent) {
          this._client = client;
          this._notifyFileEvent = notifyFileEvent;
          this._watchers = /* @__PURE__ */ new Map();
        }
        getState() {
          return { kind: "workspace", id: this.registrationType.method, registrations: this._watchers.size > 0 };
        }
        get registrationType() {
          return vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type;
        }
        fillClientCapabilities(capabilities) {
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "didChangeWatchedFiles").dynamicRegistration = true;
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "didChangeWatchedFiles").relativePatternSupport = true;
        }
        initialize(_capabilities, _documentSelector) {
        }
        register(data) {
          if (!Array.isArray(data.registerOptions.watchers)) {
            return;
          }
          const disposables = [];
          for (const watcher of data.registerOptions.watchers) {
            const globPattern = this._client.protocol2CodeConverter.asGlobPattern(watcher.globPattern);
            if (globPattern === void 0) {
              continue;
            }
            let watchCreate = true, watchChange = true, watchDelete = true;
            if (watcher.kind !== void 0 && watcher.kind !== null) {
              watchCreate = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Create) !== 0;
              watchChange = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Change) !== 0;
              watchDelete = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Delete) !== 0;
            }
            const fileSystemWatcher = vscode_1.workspace.createFileSystemWatcher(globPattern, !watchCreate, !watchChange, !watchDelete);
            this.hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete, disposables);
            disposables.push(fileSystemWatcher);
          }
          this._watchers.set(data.id, disposables);
        }
        registerRaw(id2, fileSystemWatchers) {
          let disposables = [];
          for (let fileSystemWatcher of fileSystemWatchers) {
            this.hookListeners(fileSystemWatcher, true, true, true, disposables);
          }
          this._watchers.set(id2, disposables);
        }
        hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete, listeners) {
          if (watchCreate) {
            fileSystemWatcher.onDidCreate((resource) => this._notifyFileEvent({
              uri: this._client.code2ProtocolConverter.asUri(resource),
              type: vscode_languageserver_protocol_1.FileChangeType.Created
            }), null, listeners);
          }
          if (watchChange) {
            fileSystemWatcher.onDidChange((resource) => this._notifyFileEvent({
              uri: this._client.code2ProtocolConverter.asUri(resource),
              type: vscode_languageserver_protocol_1.FileChangeType.Changed
            }), null, listeners);
          }
          if (watchDelete) {
            fileSystemWatcher.onDidDelete((resource) => this._notifyFileEvent({
              uri: this._client.code2ProtocolConverter.asUri(resource),
              type: vscode_languageserver_protocol_1.FileChangeType.Deleted
            }), null, listeners);
          }
        }
        unregister(id2) {
          let disposables = this._watchers.get(id2);
          if (disposables) {
            for (let disposable of disposables) {
              disposable.dispose();
            }
          }
        }
        dispose() {
          this._watchers.forEach((disposables) => {
            for (let disposable of disposables) {
              disposable.dispose();
            }
          });
          this._watchers.clear();
        }
      };
      exports2.FileSystemWatcherFeature = FileSystemWatcherFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/colorProvider.js
  var require_colorProvider = __commonJS({
    "node_modules/vscode-languageclient/lib/common/colorProvider.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ColorProviderFeature = void 0;
      var vscode_1 = (init_api(), __toCommonJS(api_exports));
      var vscode_languageserver_protocol_1 = require_main3();
      var features_1 = require_features();
      var ColorProviderFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.DocumentColorRequest.type);
        }
        fillClientCapabilities(capabilities) {
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "colorProvider").dynamicRegistration = true;
        }
        initialize(capabilities, documentSelector) {
          let [id2, options] = this.getRegistration(documentSelector, capabilities.colorProvider);
          if (!id2 || !options) {
            return;
          }
          this.register({ id: id2, registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const provider = {
            provideColorPresentations: (color, context, token) => {
              const client = this._client;
              const provideColorPresentations = (color2, context2, token2) => {
                const requestParams = {
                  color: color2,
                  textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(context2.document),
                  range: client.code2ProtocolConverter.asRange(context2.range)
                };
                return client.sendRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, requestParams, token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return this._client.protocol2CodeConverter.asColorPresentations(result, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideColorPresentations ? middleware.provideColorPresentations(color, context, token, provideColorPresentations) : provideColorPresentations(color, context, token);
            },
            provideDocumentColors: (document2, token) => {
              const client = this._client;
              const provideDocumentColors = (document3, token2) => {
                const requestParams = {
                  textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3)
                };
                return client.sendRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, requestParams, token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return this._client.protocol2CodeConverter.asColorInformations(result, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideDocumentColors ? middleware.provideDocumentColors(document2, token, provideDocumentColors) : provideDocumentColors(document2, token);
            }
          };
          return [vscode_1.languages.registerColorProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
        }
      };
      exports2.ColorProviderFeature = ColorProviderFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/implementation.js
  var require_implementation = __commonJS({
    "node_modules/vscode-languageclient/lib/common/implementation.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ImplementationFeature = void 0;
      var vscode_1 = (init_api(), __toCommonJS(api_exports));
      var vscode_languageserver_protocol_1 = require_main3();
      var features_1 = require_features();
      var ImplementationFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.ImplementationRequest.type);
        }
        fillClientCapabilities(capabilities) {
          let implementationSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "implementation");
          implementationSupport.dynamicRegistration = true;
          implementationSupport.linkSupport = true;
        }
        initialize(capabilities, documentSelector) {
          let [id2, options] = this.getRegistration(documentSelector, capabilities.implementationProvider);
          if (!id2 || !options) {
            return;
          }
          this.register({ id: id2, registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const provider = {
            provideImplementation: (document2, position, token) => {
              const client = this._client;
              const provideImplementation = (document3, position2, token2) => {
                return client.sendRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2), token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asDefinitionResult(result, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideImplementation ? middleware.provideImplementation(document2, position, token, provideImplementation) : provideImplementation(document2, position, token);
            }
          };
          return [this.registerProvider(selector, provider), provider];
        }
        registerProvider(selector, provider) {
          return vscode_1.languages.registerImplementationProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
        }
      };
      exports2.ImplementationFeature = ImplementationFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/typeDefinition.js
  var require_typeDefinition = __commonJS({
    "node_modules/vscode-languageclient/lib/common/typeDefinition.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TypeDefinitionFeature = void 0;
      var vscode_1 = (init_api(), __toCommonJS(api_exports));
      var vscode_languageserver_protocol_1 = require_main3();
      var features_1 = require_features();
      var TypeDefinitionFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.TypeDefinitionRequest.type);
        }
        fillClientCapabilities(capabilities) {
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "typeDefinition").dynamicRegistration = true;
          let typeDefinitionSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "typeDefinition");
          typeDefinitionSupport.dynamicRegistration = true;
          typeDefinitionSupport.linkSupport = true;
        }
        initialize(capabilities, documentSelector) {
          let [id2, options] = this.getRegistration(documentSelector, capabilities.typeDefinitionProvider);
          if (!id2 || !options) {
            return;
          }
          this.register({ id: id2, registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const provider = {
            provideTypeDefinition: (document2, position, token) => {
              const client = this._client;
              const provideTypeDefinition = (document3, position2, token2) => {
                return client.sendRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2), token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asDefinitionResult(result, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideTypeDefinition ? middleware.provideTypeDefinition(document2, position, token, provideTypeDefinition) : provideTypeDefinition(document2, position, token);
            }
          };
          return [this.registerProvider(selector, provider), provider];
        }
        registerProvider(selector, provider) {
          return vscode_1.languages.registerTypeDefinitionProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
        }
      };
      exports2.TypeDefinitionFeature = TypeDefinitionFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/workspaceFolder.js
  var require_workspaceFolder2 = __commonJS({
    "node_modules/vscode-languageclient/lib/common/workspaceFolder.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.WorkspaceFoldersFeature = exports2.arrayDiff = void 0;
      var UUID = require_uuid2();
      var vscode_1 = (init_api(), __toCommonJS(api_exports));
      var vscode_languageserver_protocol_1 = require_main3();
      function access(target, key) {
        if (target === void 0) {
          return void 0;
        }
        return target[key];
      }
      function arrayDiff(left, right) {
        return left.filter((element) => right.indexOf(element) < 0);
      }
      exports2.arrayDiff = arrayDiff;
      var WorkspaceFoldersFeature = class {
        constructor(client) {
          this._client = client;
          this._listeners = /* @__PURE__ */ new Map();
        }
        getState() {
          return { kind: "workspace", id: this.registrationType.method, registrations: this._listeners.size > 0 };
        }
        get registrationType() {
          return vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type;
        }
        fillInitializeParams(params) {
          const folders = vscode_1.workspace.workspaceFolders;
          this.initializeWithFolders(folders);
          if (folders === void 0) {
            params.workspaceFolders = null;
          } else {
            params.workspaceFolders = folders.map((folder) => this.asProtocol(folder));
          }
        }
        initializeWithFolders(currentWorkspaceFolders) {
          this._initialFolders = currentWorkspaceFolders;
        }
        fillClientCapabilities(capabilities) {
          capabilities.workspace = capabilities.workspace || {};
          capabilities.workspace.workspaceFolders = true;
        }
        initialize(capabilities) {
          const client = this._client;
          client.onRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type, (token) => {
            const workspaceFolders = () => {
              const folders = vscode_1.workspace.workspaceFolders;
              if (folders === void 0) {
                return null;
              }
              const result = folders.map((folder) => {
                return this.asProtocol(folder);
              });
              return result;
            };
            const middleware = client.middleware.workspace;
            return middleware && middleware.workspaceFolders ? middleware.workspaceFolders(token, workspaceFolders) : workspaceFolders(token);
          });
          const value = access(access(access(capabilities, "workspace"), "workspaceFolders"), "changeNotifications");
          let id2;
          if (typeof value === "string") {
            id2 = value;
          } else if (value === true) {
            id2 = UUID.generateUuid();
          }
          if (id2) {
            this.register({ id: id2, registerOptions: void 0 });
          }
        }
        sendInitialEvent(currentWorkspaceFolders) {
          let promise;
          if (this._initialFolders && currentWorkspaceFolders) {
            const removed = arrayDiff(this._initialFolders, currentWorkspaceFolders);
            const added = arrayDiff(currentWorkspaceFolders, this._initialFolders);
            if (added.length > 0 || removed.length > 0) {
              promise = this.doSendEvent(added, removed);
            }
          } else if (this._initialFolders) {
            promise = this.doSendEvent([], this._initialFolders);
          } else if (currentWorkspaceFolders) {
            promise = this.doSendEvent(currentWorkspaceFolders, []);
          }
          if (promise !== void 0) {
            promise.catch((error) => {
              this._client.error(`Sending notification ${vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type.method} failed`, error);
            });
          }
        }
        doSendEvent(addedFolders, removedFolders) {
          let params = {
            event: {
              added: addedFolders.map((folder) => this.asProtocol(folder)),
              removed: removedFolders.map((folder) => this.asProtocol(folder))
            }
          };
          return this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, params);
        }
        register(data) {
          let id2 = data.id;
          let client = this._client;
          let disposable = vscode_1.workspace.onDidChangeWorkspaceFolders((event) => {
            let didChangeWorkspaceFolders = (event2) => {
              return this.doSendEvent(event2.added, event2.removed);
            };
            let middleware = client.middleware.workspace;
            const promise = middleware && middleware.didChangeWorkspaceFolders ? middleware.didChangeWorkspaceFolders(event, didChangeWorkspaceFolders) : didChangeWorkspaceFolders(event);
            promise.catch((error) => {
              this._client.error(`Sending notification ${vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type.method} failed`, error);
            });
          });
          this._listeners.set(id2, disposable);
          this.sendInitialEvent(vscode_1.workspace.workspaceFolders);
        }
        unregister(id2) {
          let disposable = this._listeners.get(id2);
          if (disposable === void 0) {
            return;
          }
          this._listeners.delete(id2);
          disposable.dispose();
        }
        dispose() {
          for (let disposable of this._listeners.values()) {
            disposable.dispose();
          }
          this._listeners.clear();
        }
        asProtocol(workspaceFolder) {
          if (workspaceFolder === void 0) {
            return null;
          }
          return { uri: this._client.code2ProtocolConverter.asUri(workspaceFolder.uri), name: workspaceFolder.name };
        }
      };
      exports2.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/foldingRange.js
  var require_foldingRange = __commonJS({
    "node_modules/vscode-languageclient/lib/common/foldingRange.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FoldingRangeFeature = void 0;
      var vscode_1 = (init_api(), __toCommonJS(api_exports));
      var vscode_languageserver_protocol_1 = require_main3();
      var features_1 = require_features();
      var FoldingRangeFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.FoldingRangeRequest.type);
        }
        fillClientCapabilities(capabilities) {
          let capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "foldingRange");
          capability.dynamicRegistration = true;
          capability.rangeLimit = 5e3;
          capability.lineFoldingOnly = true;
          capability.foldingRangeKind = { valueSet: [vscode_languageserver_protocol_1.FoldingRangeKind.Comment, vscode_languageserver_protocol_1.FoldingRangeKind.Imports, vscode_languageserver_protocol_1.FoldingRangeKind.Region] };
          capability.foldingRange = { collapsedText: false };
        }
        initialize(capabilities, documentSelector) {
          let [id2, options] = this.getRegistration(documentSelector, capabilities.foldingRangeProvider);
          if (!id2 || !options) {
            return;
          }
          this.register({ id: id2, registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const provider = {
            provideFoldingRanges: (document2, context, token) => {
              const client = this._client;
              const provideFoldingRanges = (document3, _, token2) => {
                const requestParams = {
                  textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3)
                };
                return client.sendRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, requestParams, token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asFoldingRanges(result, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideFoldingRanges ? middleware.provideFoldingRanges(document2, context, token, provideFoldingRanges) : provideFoldingRanges(document2, context, token);
            }
          };
          return [vscode_1.languages.registerFoldingRangeProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
        }
      };
      exports2.FoldingRangeFeature = FoldingRangeFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/declaration.js
  var require_declaration = __commonJS({
    "node_modules/vscode-languageclient/lib/common/declaration.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DeclarationFeature = void 0;
      var vscode_1 = (init_api(), __toCommonJS(api_exports));
      var vscode_languageserver_protocol_1 = require_main3();
      var features_1 = require_features();
      var DeclarationFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.DeclarationRequest.type);
        }
        fillClientCapabilities(capabilities) {
          const declarationSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "declaration");
          declarationSupport.dynamicRegistration = true;
          declarationSupport.linkSupport = true;
        }
        initialize(capabilities, documentSelector) {
          const [id2, options] = this.getRegistration(documentSelector, capabilities.declarationProvider);
          if (!id2 || !options) {
            return;
          }
          this.register({ id: id2, registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const provider = {
            provideDeclaration: (document2, position, token) => {
              const client = this._client;
              const provideDeclaration = (document3, position2, token2) => {
                return client.sendRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2), token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asDeclarationResult(result, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideDeclaration ? middleware.provideDeclaration(document2, position, token, provideDeclaration) : provideDeclaration(document2, position, token);
            }
          };
          return [this.registerProvider(selector, provider), provider];
        }
        registerProvider(selector, provider) {
          return vscode_1.languages.registerDeclarationProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
        }
      };
      exports2.DeclarationFeature = DeclarationFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/selectionRange.js
  var require_selectionRange = __commonJS({
    "node_modules/vscode-languageclient/lib/common/selectionRange.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SelectionRangeFeature = void 0;
      var vscode_1 = (init_api(), __toCommonJS(api_exports));
      var vscode_languageserver_protocol_1 = require_main3();
      var features_1 = require_features();
      var SelectionRangeFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.SelectionRangeRequest.type);
        }
        fillClientCapabilities(capabilities) {
          const capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "selectionRange");
          capability.dynamicRegistration = true;
        }
        initialize(capabilities, documentSelector) {
          const [id2, options] = this.getRegistration(documentSelector, capabilities.selectionRangeProvider);
          if (!id2 || !options) {
            return;
          }
          this.register({ id: id2, registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const provider = {
            provideSelectionRanges: (document2, positions, token) => {
              const client = this._client;
              const provideSelectionRanges = async (document3, positions2, token2) => {
                const requestParams = {
                  textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                  positions: await client.code2ProtocolConverter.asPositions(positions2, token2)
                };
                return client.sendRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, requestParams, token2).then((ranges) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asSelectionRanges(ranges, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideSelectionRanges ? middleware.provideSelectionRanges(document2, positions, token, provideSelectionRanges) : provideSelectionRanges(document2, positions, token);
            }
          };
          return [this.registerProvider(selector, provider), provider];
        }
        registerProvider(selector, provider) {
          return vscode_1.languages.registerSelectionRangeProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
        }
      };
      exports2.SelectionRangeFeature = SelectionRangeFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/progress.js
  var require_progress2 = __commonJS({
    "node_modules/vscode-languageclient/lib/common/progress.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ProgressFeature = void 0;
      var vscode_languageserver_protocol_1 = require_main3();
      var progressPart_1 = require_progressPart();
      function ensure(target, key) {
        if (target[key] === void 0) {
          target[key] = /* @__PURE__ */ Object.create(null);
        }
        return target[key];
      }
      var ProgressFeature = class {
        constructor(_client) {
          this._client = _client;
          this.activeParts = /* @__PURE__ */ new Set();
        }
        getState() {
          return { kind: "window", id: vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.method, registrations: this.activeParts.size > 0 };
        }
        fillClientCapabilities(capabilities) {
          ensure(capabilities, "window").workDoneProgress = true;
        }
        initialize() {
          const client = this._client;
          const deleteHandler = (part) => {
            this.activeParts.delete(part);
          };
          const createHandler = (params) => {
            this.activeParts.add(new progressPart_1.ProgressPart(this._client, params.token, deleteHandler));
          };
          client.onRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, createHandler);
        }
        dispose() {
          for (const part of this.activeParts) {
            part.done();
          }
          this.activeParts.clear();
        }
      };
      exports2.ProgressFeature = ProgressFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/callHierarchy.js
  var require_callHierarchy2 = __commonJS({
    "node_modules/vscode-languageclient/lib/common/callHierarchy.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.CallHierarchyFeature = void 0;
      var vscode_1 = (init_api(), __toCommonJS(api_exports));
      var vscode_languageserver_protocol_1 = require_main3();
      var features_1 = require_features();
      var CallHierarchyProvider = class {
        constructor(client) {
          this.client = client;
          this.middleware = client.middleware;
        }
        prepareCallHierarchy(document2, position, token) {
          const client = this.client;
          const middleware = this.middleware;
          const prepareCallHierarchy = (document3, position2, token2) => {
            const params = client.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2);
            return client.sendRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, params, token2).then((result) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              return client.protocol2CodeConverter.asCallHierarchyItems(result, token2);
            }, (error) => {
              return client.handleFailedRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, token2, error, null);
            });
          };
          return middleware.prepareCallHierarchy ? middleware.prepareCallHierarchy(document2, position, token, prepareCallHierarchy) : prepareCallHierarchy(document2, position, token);
        }
        provideCallHierarchyIncomingCalls(item, token) {
          const client = this.client;
          const middleware = this.middleware;
          const provideCallHierarchyIncomingCalls = (item2, token2) => {
            const params = {
              item: client.code2ProtocolConverter.asCallHierarchyItem(item2)
            };
            return client.sendRequest(vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type, params, token2).then((result) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              return client.protocol2CodeConverter.asCallHierarchyIncomingCalls(result, token2);
            }, (error) => {
              return client.handleFailedRequest(vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type, token2, error, null);
            });
          };
          return middleware.provideCallHierarchyIncomingCalls ? middleware.provideCallHierarchyIncomingCalls(item, token, provideCallHierarchyIncomingCalls) : provideCallHierarchyIncomingCalls(item, token);
        }
        provideCallHierarchyOutgoingCalls(item, token) {
          const client = this.client;
          const middleware = this.middleware;
          const provideCallHierarchyOutgoingCalls = (item2, token2) => {
            const params = {
              item: client.code2ProtocolConverter.asCallHierarchyItem(item2)
            };
            return client.sendRequest(vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type, params, token2).then((result) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              return client.protocol2CodeConverter.asCallHierarchyOutgoingCalls(result, token2);
            }, (error) => {
              return client.handleFailedRequest(vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type, token2, error, null);
            });
          };
          return middleware.provideCallHierarchyOutgoingCalls ? middleware.provideCallHierarchyOutgoingCalls(item, token, provideCallHierarchyOutgoingCalls) : provideCallHierarchyOutgoingCalls(item, token);
        }
      };
      var CallHierarchyFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type);
        }
        fillClientCapabilities(cap) {
          const capabilities = cap;
          const capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "callHierarchy");
          capability.dynamicRegistration = true;
        }
        initialize(capabilities, documentSelector) {
          const [id2, options] = this.getRegistration(documentSelector, capabilities.callHierarchyProvider);
          if (!id2 || !options) {
            return;
          }
          this.register({ id: id2, registerOptions: options });
        }
        registerLanguageProvider(options) {
          const client = this._client;
          const provider = new CallHierarchyProvider(client);
          return [vscode_1.languages.registerCallHierarchyProvider(this._client.protocol2CodeConverter.asDocumentSelector(options.documentSelector), provider), provider];
        }
      };
      exports2.CallHierarchyFeature = CallHierarchyFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/semanticTokens.js
  var require_semanticTokens2 = __commonJS({
    "node_modules/vscode-languageclient/lib/common/semanticTokens.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SemanticTokensFeature = void 0;
      var vscode = (init_api(), __toCommonJS(api_exports));
      var vscode_languageserver_protocol_1 = require_main3();
      var features_1 = require_features();
      var Is = require_is4();
      var SemanticTokensFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.SemanticTokensRegistrationType.type);
        }
        fillClientCapabilities(capabilities) {
          const capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "semanticTokens");
          capability.dynamicRegistration = true;
          capability.tokenTypes = [
            vscode_languageserver_protocol_1.SemanticTokenTypes.namespace,
            vscode_languageserver_protocol_1.SemanticTokenTypes.type,
            vscode_languageserver_protocol_1.SemanticTokenTypes.class,
            vscode_languageserver_protocol_1.SemanticTokenTypes.enum,
            vscode_languageserver_protocol_1.SemanticTokenTypes.interface,
            vscode_languageserver_protocol_1.SemanticTokenTypes.struct,
            vscode_languageserver_protocol_1.SemanticTokenTypes.typeParameter,
            vscode_languageserver_protocol_1.SemanticTokenTypes.parameter,
            vscode_languageserver_protocol_1.SemanticTokenTypes.variable,
            vscode_languageserver_protocol_1.SemanticTokenTypes.property,
            vscode_languageserver_protocol_1.SemanticTokenTypes.enumMember,
            vscode_languageserver_protocol_1.SemanticTokenTypes.event,
            vscode_languageserver_protocol_1.SemanticTokenTypes.function,
            vscode_languageserver_protocol_1.SemanticTokenTypes.method,
            vscode_languageserver_protocol_1.SemanticTokenTypes.macro,
            vscode_languageserver_protocol_1.SemanticTokenTypes.keyword,
            vscode_languageserver_protocol_1.SemanticTokenTypes.modifier,
            vscode_languageserver_protocol_1.SemanticTokenTypes.comment,
            vscode_languageserver_protocol_1.SemanticTokenTypes.string,
            vscode_languageserver_protocol_1.SemanticTokenTypes.number,
            vscode_languageserver_protocol_1.SemanticTokenTypes.regexp,
            vscode_languageserver_protocol_1.SemanticTokenTypes.operator,
            vscode_languageserver_protocol_1.SemanticTokenTypes.decorator
          ];
          capability.tokenModifiers = [
            vscode_languageserver_protocol_1.SemanticTokenModifiers.declaration,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.definition,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.readonly,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.static,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.deprecated,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.abstract,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.async,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.modification,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.documentation,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.defaultLibrary
          ];
          capability.formats = [vscode_languageserver_protocol_1.TokenFormat.Relative];
          capability.requests = {
            range: true,
            full: {
              delta: true
            }
          };
          capability.multilineTokenSupport = false;
          capability.overlappingTokenSupport = false;
          capability.serverCancelSupport = true;
          capability.augmentsSyntaxTokens = true;
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "semanticTokens").refreshSupport = true;
        }
        initialize(capabilities, documentSelector) {
          const client = this._client;
          client.onRequest(vscode_languageserver_protocol_1.SemanticTokensRefreshRequest.type, async () => {
            for (const provider of this.getAllProviders()) {
              provider.onDidChangeSemanticTokensEmitter.fire();
            }
          });
          const [id2, options] = this.getRegistration(documentSelector, capabilities.semanticTokensProvider);
          if (!id2 || !options) {
            return;
          }
          this.register({ id: id2, registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const fullProvider = Is.boolean(options.full) ? options.full : options.full !== void 0;
          const hasEditProvider = options.full !== void 0 && typeof options.full !== "boolean" && options.full.delta === true;
          const eventEmitter = new vscode.EventEmitter();
          const documentProvider = fullProvider ? {
            onDidChangeSemanticTokens: eventEmitter.event,
            provideDocumentSemanticTokens: (document2, token) => {
              const client2 = this._client;
              const middleware = client2.middleware;
              const provideDocumentSemanticTokens = (document3, token2) => {
                const params = {
                  textDocument: client2.code2ProtocolConverter.asTextDocumentIdentifier(document3)
                };
                return client2.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRequest.type, params, token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client2.protocol2CodeConverter.asSemanticTokens(result, token2);
                }, (error) => {
                  return client2.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensRequest.type, token2, error, null);
                });
              };
              return middleware.provideDocumentSemanticTokens ? middleware.provideDocumentSemanticTokens(document2, token, provideDocumentSemanticTokens) : provideDocumentSemanticTokens(document2, token);
            },
            provideDocumentSemanticTokensEdits: hasEditProvider ? (document2, previousResultId, token) => {
              const client2 = this._client;
              const middleware = client2.middleware;
              const provideDocumentSemanticTokensEdits = (document3, previousResultId2, token2) => {
                const params = {
                  textDocument: client2.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                  previousResultId: previousResultId2
                };
                return client2.sendRequest(vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type, params, token2).then(async (result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  if (vscode_languageserver_protocol_1.SemanticTokens.is(result)) {
                    return await client2.protocol2CodeConverter.asSemanticTokens(result, token2);
                  } else {
                    return await client2.protocol2CodeConverter.asSemanticTokensEdits(result, token2);
                  }
                }, (error) => {
                  return client2.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type, token2, error, null);
                });
              };
              return middleware.provideDocumentSemanticTokensEdits ? middleware.provideDocumentSemanticTokensEdits(document2, previousResultId, token, provideDocumentSemanticTokensEdits) : provideDocumentSemanticTokensEdits(document2, previousResultId, token);
            } : void 0
          } : void 0;
          const hasRangeProvider = options.range === true;
          const rangeProvider = hasRangeProvider ? {
            provideDocumentRangeSemanticTokens: (document2, range, token) => {
              const client2 = this._client;
              const middleware = client2.middleware;
              const provideDocumentRangeSemanticTokens = (document3, range2, token2) => {
                const params = {
                  textDocument: client2.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                  range: client2.code2ProtocolConverter.asRange(range2)
                };
                return client2.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type, params, token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client2.protocol2CodeConverter.asSemanticTokens(result, token2);
                }, (error) => {
                  return client2.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type, token2, error, null);
                });
              };
              return middleware.provideDocumentRangeSemanticTokens ? middleware.provideDocumentRangeSemanticTokens(document2, range, token, provideDocumentRangeSemanticTokens) : provideDocumentRangeSemanticTokens(document2, range, token);
            }
          } : void 0;
          const disposables = [];
          const client = this._client;
          const legend = client.protocol2CodeConverter.asSemanticTokensLegend(options.legend);
          const documentSelector = client.protocol2CodeConverter.asDocumentSelector(selector);
          if (documentProvider !== void 0) {
            disposables.push(vscode.languages.registerDocumentSemanticTokensProvider(documentSelector, documentProvider, legend));
          }
          if (rangeProvider !== void 0) {
            disposables.push(vscode.languages.registerDocumentRangeSemanticTokensProvider(documentSelector, rangeProvider, legend));
          }
          return [new vscode.Disposable(() => disposables.forEach((item) => item.dispose())), { range: rangeProvider, full: documentProvider, onDidChangeSemanticTokensEmitter: eventEmitter }];
        }
      };
      exports2.SemanticTokensFeature = SemanticTokensFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/fileOperations.js
  var require_fileOperations2 = __commonJS({
    "node_modules/vscode-languageclient/lib/common/fileOperations.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.WillDeleteFilesFeature = exports2.WillRenameFilesFeature = exports2.WillCreateFilesFeature = exports2.DidDeleteFilesFeature = exports2.DidRenameFilesFeature = exports2.DidCreateFilesFeature = void 0;
      var code = (init_api(), __toCommonJS(api_exports));
      var minimatch = require_minimatch();
      var proto = require_main3();
      var UUID = require_uuid2();
      function ensure(target, key) {
        if (target[key] === void 0) {
          target[key] = {};
        }
        return target[key];
      }
      function access(target, key) {
        return target[key];
      }
      function assign(target, key, value) {
        target[key] = value;
      }
      var FileOperationFeature = class {
        constructor(client, event, registrationType, clientCapability, serverCapability) {
          this._client = client;
          this._event = event;
          this._registrationType = registrationType;
          this._clientCapability = clientCapability;
          this._serverCapability = serverCapability;
          this._filters = /* @__PURE__ */ new Map();
        }
        getState() {
          return { kind: "workspace", id: this._registrationType.method, registrations: this._filters.size > 0 };
        }
        filterSize() {
          return this._filters.size;
        }
        get registrationType() {
          return this._registrationType;
        }
        fillClientCapabilities(capabilities) {
          const value = ensure(ensure(capabilities, "workspace"), "fileOperations");
          assign(value, "dynamicRegistration", true);
          assign(value, this._clientCapability, true);
        }
        initialize(capabilities) {
          const options = capabilities.workspace?.fileOperations;
          const capability = options !== void 0 ? access(options, this._serverCapability) : void 0;
          if (capability?.filters !== void 0) {
            try {
              this.register({
                id: UUID.generateUuid(),
                registerOptions: { filters: capability.filters }
              });
            } catch (e) {
              this._client.warn(`Ignoring invalid glob pattern for ${this._serverCapability} registration: ${e}`);
            }
          }
        }
        register(data) {
          if (!this._listener) {
            this._listener = this._event(this.send, this);
          }
          const minimatchFilter = data.registerOptions.filters.map((filter) => {
            const matcher = new minimatch.Minimatch(filter.pattern.glob, FileOperationFeature.asMinimatchOptions(filter.pattern.options));
            if (!matcher.makeRe()) {
              throw new Error(`Invalid pattern ${filter.pattern.glob}!`);
            }
            return { scheme: filter.scheme, matcher, kind: filter.pattern.matches };
          });
          this._filters.set(data.id, minimatchFilter);
        }
        unregister(id2) {
          this._filters.delete(id2);
          if (this._filters.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = void 0;
          }
        }
        dispose() {
          this._filters.clear();
          if (this._listener) {
            this._listener.dispose();
            this._listener = void 0;
          }
        }
        getFileType(uri) {
          return FileOperationFeature.getFileType(uri);
        }
        async filter(event, prop) {
          const fileMatches = await Promise.all(event.files.map(async (item) => {
            const uri = prop(item);
            const path = uri.fsPath.replace(/\\/g, "/");
            for (const filters of this._filters.values()) {
              for (const filter of filters) {
                if (filter.scheme !== void 0 && filter.scheme !== uri.scheme) {
                  continue;
                }
                if (filter.matcher.match(path)) {
                  if (filter.kind === void 0) {
                    return true;
                  }
                  const fileType = await this.getFileType(uri);
                  if (fileType === void 0) {
                    this._client.error(`Failed to determine file type for ${uri.toString()}.`);
                    return true;
                  }
                  if (fileType === code.FileType.File && filter.kind === proto.FileOperationPatternKind.file || fileType === code.FileType.Directory && filter.kind === proto.FileOperationPatternKind.folder) {
                    return true;
                  }
                } else if (filter.kind === proto.FileOperationPatternKind.folder) {
                  const fileType = await FileOperationFeature.getFileType(uri);
                  if (fileType === code.FileType.Directory && filter.matcher.match(`${path}/`)) {
                    return true;
                  }
                }
              }
            }
            return false;
          }));
          const files = event.files.filter((_, index) => fileMatches[index]);
          return { ...event, files };
        }
        static async getFileType(uri) {
          try {
            return (await code.workspace.fs.stat(uri)).type;
          } catch (e) {
            return void 0;
          }
        }
        static asMinimatchOptions(options) {
          if (options === void 0) {
            return void 0;
          }
          if (options.ignoreCase === true) {
            return { nocase: true };
          }
          return void 0;
        }
      };
      var NotificationFileOperationFeature = class extends FileOperationFeature {
        constructor(client, event, notificationType, clientCapability, serverCapability, accessUri, createParams) {
          super(client, event, notificationType, clientCapability, serverCapability);
          this._notificationType = notificationType;
          this._accessUri = accessUri;
          this._createParams = createParams;
        }
        async send(originalEvent) {
          const filteredEvent = await this.filter(originalEvent, this._accessUri);
          if (filteredEvent.files.length) {
            const next = async (event) => {
              return this._client.sendNotification(this._notificationType, this._createParams(event));
            };
            return this.doSend(filteredEvent, next);
          }
        }
      };
      var CachingNotificationFileOperationFeature = class extends NotificationFileOperationFeature {
        constructor() {
          super(...arguments);
          this._fsPathFileTypes = /* @__PURE__ */ new Map();
        }
        async getFileType(uri) {
          const fsPath = uri.fsPath;
          if (this._fsPathFileTypes.has(fsPath)) {
            return this._fsPathFileTypes.get(fsPath);
          }
          const type = await FileOperationFeature.getFileType(uri);
          if (type) {
            this._fsPathFileTypes.set(fsPath, type);
          }
          return type;
        }
        async cacheFileTypes(event, prop) {
          await this.filter(event, prop);
        }
        clearFileTypeCache() {
          this._fsPathFileTypes.clear();
        }
        unregister(id2) {
          super.unregister(id2);
          if (this.filterSize() === 0 && this._willListener) {
            this._willListener.dispose();
            this._willListener = void 0;
          }
        }
        dispose() {
          super.dispose();
          if (this._willListener) {
            this._willListener.dispose();
            this._willListener = void 0;
          }
        }
      };
      var DidCreateFilesFeature = class extends NotificationFileOperationFeature {
        constructor(client) {
          super(client, code.workspace.onDidCreateFiles, proto.DidCreateFilesNotification.type, "didCreate", "didCreate", (i) => i, client.code2ProtocolConverter.asDidCreateFilesParams);
        }
        doSend(event, next) {
          const middleware = this._client.middleware.workspace;
          return middleware?.didCreateFiles ? middleware.didCreateFiles(event, next) : next(event);
        }
      };
      exports2.DidCreateFilesFeature = DidCreateFilesFeature;
      var DidRenameFilesFeature = class extends CachingNotificationFileOperationFeature {
        constructor(client) {
          super(client, code.workspace.onDidRenameFiles, proto.DidRenameFilesNotification.type, "didRename", "didRename", (i) => i.oldUri, client.code2ProtocolConverter.asDidRenameFilesParams);
        }
        register(data) {
          if (!this._willListener) {
            this._willListener = code.workspace.onWillRenameFiles(this.willRename, this);
          }
          super.register(data);
        }
        willRename(e) {
          e.waitUntil(this.cacheFileTypes(e, (i) => i.oldUri));
        }
        doSend(event, next) {
          this.clearFileTypeCache();
          const middleware = this._client.middleware.workspace;
          return middleware?.didRenameFiles ? middleware.didRenameFiles(event, next) : next(event);
        }
      };
      exports2.DidRenameFilesFeature = DidRenameFilesFeature;
      var DidDeleteFilesFeature = class extends CachingNotificationFileOperationFeature {
        constructor(client) {
          super(client, code.workspace.onDidDeleteFiles, proto.DidDeleteFilesNotification.type, "didDelete", "didDelete", (i) => i, client.code2ProtocolConverter.asDidDeleteFilesParams);
        }
        register(data) {
          if (!this._willListener) {
            this._willListener = code.workspace.onWillDeleteFiles(this.willDelete, this);
          }
          super.register(data);
        }
        willDelete(e) {
          e.waitUntil(this.cacheFileTypes(e, (i) => i));
        }
        doSend(event, next) {
          this.clearFileTypeCache();
          const middleware = this._client.middleware.workspace;
          return middleware?.didDeleteFiles ? middleware.didDeleteFiles(event, next) : next(event);
        }
      };
      exports2.DidDeleteFilesFeature = DidDeleteFilesFeature;
      var RequestFileOperationFeature = class extends FileOperationFeature {
        constructor(client, event, requestType, clientCapability, serverCapability, accessUri, createParams) {
          super(client, event, requestType, clientCapability, serverCapability);
          this._requestType = requestType;
          this._accessUri = accessUri;
          this._createParams = createParams;
        }
        async send(originalEvent) {
          const waitUntil = this.waitUntil(originalEvent);
          originalEvent.waitUntil(waitUntil);
        }
        async waitUntil(originalEvent) {
          const filteredEvent = await this.filter(originalEvent, this._accessUri);
          if (filteredEvent.files.length) {
            const next = (event) => {
              return this._client.sendRequest(this._requestType, this._createParams(event), event.token).then(this._client.protocol2CodeConverter.asWorkspaceEdit);
            };
            return this.doSend(filteredEvent, next);
          } else {
            return void 0;
          }
        }
      };
      var WillCreateFilesFeature = class extends RequestFileOperationFeature {
        constructor(client) {
          super(client, code.workspace.onWillCreateFiles, proto.WillCreateFilesRequest.type, "willCreate", "willCreate", (i) => i, client.code2ProtocolConverter.asWillCreateFilesParams);
        }
        doSend(event, next) {
          const middleware = this._client.middleware.workspace;
          return middleware?.willCreateFiles ? middleware.willCreateFiles(event, next) : next(event);
        }
      };
      exports2.WillCreateFilesFeature = WillCreateFilesFeature;
      var WillRenameFilesFeature = class extends RequestFileOperationFeature {
        constructor(client) {
          super(client, code.workspace.onWillRenameFiles, proto.WillRenameFilesRequest.type, "willRename", "willRename", (i) => i.oldUri, client.code2ProtocolConverter.asWillRenameFilesParams);
        }
        doSend(event, next) {
          const middleware = this._client.middleware.workspace;
          return middleware?.willRenameFiles ? middleware.willRenameFiles(event, next) : next(event);
        }
      };
      exports2.WillRenameFilesFeature = WillRenameFilesFeature;
      var WillDeleteFilesFeature = class extends RequestFileOperationFeature {
        constructor(client) {
          super(client, code.workspace.onWillDeleteFiles, proto.WillDeleteFilesRequest.type, "willDelete", "willDelete", (i) => i, client.code2ProtocolConverter.asWillDeleteFilesParams);
        }
        doSend(event, next) {
          const middleware = this._client.middleware.workspace;
          return middleware?.willDeleteFiles ? middleware.willDeleteFiles(event, next) : next(event);
        }
      };
      exports2.WillDeleteFilesFeature = WillDeleteFilesFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/linkedEditingRange.js
  var require_linkedEditingRange2 = __commonJS({
    "node_modules/vscode-languageclient/lib/common/linkedEditingRange.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LinkedEditingFeature = void 0;
      var code = (init_api(), __toCommonJS(api_exports));
      var proto = require_main3();
      var features_1 = require_features();
      var LinkedEditingFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, proto.LinkedEditingRangeRequest.type);
        }
        fillClientCapabilities(capabilities) {
          const linkedEditingSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "linkedEditingRange");
          linkedEditingSupport.dynamicRegistration = true;
        }
        initialize(capabilities, documentSelector) {
          let [id2, options] = this.getRegistration(documentSelector, capabilities.linkedEditingRangeProvider);
          if (!id2 || !options) {
            return;
          }
          this.register({ id: id2, registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const provider = {
            provideLinkedEditingRanges: (document2, position, token) => {
              const client = this._client;
              const provideLinkedEditing = (document3, position2, token2) => {
                return client.sendRequest(proto.LinkedEditingRangeRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2), token2).then((result) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asLinkedEditingRanges(result, token2);
                }, (error) => {
                  return client.handleFailedRequest(proto.LinkedEditingRangeRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideLinkedEditingRange ? middleware.provideLinkedEditingRange(document2, position, token, provideLinkedEditing) : provideLinkedEditing(document2, position, token);
            }
          };
          return [this.registerProvider(selector, provider), provider];
        }
        registerProvider(selector, provider) {
          return code.languages.registerLinkedEditingRangeProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
        }
      };
      exports2.LinkedEditingFeature = LinkedEditingFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/typeHierarchy.js
  var require_typeHierarchy2 = __commonJS({
    "node_modules/vscode-languageclient/lib/common/typeHierarchy.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TypeHierarchyFeature = void 0;
      var vscode_1 = (init_api(), __toCommonJS(api_exports));
      var vscode_languageserver_protocol_1 = require_main3();
      var features_1 = require_features();
      var TypeHierarchyProvider = class {
        constructor(client) {
          this.client = client;
          this.middleware = client.middleware;
        }
        prepareTypeHierarchy(document2, position, token) {
          const client = this.client;
          const middleware = this.middleware;
          const prepareTypeHierarchy = (document3, position2, token2) => {
            const params = client.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2);
            return client.sendRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, params, token2).then((result) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              return client.protocol2CodeConverter.asTypeHierarchyItems(result, token2);
            }, (error) => {
              return client.handleFailedRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, token2, error, null);
            });
          };
          return middleware.prepareTypeHierarchy ? middleware.prepareTypeHierarchy(document2, position, token, prepareTypeHierarchy) : prepareTypeHierarchy(document2, position, token);
        }
        provideTypeHierarchySupertypes(item, token) {
          const client = this.client;
          const middleware = this.middleware;
          const provideTypeHierarchySupertypes = (item2, token2) => {
            const params = {
              item: client.code2ProtocolConverter.asTypeHierarchyItem(item2)
            };
            return client.sendRequest(vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type, params, token2).then((result) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              return client.protocol2CodeConverter.asTypeHierarchyItems(result, token2);
            }, (error) => {
              return client.handleFailedRequest(vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type, token2, error, null);
            });
          };
          return middleware.provideTypeHierarchySupertypes ? middleware.provideTypeHierarchySupertypes(item, token, provideTypeHierarchySupertypes) : provideTypeHierarchySupertypes(item, token);
        }
        provideTypeHierarchySubtypes(item, token) {
          const client = this.client;
          const middleware = this.middleware;
          const provideTypeHierarchySubtypes = (item2, token2) => {
            const params = {
              item: client.code2ProtocolConverter.asTypeHierarchyItem(item2)
            };
            return client.sendRequest(vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type, params, token2).then((result) => {
              if (token2.isCancellationRequested) {
                return null;
              }
              return client.protocol2CodeConverter.asTypeHierarchyItems(result, token2);
            }, (error) => {
              return client.handleFailedRequest(vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type, token2, error, null);
            });
          };
          return middleware.provideTypeHierarchySubtypes ? middleware.provideTypeHierarchySubtypes(item, token, provideTypeHierarchySubtypes) : provideTypeHierarchySubtypes(item, token);
        }
      };
      var TypeHierarchyFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type);
        }
        fillClientCapabilities(capabilities) {
          const capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "typeHierarchy");
          capability.dynamicRegistration = true;
        }
        initialize(capabilities, documentSelector) {
          const [id2, options] = this.getRegistration(documentSelector, capabilities.typeHierarchyProvider);
          if (!id2 || !options) {
            return;
          }
          this.register({ id: id2, registerOptions: options });
        }
        registerLanguageProvider(options) {
          const client = this._client;
          const provider = new TypeHierarchyProvider(client);
          return [vscode_1.languages.registerTypeHierarchyProvider(client.protocol2CodeConverter.asDocumentSelector(options.documentSelector), provider), provider];
        }
      };
      exports2.TypeHierarchyFeature = TypeHierarchyFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/inlineValue.js
  var require_inlineValue2 = __commonJS({
    "node_modules/vscode-languageclient/lib/common/inlineValue.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.InlineValueFeature = void 0;
      var vscode_1 = (init_api(), __toCommonJS(api_exports));
      var vscode_languageserver_protocol_1 = require_main3();
      var features_1 = require_features();
      var InlineValueFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.InlineValueRequest.type);
        }
        fillClientCapabilities(capabilities) {
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "inlineValue").dynamicRegistration = true;
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "inlineValue").refreshSupport = true;
        }
        initialize(capabilities, documentSelector) {
          this._client.onRequest(vscode_languageserver_protocol_1.InlineValueRefreshRequest.type, async () => {
            for (const provider of this.getAllProviders()) {
              provider.onDidChangeInlineValues.fire();
            }
          });
          const [id2, options] = this.getRegistration(documentSelector, capabilities.inlineValueProvider);
          if (!id2 || !options) {
            return;
          }
          this.register({ id: id2, registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const eventEmitter = new vscode_1.EventEmitter();
          const provider = {
            onDidChangeInlineValues: eventEmitter.event,
            provideInlineValues: (document2, viewPort, context, token) => {
              const client = this._client;
              const provideInlineValues = (document3, viewPort2, context2, token2) => {
                const requestParams = {
                  textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                  range: client.code2ProtocolConverter.asRange(viewPort2),
                  context: client.code2ProtocolConverter.asInlineValueContext(context2)
                };
                return client.sendRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, requestParams, token2).then((values) => {
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asInlineValues(values, token2);
                }, (error) => {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, token2, error, null);
                });
              };
              const middleware = client.middleware;
              return middleware.provideInlineValues ? middleware.provideInlineValues(document2, viewPort, context, token, provideInlineValues) : provideInlineValues(document2, viewPort, context, token);
            }
          };
          return [this.registerProvider(selector, provider), { provider, onDidChangeInlineValues: eventEmitter }];
        }
        registerProvider(selector, provider) {
          return vscode_1.languages.registerInlineValuesProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
        }
      };
      exports2.InlineValueFeature = InlineValueFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/inlayHint.js
  var require_inlayHint2 = __commonJS({
    "node_modules/vscode-languageclient/lib/common/inlayHint.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.InlayHintsFeature = void 0;
      var vscode_1 = (init_api(), __toCommonJS(api_exports));
      var vscode_languageserver_protocol_1 = require_main3();
      var features_1 = require_features();
      var InlayHintsFeature = class extends features_1.TextDocumentLanguageFeature {
        constructor(client) {
          super(client, vscode_languageserver_protocol_1.InlayHintRequest.type);
        }
        fillClientCapabilities(capabilities) {
          const inlayHint = (0, features_1.ensure)((0, features_1.ensure)(capabilities, "textDocument"), "inlayHint");
          inlayHint.dynamicRegistration = true;
          inlayHint.resolveSupport = {
            properties: ["tooltip", "textEdits", "label.tooltip", "label.location", "label.command"]
          };
          (0, features_1.ensure)((0, features_1.ensure)(capabilities, "workspace"), "inlayHint").refreshSupport = true;
        }
        initialize(capabilities, documentSelector) {
          this._client.onRequest(vscode_languageserver_protocol_1.InlayHintRefreshRequest.type, async () => {
            for (const provider of this.getAllProviders()) {
              provider.onDidChangeInlayHints.fire();
            }
          });
          const [id2, options] = this.getRegistration(documentSelector, capabilities.inlayHintProvider);
          if (!id2 || !options) {
            return;
          }
          this.register({ id: id2, registerOptions: options });
        }
        registerLanguageProvider(options) {
          const selector = options.documentSelector;
          const eventEmitter = new vscode_1.EventEmitter();
          const provider = {
            onDidChangeInlayHints: eventEmitter.event,
            provideInlayHints: (document2, viewPort, token) => {
              const client = this._client;
              const provideInlayHints = async (document3, viewPort2, token2) => {
                const requestParams = {
                  textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                  range: client.code2ProtocolConverter.asRange(viewPort2)
                };
                try {
                  const values = await client.sendRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, requestParams, token2);
                  if (token2.isCancellationRequested) {
                    return null;
                  }
                  return client.protocol2CodeConverter.asInlayHints(values, token2);
                } catch (error) {
                  return client.handleFailedRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, token2, error, null);
                }
              };
              const middleware = client.middleware;
              return middleware.provideInlayHints ? middleware.provideInlayHints(document2, viewPort, token, provideInlayHints) : provideInlayHints(document2, viewPort, token);
            }
          };
          provider.resolveInlayHint = options.resolveProvider === true ? (hint, token) => {
            const client = this._client;
            const resolveInlayHint = async (item, token2) => {
              try {
                const value = await client.sendRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, client.code2ProtocolConverter.asInlayHint(item), token2);
                if (token2.isCancellationRequested) {
                  return null;
                }
                const result = client.protocol2CodeConverter.asInlayHint(value, token2);
                return token2.isCancellationRequested ? null : result;
              } catch (error) {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, token2, error, null);
              }
            };
            const middleware = client.middleware;
            return middleware.resolveInlayHint ? middleware.resolveInlayHint(hint, token, resolveInlayHint) : resolveInlayHint(hint, token);
          } : void 0;
          return [this.registerProvider(selector, provider), { provider, onDidChangeInlayHints: eventEmitter }];
        }
        registerProvider(selector, provider) {
          return vscode_1.languages.registerInlayHintsProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
        }
      };
      exports2.InlayHintsFeature = InlayHintsFeature;
    }
  });

  // node_modules/vscode-languageclient/lib/common/client.js
  var require_client = __commonJS({
    "node_modules/vscode-languageclient/lib/common/client.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ProposedFeatures = exports2.BaseLanguageClient = exports2.MessageTransports = exports2.SuspendMode = exports2.State = exports2.CloseAction = exports2.ErrorAction = exports2.RevealOutputChannelOn = void 0;
      var vscode_1 = (init_api(), __toCommonJS(api_exports));
      var vscode_languageserver_protocol_1 = require_main3();
      var c2p = require_codeConverter();
      var p2c = require_protocolConverter();
      var Is = require_is4();
      var async_1 = require_async();
      var UUID = require_uuid2();
      var progressPart_1 = require_progressPart();
      var features_1 = require_features();
      var diagnostic_1 = require_diagnostic2();
      var notebook_1 = require_notebook2();
      var configuration_1 = require_configuration3();
      var textSynchronization_1 = require_textSynchronization();
      var completion_1 = require_completion();
      var hover_1 = require_hover();
      var definition_1 = require_definition();
      var signatureHelp_1 = require_signatureHelp();
      var documentHighlight_1 = require_documentHighlight();
      var documentSymbol_1 = require_documentSymbol();
      var workspaceSymbol_1 = require_workspaceSymbol();
      var reference_1 = require_reference();
      var codeAction_1 = require_codeAction();
      var codeLens_1 = require_codeLens();
      var formatting_1 = require_formatting();
      var rename_1 = require_rename();
      var documentLink_1 = require_documentLink();
      var executeCommand_1 = require_executeCommand();
      var fileSystemWatcher_1 = require_fileSystemWatcher();
      var colorProvider_1 = require_colorProvider();
      var implementation_1 = require_implementation();
      var typeDefinition_1 = require_typeDefinition();
      var workspaceFolder_1 = require_workspaceFolder2();
      var foldingRange_1 = require_foldingRange();
      var declaration_1 = require_declaration();
      var selectionRange_1 = require_selectionRange();
      var progress_1 = require_progress2();
      var callHierarchy_1 = require_callHierarchy2();
      var semanticTokens_1 = require_semanticTokens2();
      var fileOperations_1 = require_fileOperations2();
      var linkedEditingRange_1 = require_linkedEditingRange2();
      var typeHierarchy_1 = require_typeHierarchy2();
      var inlineValue_1 = require_inlineValue2();
      var inlayHint_1 = require_inlayHint2();
      var RevealOutputChannelOn;
      (function(RevealOutputChannelOn2) {
        RevealOutputChannelOn2[RevealOutputChannelOn2["Info"] = 1] = "Info";
        RevealOutputChannelOn2[RevealOutputChannelOn2["Warn"] = 2] = "Warn";
        RevealOutputChannelOn2[RevealOutputChannelOn2["Error"] = 3] = "Error";
        RevealOutputChannelOn2[RevealOutputChannelOn2["Never"] = 4] = "Never";
      })(RevealOutputChannelOn = exports2.RevealOutputChannelOn || (exports2.RevealOutputChannelOn = {}));
      var ErrorAction;
      (function(ErrorAction2) {
        ErrorAction2[ErrorAction2["Continue"] = 1] = "Continue";
        ErrorAction2[ErrorAction2["Shutdown"] = 2] = "Shutdown";
      })(ErrorAction = exports2.ErrorAction || (exports2.ErrorAction = {}));
      var CloseAction;
      (function(CloseAction2) {
        CloseAction2[CloseAction2["DoNotRestart"] = 1] = "DoNotRestart";
        CloseAction2[CloseAction2["Restart"] = 2] = "Restart";
      })(CloseAction = exports2.CloseAction || (exports2.CloseAction = {}));
      var State;
      (function(State2) {
        State2[State2["Stopped"] = 1] = "Stopped";
        State2[State2["Starting"] = 3] = "Starting";
        State2[State2["Running"] = 2] = "Running";
      })(State = exports2.State || (exports2.State = {}));
      var SuspendMode;
      (function(SuspendMode2) {
        SuspendMode2["off"] = "off";
        SuspendMode2["on"] = "on";
      })(SuspendMode = exports2.SuspendMode || (exports2.SuspendMode = {}));
      var DefaultErrorHandler = class {
        constructor(client, maxRestartCount) {
          this.client = client;
          this.maxRestartCount = maxRestartCount;
          this.restarts = [];
        }
        error(_error, _message, count) {
          if (count && count <= 3) {
            return { action: ErrorAction.Continue };
          }
          return { action: ErrorAction.Shutdown };
        }
        closed() {
          this.restarts.push(Date.now());
          if (this.restarts.length <= this.maxRestartCount) {
            return { action: CloseAction.Restart };
          } else {
            let diff = this.restarts[this.restarts.length - 1] - this.restarts[0];
            if (diff <= 3 * 60 * 1e3) {
              return { action: CloseAction.DoNotRestart, message: `The ${this.client.name} server crashed ${this.maxRestartCount + 1} times in the last 3 minutes. The server will not be restarted. See the output for more information.` };
            } else {
              this.restarts.shift();
              return { action: CloseAction.Restart };
            }
          }
        }
      };
      var ClientState;
      (function(ClientState2) {
        ClientState2["Initial"] = "initial";
        ClientState2["Starting"] = "starting";
        ClientState2["StartFailed"] = "startFailed";
        ClientState2["Running"] = "running";
        ClientState2["Stopping"] = "stopping";
        ClientState2["Stopped"] = "stopped";
      })(ClientState || (ClientState = {}));
      var MessageTransports;
      (function(MessageTransports2) {
        function is(value) {
          let candidate = value;
          return candidate && vscode_languageserver_protocol_1.MessageReader.is(value.reader) && vscode_languageserver_protocol_1.MessageWriter.is(value.writer);
        }
        MessageTransports2.is = is;
      })(MessageTransports = exports2.MessageTransports || (exports2.MessageTransports = {}));
      var BaseLanguageClient = class {
        constructor(id2, name, clientOptions) {
          this._traceFormat = vscode_languageserver_protocol_1.TraceFormat.Text;
          this._diagnosticQueue = /* @__PURE__ */ new Map();
          this._diagnosticQueueState = { state: "idle" };
          this._features = [];
          this._dynamicFeatures = /* @__PURE__ */ new Map();
          this.workspaceEditLock = new async_1.Semaphore(1);
          this._id = id2;
          this._name = name;
          clientOptions = clientOptions || {};
          const markdown = { isTrusted: false, supportHtml: false };
          if (clientOptions.markdown !== void 0) {
            markdown.isTrusted = clientOptions.markdown.isTrusted === true;
            markdown.supportHtml = clientOptions.markdown.supportHtml === true;
          }
          this._clientOptions = {
            documentSelector: clientOptions.documentSelector ?? [],
            synchronize: clientOptions.synchronize ?? {},
            diagnosticCollectionName: clientOptions.diagnosticCollectionName,
            outputChannelName: clientOptions.outputChannelName ?? this._name,
            revealOutputChannelOn: clientOptions.revealOutputChannelOn ?? RevealOutputChannelOn.Error,
            stdioEncoding: clientOptions.stdioEncoding ?? "utf8",
            initializationOptions: clientOptions.initializationOptions,
            initializationFailedHandler: clientOptions.initializationFailedHandler,
            progressOnInitialization: !!clientOptions.progressOnInitialization,
            errorHandler: clientOptions.errorHandler ?? this.createDefaultErrorHandler(clientOptions.connectionOptions?.maxRestartCount),
            middleware: clientOptions.middleware ?? {},
            uriConverters: clientOptions.uriConverters,
            workspaceFolder: clientOptions.workspaceFolder,
            connectionOptions: clientOptions.connectionOptions,
            markdown,
            // suspend: {
            // 	mode: clientOptions.suspend?.mode ?? SuspendMode.off,
            // 	callback: clientOptions.suspend?.callback ?? (() => Promise.resolve(true)),
            // 	interval: clientOptions.suspend?.interval ? Math.max(clientOptions.suspend.interval, defaultInterval) : defaultInterval
            // },
            diagnosticPullOptions: clientOptions.diagnosticPullOptions ?? { onChange: true, onSave: false },
            notebookDocumentOptions: clientOptions.notebookDocumentOptions ?? {}
          };
          this._clientOptions.synchronize = this._clientOptions.synchronize || {};
          this._state = ClientState.Initial;
          this._ignoredRegistrations = /* @__PURE__ */ new Set();
          this._listeners = [];
          this._notificationHandlers = /* @__PURE__ */ new Map();
          this._pendingNotificationHandlers = /* @__PURE__ */ new Map();
          this._notificationDisposables = /* @__PURE__ */ new Map();
          this._requestHandlers = /* @__PURE__ */ new Map();
          this._pendingRequestHandlers = /* @__PURE__ */ new Map();
          this._requestDisposables = /* @__PURE__ */ new Map();
          this._progressHandlers = /* @__PURE__ */ new Map();
          this._pendingProgressHandlers = /* @__PURE__ */ new Map();
          this._progressDisposables = /* @__PURE__ */ new Map();
          this._connection = void 0;
          this._initializeResult = void 0;
          if (clientOptions.outputChannel) {
            this._outputChannel = clientOptions.outputChannel;
            this._disposeOutputChannel = false;
          } else {
            this._outputChannel = void 0;
            this._disposeOutputChannel = true;
          }
          this._traceOutputChannel = clientOptions.traceOutputChannel;
          this._diagnostics = void 0;
          this._fileEvents = [];
          this._fileEventDelayer = new async_1.Delayer(250);
          this._onStop = void 0;
          this._telemetryEmitter = new vscode_languageserver_protocol_1.Emitter();
          this._stateChangeEmitter = new vscode_languageserver_protocol_1.Emitter();
          this._trace = vscode_languageserver_protocol_1.Trace.Off;
          this._tracer = {
            log: (messageOrDataObject, data) => {
              if (Is.string(messageOrDataObject)) {
                this.logTrace(messageOrDataObject, data);
              } else {
                this.logObjectTrace(messageOrDataObject);
              }
            }
          };
          this._c2p = c2p.createConverter(clientOptions.uriConverters ? clientOptions.uriConverters.code2Protocol : void 0);
          this._p2c = p2c.createConverter(clientOptions.uriConverters ? clientOptions.uriConverters.protocol2Code : void 0, this._clientOptions.markdown.isTrusted, this._clientOptions.markdown.supportHtml);
          this._syncedDocuments = /* @__PURE__ */ new Map();
          this.registerBuiltinFeatures();
        }
        get name() {
          return this._name;
        }
        get middleware() {
          return this._clientOptions.middleware ?? /* @__PURE__ */ Object.create(null);
        }
        get clientOptions() {
          return this._clientOptions;
        }
        get protocol2CodeConverter() {
          return this._p2c;
        }
        get code2ProtocolConverter() {
          return this._c2p;
        }
        get onTelemetry() {
          return this._telemetryEmitter.event;
        }
        get onDidChangeState() {
          return this._stateChangeEmitter.event;
        }
        get outputChannel() {
          if (!this._outputChannel) {
            this._outputChannel = vscode_1.window.createOutputChannel(this._clientOptions.outputChannelName ? this._clientOptions.outputChannelName : this._name);
          }
          return this._outputChannel;
        }
        get traceOutputChannel() {
          if (this._traceOutputChannel) {
            return this._traceOutputChannel;
          }
          return this.outputChannel;
        }
        get diagnostics() {
          return this._diagnostics;
        }
        get state() {
          return this.getPublicState();
        }
        get $state() {
          return this._state;
        }
        set $state(value) {
          let oldState = this.getPublicState();
          this._state = value;
          let newState = this.getPublicState();
          if (newState !== oldState) {
            this._stateChangeEmitter.fire({ oldState, newState });
          }
        }
        getPublicState() {
          switch (this.$state) {
            case ClientState.Starting:
              return State.Starting;
            case ClientState.Running:
              return State.Running;
            default:
              return State.Stopped;
          }
        }
        get initializeResult() {
          return this._initializeResult;
        }
        async sendRequest(type, ...params) {
          if (this.$state === ClientState.StartFailed || this.$state === ClientState.Stopping || this.$state === ClientState.Stopped) {
            return Promise.reject(new vscode_languageserver_protocol_1.ResponseError(vscode_languageserver_protocol_1.ErrorCodes.ConnectionInactive, `Client is not running`));
          }
          try {
            const connection = await this.$start();
            await this.forceDocumentSync();
            return connection.sendRequest(type, ...params);
          } catch (error) {
            this.error(`Sending request ${Is.string(type) ? type : type.method} failed.`, error);
            throw error;
          }
        }
        onRequest(type, handler) {
          const method = typeof type === "string" ? type : type.method;
          this._requestHandlers.set(method, handler);
          const connection = this.activeConnection();
          let disposable;
          if (connection !== void 0) {
            this._requestDisposables.set(method, connection.onRequest(type, handler));
            disposable = {
              dispose: () => {
                const disposable2 = this._requestDisposables.get(method);
                if (disposable2 !== void 0) {
                  disposable2.dispose();
                  this._requestDisposables.delete(method);
                }
              }
            };
          } else {
            this._pendingRequestHandlers.set(method, handler);
            disposable = {
              dispose: () => {
                this._pendingRequestHandlers.delete(method);
                const disposable2 = this._requestDisposables.get(method);
                if (disposable2 !== void 0) {
                  disposable2.dispose();
                  this._requestDisposables.delete(method);
                }
              }
            };
          }
          return {
            dispose: () => {
              this._requestHandlers.delete(method);
              disposable.dispose();
            }
          };
        }
        async sendNotification(type, params) {
          if (this.$state === ClientState.StartFailed || this.$state === ClientState.Stopping || this.$state === ClientState.Stopped) {
            return Promise.reject(new vscode_languageserver_protocol_1.ResponseError(vscode_languageserver_protocol_1.ErrorCodes.ConnectionInactive, `Client is not running`));
          }
          try {
            const connection = await this.$start();
            await this.forceDocumentSync();
            return connection.sendNotification(type, params);
          } catch (error) {
            this.error(`Sending notification ${Is.string(type) ? type : type.method} failed.`, error);
            throw error;
          }
        }
        onNotification(type, handler) {
          const method = typeof type === "string" ? type : type.method;
          this._notificationHandlers.set(method, handler);
          const connection = this.activeConnection();
          let disposable;
          if (connection !== void 0) {
            this._notificationDisposables.set(method, connection.onNotification(type, handler));
            disposable = {
              dispose: () => {
                const disposable2 = this._notificationDisposables.get(method);
                if (disposable2 !== void 0) {
                  disposable2.dispose();
                  this._notificationDisposables.delete(method);
                }
              }
            };
          } else {
            this._pendingNotificationHandlers.set(method, handler);
            disposable = {
              dispose: () => {
                this._pendingNotificationHandlers.delete(method);
                const disposable2 = this._notificationDisposables.get(method);
                if (disposable2 !== void 0) {
                  disposable2.dispose();
                  this._notificationDisposables.delete(method);
                }
              }
            };
          }
          return {
            dispose: () => {
              this._notificationHandlers.delete(method);
              disposable.dispose();
            }
          };
        }
        async sendProgress(type, token, value) {
          if (this.$state === ClientState.StartFailed || this.$state === ClientState.Stopping || this.$state === ClientState.Stopped) {
            return Promise.reject(new vscode_languageserver_protocol_1.ResponseError(vscode_languageserver_protocol_1.ErrorCodes.ConnectionInactive, `Client is not running`));
          }
          try {
            const connection = await this.$start();
            return connection.sendProgress(type, token, value);
          } catch (error) {
            this.error(`Sending progress for token ${token} failed.`, error);
            throw error;
          }
        }
        onProgress(type, token, handler) {
          this._progressHandlers.set(token, { type, handler });
          const connection = this.activeConnection();
          let disposable;
          const handleWorkDoneProgress = this._clientOptions.middleware?.handleWorkDoneProgress;
          const realHandler = vscode_languageserver_protocol_1.WorkDoneProgress.is(type) && handleWorkDoneProgress !== void 0 ? (params) => {
            handleWorkDoneProgress(token, params, () => handler(params));
          } : handler;
          if (connection !== void 0) {
            this._progressDisposables.set(token, connection.onProgress(type, token, realHandler));
            disposable = {
              dispose: () => {
                const disposable2 = this._progressDisposables.get(token);
                if (disposable2 !== void 0) {
                  disposable2.dispose();
                  this._progressDisposables.delete(token);
                }
              }
            };
          } else {
            this._pendingProgressHandlers.set(token, { type, handler });
            disposable = {
              dispose: () => {
                this._pendingProgressHandlers.delete(token);
                const disposable2 = this._progressDisposables.get(token);
                if (disposable2 !== void 0) {
                  disposable2.dispose();
                  this._progressDisposables.delete(token);
                }
              }
            };
          }
          return {
            dispose: () => {
              this._progressHandlers.delete(token);
              disposable.dispose();
            }
          };
        }
        createDefaultErrorHandler(maxRestartCount) {
          if (maxRestartCount !== void 0 && maxRestartCount < 0) {
            throw new Error(`Invalid maxRestartCount: ${maxRestartCount}`);
          }
          return new DefaultErrorHandler(this, maxRestartCount ?? 4);
        }
        async setTrace(value) {
          this._trace = value;
          const connection = this.activeConnection();
          if (connection !== void 0) {
            await connection.trace(this._trace, this._tracer, {
              sendNotification: false,
              traceFormat: this._traceFormat
            });
          }
        }
        data2String(data) {
          if (data instanceof vscode_languageserver_protocol_1.ResponseError) {
            const responseError = data;
            return `  Message: ${responseError.message}
  Code: ${responseError.code} ${responseError.data ? "\n" + responseError.data.toString() : ""}`;
          }
          if (data instanceof Error) {
            if (Is.string(data.stack)) {
              return data.stack;
            }
            return data.message;
          }
          if (Is.string(data)) {
            return data;
          }
          return data.toString();
        }
        info(message, data, showNotification = true) {
          this.outputChannel.appendLine(`[Info  - ${new Date().toLocaleTimeString()}] ${message}`);
          if (data !== null && data !== void 0) {
            this.outputChannel.appendLine(this.data2String(data));
          }
          if (showNotification && this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Info) {
            this.showNotificationMessage(vscode_languageserver_protocol_1.MessageType.Info, message);
          }
        }
        warn(message, data, showNotification = true) {
          this.outputChannel.appendLine(`[Warn  - ${new Date().toLocaleTimeString()}] ${message}`);
          if (data !== null && data !== void 0) {
            this.outputChannel.appendLine(this.data2String(data));
          }
          if (showNotification && this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Warn) {
            this.showNotificationMessage(vscode_languageserver_protocol_1.MessageType.Warning, message);
          }
        }
        error(message, data, showNotification = true) {
          this.outputChannel.appendLine(`[Error - ${new Date().toLocaleTimeString()}] ${message}`);
          if (data !== null && data !== void 0) {
            this.outputChannel.appendLine(this.data2String(data));
          }
          if (showNotification === "force" || showNotification && this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Error) {
            this.showNotificationMessage(vscode_languageserver_protocol_1.MessageType.Error, message);
          }
        }
        showNotificationMessage(type, message) {
          message = message ?? "A request has failed. See the output for more information.";
          const messageFunc = type === vscode_languageserver_protocol_1.MessageType.Error ? vscode_1.window.showErrorMessage : type === vscode_languageserver_protocol_1.MessageType.Warning ? vscode_1.window.showWarningMessage : vscode_1.window.showInformationMessage;
          void messageFunc(message, "Go to output").then((selection) => {
            if (selection !== void 0) {
              this.outputChannel.show(true);
            }
          });
        }
        logTrace(message, data) {
          this.traceOutputChannel.appendLine(`[Trace - ${new Date().toLocaleTimeString()}] ${message}`);
          if (data) {
            this.traceOutputChannel.appendLine(this.data2String(data));
          }
        }
        logObjectTrace(data) {
          if (data.isLSPMessage && data.type) {
            this.traceOutputChannel.append(`[LSP   - ${new Date().toLocaleTimeString()}] `);
          } else {
            this.traceOutputChannel.append(`[Trace - ${new Date().toLocaleTimeString()}] `);
          }
          if (data) {
            this.traceOutputChannel.appendLine(`${JSON.stringify(data)}`);
          }
        }
        needsStart() {
          return this.$state === ClientState.Initial || this.$state === ClientState.Stopping || this.$state === ClientState.Stopped;
        }
        needsStop() {
          return this.$state === ClientState.Starting || this.$state === ClientState.Running;
        }
        activeConnection() {
          return this.$state === ClientState.Running && this._connection !== void 0 ? this._connection : void 0;
        }
        isRunning() {
          return this.$state === ClientState.Running;
        }
        async start() {
          if (this._disposed === "disposing" || this._disposed === "disposed") {
            throw new Error(`Client got disposed and can't be restarted.`);
          }
          if (this.$state === ClientState.Stopping) {
            throw new Error(`Client is currently stopping. Can only restart a full stopped client`);
          }
          if (this._onStart !== void 0) {
            return this._onStart;
          }
          const [promise, resolve2, reject] = this.createOnStartPromise();
          this._onStart = promise;
          if (this._diagnostics === void 0) {
            this._diagnostics = this._clientOptions.diagnosticCollectionName ? vscode_1.languages.createDiagnosticCollection(this._clientOptions.diagnosticCollectionName) : vscode_1.languages.createDiagnosticCollection();
          }
          for (const [method, handler] of this._notificationHandlers) {
            if (!this._pendingNotificationHandlers.has(method)) {
              this._pendingNotificationHandlers.set(method, handler);
            }
          }
          for (const [method, handler] of this._requestHandlers) {
            if (!this._pendingRequestHandlers.has(method)) {
              this._pendingRequestHandlers.set(method, handler);
            }
          }
          for (const [token, data] of this._progressHandlers) {
            if (!this._pendingProgressHandlers.has(token)) {
              this._pendingProgressHandlers.set(token, data);
            }
          }
          this.$state = ClientState.Starting;
          try {
            const connection = await this.createConnection();
            connection.onNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, (message) => {
              switch (message.type) {
                case vscode_languageserver_protocol_1.MessageType.Error:
                  this.error(message.message, void 0, false);
                  break;
                case vscode_languageserver_protocol_1.MessageType.Warning:
                  this.warn(message.message, void 0, false);
                  break;
                case vscode_languageserver_protocol_1.MessageType.Info:
                  this.info(message.message, void 0, false);
                  break;
                default:
                  this.outputChannel.appendLine(message.message);
              }
            });
            connection.onNotification(vscode_languageserver_protocol_1.ShowMessageNotification.type, (message) => {
              switch (message.type) {
                case vscode_languageserver_protocol_1.MessageType.Error:
                  void vscode_1.window.showErrorMessage(message.message);
                  break;
                case vscode_languageserver_protocol_1.MessageType.Warning:
                  void vscode_1.window.showWarningMessage(message.message);
                  break;
                case vscode_languageserver_protocol_1.MessageType.Info:
                  void vscode_1.window.showInformationMessage(message.message);
                  break;
                default:
                  void vscode_1.window.showInformationMessage(message.message);
              }
            });
            connection.onRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, (params) => {
              let messageFunc;
              switch (params.type) {
                case vscode_languageserver_protocol_1.MessageType.Error:
                  messageFunc = vscode_1.window.showErrorMessage;
                  break;
                case vscode_languageserver_protocol_1.MessageType.Warning:
                  messageFunc = vscode_1.window.showWarningMessage;
                  break;
                case vscode_languageserver_protocol_1.MessageType.Info:
                  messageFunc = vscode_1.window.showInformationMessage;
                  break;
                default:
                  messageFunc = vscode_1.window.showInformationMessage;
              }
              let actions = params.actions || [];
              return messageFunc(params.message, ...actions);
            });
            connection.onNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, (data) => {
              this._telemetryEmitter.fire(data);
            });
            connection.onRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, async (params) => {
              const showDocument = async (params2) => {
                const uri = this.protocol2CodeConverter.asUri(params2.uri);
                try {
                  if (params2.external === true) {
                    const success = await vscode_1.env.openExternal(uri);
                    return { success };
                  } else {
                    const options = {};
                    if (params2.selection !== void 0) {
                      options.selection = this.protocol2CodeConverter.asRange(params2.selection);
                    }
                    if (params2.takeFocus === void 0 || params2.takeFocus === false) {
                      options.preserveFocus = true;
                    } else if (params2.takeFocus === true) {
                      options.preserveFocus = false;
                    }
                    await vscode_1.window.showTextDocument(uri, options);
                    return { success: true };
                  }
                } catch (error) {
                  return { success: false };
                }
              };
              const middleware = this._clientOptions.middleware.window?.showDocument;
              if (middleware !== void 0) {
                return middleware(params, showDocument);
              } else {
                return showDocument(params);
              }
            });
            connection.listen();
            await this.initialize(connection);
            resolve2();
          } catch (error) {
            this.$state = ClientState.StartFailed;
            this.error(`${this._name} client: couldn't create connection to server.`, error, "force");
            reject(error);
          }
          return this._onStart;
        }
        createOnStartPromise() {
          let resolve2;
          let reject;
          const promise = new Promise((_resolve, _reject) => {
            resolve2 = _resolve;
            reject = _reject;
          });
          return [promise, resolve2, reject];
        }
        async initialize(connection) {
          this.refreshTrace(connection, false);
          const initOption = this._clientOptions.initializationOptions;
          const [rootPath, workspaceFolders] = this._clientOptions.workspaceFolder !== void 0 ? [this._clientOptions.workspaceFolder.uri.fsPath, [{ uri: this._c2p.asUri(this._clientOptions.workspaceFolder.uri), name: this._clientOptions.workspaceFolder.name }]] : [this._clientGetRootPath(), null];
          const initParams = {
            processId: null,
            clientInfo: {
              name: vscode_1.env.appName,
              version: vscode_1.version
            },
            locale: this.getLocale(),
            rootPath: rootPath ? rootPath : null,
            rootUri: rootPath ? this._c2p.asUri(vscode_1.Uri.file(rootPath)) : null,
            capabilities: this.computeClientCapabilities(),
            initializationOptions: Is.func(initOption) ? initOption() : initOption,
            trace: vscode_languageserver_protocol_1.Trace.toString(this._trace),
            workspaceFolders
          };
          this.fillInitializeParams(initParams);
          if (this._clientOptions.progressOnInitialization) {
            const token = UUID.generateUuid();
            const part = new progressPart_1.ProgressPart(connection, token);
            initParams.workDoneToken = token;
            try {
              const result = await this.doInitialize(connection, initParams);
              part.done();
              return result;
            } catch (error) {
              part.cancel();
              throw error;
            }
          } else {
            return this.doInitialize(connection, initParams);
          }
        }
        async doInitialize(connection, initParams) {
          try {
            const result = await connection.initialize(initParams);
            if (result.capabilities.positionEncoding !== void 0 && result.capabilities.positionEncoding !== vscode_languageserver_protocol_1.PositionEncodingKind.UTF16) {
              throw new Error(`Unsupported position encoding (${result.capabilities.positionEncoding}) received from server ${this.name}`);
            }
            this._initializeResult = result;
            this.$state = ClientState.Running;
            let textDocumentSyncOptions = void 0;
            if (Is.number(result.capabilities.textDocumentSync)) {
              if (result.capabilities.textDocumentSync === vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {
                textDocumentSyncOptions = {
                  openClose: false,
                  change: vscode_languageserver_protocol_1.TextDocumentSyncKind.None,
                  save: void 0
                };
              } else {
                textDocumentSyncOptions = {
                  openClose: true,
                  change: result.capabilities.textDocumentSync,
                  save: {
                    includeText: false
                  }
                };
              }
            } else if (result.capabilities.textDocumentSync !== void 0 && result.capabilities.textDocumentSync !== null) {
              textDocumentSyncOptions = result.capabilities.textDocumentSync;
            }
            this._capabilities = Object.assign({}, result.capabilities, { resolvedTextDocumentSync: textDocumentSyncOptions });
            connection.onNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, (params) => this.handleDiagnostics(params));
            connection.onRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, (params) => this.handleRegistrationRequest(params));
            connection.onRequest("client/registerFeature", (params) => this.handleRegistrationRequest(params));
            connection.onRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, (params) => this.handleUnregistrationRequest(params));
            connection.onRequest("client/unregisterFeature", (params) => this.handleUnregistrationRequest(params));
            connection.onRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, (params) => this.handleApplyWorkspaceEdit(params));
            for (const [method, handler] of this._pendingNotificationHandlers) {
              this._notificationDisposables.set(method, connection.onNotification(method, handler));
            }
            this._pendingNotificationHandlers.clear();
            for (const [method, handler] of this._pendingRequestHandlers) {
              this._requestDisposables.set(method, connection.onRequest(method, handler));
            }
            this._pendingRequestHandlers.clear();
            for (const [token, data] of this._pendingProgressHandlers) {
              this._progressDisposables.set(token, connection.onProgress(data.type, token, data.handler));
            }
            this._pendingProgressHandlers.clear();
            await connection.sendNotification(vscode_languageserver_protocol_1.InitializedNotification.type, {});
            this.hookFileEvents(connection);
            this.hookConfigurationChanged(connection);
            this.initializeFeatures(connection);
            return result;
          } catch (error) {
            if (this._clientOptions.initializationFailedHandler) {
              if (this._clientOptions.initializationFailedHandler(error)) {
                void this.initialize(connection);
              } else {
                void this.stop();
              }
            } else if (error instanceof vscode_languageserver_protocol_1.ResponseError && error.data && error.data.retry) {
              void vscode_1.window.showErrorMessage(error.message, { title: "Retry", id: "retry" }).then((item) => {
                if (item && item.id === "retry") {
                  void this.initialize(connection);
                } else {
                  void this.stop();
                }
              });
            } else {
              if (error && error.message) {
                void vscode_1.window.showErrorMessage(error.message);
              }
              this.error("Server initialization failed.", error);
              void this.stop();
            }
            throw error;
          }
        }
        _clientGetRootPath() {
          let folders = vscode_1.workspace.workspaceFolders;
          if (!folders || folders.length === 0) {
            return void 0;
          }
          let folder = folders[0];
          if (folder.uri.scheme === "file") {
            return folder.uri.fsPath;
          }
          return void 0;
        }
        stop(timeout = 2e3) {
          return this.shutdown("stop", timeout);
        }
        dispose(timeout = 2e3) {
          try {
            this._disposed = "disposing";
            return this.stop(timeout);
          } finally {
            this._disposed = "disposed";
          }
        }
        async shutdown(mode, timeout) {
          if (this.$state === ClientState.Stopped || this.$state === ClientState.Initial) {
            return;
          }
          if (this.$state === ClientState.Stopping) {
            if (this._onStop !== void 0) {
              return this._onStop;
            } else {
              throw new Error(`Client is stopping but no stop promise available.`);
            }
          }
          const connection = this.activeConnection();
          if (connection === void 0 || this.$state !== ClientState.Running) {
            throw new Error(`Client is not running and can't be stopped. It's current state is: ${this.$state}`);
          }
          this._initializeResult = void 0;
          this.$state = ClientState.Stopping;
          this.cleanUp(mode);
          const tp = new Promise((c) => {
            (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(c, timeout);
          });
          const shutdown = (async (connection2) => {
            await connection2.shutdown();
            await connection2.exit();
            return connection2;
          })(connection);
          return this._onStop = Promise.race([tp, shutdown]).then((connection2) => {
            if (connection2 !== void 0) {
              connection2.end();
              connection2.dispose();
            } else {
              this.error(`Stopping server timed out`, void 0, false);
              throw new Error(`Stopping the server timed out`);
            }
          }, (error) => {
            this.error(`Stopping server failed`, error, false);
            throw error;
          }).finally(() => {
            this.$state = ClientState.Stopped;
            mode === "stop" && this.cleanUpChannel();
            this._onStart = void 0;
            this._onStop = void 0;
            this._connection = void 0;
            this._ignoredRegistrations.clear();
          });
        }
        cleanUp(mode) {
          this._fileEvents = [];
          this._fileEventDelayer.cancel();
          const disposables = this._listeners.splice(0, this._listeners.length);
          for (const disposable of disposables) {
            disposable.dispose();
          }
          if (this._syncedDocuments) {
            this._syncedDocuments.clear();
          }
          for (const feature of Array.from(this._features.entries()).map((entry) => entry[1]).reverse()) {
            feature.dispose();
          }
          if (mode === "stop" && this._diagnostics !== void 0) {
            this._diagnostics.dispose();
            this._diagnostics = void 0;
          }
          if (this._idleInterval !== void 0) {
            this._idleInterval.dispose();
            this._idleInterval = void 0;
          }
        }
        cleanUpChannel() {
          if (this._outputChannel !== void 0 && this._disposeOutputChannel) {
            this._outputChannel.dispose();
            this._outputChannel = void 0;
          }
        }
        notifyFileEvent(event) {
          const client = this;
          async function didChangeWatchedFile(event2) {
            client._fileEvents.push(event2);
            return client._fileEventDelayer.trigger(async () => {
              const connection = await client.$start();
              await client.forceDocumentSync();
              const result = connection.sendNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, { changes: client._fileEvents });
              client._fileEvents = [];
              return result;
            });
          }
          const workSpaceMiddleware = this.clientOptions.middleware?.workspace;
          (workSpaceMiddleware?.didChangeWatchedFile ? workSpaceMiddleware.didChangeWatchedFile(event, didChangeWatchedFile) : didChangeWatchedFile(event)).catch((error) => {
            client.error(`Notify file events failed.`, error);
          });
        }
        async forceDocumentSync() {
          if (this._didChangeTextDocumentFeature === void 0) {
            this._didChangeTextDocumentFeature = this._dynamicFeatures.get(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type.method);
          }
          return this._didChangeTextDocumentFeature.forceDelivery();
        }
        handleDiagnostics(params) {
          if (!this._diagnostics) {
            return;
          }
          const key = params.uri;
          if (this._diagnosticQueueState.state === "busy" && this._diagnosticQueueState.document === key) {
            this._diagnosticQueueState.tokenSource.cancel();
          }
          this._diagnosticQueue.set(params.uri, params.diagnostics);
          this.triggerDiagnosticQueue();
        }
        triggerDiagnosticQueue() {
          (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {
            this.workDiagnosticQueue();
          });
        }
        workDiagnosticQueue() {
          if (this._diagnosticQueueState.state === "busy") {
            return;
          }
          const next = this._diagnosticQueue.entries().next();
          if (next.done === true) {
            return;
          }
          const [document2, diagnostics] = next.value;
          this._diagnosticQueue.delete(document2);
          const tokenSource = new vscode_1.CancellationTokenSource();
          this._diagnosticQueueState = { state: "busy", document: document2, tokenSource };
          this._p2c.asDiagnostics(diagnostics, tokenSource.token).then((converted) => {
            if (!tokenSource.token.isCancellationRequested) {
              const uri = this._p2c.asUri(document2);
              const middleware = this.clientOptions.middleware;
              if (middleware.handleDiagnostics) {
                middleware.handleDiagnostics(uri, converted, (uri2, diagnostics2) => this.setDiagnostics(uri2, diagnostics2));
              } else {
                this.setDiagnostics(uri, converted);
              }
            }
          }).finally(() => {
            this._diagnosticQueueState = { state: "idle" };
            this.triggerDiagnosticQueue();
          });
        }
        setDiagnostics(uri, diagnostics) {
          if (!this._diagnostics) {
            return;
          }
          this._diagnostics.set(uri, diagnostics);
        }
        async $start() {
          if (this.$state === ClientState.StartFailed) {
            throw new Error(`Previous start failed. Can't restart server.`);
          }
          await this.start();
          const connection = this.activeConnection();
          if (connection === void 0) {
            throw new Error(`Starting server failed`);
          }
          return connection;
        }
        async createConnection() {
          let errorHandler2 = (error, message, count) => {
            this.handleConnectionError(error, message, count);
          };
          let closeHandler = () => {
            this.handleConnectionClosed();
          };
          const transports = await this.createMessageTransports(this._clientOptions.stdioEncoding || "utf8");
          this._connection = createConnection(transports.reader, transports.writer, errorHandler2, closeHandler, this._clientOptions.connectionOptions);
          return this._connection;
        }
        handleConnectionClosed() {
          if (this.$state === ClientState.Stopped) {
            return;
          }
          try {
            if (this._connection !== void 0) {
              this._connection.dispose();
            }
          } catch (error) {
          }
          let handlerResult = { action: CloseAction.DoNotRestart };
          if (this.$state !== ClientState.Stopping) {
            try {
              handlerResult = this._clientOptions.errorHandler.closed();
            } catch (error) {
            }
          }
          this._connection = void 0;
          if (handlerResult.action === CloseAction.DoNotRestart) {
            this.error(handlerResult.message ?? "Connection to server got closed. Server will not be restarted.", void 0, "force");
            this.cleanUp("stop");
            if (this.$state === ClientState.Starting) {
              this.$state = ClientState.StartFailed;
            } else {
              this.$state = ClientState.Stopped;
            }
            this._onStop = Promise.resolve();
            this._onStart = void 0;
          } else if (handlerResult.action === CloseAction.Restart) {
            this.info(handlerResult.message ?? "Connection to server got closed. Server will restart.");
            this.cleanUp("restart");
            this.$state = ClientState.Initial;
            this._onStop = Promise.resolve();
            this._onStart = void 0;
            this.start().catch((error) => this.error(`Restarting server failed`, error, "force"));
          }
        }
        handleConnectionError(error, message, count) {
          const handlerResult = this._clientOptions.errorHandler.error(error, message, count);
          if (handlerResult.action === ErrorAction.Shutdown) {
            this.error(handlerResult.message ?? `Client ${this._name}: connection to server is erroring. Shutting down server.`, void 0, "force");
            this.stop().catch((error2) => {
              this.error(`Stopping server failed`, error2, false);
            });
          }
        }
        hookConfigurationChanged(connection) {
          this._listeners.push(vscode_1.workspace.onDidChangeConfiguration(() => {
            this.refreshTrace(connection, true);
          }));
        }
        refreshTrace(connection, sendNotification = false) {
          const config = vscode_1.workspace.getConfiguration(this._id);
          let trace = vscode_languageserver_protocol_1.Trace.Off;
          let traceFormat = vscode_languageserver_protocol_1.TraceFormat.Text;
          if (config) {
            const traceConfig = config.get("trace.server", "off");
            if (typeof traceConfig === "string") {
              trace = vscode_languageserver_protocol_1.Trace.fromString(traceConfig);
            } else {
              trace = vscode_languageserver_protocol_1.Trace.fromString(config.get("trace.server.verbosity", "off"));
              traceFormat = vscode_languageserver_protocol_1.TraceFormat.fromString(config.get("trace.server.format", "text"));
            }
          }
          this._trace = trace;
          this._traceFormat = traceFormat;
          connection.trace(this._trace, this._tracer, {
            sendNotification,
            traceFormat: this._traceFormat
          }).catch((error) => {
            this.error(`Updating trace failed with error`, error, false);
          });
        }
        hookFileEvents(_connection) {
          let fileEvents = this._clientOptions.synchronize.fileEvents;
          if (!fileEvents) {
            return;
          }
          let watchers;
          if (Is.array(fileEvents)) {
            watchers = fileEvents;
          } else {
            watchers = [fileEvents];
          }
          if (!watchers) {
            return;
          }
          this._dynamicFeatures.get(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type.method).registerRaw(UUID.generateUuid(), watchers);
        }
        registerFeatures(features) {
          for (let feature of features) {
            this.registerFeature(feature);
          }
        }
        registerFeature(feature) {
          this._features.push(feature);
          if (features_1.DynamicFeature.is(feature)) {
            const registrationType = feature.registrationType;
            this._dynamicFeatures.set(registrationType.method, feature);
          }
        }
        getFeature(request) {
          return this._dynamicFeatures.get(request);
        }
        hasDedicatedTextSynchronizationFeature(textDocument) {
          const feature = this.getFeature(vscode_languageserver_protocol_1.NotebookDocumentSyncRegistrationType.method);
          if (feature === void 0 || !(feature instanceof notebook_1.NotebookDocumentSyncFeature)) {
            return false;
          }
          return feature.handles(textDocument);
        }
        registerBuiltinFeatures() {
          this.registerFeature(new configuration_1.ConfigurationFeature(this));
          this.registerFeature(new textSynchronization_1.DidOpenTextDocumentFeature(this, this._syncedDocuments));
          this.registerFeature(new textSynchronization_1.DidChangeTextDocumentFeature(this));
          this.registerFeature(new textSynchronization_1.WillSaveFeature(this));
          this.registerFeature(new textSynchronization_1.WillSaveWaitUntilFeature(this));
          this.registerFeature(new textSynchronization_1.DidSaveTextDocumentFeature(this));
          this.registerFeature(new textSynchronization_1.DidCloseTextDocumentFeature(this, this._syncedDocuments));
          this.registerFeature(new fileSystemWatcher_1.FileSystemWatcherFeature(this, (event) => this.notifyFileEvent(event)));
          this.registerFeature(new completion_1.CompletionItemFeature(this));
          this.registerFeature(new hover_1.HoverFeature(this));
          this.registerFeature(new signatureHelp_1.SignatureHelpFeature(this));
          this.registerFeature(new definition_1.DefinitionFeature(this));
          this.registerFeature(new reference_1.ReferencesFeature(this));
          this.registerFeature(new documentHighlight_1.DocumentHighlightFeature(this));
          this.registerFeature(new documentSymbol_1.DocumentSymbolFeature(this));
          this.registerFeature(new workspaceSymbol_1.WorkspaceSymbolFeature(this));
          this.registerFeature(new codeAction_1.CodeActionFeature(this));
          this.registerFeature(new codeLens_1.CodeLensFeature(this));
          this.registerFeature(new formatting_1.DocumentFormattingFeature(this));
          this.registerFeature(new formatting_1.DocumentRangeFormattingFeature(this));
          this.registerFeature(new formatting_1.DocumentOnTypeFormattingFeature(this));
          this.registerFeature(new rename_1.RenameFeature(this));
          this.registerFeature(new documentLink_1.DocumentLinkFeature(this));
          this.registerFeature(new executeCommand_1.ExecuteCommandFeature(this));
          this.registerFeature(new configuration_1.SyncConfigurationFeature(this));
          this.registerFeature(new typeDefinition_1.TypeDefinitionFeature(this));
          this.registerFeature(new implementation_1.ImplementationFeature(this));
          this.registerFeature(new colorProvider_1.ColorProviderFeature(this));
          if (this.clientOptions.workspaceFolder === void 0) {
            this.registerFeature(new workspaceFolder_1.WorkspaceFoldersFeature(this));
          }
          this.registerFeature(new foldingRange_1.FoldingRangeFeature(this));
          this.registerFeature(new declaration_1.DeclarationFeature(this));
          this.registerFeature(new selectionRange_1.SelectionRangeFeature(this));
          this.registerFeature(new progress_1.ProgressFeature(this));
          this.registerFeature(new callHierarchy_1.CallHierarchyFeature(this));
          this.registerFeature(new semanticTokens_1.SemanticTokensFeature(this));
          this.registerFeature(new linkedEditingRange_1.LinkedEditingFeature(this));
          this.registerFeature(new fileOperations_1.DidCreateFilesFeature(this));
          this.registerFeature(new fileOperations_1.DidRenameFilesFeature(this));
          this.registerFeature(new fileOperations_1.DidDeleteFilesFeature(this));
          this.registerFeature(new fileOperations_1.WillCreateFilesFeature(this));
          this.registerFeature(new fileOperations_1.WillRenameFilesFeature(this));
          this.registerFeature(new fileOperations_1.WillDeleteFilesFeature(this));
          this.registerFeature(new typeHierarchy_1.TypeHierarchyFeature(this));
          this.registerFeature(new inlineValue_1.InlineValueFeature(this));
          this.registerFeature(new inlayHint_1.InlayHintsFeature(this));
          this.registerFeature(new diagnostic_1.DiagnosticFeature(this));
          this.registerFeature(new notebook_1.NotebookDocumentSyncFeature(this));
        }
        registerProposedFeatures() {
          this.registerFeatures(ProposedFeatures.createAll(this));
        }
        fillInitializeParams(params) {
          for (let feature of this._features) {
            if (Is.func(feature.fillInitializeParams)) {
              feature.fillInitializeParams(params);
            }
          }
        }
        computeClientCapabilities() {
          const result = {};
          (0, features_1.ensure)(result, "workspace").applyEdit = true;
          const workspaceEdit = (0, features_1.ensure)((0, features_1.ensure)(result, "workspace"), "workspaceEdit");
          workspaceEdit.documentChanges = true;
          workspaceEdit.resourceOperations = [vscode_languageserver_protocol_1.ResourceOperationKind.Create, vscode_languageserver_protocol_1.ResourceOperationKind.Rename, vscode_languageserver_protocol_1.ResourceOperationKind.Delete];
          workspaceEdit.failureHandling = vscode_languageserver_protocol_1.FailureHandlingKind.TextOnlyTransactional;
          workspaceEdit.normalizesLineEndings = true;
          workspaceEdit.changeAnnotationSupport = {
            groupsOnLabel: true
          };
          const diagnostics = (0, features_1.ensure)((0, features_1.ensure)(result, "textDocument"), "publishDiagnostics");
          diagnostics.relatedInformation = true;
          diagnostics.versionSupport = false;
          diagnostics.tagSupport = { valueSet: [vscode_languageserver_protocol_1.DiagnosticTag.Unnecessary, vscode_languageserver_protocol_1.DiagnosticTag.Deprecated] };
          diagnostics.codeDescriptionSupport = true;
          diagnostics.dataSupport = true;
          const windowCapabilities = (0, features_1.ensure)(result, "window");
          const showMessage = (0, features_1.ensure)(windowCapabilities, "showMessage");
          showMessage.messageActionItem = { additionalPropertiesSupport: true };
          const showDocument = (0, features_1.ensure)(windowCapabilities, "showDocument");
          showDocument.support = true;
          const generalCapabilities = (0, features_1.ensure)(result, "general");
          generalCapabilities.staleRequestSupport = {
            cancel: true,
            retryOnContentModified: Array.from(BaseLanguageClient.RequestsToCancelOnContentModified)
          };
          generalCapabilities.regularExpressions = { engine: "ECMAScript", version: "ES2020" };
          generalCapabilities.markdown = {
            parser: "marked",
            version: "1.1.0"
          };
          generalCapabilities.positionEncodings = ["utf-16"];
          if (this._clientOptions.markdown.supportHtml) {
            generalCapabilities.markdown.allowedTags = ["ul", "li", "p", "code", "blockquote", "ol", "h1", "h2", "h3", "h4", "h5", "h6", "hr", "em", "pre", "table", "thead", "tbody", "tr", "th", "td", "div", "del", "a", "strong", "br", "img", "span"];
          }
          for (let feature of this._features) {
            feature.fillClientCapabilities(result);
          }
          return result;
        }
        initializeFeatures(_connection) {
          const documentSelector = this._clientOptions.documentSelector;
          for (const feature of this._features) {
            if (Is.func(feature.preInitialize)) {
              feature.preInitialize(this._capabilities, documentSelector);
            }
          }
          for (const feature of this._features) {
            feature.initialize(this._capabilities, documentSelector);
          }
        }
        async handleRegistrationRequest(params) {
          if (!this.isRunning()) {
            for (const registration of params.registrations) {
              this._ignoredRegistrations.add(registration.id);
            }
            return;
          }
          for (const registration of params.registrations) {
            const feature = this._dynamicFeatures.get(registration.method);
            if (feature === void 0) {
              return Promise.reject(new Error(`No feature implementation for ${registration.method} found. Registration failed.`));
            }
            const options = registration.registerOptions ?? {};
            options.documentSelector = options.documentSelector ?? this._clientOptions.documentSelector;
            const data = {
              id: registration.id,
              registerOptions: options
            };
            try {
              feature.register(data);
            } catch (err) {
              return Promise.reject(err);
            }
          }
        }
        async handleUnregistrationRequest(params) {
          for (let unregistration of params.unregisterations) {
            if (this._ignoredRegistrations.has(unregistration.id)) {
              continue;
            }
            const feature = this._dynamicFeatures.get(unregistration.method);
            if (!feature) {
              return Promise.reject(new Error(`No feature implementation for ${unregistration.method} found. Unregistration failed.`));
            }
            feature.unregister(unregistration.id);
          }
        }
        async handleApplyWorkspaceEdit(params) {
          const workspaceEdit = params.edit;
          const converted = await this.workspaceEditLock.lock(() => {
            return this._p2c.asWorkspaceEdit(workspaceEdit);
          });
          const openTextDocuments = /* @__PURE__ */ new Map();
          vscode_1.workspace.textDocuments.forEach((document2) => openTextDocuments.set(document2.uri.toString(), document2));
          let versionMismatch = false;
          if (workspaceEdit.documentChanges) {
            for (const change of workspaceEdit.documentChanges) {
              if (vscode_languageserver_protocol_1.TextDocumentEdit.is(change) && change.textDocument.version && change.textDocument.version >= 0) {
                const textDocument = openTextDocuments.get(change.textDocument.uri);
                if (textDocument && textDocument.version !== change.textDocument.version) {
                  versionMismatch = true;
                  break;
                }
              }
            }
          }
          if (versionMismatch) {
            return Promise.resolve({ applied: false });
          }
          return Is.asPromise(vscode_1.workspace.applyEdit(converted).then((value) => {
            return { applied: value };
          }));
        }
        handleFailedRequest(type, token, error, defaultValue, showNotification = true) {
          if (error instanceof vscode_languageserver_protocol_1.ResponseError) {
            if (error.code === vscode_languageserver_protocol_1.ErrorCodes.PendingResponseRejected || error.code === vscode_languageserver_protocol_1.ErrorCodes.ConnectionInactive) {
              return defaultValue;
            }
            if (error.code === vscode_languageserver_protocol_1.LSPErrorCodes.RequestCancelled || error.code === vscode_languageserver_protocol_1.LSPErrorCodes.ServerCancelled) {
              if (token !== void 0 && token.isCancellationRequested) {
                return defaultValue;
              } else {
                if (error.data !== void 0) {
                  throw new features_1.LSPCancellationError(error.data);
                } else {
                  throw new vscode_1.CancellationError();
                }
              }
            } else if (error.code === vscode_languageserver_protocol_1.LSPErrorCodes.ContentModified) {
              if (BaseLanguageClient.RequestsToCancelOnContentModified.has(type.method)) {
                throw new vscode_1.CancellationError();
              } else {
                return defaultValue;
              }
            }
          }
          this.error(`Request ${type.method} failed.`, error, showNotification);
          throw error;
        }
      };
      exports2.BaseLanguageClient = BaseLanguageClient;
      BaseLanguageClient.RequestsToCancelOnContentModified = /* @__PURE__ */ new Set([
        vscode_languageserver_protocol_1.SemanticTokensRequest.method,
        vscode_languageserver_protocol_1.SemanticTokensRangeRequest.method,
        vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.method
      ]);
      var ConsoleLogger = class {
        error(message) {
          (0, vscode_languageserver_protocol_1.RAL)().console.error(message);
        }
        warn(message) {
          (0, vscode_languageserver_protocol_1.RAL)().console.warn(message);
        }
        info(message) {
          (0, vscode_languageserver_protocol_1.RAL)().console.info(message);
        }
        log(message) {
          (0, vscode_languageserver_protocol_1.RAL)().console.log(message);
        }
      };
      function createConnection(input, output, errorHandler2, closeHandler, options) {
        let _lastUsed = -1;
        const logger = new ConsoleLogger();
        const connection = (0, vscode_languageserver_protocol_1.createProtocolConnection)(input, output, logger, options);
        connection.onError((data) => {
          errorHandler2(data[0], data[1], data[2]);
        });
        connection.onClose(closeHandler);
        const result = {
          get lastUsed() {
            return _lastUsed;
          },
          resetLastUsed: () => {
            _lastUsed = -1;
          },
          listen: () => connection.listen(),
          sendRequest: (type, ...params) => {
            _lastUsed = Date.now();
            return connection.sendRequest(type, ...params);
          },
          onRequest: (type, handler) => connection.onRequest(type, handler),
          hasPendingResponse: () => connection.hasPendingResponse(),
          sendNotification: (type, params) => {
            _lastUsed = Date.now();
            return connection.sendNotification(type, params);
          },
          onNotification: (type, handler) => connection.onNotification(type, handler),
          onProgress: connection.onProgress,
          sendProgress: connection.sendProgress,
          trace: (value, tracer, sendNotificationOrTraceOptions) => {
            const defaultTraceOptions = {
              sendNotification: false,
              traceFormat: vscode_languageserver_protocol_1.TraceFormat.Text
            };
            if (sendNotificationOrTraceOptions === void 0) {
              return connection.trace(value, tracer, defaultTraceOptions);
            } else if (Is.boolean(sendNotificationOrTraceOptions)) {
              return connection.trace(value, tracer, sendNotificationOrTraceOptions);
            } else {
              return connection.trace(value, tracer, sendNotificationOrTraceOptions);
            }
          },
          initialize: (params) => {
            _lastUsed = Date.now();
            return connection.sendRequest(vscode_languageserver_protocol_1.InitializeRequest.type, params);
          },
          shutdown: () => {
            _lastUsed = Date.now();
            return connection.sendRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, void 0);
          },
          exit: () => {
            _lastUsed = Date.now();
            return connection.sendNotification(vscode_languageserver_protocol_1.ExitNotification.type);
          },
          end: () => connection.end(),
          dispose: () => connection.dispose()
        };
        return result;
      }
      var ProposedFeatures;
      (function(ProposedFeatures2) {
        function createAll(_client) {
          let result = [];
          return result;
        }
        ProposedFeatures2.createAll = createAll;
      })(ProposedFeatures = exports2.ProposedFeatures || (exports2.ProposedFeatures = {}));
    }
  });

  // node_modules/vscode-languageclient/lib/common/api.js
  var require_api8 = __commonJS({
    "node_modules/vscode-languageclient/lib/common/api.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DiagnosticPullMode = exports2.vsdiag = void 0;
      __exportStar(require_main3(), exports2);
      __exportStar(require_features(), exports2);
      var diagnostic_1 = require_diagnostic2();
      Object.defineProperty(exports2, "vsdiag", { enumerable: true, get: function() {
        return diagnostic_1.vsdiag;
      } });
      Object.defineProperty(exports2, "DiagnosticPullMode", { enumerable: true, get: function() {
        return diagnostic_1.DiagnosticPullMode;
      } });
      __exportStar(require_client(), exports2);
    }
  });

  // node_modules/vscode-languageclient/lib/browser/main.js
  var require_main6 = __commonJS({
    "node_modules/vscode-languageclient/lib/browser/main.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LanguageClient = void 0;
      var api_1 = require_api8();
      var browser_1 = require_browser2();
      __exportStar(require_browser2(), exports2);
      __exportStar(require_api8(), exports2);
      var LanguageClient = class extends api_1.BaseLanguageClient {
        constructor(id2, name, clientOptions, worker) {
          super(id2, name, clientOptions);
          this.worker = worker;
        }
        createMessageTransports(_encoding) {
          const reader = new browser_1.BrowserMessageReader(this.worker);
          const writer = new browser_1.BrowserMessageWriter(this.worker);
          return Promise.resolve({ reader, writer });
        }
        getLocale() {
          return "en";
        }
      };
      exports2.LanguageClient = LanguageClient;
    }
  });

  // out/language/hello-document-builder.js
  var require_hello_document_builder = __commonJS({
    "out/language/hello-document-builder.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.HelloWorldDocumentBuilder = void 0;
      var langium_1 = require_lib2();
      var vscode_languageclient_1 = require_main6();
      var HelloWorldDocumentBuilder = class extends langium_1.DefaultDocumentBuilder {
        async update(changed, deleted, cancelToken = vscode_languageclient_1.CancellationToken.None) {
          console.log("update: changed:", changed.map((uri) => uri.toString()), "deleted:", deleted.map((uri) => uri.toString()));
          await super.update(changed, deleted, cancelToken);
        }
      };
      exports2.HelloWorldDocumentBuilder = HelloWorldDocumentBuilder;
    }
  });

  // out/language/hello-world-module.js
  var require_hello_world_module = __commonJS({
    "out/language/hello-world-module.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createHelloWorldServices = exports2.HelloWorldModule = void 0;
      var langium_1 = require_lib2();
      var module_1 = require_module2();
      var hello_world_validator_1 = require_hello_world_validator();
      var hello_semantic_tokens_1 = require_hello_semantic_tokens();
      var hello_document_builder_1 = require_hello_document_builder();
      exports2.HelloWorldModule = {
        validation: {
          HelloWorldValidator: () => new hello_world_validator_1.HelloWorldValidator()
        },
        lsp: {
          SemanticTokenProvider: (services) => new hello_semantic_tokens_1.HelloSemanticTokenProvider(services)
        }
      };
      function createHelloWorldServices(context) {
        const shared = (0, langium_1.inject)((0, langium_1.createDefaultSharedModule)(context), module_1.HelloWorldGeneratedSharedModule, {
          workspace: {
            DocumentBuilder: (services) => new hello_document_builder_1.HelloWorldDocumentBuilder(services)
          }
        });
        const HelloWorld = (0, langium_1.inject)((0, langium_1.createDefaultModule)({ shared }), module_1.HelloWorldGeneratedModule, exports2.HelloWorldModule);
        shared.ServiceRegistry.register(HelloWorld);
        (0, hello_world_validator_1.registerValidationChecks)(HelloWorld);
        return { shared, HelloWorld };
      }
      exports2.createHelloWorldServices = createHelloWorldServices;
    }
  });

  // out/language/main-browser.js
  var require_main_browser = __commonJS({
    "out/language/main-browser.js"(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      var langium_1 = require_lib2();
      var browser_1 = require_browser3();
      var hello_world_module_1 = require_hello_world_module();
      var vscode_uri_1 = require_umd();
      console.log("a");
      var messageReader = new browser_1.BrowserMessageReader(self);
      messageReader.listen((m) => console.log("xxx", m));
      var messageWriter = new browser_1.BrowserMessageWriter(self);
      var connection = (0, browser_1.createConnection)(messageReader, messageWriter);
      var { shared } = (0, hello_world_module_1.createHelloWorldServices)(Object.assign({ connection }, langium_1.EmptyFileSystem));
      var documentBuilder = shared.workspace.DocumentBuilder;
      var documents = shared.workspace.TextDocuments;
      var mutex = shared.workspace.MutexLock;
      async function onDidClose(uri) {
        await mutex.lock((token) => documentBuilder.update([], [uri], token));
      }
      documents.onDidClose(async (event) => {
        console.log("onDidClose", event.document.uri.toString());
        await onDidClose(vscode_uri_1.URI.parse(event.document.uri));
      });
      connection.onRequest("custom/clear", async () => {
        documentBuilder.update([], documents.all().map((d) => vscode_uri_1.URI.parse(d.uri)), void 0);
        return "";
      });
      (0, langium_1.startLanguageServer)(shared);
    }
  });
  require_main_browser();
})();
